_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/404"],{

/***/ "./components/Avatar.js":
/*!******************************!*\
  !*** ./components/Avatar.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Avatar.js";

/**
 * Profile Avatar as SVG
 * @description Main Site Avatar for profile
 * @author dtro-devuk @github:dtro-devuk.io
 */
const Avatar = ({
  className
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("svg", {
    version: "1.1",
    id: "svg3169",
    className: className,
    fill: "none",
    viewBox: "0 0 540.84509 539.49298",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
      id: "title3742",
      children: "dtro-devuk avatar "
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("metadata", {
      id: "metadata3175"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("defs", {
      id: "defs3173"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("image", {
      width: "540.84509",
      height: "539.49298",
      preserveAspectRatio: "none",
      href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGPCAYAAAByP4aCAAAAAXNSR0IArs4c6QAAAARnQU1BAACx\r jwv8YQUAAAAJcEhZcwAACusAAArrAYKLDVoAAADbaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8\r P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pg0KPHg6\r eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+DQogIDxyZGY6UkRGIHhtbG5zOnJkZj0i\r aHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgLz4NCjwveDp4bXBt\r ZXRhPg0KPD94cGFja2V0IGVuZD0iciI/PiMHdFEAAP6+SURBVHhe7L0HwG1XVSe+vt77672/l04q\r CQGBAAFBHUUHRkfFjn0cy98ZHUWxjH10HNGx90HUEUZFBNIgBNJIfcl7yev1e+Xrvf/Xb6212yn3\r u997iQGS37377NX2Pvuee85eZ5ezT83S3FNLFGFpaYmeeuo5euvb30v95wZMmkUtUQ0HQ02NEYKE\r YWR5RpqAEfMRLWSJjumQTSwHmC/UGV2m06/SMZLyRrSQGVvmS49Hzt7ojL1nc/YA81lRLBB14JcW\r 52lurJ+JBZNkUFNHDZ0b+O+st2zi1DEk4wIUCMW0OBeF6UpNihWVz7MyRHbVJskYXmKyAlSd0wuA\r 5LLOYxm1Q97sUhJWmSay42qoBCUKLy7f1xJ0heoCoYhS+dLiAs2OXARhEocl2rC+gx558G9o/frV\r Jnt5IHgBw/nzA/Seb/tJjgdNUoRwIaSVePYCKeBzlXGWt0jsnC6mgbiSTuUSRGS0h8lzOqWRn0qc\r HIAww7soKR+APLLlMkYyj3jEIlPSEfpxrFcamHZpBE6vAt2Fz8EQ9BURpU2tRWHBRAIwLgRSf38+\r l8jAgok8nCAohOKNBs3XpBayiHQhoRdJ8IiFWt70k1rkBEn+UcgbZsK/JYr2H4Wi8kvImKUsh/ST\r tzAkYt64kCiyCDp/LjErQfRAsImlQcQbhKyeISWWPGEjAoNjvMBY3vi8XkERcg5kcXFJnMdi+S2A\r wB9bQdEBzsjcn+YRM6CNlyircwgnlcqdzmgvcnIg0jnaQ/MqzC8pr+kkMtojLhMQ6SWP1FZlxpqt\r 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\r AABJRU5ErkJggg==\r ",
      id: "image3179"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, undefined);
};

_c = Avatar;
/* harmony default export */ __webpack_exports__["default"] = (Avatar);

var _c;

$RefreshReg$(_c, "Avatar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Container.js":
/*!*********************************!*\
  !*** ./components/Container.js ***!
  \*********************************/
/*! exports provided: description, siteTitle, profileName, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "description", function() { return description; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteTitle", function() { return siteTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profileName", function() { return profileName; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Head */ "./components/Head.js");
/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Header */ "./components/Header.js");
/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/Footer */ "./components/Footer.js");

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Container.js";

/**
 * Container
 * @description Main Container for the App
 * @author dtro-devuk @github:dtro-devuk.io
 */




const description = 'This example configures a simple Next10 and Tailwind CSS app with routing for deployment to GitHub Pages repository.';
const siteTitle = 'Next 10, Tailwind App deployed to GitHub pages example';
const profileName = 'dtro-devuk';

const Container = ({
  children
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    id: "container",
    className: "bg-gray-300",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Head__WEBPACK_IMPORTED_MODULE_2__["default"], {
      title: siteTitle,
      description: description
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Header__WEBPACK_IMPORTED_MODULE_3__["default"], {
      caption: siteTitle,
      author: profileName,
      description: description
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("main", {
      id: "main-content",
      role: "main",
      "aria-label": "main content area for the page",
      className: "flex-1 p-3 overflow-y-hidden justify-center bg-white",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Footer__WEBPACK_IMPORTED_MODULE_4__["default"], {
      caption: siteTitle,
      author: profileName
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 19,
    columnNumber: 5
  }, undefined);
};

_c = Container;
/* harmony default export */ __webpack_exports__["default"] = (Container);
Container.propTypes = {
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node.isRequired
};

var _c;

$RefreshReg$(_c, "Container");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Footer.js":
/*!******************************!*\
  !*** ./components/Footer.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Footer.js";

/**
 * Site Footer Component
 * @description footer elements to be included here
 * @author dtro-devuk @github:dtro-devuk.io
 */


const Footer = ({
  caption,
  author
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("footer", {
    id: "main-footer",
    role: "contentinfo",
    "aria-label": "main footer content info",
    className: "w-full p-3\r flex flex-col items-center text-center \r bg-gray-800 ",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "text-white",
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        className: " text-xl md:text-1xl lg:text-2xl p-3",
        children: caption || ''
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 19,
        columnNumber: 9
      }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        className: " text-xl md:text-1xl lg:text-2xl p-3",
        children: ["(c) ", author, " 2021"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 9
      }, undefined)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }, undefined)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, undefined);
};

_c = Footer;
/* harmony default export */ __webpack_exports__["default"] = (Footer);
Footer.propTypes = {
  caption: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Footer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Hamburger.js":
/*!*********************************!*\
  !*** ./components/Hamburger.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);



var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Hamburger.js";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Hamburger Toggle Button with animation
 * @description Toggle Burger button, open and close animations and aria support
 * @author dtro-devuk @github:dtro-devuk.io
 */


/**
 * Hamburger Toggle Button
 * With animated Open and Close, animations courtesy of Johnshu, see readme for attributions
 * @param {*} param0
 */

const Hamburger = (_ref) => {
  let {
    open,
    setOpen
  } = _ref,
      props = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref, ["open", "setOpen"]);

  const isOpen = open ? true : false;
  /**
   * Show/Hide the Menu
   */

  const handleToggleMenuClick = (event, open) => {
    if (event.ctrlKey || event.metaKey || event.shiftKey) {
      return; // let the browser deal with the click natively
    }

    event.preventDefault();
    setOpen(open);
  };

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("button", _objectSpread(_objectSpread({
    className: "hamburger--spring-r ".concat(open ? 'is-active' : '', "\n            p-1 md:p-3 ml-3 mr-3 \n            lg:hidden lg:ml-0 lg:w-0 \n            text-yellow-500 hover:text-white             \n            rounded\n            transform hover:scale-125 hover:bg-opacity-50 transition ease-out duration-500\n            focus:outline-none"),
    id: "hamburger-btn",
    "aria-label": "Hamburger Menu Toggle Button",
    "aria-expanded": isOpen,
    "aria-controls": "{menuId}",
    type: "button",
    tabIndex: "0",
    onClick: event => handleToggleMenuClick(event, !open)
  }, props), {}, {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("span", {
      className: "hamburger-box",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("span", {
        className: "hamburger-inner rounded"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 50,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 49,
      columnNumber: 7
    }, undefined)
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 32,
    columnNumber: 5
  }, undefined);
};

_c = Hamburger;
Hamburger.propTypes = {
  open: prop_types__WEBPACK_IMPORTED_MODULE_4__["bool"].isRequired,
  setOpen: prop_types__WEBPACK_IMPORTED_MODULE_4__["func"].isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Hamburger);

var _c;

$RefreshReg$(_c, "Hamburger");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/HamburgerMenu.js":
/*!*************************************!*\
  !*** ./components/HamburgerMenu.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\HamburgerMenu.js";

/**
 * Hamburger Menu
 * @description Opens and Close based on properties passed from the associated Hamburger Toggle Button, see Hamburger.js
 * @author dtro-devuk @github:dtro-devuk.io
 */




const HamburgerMenu = (_ref) => {
  let {
    open
  } = _ref,
      props = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, ["open"]);

  const isHidden = open ? true : false;
  const isOpen = open;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    "aria-hidden": !isHidden,
    className: "mt-2 w-full lg:inline-flex lg:flex-grow lg:w-auto \n    ".concat(!isHidden ? 'hidden' : ''),
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "lg:translate-y-0\n            lg:inline-flex lg:flex-row lg:ml-auto lg:w-auto w-full \n            lg:items-center items-start flex flex-col lg:h-auto\n            transition ".concat(isOpen ? 'translate-y-0 ease-out duration-1000 transform ' : '-translate-y-full ease-in duration-1000 transform '),
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "/blog",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "lg:inline-flex lg:w-auto w-full px-3 py-2 rounded text-lg\n          text-yellow-500 hover:text-white lg:hover:bg-yellow-500 \n          active:text-white focus:outline-none\n          transform ".concat('hover:scale-x-90 transition ease-in-out duration-500'),
          children: "Blog"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 33,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 9
      }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "/about",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "lg:inline-flex lg:w-auto w-full px-3 py-2 rounded text-lg\n                text-yellow-400 hover:text-white lg:hover:bg-yellow-500 \n                active:text-white focus:outline-none \n                transform ".concat('hover:scale-x-90 transition ease-in-out duration-500'),
          children: "About"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 44,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 9
      }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "https://www.github.com/dtro-devuk",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "lg:inline-flex lg:w-auto w-full px-3 py-2 rounded text-lg\n                text-yellow-500 hover:text-white lg:hover:bg-yellow-500 \n                active:text-yellow-600 focus:outline-none\"\n                transform ".concat('hover:scale-x-90 transition ease-in-out duration-500'),
          target: "_blank",
          rel: "noopener noreferrer",
          children: "Github"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 55,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 9
      }, undefined)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 7
    }, undefined)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 17,
    columnNumber: 5
  }, undefined);
};

_c = HamburgerMenu;
HamburgerMenu.propTypes = {
  open: prop_types__WEBPACK_IMPORTED_MODULE_4__["bool"].isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (HamburgerMenu);

var _c;

$RefreshReg$(_c, "HamburgerMenu");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Head.js":
/*!****************************!*\
  !*** ./components/Head.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Head.js";

/**
 * Head
 * @description Site Head modifications
 * @author dtro-devuk @github:dtro-devuk.io
 */




const Head = ({
  title,
  description
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_3___default.a, {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      charSet: "UTF-8"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
      children: title || ''
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      name: "description",
      content: description || ''
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      name: "viewport",
      content: "width=device-width, initial-scale=1 shrink-to-fit=no, user-scalable=0"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, undefined);
};

_c = Head;
/* harmony default export */ __webpack_exports__["default"] = (Head);
Head.propTypes = {
  title: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired,
  description: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Header.js":
/*!******************************!*\
  !*** ./components/Header.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Navbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Navbar */ "./components/Navbar.js");

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Header.js";

/**
 * Header Component
 * @description Site Header including the Navigation menu
 * @author dtro-devuk @github:dtro-devuk.io
 */



const Header = ({
  caption,
  author,
  description
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("header", {
    id: "header",
    role: "banner",
    className: "sticky-header\r flex flex-col items-center text-center\r bg-gray-800",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "p-3 font-black\r text-2xl md:text-3xl lg:text-4xl\r text-white",
      children: caption || ''
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Navbar__WEBPACK_IMPORTED_MODULE_2__["default"], {
      author: author
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "bg-gray-300 w-full",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
        "aria-label": "Demo description",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h1", {
          className: "p-3 m-3 font-bold text-gray-700 italic font-sans text-xl text-center",
          children: description
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 30,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 29,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, undefined);
};

_c = Header;
/* harmony default export */ __webpack_exports__["default"] = (Header);
Header.propTypes = {
  caption: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  author: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  description: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Header");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/HomeButton.js":
/*!**********************************!*\
  !*** ./components/HomeButton.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\HomeButton.js";

/**
 *Home Button
 * @description Return to the Home Page
 * @author dtro-devuk @github:dtro-devuk.io
 */


const defaultButtonCaption = '← Back to Home';
const defaultClassName = 'bg-gray-500 text-white hover:bg-yellow-500 hover:text-black font-bold text-md px-4 py-2 rounded shadow hover:shadow-md outline-none focus:outline-none mr-1 mb-1 transition all ease duration-500';

const HomeButton = ({
  caption,
  className
}) => {
  const buttonCaption = setButtonCaption(caption);
  const thisClassName = setClassName(className);
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "/",
    scroll: false,
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("button", {
      id: "home-button",
      "aria-label": "Home Button",
      className: thisClassName,
      type: "button",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
        children: buttonCaption
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 22,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 7
    }, undefined)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 20,
    columnNumber: 5
  }, undefined);
};

_c = HomeButton;

const setButtonCaption = caption => {
  let newCaption = '';

  if (caption != '' && caption != undefined) {
    newCaption = caption;
  } else {
    newCaption = defaultButtonCaption;
  }

  return defaultButtonCaption;
};

const setClassName = className => {
  let newClassName = '';

  if (className != '' && className != undefined) {
    newClassName = className;
  } else {
    newClassName = defaultClassName;
  }

  return newClassName;
};

HomeButton.propTypes = {
  caption: prop_types__WEBPACK_IMPORTED_MODULE_2__["string"],
  className: prop_types__WEBPACK_IMPORTED_MODULE_2__["string"]
};
/* harmony default export */ __webpack_exports__["default"] = (HomeButton);

var _c;

$RefreshReg$(_c, "HomeButton");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Navbar.js":
/*!******************************!*\
  !*** ./components/Navbar.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lib_hooks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/hooks.js */ "./lib/hooks.js");
/* harmony import */ var _components_Avatar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/Avatar */ "./components/Avatar.js");
/* harmony import */ var _components_Hamburger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/Hamburger */ "./components/Hamburger.js");
/* harmony import */ var _components_HamburgerMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/HamburgerMenu */ "./components/HamburgerMenu.js");



var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Navbar.js",
    _s = $RefreshSig$();

/**
 * Navigation Menu Bar Component
 * @description Horizontal Vertically expanding Navigation Menu with animations
 * @author dtro-devuk @github:dtro-devuk.io
 */







/**
 * Main Navigation Menu Bar (Horizontal)
 */

const NavBar = ({
  author
}) => {
  _s();

  const {
    0: open,
    1: setOpen
  } = Object(react__WEBPACK_IMPORTED_MODULE_3__["useState"])(false);
  const node = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(null);
  const menuId = 'mobile-menu';
  Object(_lib_hooks_js__WEBPACK_IMPORTED_MODULE_4__["useOnMouseClickOutsideNav"])(node, () => setOpen(false));
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      ref: node,
      className: "",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("nav", {
        id: "navbar",
        role: "navigation",
        className: "sticky-header w-full\r bg-gray-800 flex flex-wrap items-center justify-between mt-0 py-2",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
          href: "/",
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
            className: "inline-flex items-center p-2 w-auto cursor-pointer focus:outline-none",
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Avatar__WEBPACK_IMPORTED_MODULE_5__["default"], {
              className: "h-14 w-14 rounded-full mr-2 md:h-20 md:w-20\r border-4 border-white-200 \r transform hover:scale-125 hover:bg-opacity-50 transition ease-out duration-500"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 38,
              columnNumber: 15
            }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
              className: "p-3 font-bold italic\r text-2xl md:text-3xl lg:text-4xl\r text-blue-400",
              children: ["@", author || '']
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 44,
              columnNumber: 15
            }, undefined)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 37,
            columnNumber: 13
          }, undefined)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 36,
          columnNumber: 11
        }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
          className: "inline-flex my-2 pt-2 ml-auto sm:w-auto",
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Hamburger__WEBPACK_IMPORTED_MODULE_6__["default"], {
            open: open,
            setOpen: setOpen,
            "aria-controls": menuId
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 55,
            columnNumber: 13
          }, undefined)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 54,
          columnNumber: 11
        }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_HamburgerMenu__WEBPACK_IMPORTED_MODULE_7__["default"], {
          open: open,
          setOpen: setOpen,
          id: menuId
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 57,
          columnNumber: 11
        }, undefined)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 7
    }, undefined)
  }, void 0, false);
};

_s(NavBar, "eo+ALe2yXdMitpGGRHVPwEDJmcQ=", false, function () {
  return [_lib_hooks_js__WEBPACK_IMPORTED_MODULE_4__["useOnMouseClickOutsideNav"]];
});

_c = NavBar;
/* harmony default export */ __webpack_exports__["default"] = (NavBar);
NavBar.propTypes = {
  author: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "NavBar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./lib/hooks.js":
/*!**********************!*\
  !*** ./lib/hooks.js ***!
  \**********************/
/*! exports provided: useOnMouseClickOutsideNav */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useOnMouseClickOutsideNav", function() { return useOnMouseClickOutsideNav; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var _s = $RefreshSig$();

/**
 * Hooks Functions
 * @description Main Global Site Hooks to included here
 * @author dtro-devuk @github:dtro-devuk.io
 */

/**
 * Use this to determine if the user clicked outside an element (e.g. Nav Bar Menu)
 * @param {*} ref
 * @param {*} handler
 */

const useOnMouseClickOutsideNav = (ref, handler) => {
  _s();

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    const listener = event => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }

      handler(event);
    };

    document.addEventListener('mousedown', listener);
    return () => {
      document.removeEventListener('mousedown', listener);
    };
  }, [ref, handler]);
};

_s(useOnMouseClickOutsideNav, "OD7bBpZva5O2jO+Puf00hKivP7c=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutProperties; });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F404&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-gh-pages-example%5Cpages%5C404.js!./":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F404&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-gh-pages-example%5Cpages%5C404.js ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


      (window.__NEXT_P = window.__NEXT_P || []).push([
        "/404",
        function () {
          return __webpack_require__(/*! ./pages/404.js */ "./pages/404.js");
        }
      ]);
    

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

const prefetched = {};

function prefetch(router, href, as, options) {
  if ( false || !router) return;
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options).catch(err => {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  const curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  const {
    target
  } = event.currentTarget;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  const {
    nodeName
  } = e.currentTarget;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow,
    locale,
    scroll
  }).then(success => {
    if (!success) return;

    if (scroll) {
      // FIXME: proper route announcing at Router level, not Link:
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    } // TypeScript trick for type-guarding:


    const requiredPropsGuard = {
      href: true
    };
    const requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(key => {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // TypeScript trick for type-guarding:

    const optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    const optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(key => {
      const valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    const hasWarned = _react.default.useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  const p = props.prefetch !== false;
  const router = (0, _router2.useRouter)();
  const pathname = router && router.pathname || '/';

  const {
    href,
    as
  } = _react.default.useMemo(() => {
    const [resolvedHref, resolvedAs] = (0, _router.resolveHref)(pathname, props.href, true);
    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]);

  let {
    children,
    replace,
    shallow,
    scroll,
    locale
  } = props; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react.default.createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  const child = _react.Children.only(children);

  const childRef = child && typeof child === 'object' && child.ref;
  const [setIntersectionRef, isVisible] = (0, _useIntersection.useIntersection)({
    rootMargin: '200px'
  });

  const setRef = _react.default.useCallback(el => {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  (0, _react.useEffect)(() => {
    const shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);
    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    const isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);
  const childProps = {
    ref: setRef,
    onClick: e => {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = e => {
    if (!(0, _router.isLocalURL)(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    const localeDomain = (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);
    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react.default.cloneElement(child, childProps);
}

_s(Link, "7cX92ILFgstKFyzTMH+g73G4t5k=");

_c = Link;
var _default = Link;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


const normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = void 0;

const requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  let start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function () {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

var _default = requestIdleCallback;
exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports.default = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js")); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


const MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  let entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  let resolver;
  const prom = new Promise(resolve => {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(value => (resolver(value), value)) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

const canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise((res, rej) => {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

const ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise((resolve, reject) => {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = () => reject(markAssetError(new Error("Failed to load script: ".concat(src)))); // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
}

function idleTimeout(ms, err) {
  return new Promise((_resolve, reject) => (0, _requestIdleCallback.default)(() => setTimeout(() => reject(err), ms)));
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  const onBuildManifest = new Promise(resolve => {
    // Mandatory because this is not concurrent safe:
    const cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = () => {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return Promise.race([onBuildManifest, idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')))]);
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute.default)(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(manifest => {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + encodeURI(entry));
    return {
      scripts: allFiles.filter(v => v.endsWith('.js')),
      css: allFiles.filter(v => v.endsWith('.css'))
    };
  });
}

function createRouteLoader(assetPrefix) {
  const entrypoints = new Map();
  const loadedScripts = new Map();
  const styleSheets = new Map();
  const routes = new Map();

  function maybeExecuteScript(src) {
    let prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    let prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(res => {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(text => ({
        href: href,
        content: text
      }));
    }).catch(err => {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },

    onEntrypoint(route, execute) {
      Promise.resolve(execute).then(fn => fn()).then(exports => ({
        component: exports && exports.default || exports,
        exports: exports
      }), err => ({
        error: err
      })).then(input => {
        const old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },

    loadRoute(route) {
      return withFuture(route, routes, async () => {
        try {
          const {
            scripts,
            css
          } = await getFilesForRoute(assetPrefix, route);
          const [, styles] = await Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);
          const entrypoint = await Promise.race([this.whenEntrypoint(route), idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route))))]);
          const res = Object.assign({
            styles
          }, entrypoint);
          return 'error' in entrypoint ? entrypoint : res;
        } catch (err) {
          return {
            error: err
          };
        }
      });
    },

    prefetch(route) {
      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      let cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script, 'script')) : [])).then(() => {
        (0, _requestIdleCallback.default)(() => this.loadRoute(route));
      }).catch( // swallow prefetch errors
      () => {});
    }

  };
}

var _default = createRouteLoader;
exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2.default;
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter.default;
/* global window */

const singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],

  ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }

}; // Create public properties and methods of the router in the singletonRouter

const urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady'];
const routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
const coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get() {
    return _router2.default.events;
  }

});
urlPropertyFields.forEach(field => {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get() {
      const router = getRouter();
      return router[field];
    }

  });
});
coreMethodFields.forEach(field => {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = (...args) => {
    const router = getRouter();
    return router[field](...args);
  };
});
routerEvents.forEach(event => {
  singletonRouter.ready(() => {
    _router2.default.events.on(event, (...args) => {
      const eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      const _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField](...args);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    const message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports.default = _default;

function useRouter() {
  _s();

  return _react.default.useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

const createRouter = (...args) => {
  singletonRouter.router = new _router2.default(...args);
  singletonRouter.readyCallbacks.forEach(cb => cb());
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  const _router = router;
  const instance = {};

  for (const property of urlPropertyFields) {
    if (typeof _router[property] === 'object') {
      instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

      continue;
    }

    instance[property] = _router[property];
  } // Events is a static property on the router, the router doesn't have to be initialized to use it


  instance.events = _router2.default.events;
  coreMethodFields.forEach(field => {
    instance[field] = (...args) => {
      return _router[field](...args);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js"));

const hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection({
  rootMargin,
  disabled
}) {
  const isDisabled = disabled || !hasIntersectionObserver;
  const unobserve = (0, _react.useRef)();
  const [visible, setVisible] = (0, _react.useState)(false);
  const setRef = (0, _react.useCallback)(el => {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {
        rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(() => {
    if (!hasIntersectionObserver) {
      if (!visible) (0, _requestIdleCallback.default)(() => setVisible(true));
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  const {
    id,
    observer,
    elements
  } = createObserver(options);
  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements.delete(element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers.delete(id);
    }
  };
}

const observers = new Map();

function createObserver(options) {
  const id = options.rootMargin || '';
  let instance = observers.get(id);

  if (instance) {
    return instance;
  }

  const elements = new Map();
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      const callback = elements.get(entry.target);
      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id,
    observer,
    elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.default = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react.default.createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const AmpStateContext = /*#__PURE__*/_react.default.createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isInAmpMode({
  ampFirst = false,
  hybrid = false,
  hasQuery = false
} = {}) {
  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react.default.useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const HeadManagerContext = /*#__PURE__*/_react.default.createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead(inAmpMode = false) {
  const head = [/*#__PURE__*/_react.default.createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react.default.createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react.default.Fragment) {
    return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild) => {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

const METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  const keys = new Set();
  const tags = new Set();
  const metaTypes = new Set();
  const metaCategories = {};
  return h => {
    let isUnique = true;
    let hasKey = false;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      hasKey = true;
      const key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (let i = 0, len = METATYPES.length; i < len; i++) {
          const metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            const category = h.props[metatype];
            const categories = metaCategories[metatype] || new Set();

            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce((list, headElement) => {
    const headElementChildren = _react.default.Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map((c, i) => {
    const key = c.key || i;

    if (false) {}

    return /*#__PURE__*/_react.default.cloneElement(c, {
      key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head({
  children
}) {
  const ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  const headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react.default.createElement(_sideEffect.default, {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = () => {};

var _default = Head;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  let detectedLocale; // first item will be empty string from splitting at first char

  const pathnameParts = pathname.split('/');
  (locales || []).some(locale => {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname,
    detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  const all = Object.create(null);
  return {
    on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },

    off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },

    emit(type, ...evts) {
      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(handler => {
        handler(...evts);
      });
    }

  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const RouterContext = /*#__PURE__*/_react.default.createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports.default = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


let detectDomainLocale;

if (false) {}

const basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) {}

  return false;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function pathNoQueryHash(path) {
  const queryIndex = path.indexOf('?');
  const hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = "/".concat(path);
  return path;
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    const locationOrigin = (0, _utils.getLocationOrigin)();
    const resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  let interpolatedRoute = '';
  const dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  const dynamicGroups = dynamicRegex.groups;
  const dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  const params = Object.keys(dynamicGroups);

  if (!params.every(param => {
    let value = dynamicMatches[param] || '';
    const {
      repeat,
      optional
    } = dynamicGroups[param]; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    let replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  const filteredQuery = {};
  Object.keys(query).forEach(key => {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  const base = new URL(currentPath, 'http://n');
  const urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    const finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    let interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
      const {
        result,
        params
      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  const origin = (0, _utils.getLocationOrigin)();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  let [resolvedHref, resolvedAs] = resolveHref(router.pathname, url, true);
  const origin = (0, _utils.getLocationOrigin)();
  const hrefHadOrigin = resolvedHref.startsWith(origin);
  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  const preparedAs = as ? stripOrigin(resolveHref(router.pathname, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

const manualScrollRestoration =  false && false;
const SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(res => {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(data => {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error("Failed to load static props");
        });
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

class Router {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  constructor(_pathname, _query, _as, {
    initialProps,
    pageLoader,
    App,
    wrapApp,
    Component,
    err,
    subscription,
    isFallback,
    locale,
    locales,
    defaultLocale,
    domainLocales
  }) {
    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;
    this.domainLocales = void 0;
    this.isReady = void 0;
    this._idx = 0;

    this.onPopState = e => {
      const state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        const {
          pathname,
          query
        } = this;
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(pathname),
          query
        }), (0, _utils.getURL)());
        return;
      }

      if (!state.__N) {
        return;
      }

      let forcedScroll;
      const {
        url,
        as,
        options,
        idx
      } = state;

      if (false) {}

      this._idx = idx;
      const {
        pathname
      } = (0, _parseRelativeUrl.parseRelativeUrl)(url); // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site

      if (this.isSsr && as === this.asPath && pathname === this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (this._bps && !this._bps(state)) {
        return;
      }

      this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && this._shallow,
        locale: options.locale || this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component,
        initial: true,
        props: initialProps,
        err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    const autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search);

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  reload() {
    window.location.reload();
  }
  /**
  * Go back in history
  */


  back() {
    window.history.back();
  }
  /**
  * Performs a `pushState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  push(url, as, options = {}) {
    if (false) {}

    ;
    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('pushState', url, as, options);
  }
  /**
  * Performs a `replaceState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  replace(url, as, options = {}) {
    ;
    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('replaceState', url, as, options);
  }

  async change(method, url, as, options, forcedScroll) {
    var _options$scroll;

    if (!isLocalURL(url)) {
      window.location.href = url;
      return false;
    } // for static pages with query params in the URL we delay
    // marking the router ready until after the query is updated


    if (options._h) {
      this.isReady = true;
    } // Default to scroll reset behavior unless explicitly specified to be
    // `false`! This makes the behavior between using `Router#push` and a
    // `<Link />` consistent.


    options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);
    let localeChange = options.locale !== this.locale;

    if (false) { var _this$locales; }

    if (!options._h) {
      this.isSsr = false;
    } // marking route changes as a navigation start entry


    if (_utils.ST) {
      performance.mark('routeChange');
    }

    const {
      shallow = false
    } = options;
    const routeProps = {
      shallow
    };

    if (this._inFlightRoute) {
      this.abortComponentLoad(this._inFlightRoute, routeProps);
    }

    as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
    this._inFlightRoute = as; // If the url change is only related to a hash change
    // We should not proceed. We should only change the state.
    // WARNING: `_h` is an internal option for handing Next.js client-side
    // hydration. Your app should _never_ use this property. It may change at
    // any time without notice.

    if (!options._h && this.onlyAHashChange(cleanedAs)) {
      this.asPath = cleanedAs;
      Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

      this.changeState(method, url, as, options);
      this.scrollToHash(cleanedAs);
      this.notify(this.components[this.route], null);
      Router.events.emit('hashChangeComplete', as, routeProps);
      return true;
    }

    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
    let {
      pathname,
      query
    } = parsed; // The build manifest needs to be loaded before auto-static dynamic pages
    // get their query parameters to allow ensuring they can be parsed properly
    // when rewritten to

    let pages, rewrites;

    try {
      pages = await this.pageLoader.getPageList();
      ({
        __rewrites: rewrites
      } = await (0, _routeLoader.getClientBuildManifest)());
    } catch (err) {
      // If we fail to resolve the page list or client-build manifest, we must
      // do a server-side transition:
      window.location.href = as;
      return false;
    }

    parsed = this._resolveHref(parsed, pages);

    if (parsed.pathname !== pathname) {
      pathname = parsed.pathname;
      url = (0, _utils.formatWithValidation)(parsed);
    } // url and as should always be prefixed with basePath by this
    // point by either next/link or router.push/replace so strip the
    // basePath from the pathname to match the pages dir 1-to-1


    pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
    // (not location.reload() but reload getInitialProps and other Next.js stuffs)
    // We also need to set the method = replaceState always
    // as this should not go into the history (That's how browsers work)
    // We should compare the new asPath to the current asPath, not the url

    if (!this.urlIsNew(cleanedAs) && !localeChange) {
      method = 'replaceState';
    }

    let route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // we need to resolve the as value using rewrites for dynamic SSG
    // pages to allow building the data URL correctly

    let resolvedAs = as;

    if ( true && as.startsWith('/')) {
      resolvedAs = (0, _resolveRewrites.default)(addBasePath(addLocale(delBasePath((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname), this.locale)), pages, rewrites, query, p => this._resolveHref({
        pathname: p
      }, pages).pathname, this.locales);

      if (resolvedAs !== as) {
        const potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
          pathname: (0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(resolvedAs) ? delBasePath(resolvedAs) : resolvedAs, this.locales).pathname
        }), pages, false).pathname); // if this directly matches a page we need to update the href to
        // allow the correct page chunk to be loaded

        if (pages.includes(potentialHref)) {
          route = potentialHref;
          pathname = potentialHref;
          parsed.pathname = pathname;
          url = (0, _utils.formatWithValidation)(parsed);
        }
      }
    }

    if (!isLocalURL(as)) {
      if (true) {
        throw new Error("Invalid href: \"".concat(url, "\" and as: \"").concat(as, "\", received relative href and external as") + "\nSee more info: https://err.sh/next.js/invalid-relative-url-external-as");
      }

      window.location.href = as;
      return false;
    }

    resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

    if ((0, _isDynamic.isDynamicRoute)(route)) {
      const parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
      const asPathname = parsedAs.pathname;
      const routeRegex = (0, _routeRegex.getRouteRegex)(route);
      const routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
      const shouldInterpolate = route === asPathname;
      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);

        if (missingParams.length > 0) {
          if (true) {
            console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
          }

          throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));
        }
      } else if (shouldInterpolate) {
        as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {
          pathname: interpolatedAs.result,
          query: omitParmsFromQuery(query, interpolatedAs.params)
        }));
      } else {
        // Merge params into `query`, overwriting any specified in search
        Object.assign(query, routeMatch);
      }
    }

    Router.events.emit('routeChangeStart', as, routeProps);

    try {
      let routeInfo = await this.getRouteInfo(route, pathname, query, addBasePath(addLocale(resolvedAs, this.locale)), routeProps);
      let {
        error,
        props,
        __N_SSG,
        __N_SSP
      } = routeInfo; // handle redirect on client-transition

      if ((__N_SSG || __N_SSP) && props) {
        if (props.pageProps && props.pageProps.__N_REDIRECT) {
          const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
          // client-navigation if it is falling back to hard navigation if
          // it's not

          if (destination.startsWith('/')) {
            const parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

            this._resolveHref(parsedHref, pages, false);

            if (pages.includes(parsedHref.pathname)) {
              const {
                url: newUrl,
                as: newAs
              } = prepareUrlAs(this, destination, destination);
              return this.change(method, newUrl, newAs, options);
            }
          }

          window.location.href = destination;
          return new Promise(() => {});
        } // handle SSG data 404


        if (props.notFound === SSG_DATA_NOT_FOUND) {
          let notFoundRoute;

          try {
            await this.fetchComponent('/404');
            notFoundRoute = '/404';
          } catch (_) {
            notFoundRoute = '/_error';
          }

          routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, {
            shallow: false
          });
        }
      }

      Router.events.emit('beforeHistoryChange', as, routeProps);
      this.changeState(method, url, as, options);

      if (true) {
        const appComp = this.components['/_app'].Component;
        window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
      }

      await this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (options.scroll ? {
        x: 0,
        y: 0
      } : null)).catch(e => {
        if (e.cancelled) error = error || e;else throw e;
      });

      if (error) {
        Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
        throw error;
      }

      if (false) {}

      Router.events.emit('routeChangeComplete', as, routeProps);
      return true;
    } catch (err) {
      if (err.cancelled) {
        return false;
      }

      throw err;
    }
  }

  changeState(method, url, as, options = {}) {
    if (true) {
      if (typeof window.history === 'undefined') {
        console.error("Warning: window.history is not available.");
        return;
      }

      if (typeof window.history[method] === 'undefined') {
        console.error("Warning: window.history.".concat(method, " is not available"));
        return;
      }
    }

    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
      this._shallow = options.shallow;
      window.history[method]({
        url,
        as,
        options,
        __N: true,
        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
      }, // Most browsers currently ignores this parameter, although they may use it in the future.
      // Passing the empty string here should be safe against future changes to the method.
      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
      '', as);
    }
  }

  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
    if (err.cancelled) {
      // bubble up cancellation errors
      throw err;
    }

    if ((0, _routeLoader.isAssetError)(err) || loadErrorFail) {
      Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
      //  1. Page doesn't exists
      //  2. Page does exist in a different zone
      //  3. Internal error while loading the page
      // So, doing a hard reload is the proper way to deal with this.

      window.location.href = as; // Changing the URL doesn't block executing the current code path.
      // So let's throw a cancellation error stop the routing logic.

      throw buildCancellationError();
    }

    try {
      let Component;
      let styleSheets;
      let props;

      if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {
        ;
        ({
          page: Component,
          styleSheets
        } = await this.fetchComponent('/_error'));
      }

      const routeInfo = {
        props,
        Component,
        styleSheets,
        err,
        error: err
      };

      if (!routeInfo.props) {
        try {
          routeInfo.props = await this.getInitialProps(Component, {
            err,
            pathname,
            query
          });
        } catch (gipErr) {
          console.error('Error in error page `getInitialProps`: ', gipErr);
          routeInfo.props = {};
        }
      }

      return routeInfo;
    } catch (routeInfoErr) {
      return this.handleRouteInfoError(routeInfoErr, pathname, query, as, routeProps, true);
    }
  }

  async getRouteInfo(route, pathname, query, as, routeProps) {
    try {
      const existingRouteInfo = this.components[route];

      if (routeProps.shallow && existingRouteInfo && this.route === route) {
        return existingRouteInfo;
      }

      const cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;
      const routeInfo = cachedRouteInfo ? cachedRouteInfo : await this.fetchComponent(route).then(res => ({
        Component: res.page,
        styleSheets: res.styleSheets,
        __N_SSG: res.mod.__N_SSG,
        __N_SSP: res.mod.__N_SSP
      }));
      const {
        Component,
        __N_SSG,
        __N_SSP
      } = routeInfo;

      if (true) {
        const {
          isValidElementType
        } = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

        if (!isValidElementType(Component)) {
          throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));
        }
      }

      let dataHref;

      if (__N_SSG || __N_SSP) {
        dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
          pathname,
          query
        }), delBasePath(as), __N_SSG, this.locale);
      }

      const props = await this._getData(() => __N_SSG ? this._getStaticData(dataHref) : __N_SSP ? this._getServerData(dataHref) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
      {
        pathname,
        query,
        asPath: as
      }));
      routeInfo.props = props;
      this.components[route] = routeInfo;
      return routeInfo;
    } catch (err) {
      return this.handleRouteInfoError(err, pathname, query, as, routeProps);
    }
  }

  set(route, pathname, query, as, data, resetScroll) {
    this.isFallback = false;
    this.route = route;
    this.pathname = pathname;
    this.query = query;
    this.asPath = as;
    return this.notify(data, resetScroll);
  }
  /**
  * Callback to execute before replacing router state
  * @param cb callback to be executed
  */


  beforePopState(cb) {
    this._bps = cb;
  }

  onlyAHashChange(as) {
    if (!this.asPath) return false;
    const [oldUrlNoHash, oldHash] = this.asPath.split('#');
    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same

    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
      return true;
    } // If the urls are change, there's more than a hash change


    if (oldUrlNoHash !== newUrlNoHash) {
      return false;
    } // If the hash has changed, then it's a hash only change.
    // This check is necessary to handle both the enter and
    // leave hash === '' cases. The identity case falls through
    // and is treated as a next reload.


    return oldHash !== newHash;
  }

  scrollToHash(as) {
    const [, hash] = as.split('#'); // Scroll to top if the hash is just `#` with no value

    if (hash === '') {
      window.scrollTo(0, 0);
      return;
    } // First we check if the element by id is found


    const idEl = document.getElementById(hash);

    if (idEl) {
      idEl.scrollIntoView();
      return;
    } // If there's no element with the id, we check the `name` property
    // To mirror browsers


    const nameEl = document.getElementsByName(hash)[0];

    if (nameEl) {
      nameEl.scrollIntoView();
    }
  }

  urlIsNew(asPath) {
    return this.asPath !== asPath;
  }

  _resolveHref(parsedHref, pages, applyBasePath = true) {
    const {
      pathname
    } = parsedHref;
    const cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

    if (cleanPathname === '/404' || cleanPathname === '/_error') {
      return parsedHref;
    } // handle resolving href for dynamic routes


    if (!pages.includes(cleanPathname)) {
      // eslint-disable-next-line array-callback-return
      pages.some(page => {
        if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
          parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
          return true;
        }
      });
    }

    parsedHref.pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(parsedHref.pathname);
    return parsedHref;
  }
  /**
  * Prefetch page code, you may wait for the data during page rendering.
  * This feature only works in production!
  * @param url the href of prefetched page
  * @param asPath the as path of the prefetched page
  */


  async prefetch(url, asPath = url, options = {}) {
    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
    let {
      pathname
    } = parsed;

    if (false) {}

    const pages = await this.pageLoader.getPageList();
    parsed = this._resolveHref(parsed, pages, false);

    if (parsed.pathname !== pathname) {
      pathname = parsed.pathname;
      url = (0, _utils.formatWithValidation)(parsed);
    } // Prefetch is not supported in development mode because it would trigger on-demand-entries


    if (true) {
      return;
    }

    const route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
    await Promise.all([this.pageLoader._isSsg(url).then(isSsg => {
      return isSsg ? this._getStaticData(this.pageLoader.getDataHref(url, asPath, true, typeof options.locale !== 'undefined' ? options.locale : this.locale)) : false;
    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);
  }

  async fetchComponent(route) {
    let cancelled = false;

    const cancel = this.clc = () => {
      cancelled = true;
    };

    const componentResult = await this.pageLoader.loadPage(route);

    if (cancelled) {
      const error = new Error("Abort fetching component for route: \"".concat(route, "\""));
      error.cancelled = true;
      throw error;
    }

    if (cancel === this.clc) {
      this.clc = null;
    }

    return componentResult;
  }

  _getData(fn) {
    let cancelled = false;

    const cancel = () => {
      cancelled = true;
    };

    this.clc = cancel;
    return fn().then(data => {
      if (cancel === this.clc) {
        this.clc = null;
      }

      if (cancelled) {
        const err = new Error('Loading initial props cancelled');
        err.cancelled = true;
        throw err;
      }

      return data;
    });
  }

  _getStaticData(dataHref) {
    const {
      href: cacheKey
    } = new URL(dataHref, window.location.href);

    if (false) {}

    return fetchNextData(dataHref, this.isSsr).then(data => {
      this.sdc[cacheKey] = data;
      return data;
    });
  }

  _getServerData(dataHref) {
    return fetchNextData(dataHref, this.isSsr);
  }

  getInitialProps(Component, ctx) {
    const {
      Component: App
    } = this.components['/_app'];

    const AppTree = this._wrapApp(App);

    ctx.AppTree = AppTree;
    return (0, _utils.loadGetInitialProps)(App, {
      AppTree,
      Component,
      router: this,
      ctx
    });
  }

  abortComponentLoad(as, routeProps) {
    if (this.clc) {
      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
      this.clc();
      this.clc = null;
    }
  }

  notify(data, resetScroll) {
    return this.sub(data, this.components['/_app'].Component, resetScroll);
  }

}

exports.default = Router;
Router.events = (0, _mitt.default)();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


const slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  let {
    auth,
    hostname
  } = urlObj;
  let protocol = urlObj.protocol || '';
  let pathname = urlObj.pathname || '';
  let hash = urlObj.hash || '';
  let query = urlObj.query || '';
  let host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  let search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route, ext = '') {
  const path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  const globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  const resolvedBase = base ? new URL(base, globalBase) : globalBase;
  const {
    pathname,
    searchParams,
    search,
    hash,
    href,
    origin
  } = new URL(url, resolvedBase);

  if (origin !== globalBase.origin) {
    throw new Error("invariant: invalid relative URL, router received ".concat(url));
  }

  return {
    pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search,
    hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports.default = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

const matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

const customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = (customRoute = false) => {
  return path => {
    const keys = [];
    const matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return (pathname, params) => {
      const res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        for (const key of keys) {
          // unnamed params should be removed as they
          // are not allowed to be used in the destination
          if (typeof key.name === 'number') {
            delete res.params[key.name];
          }
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.compileNonPath = compileNonPath;
exports.default = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function compileNonPath(value, params) {
  if (!value.includes(':')) {
    return value;
  }

  for (const key of Object.keys(params)) {
    if (value.includes(":".concat(key))) {
      value = value.replace(new RegExp(":".concat(key, "\\*"), 'g'), ":".concat(key, "--ESCAPED_PARAM_ASTERISKS")).replace(new RegExp(":".concat(key, "\\?"), 'g'), ":".concat(key, "--ESCAPED_PARAM_QUESTION")).replace(new RegExp(":".concat(key, "\\+"), 'g'), ":".concat(key, "--ESCAPED_PARAM_PLUS")).replace(new RegExp(":".concat(key, "(?!\\w)"), 'g'), "--ESCAPED_PARAM_COLON".concat(key));
    }
  }

  value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled
  // correctly

  return pathToRegexp.compile("/".concat(value), {
    validate: false
  })(params).substr(1);
}

function prepareDestination(destination, params, query, appendParamsToQuery) {
  let parsedDestination = {}; // clone query so we don't modify the original

  query = Object.assign({}, query);
  const hadLocale = query.__nextLocale;
  delete query.__nextLocale;
  delete query.__nextDefaultLocale;

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    const {
      pathname,
      searchParams,
      hash,
      hostname,
      port,
      protocol,
      search,
      href
    } = new URL(destination);
    parsedDestination = {
      pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash,
      protocol,
      hostname,
      port,
      search,
      href
    };
  }

  const destQuery = parsedDestination.query;
  const destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  const destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  const destPathParams = destPathParamKeys.map(key => key.name);
  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  let newUrl; // update any params in query values

  for (const [key, strOrArray] of Object.entries(destQuery)) {
    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = compileNonPath(value, params);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  let paramKeys = Object.keys(params); // remove internal param for i18n

  if (hadLocale) {
    paramKeys = paramKeys.filter(name => name !== 'nextInternalLocale');
  }

  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {
    for (const key of paramKeys) {
      if (!(key in destQuery)) {
        destQuery[key] = params[key];
      }
    }
  }

  try {
    newUrl = destinationCompiler(params);
    const [pathname, hash] = newUrl.split('#');
    parsedDestination.pathname = pathname;
    parsedDestination.hash = "".concat(hash ? '#' : '').concat(hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl,
    parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  const query = {};
  searchParams.forEach((value, key) => {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  const result = new URLSearchParams();
  Object.entries(urlQuery).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach(item => result.append(key, stringifyUrlQueryParam(item)));
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target, ...searchParamsList) {
  searchParamsList.forEach(searchParams => {
    Array.from(searchParams.keys()).forEach(key => target.delete(key));
    searchParams.forEach((value, key) => target.append(key, value));
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const customRouteMatcher = (0, _pathMatch.default)(true);

function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
  if (!pages.includes((0, _normalizeLocalePath.normalizeLocalePath)(asPath, locales).pathname)) {
    for (const rewrite of rewrites) {
      const matcher = customRouteMatcher(rewrite.source);
      const params = matcher(asPath);

      if (params) {
        if (!rewrite.destination) {
          // this is a proxied rewrite which isn't handled on the client
          break;
        }

        const destRes = (0, _prepareDestination.default)(rewrite.destination, params, query, true);
        asPath = destRes.parsedDestination.pathname;
        Object.assign(query, destRes.parsedDestination.query);
        const fsPathname = (0, _normalizeLocalePath.normalizeLocalePath)((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath), locales).pathname;

        if (pages.includes(fsPathname)) {
          asPath = fsPathname; // check if we now match a page as this means we are done
          // resolving the rewrites

          break;
        } // check if we match a dynamic-route, if so we break the rewrites chain


        const resolvedHref = resolveHref(fsPathname);

        if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
          asPath = fsPathname;
          break;
        }
      }
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  const {
    re,
    groups
  } = routeRegex;
  return pathname => {
    const routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    const decode = param => {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        const err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    const params = {};
    Object.keys(groups).forEach(slugName => {
      const g = groups[slugName];
      const m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(entry => decode(entry)) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  const optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  const repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat,
    optional
  };
}

function getRouteRegex(normalizedRoute) {
  const segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  const groups = {};
  let groupIndex = 1;
  const parameterizedRoute = segments.map(segment => {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      const {
        key,
        optional,
        repeat
      } = parseParameter(segment.slice(1, -1));
      groups[key] = {
        pos: groupIndex++,
        repeat,
        optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

const isServer = false;

class _default extends _react.Component {
  constructor(props) {
    super(props);
    this._hasHeadManager = void 0;

    this.emitChange = () => {
      if (this._hasHeadManager) {
        this.props.headManager.updateHead(this.props.reduceComponentsToState([...this.props.headManager.mountedInstances], this.props));
      }
    };

    this._hasHeadManager = this.props.headManager && this.props.headManager.mountedInstances;

    if (isServer && this._hasHeadManager) {
      this.props.headManager.mountedInstances.add(this);
      this.emitChange();
    }
  }

  componentDidMount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances.add(this);
    }

    this.emitChange();
  }

  componentDidUpdate() {
    this.emitChange();
  }

  componentWillUnmount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances.delete(this);
    }

    this.emitChange();
  }

  render() {
    return null;
  }

}

exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  let used = false;
  let result;
  return (...args) => {
    if (!used) {
      used = true;
      result = fn(...args);
    }

    return result;
  };
}

function getLocationOrigin() {
  const {
    protocol,
    hostname,
    port
  } = window.location;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  const {
    href
  } = window.location;
  const origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

async function loadGetInitialProps(App, ctx) {
  if (true) {
    var _App$prototype;

    if ((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps) {
      const message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
      throw new Error(message);
    }
  } // when called from _app `ctx` is nested in `ctx`


  const res = ctx.res || ctx.ctx && ctx.ctx.res;

  if (!App.getInitialProps) {
    if (ctx.ctx && ctx.Component) {
      // @ts-ignore pageProps default
      return {
        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
      };
    }

    return {};
  }

  const props = await App.getInitialProps(ctx);

  if (res && isResSent(res)) {
    return props;
  }

  if (!props) {
    const message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
    throw new Error(message);
  }

  if (true) {
    if (Object.keys(props).length === 0 && !ctx.ctx) {
      console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
    }
  }

  return props;
}

const urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(key => {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

const SP = typeof performance !== 'undefined';
exports.SP = SP;
const ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js")


/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./pages/404.js":
/*!**********************!*\
  !*** ./pages/404.js ***!
  \**********************/
/*! exports provided: NotFoundPage, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotFoundPage", function() { return NotFoundPage; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Container */ "./components/Container.js");
/* harmony import */ var _components_HomeButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/HomeButton */ "./components/HomeButton.js");

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\pages\\404.js";



const NotFoundPage = () => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Container__WEBPACK_IMPORTED_MODULE_2__["default"], {
    home: true,
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_1___default.a, {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
        children: "404 - Page Not Found"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 10,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 9,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
      id: "relative block",
      className: "h-96 relative",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "absolute w-full h-full bg-transparent",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h1", {
          className: "mt-25 p-5 text-center\r text-4xl md:text-6xl lg:text-6xl font-bold \r text-red-500",
          children: "404 Page Not Found"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 14,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 13,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        id: "404",
        className: "bg-gray-900 \r w-10% py-10 flex flex-col items-center justify-center",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 31,
          columnNumber: 11
        }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_HomeButton__WEBPACK_IMPORTED_MODULE_3__["default"], {
          caption: "Return Home",
          className: "mr-1 mb-1 text-white bg-red-700\r hover:bg-yellow-500 hover:text-black \r font-bold text-md px-4 py-2 rounded shadow hover:shadow-md outline-none focus:outline-none \r transition all ease duration-500"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 32,
          columnNumber: 11
        }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("canvas", {
          id: "viz404",
          className: "w-2/3 h-1/8 bg-gray-900 "
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 39,
          columnNumber: 11
        }, undefined)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 8,
    columnNumber: 5
  }, undefined);
};
_c = NotFoundPage;
/* harmony default export */ __webpack_exports__["default"] = (NotFoundPage);

var _c;

$RefreshReg$(_c, "NotFoundPage");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F404&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-gh-pages-example%5Cpages%5C404.js!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BdmF0YXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ29udGFpbmVyLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9IYW1idXJnZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvSGFtYnVyZ2VyTWVudS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9IZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0hlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Ib21lQnV0dG9uLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL05hdmJhci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbGliL2hvb2tzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzPzI5ODIiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvbGluay50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcm91dGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24udHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3dpdGgtcm91dGVyLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9hbXAtY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9hbXAudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvaGVhZC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvbWl0dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhdGgtbWF0Y2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3ByZXBhcmUtZGVzdGluYXRpb24udHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yZXNvbHZlLXJld3JpdGVzLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9zaWRlLWVmZmVjdC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaGVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8od2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvNDA0LmpzIl0sIm5hbWVzIjpbIkF2YXRhciIsImNsYXNzTmFtZSIsImRlc2NyaXB0aW9uIiwic2l0ZVRpdGxlIiwicHJvZmlsZU5hbWUiLCJDb250YWluZXIiLCJjaGlsZHJlbiIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIm5vZGUiLCJpc1JlcXVpcmVkIiwiRm9vdGVyIiwiY2FwdGlvbiIsImF1dGhvciIsInN0cmluZyIsIkhhbWJ1cmdlciIsIm9wZW4iLCJzZXRPcGVuIiwicHJvcHMiLCJpc09wZW4iLCJoYW5kbGVUb2dnbGVNZW51Q2xpY2siLCJldmVudCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJwcmV2ZW50RGVmYXVsdCIsImJvb2wiLCJmdW5jIiwiSGFtYnVyZ2VyTWVudSIsImlzSGlkZGVuIiwiSGVhZCIsInRpdGxlIiwiSGVhZGVyIiwiZGVmYXVsdEJ1dHRvbkNhcHRpb24iLCJkZWZhdWx0Q2xhc3NOYW1lIiwiSG9tZUJ1dHRvbiIsImJ1dHRvbkNhcHRpb24iLCJzZXRCdXR0b25DYXB0aW9uIiwidGhpc0NsYXNzTmFtZSIsInNldENsYXNzTmFtZSIsIm5ld0NhcHRpb24iLCJ1bmRlZmluZWQiLCJuZXdDbGFzc05hbWUiLCJOYXZCYXIiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsIm1lbnVJZCIsInVzZU9uTW91c2VDbGlja091dHNpZGVOYXYiLCJyZWYiLCJoYW5kbGVyIiwidXNlRWZmZWN0IiwibGlzdGVuZXIiLCJjdXJyZW50IiwiY29udGFpbnMiLCJ0YXJnZXQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHJlZmV0Y2hlZCIsInJvdXRlciIsImVyciIsImN1ckxvY2FsZSIsIm9wdGlvbnMiLCJocmVmIiwiZSIsIm5vZGVOYW1lIiwiaXNNb2RpZmllZEV2ZW50Iiwic2Nyb2xsIiwiYXMiLCJyZXBsYWNlIiwic3VjY2VzcyIsImFyZ3MiLCJrZXkiLCJleHBlY3RlZCIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJPYmplY3QiLCJjcmVhdGVQcm9wRXJyb3IiLCJhY3R1YWwiLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwic2hhbGxvdyIsInBhc3NIcmVmIiwicHJlZmV0Y2giLCJsb2NhbGUiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsIlJlYWN0IiwiY29uc29sZSIsInAiLCJwYXRobmFtZSIsInJlc29sdmVkQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwiY2hpbGRSZWYiLCJyb290TWFyZ2luIiwic2V0UmVmIiwiZWwiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJzaG91bGRQcmVmZXRjaCIsImlzVmlzaWJsZSIsImlzUHJlZmV0Y2hlZCIsImNoaWxkUHJvcHMiLCJvbkNsaWNrIiwibGlua0NsaWNrZWQiLCJwcmlvcml0eSIsImxvY2FsZURvbWFpbiIsIkxpbmsiLCJwYXRoIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJwcm9jZXNzIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNlbGYiLCJzdGFydCIsIkRhdGUiLCJzZXRUaW1lb3V0IiwiY2IiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIk1hdGgiLCJNU19NQVhfSURMRV9ERUxBWSIsImVudHJ5IiwibWFwIiwiUHJvbWlzZSIsInByb20iLCJyZXNvbHZlIiwicmVzb2x2ZXIiLCJmdXR1cmUiLCJnZW5lcmF0b3IiLCJ2YWx1ZSIsImxpbmsiLCJ3aW5kb3ciLCJjYW5QcmVmZXRjaCIsImhhc1ByZWZldGNoIiwicmVzIiwiQVNTRVRfTE9BRF9FUlJPUiIsIlN5bWJvbCIsInNjcmlwdCIsInJlamVjdCIsIm1hcmtBc3NldEVycm9yIiwib25CdWlsZE1hbmlmZXN0IiwiaWRsZVRpbWVvdXQiLCJzY3JpcHRzIiwiYXNzZXRQcmVmaXgiLCJlbmNvZGVVUkkiLCJjc3MiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwibWFuaWZlc3QiLCJyb3V0ZSIsImFsbEZpbGVzIiwidiIsImVudHJ5cG9pbnRzIiwibG9hZGVkU2NyaXB0cyIsInN0eWxlU2hlZXRzIiwicm91dGVzIiwiYXBwZW5kU2NyaXB0IiwiZmV0Y2giLCJ0ZXh0IiwiY29udGVudCIsIndoZW5FbnRyeXBvaW50Iiwid2l0aEZ1dHVyZSIsIm9uRW50cnlwb2ludCIsImZuIiwiZXhwb3J0cyIsImNvbXBvbmVudCIsImVycm9yIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJnZXRGaWxlc0ZvclJvdXRlIiwiZW50cnlwb2ludCIsImNuIiwibmF2aWdhdG9yIiwib3V0cHV0IiwicHJlZmV0Y2hWaWFEb20iLCJjcmVhdGVSb3V0ZUxvYWRlciIsInNpbmdsZXRvblJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJnZXQiLCJSb3V0ZXIiLCJmaWVsZCIsImdldFJvdXRlciIsImV2ZW50RmllbGQiLCJfc2luZ2xldG9uUm91dGVyIiwibWVzc2FnZSIsIlJvdXRlckNvbnRleHQiLCJjcmVhdGVSb3V0ZXIiLCJfcm91dGVyIiwiaW5zdGFuY2UiLCJBcnJheSIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiaXNEaXNhYmxlZCIsImRpc2FibGVkIiwidW5vYnNlcnZlIiwib2JzZXJ2ZSIsInNldFZpc2libGUiLCJjcmVhdGVPYnNlcnZlciIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJpZCIsImVudHJpZXMiLCJjYWxsYmFjayIsIkNvbXBvc2VkQ29tcG9uZW50IiwiZ2V0SW5pdGlhbFByb3BzIiwiV2l0aFJvdXRlcldyYXBwZXIiLCJuYW1lIiwiQW1wU3RhdGVDb250ZXh0IiwiYW1wRmlyc3QiLCJoeWJyaWQiLCJoYXNRdWVyeSIsImlzSW5BbXBNb2RlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiaW5BbXBNb2RlIiwiaGVhZCIsImxpc3QiLCJmcmFnbWVudExpc3QiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5IiwiaSIsImxlbiIsIm1ldGF0eXBlIiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwiaGVhZEVsZW1lbnRzIiwiaGVhZEVsZW1lbnRDaGlsZHJlbiIsImhlYWRFbGVtZW50IiwiZGVmYXVsdEhlYWQiLCJ1bmlxdWUiLCJjIiwiYW1wU3RhdGUiLCJoZWFkTWFuYWdlciIsInBhdGhuYW1lUGFydHMiLCJsb2NhbGVzIiwiZGV0ZWN0ZWRMb2NhbGUiLCJhbGwiLCJvbiIsIm9mZiIsImVtaXQiLCJiYXNlUGF0aCIsImNhbmNlbGxlZCIsInByZWZpeCIsInBhdGhOb1F1ZXJ5SGFzaCIsInF1ZXJ5SW5kZXgiLCJoYXNoSW5kZXgiLCJhZGRQYXRoUHJlZml4IiwidXJsIiwibG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsImhhc0Jhc2VQYXRoIiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJhc1BhdGhuYW1lIiwicGFyYW1zIiwicGFyYW0iLCJyZXBsYWNlZCIsInJlcGVhdCIsIm9wdGlvbmFsIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3VsdCIsImZpbHRlcmVkUXVlcnkiLCJxdWVyeSIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImlzTG9jYWxVUkwiLCJyZXNvbHZlQXMiLCJmaW5hbFVybCIsImludGVycG9sYXRlZEFzIiwiaW50ZXJwb2xhdGVBcyIsImhhc2giLCJvbWl0UGFybXNGcm9tUXVlcnkiLCJyZXNvbHZlZEhyZWYiLCJvcmlnaW4iLCJyZXNvbHZlSHJlZiIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInN0cmlwT3JpZ2luIiwicHJlcGFyZWRVcmwiLCJhZGRCYXNlUGF0aCIsInByZXBhcmVkQXMiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIlNTR19EQVRBX05PVF9GT1VORCIsImNyZWRlbnRpYWxzIiwiYXR0ZW1wdHMiLCJmZXRjaFJldHJ5IiwiZGF0YSIsIm5vdEZvdW5kIiwiaXNTZXJ2ZXJSZW5kZXIiLCJjb25zdHJ1Y3RvciIsImFzUGF0aCIsImNvbXBvbmVudHMiLCJzZGMiLCJzdWIiLCJjbGMiLCJwYWdlTG9hZGVyIiwiX2JwcyIsImV2ZW50cyIsIl93cmFwQXBwIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwiX2luRmxpZ2h0Um91dGUiLCJfc2hhbGxvdyIsImRlZmF1bHRMb2NhbGUiLCJkb21haW5Mb2NhbGVzIiwiaXNSZWFkeSIsIl9pZHgiLCJzdGF0ZSIsImluaXRpYWwiLCJfX05fU1NHIiwiaW5pdGlhbFByb3BzIiwiX19OX1NTUCIsIkNvbXBvbmVudCIsImF1dG9FeHBvcnREeW5hbWljIiwicmVsb2FkIiwiYmFjayIsInB1c2giLCJwcmVwYXJlVXJsQXMiLCJsb2NhbGVDaGFuZ2UiLCJTVCIsInBlcmZvcm1hbmNlIiwicm91dGVQcm9wcyIsImFkZExvY2FsZSIsImRlbEJhc2VQYXRoIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwicGFyc2VkIiwicGFnZXMiLCJfX3Jld3JpdGVzIiwibWV0aG9kIiwicG90ZW50aWFsSHJlZiIsInBhcnNlZEFzIiwicm91dGVSZWdleCIsInJvdXRlTWF0Y2giLCJzaG91bGRJbnRlcnBvbGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJyb3V0ZUluZm8iLCJkZXN0aW5hdGlvbiIsInBhcnNlZEhyZWYiLCJub3RGb3VuZFJvdXRlIiwiYXBwQ29tcCIsImZvcmNlZFNjcm9sbCIsIngiLCJ5IiwiY2hhbmdlU3RhdGUiLCJfX04iLCJpZHgiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwicGFnZSIsImV4aXN0aW5nUm91dGVJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwicmVxdWlyZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImRhdGFIcmVmIiwic2V0IiwiYmVmb3JlUG9wU3RhdGUiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImlkRWwiLCJuYW1lRWwiLCJ1cmxJc05ldyIsIl9yZXNvbHZlSHJlZiIsImFwcGx5QmFzZVBhdGgiLCJjbGVhblBhdGhuYW1lIiwiaXNTc2ciLCJjYW5jZWwiLCJjb21wb25lbnRSZXN1bHQiLCJfZ2V0RGF0YSIsIl9nZXRTdGF0aWNEYXRhIiwiZmV0Y2hOZXh0RGF0YSIsIl9nZXRTZXJ2ZXJEYXRhIiwiQXBwVHJlZSIsImN0eCIsImFib3J0Q29tcG9uZW50TG9hZCIsIm5vdGlmeSIsInNsYXNoZWRQcm90b2NvbHMiLCJwcm90b2NvbCIsInVybE9iaiIsImhvc3QiLCJhdXRoIiwiaG9zdG5hbWUiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInNlYXJjaCIsImV4dCIsIlRFU1RfUk9VVEUiLCJnbG9iYWxCYXNlIiwicmVzb2x2ZWRCYXNlIiwibWF0Y2hlck9wdGlvbnMiLCJzZW5zaXRpdmUiLCJkZWxpbWl0ZXIiLCJjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zIiwic3RyaWN0IiwiY3VzdG9tUm91dGUiLCJtYXRjaGVyUmVnZXgiLCJwYXRoVG9SZWdleHAiLCJtYXRjaGVyIiwidmFsaWRhdGUiLCJwYXJzZWREZXN0aW5hdGlvbiIsImhhZExvY2FsZSIsImRlc3RRdWVyeSIsImRlc3RQYXRoIiwiZGVzdFBhdGhQYXJhbUtleXMiLCJkZXN0UGF0aFBhcmFtcyIsImRlc3RpbmF0aW9uQ29tcGlsZXIiLCJzdHJPckFycmF5IiwiY29tcGlsZU5vblBhdGgiLCJwYXJhbUtleXMiLCJhcHBlbmRQYXJhbXNUb1F1ZXJ5IiwibmV3VXJsIiwic2VhcmNoUGFyYW1zIiwiaXNOYU4iLCJpdGVtIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInNlYXJjaFBhcmFtc0xpc3QiLCJjdXN0b21Sb3V0ZU1hdGNoZXIiLCJyZXdyaXRlIiwiZGVzdFJlcyIsImZzUGF0aG5hbWUiLCJyZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNsdWdOYW1lIiwiZyIsImdyb3VwcyIsIm0iLCJzdHIiLCJzZWdtZW50cyIsIm5vcm1hbGl6ZWRSb3V0ZSIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJwYXJzZVBhcmFtZXRlciIsInBvcyIsImVzY2FwZVJlZ2V4IiwiaXNTZXJ2ZXIiLCJfaGFzSGVhZE1hbmFnZXIiLCJlbWl0Q2hhbmdlIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsInVzZWQiLCJwb3J0IiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJBcHAiLCJnZXREaXNwbGF5TmFtZSIsInBhZ2VQcm9wcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJpc1Jlc1NlbnQiLCJ1cmxPYmplY3RLZXlzIiwiU1AiLCJOb3RGb3VuZFBhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1BLE1BQU0sR0FBRyxDQUFDO0FBQUVDO0FBQUYsQ0FBRCxLQUFtQjtBQUNoQyxzQkFDRTtBQUNFLFdBQU8sRUFBQyxLQURWO0FBRUUsTUFBRSxFQUFDLFNBRkw7QUFHRSxhQUFTLEVBQUVBLFNBSGI7QUFJRSxRQUFJLEVBQUMsTUFKUDtBQUtFLFdBQU8sRUFBQyx5QkFMVjtBQUFBLDRCQU9FO0FBQU8sUUFBRSxFQUFDLFdBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBUEYsZUFRRTtBQUFVLFFBQUUsRUFBQztB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LGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEM7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7O0FBR2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsMkRBQTJELFNBQVM7QUFDcEUseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFB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MEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEM7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7O0FBR2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7OztBQzV4RWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsaUZBQTRCO0FBQ3ZEOzs7Ozs7Ozs7Ozs7O0FDTmE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsaUhBQTRDO0FBQ3ZFOzs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJBO0FBRUE7QUFDQTtBQUVPLE1BQU1zSSxZQUFZLEdBQUcsTUFBTTtBQUNoQyxzQkFDRSxxRUFBQyw2REFBRDtBQUFXLFFBQUksTUFBZjtBQUFBLDRCQUNFLHFFQUFDLGdEQUFEO0FBQUEsNkJBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQURGLGVBSUU7QUFBUyxRQUFFLEVBQUMsZ0JBQVo7QUFBNkIsZUFBUyxFQUFDLGVBQXZDO0FBQUEsNkJBQ0U7QUFBSyxpQkFBUyxFQUFDLHVDQUFmO0FBQUEsK0JBQ0U7QUFDRSxtQkFBUyxFQUFDLG9GQURaO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBSkYsZUFpQkU7QUFBQSw2QkFDRTtBQUNFLFVBQUUsRUFBQyxLQURMO0FBRUUsaUJBQVMsRUFBQyxzRUFGWjtBQUFBLGdDQUtFO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJBTEYsZUFNRSxxRUFBQyw4REFBRDtBQUNFLGlCQUFPLEVBQUMsYUFEVjtBQUVFLG1CQUFTLEVBQUM7QUFGWjtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQU5GLGVBYUU7QUFBUSxZQUFFLEVBQUMsUUFBWDtBQUFvQixtQkFBUyxFQUFDO0FBQTlCO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJBYkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFqQkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBREY7QUFxQ0QsQ0F0Q007S0FBTUEsWTtBQXdDRUEsMkVBQWYiLCJmaWxlIjoic3RhdGljL2NodW5rcy9wYWdlcy80MDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUHJvZmlsZSBBdmF0YXIgYXMgU1ZHXHJcbiAqIEBkZXNjcmlwdGlvbiBNYWluIFNpdGUgQXZhdGFyIGZvciBwcm9maWxlXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5jb25zdCBBdmF0YXIgPSAoeyBjbGFzc05hbWUgfSkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHZlcnNpb249XCIxLjFcIlxyXG4gICAgICBpZD1cInN2ZzMxNjlcIlxyXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cclxuICAgICAgZmlsbD1cIm5vbmVcIlxyXG4gICAgICB2aWV3Qm94PVwiMCAwIDU0MC44NDUwOSA1MzkuNDkyOThcIlxyXG4gICAgPlxyXG4gICAgICA8dGl0bGUgaWQ9XCJ0aXRsZTM3NDJcIj5kdHJvLWRldnVrIGF2YXRhciA8L3RpdGxlPlxyXG4gICAgICA8bWV0YWRhdGEgaWQ9XCJtZXRhZGF0YTMxNzVcIj48L21ldGFkYXRhPlxyXG4gICAgICA8ZGVmcyBpZD1cImRlZnMzMTczXCIgLz5cclxuICAgICAgPGltYWdlXHJcbiAgICAgICAgd2lkdGg9XCI1NDAuODQ1MDlcIlxyXG4gICAgICAgIGhlaWdodD1cIjUzOS40OTI5OFwiXHJcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIlxyXG4gICAgICAgIGhyZWY9XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVpBQUFBR1BDQVlBQUFCeVA0YUNBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeFxyXG4gIGp3djhZUVVBQUFBSmNFaFpjd0FBQ3VzQUFBcnJBWUtMRFZvQUFBRGJhVlJZZEZoTlREcGpiMjB1WVdSdlltVXVlRzF3QUFBQUFBQThcclxuICBQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BnMEtQSGc2XHJcbiAgZUcxd2JXVjBZU0I0Yld4dWN6cDRQU0poWkc5aVpUcHVjenB0WlhSaEx5SStEUW9nSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaVxyXG4gIGFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJZ0x6NE5Dand2ZURwNGJYQnRcclxuICBaWFJoUGcwS1BEOTRjR0ZqYTJWMElHVnVaRDBpY2lJL1BpTUhkRkVBQVA2K1NVUkJWSGhlN0wwSHdHMVhWU2UrdnQ3NzY3Mi9sMDRxXHJcbiAgQ1FHQkFBRkJIVVVIUmtmRmpuMGN5OThaSFVXeGpIMTBITkd4OTBIVUVVWkZCTklnQk5KSWZjbDd5ZXYxZStYcnZmL1hiNjIxMnluM1xyXG4gIHU5OTdpUUdTMzczNzdOWDJQdnVlZTg1ZVo1ZXpUODNTM0ZOTEZHRnBhWW1lZXVvNWV1dmIzMHY5NXdaTW1rVXRVUTBIUTAyTkVZS0VcclxuICBZV1I1UnBxQUVmTVJMV1NKanVtUVRTd0htQy9VR1YybTA2L1NNWkx5UnJTUUdWdm1TNDlIenQ3b2pMMW5jL1lBODFsUkxCQjE0SmNXXHJcbiAgNTJsdXJKK0pCWk5rVUZOSERaMGIrTytzdDJ6aTFERWs0d0lVQ01XME9CZUY2VXBOaWhXVno3TXlSSGJWSnNrWVhtS3lBbFNkMHd1QVxyXG4gIDVMTE9ZeG0xUTk3c1VoSldtU2F5NDJxb0JDVUtMeTdmMXhKMGhlb0NvWWhTK2RMaUFzMk9YQVJoRW9jbDJyQytneDU1OEc5by9mclZcclxuICBKbnQ1SUhnQncvbnpBL1NlYi90SmpnZE5Vb1J3SWFTVmVQWUNLZUJ6bFhHV3QwanNuQzZtZ2JpU1R1VVNSR1MwaDhsek9xV1JuMHFjXHJcbiAgSElBd3c3c29LUitBUExMbE1rWXlqM2pFSWxQU0VmcHhyRmNhbUhacEJFNnZBdDJGejhFUTlCVVJwVTJ0UldIQlJBSXdMZ1JTZjM4K1xyXG4gIGw4akFnb2s4bkNBb2hPS05CczNYcEJheWlIUWhvUmRKOElpRld0NzBrMXJrQkVuK1VjZ2Jac0svSllyMkg0V2k4a3ZJbUtVc2gvU1RcclxuICB0ekFrWXQ2NGtDaXlDRHAvTGpFclFmUkFzSW1sUWNRYmhLeWVJU1dXUEdFakFvTmp2TUJZM3ZpOFhrRVJjZzVrY1hGSm5NZGkrUzJBXHJcbiAgd0I5YlFkRUJ6c2pjbitZUk02Q05seWlyY3dnbmxjcWR6bWd2Y25JZzBqbmFRL01xekM4cHIra2tNdG9qTGhNUTZTV1AxRlpseHBxdFxyXG4gIGJOMUdDUTRPSnZPaVNDOHEzWDlrd0JBRjN4ZnhKM2UzbEllV3dFSFRwdnNFd0xnUVNObS9mVko0QTA4R09FRlFDTVViLzNzUUluMEtcclxuICBrenM3Q1VFY0VJVHBKOVprbUNSUEM2a0JoMHRCVVQ0dmRyZ1VaUElvT2g3ODllclVta1BwVVZZa1l0NjRrTFh6TURuYnVITkRrcWlTXHJcbiAgWVhvZkRGNVVvR05vQ1RVL1VYbTFZN3hBU05TR2VpMVZyaGRmYnNnNWtLb1FIZHNNdzhnY2ZFRCtSSWVzM21nUng3cVVkaWVPd2hNTVxyXG4gIG95WEN4dW1NOWlJbkIrTDh2SUVDUXM5R09vbThnbEZVcHNnMktCaE1aL0xWajVucEJnb0QwMktQWUNLMVZrcFVMZ2NIMDhkcCtDWmdcclxuICBZUkpON3BMdUs0K0N0QUtUT3lIVTJLL3RPOTAvSUFZV2xGVTRKZ2lGNG8zTFR4alRwWEJ5czVGZ29nUXFURCtSYWN6NGZDd2t5dVdRXHJcbiAgdGJlUXpUTVhMaUhKQ2tKUi9vV0djU2hPeEdFNVJMYTVmQ05WWWxuNHJ3UjRNVzhReXV3RWF1UFBSYkNtQ1dsY2lFZ3hqT1FHTFpYTFxyXG4gIEN6YW1FTUlDWDBQejQrYzRYdjZHN09XRVMzTWdBbmR3WXhUdzhvYzVaR25qSlNxM0MxbUFjSXpSRXNWeXdHaUpZcDNTYVg0R09YRlNcclxuICB1MEJHUE1mdXBGVkVPaUVqSGpGNHh6S2hIeUZWcDV5QjZZeDlDS2FxbE1hTEhjTXRrTVhsbkFlak1LMEpPSElYbHBVOGd0bHB3WlQxXHJcbiAgTUYwazlHYU9TQk1ZVE82Tmd5aEFCZW5IVEJ3aGdUZkp2bHlvaEl4dG5JZUVFbFdhS2hPS1AwV1dseHJLUDBYV0ZuampRcWtpcitSUVxyXG4gIENaRmRrazhrOW1SUktRMnhLRmVPTEZUdnJrc3g5WEJwSXFHd3ZCSERqSTRoSlpLOFlHTkNKdlJha3JaSVFYaDU0aElkU0hyQUZSbFpcclxuICBjdkNCbUlsby95Y0NNYzJRUDlIb292UVNaZVVjSkRMYUl6NjVZcDBYR293V0U5a0lpOWlkb0lwSUoyVEVJd2J2V0NiMEk2VHFsRE13XHJcbiAgbmJIM2pLaDAzNUVCUXhTUnlPbE5BSldrcVFiRmFTVTRtWWZadVgxN3RXT0NVRXdreE9WWFhZREp2TEdKUEZTUWZzekVFVDZ0RjFnb1xyXG4gIFEyUVRwNVdRWXpNaFc0cHF3a3VKb3ZMa1EvckphSG5qUWs0UWhCYktFTmtrNlUza3RVV2xNSGdSYjVMOXhsQ1pQMytkcWNEWnV4Q1JcclxuICBKZmxwT1JpKzVZRTREYlUxUzdSNmRRL1YxcVpwWHc2NGpCYUlRL2FnTXgzK01VYUIza1U1T3dmNzg0ME9PcU1saXVXQWt4dnRFVTZrXHJcbiAgeUVCakNCM3JkQklaN2VIU0E1Rk95SWhIbk1sVFAwS3FUamtEMHhsN3o0aktwemFZdmtJYTZQTHBxb0JsVTV6V0t6MnBjSXdYcUltVlxyXG4gIElhdFRtRXdOUFJ1Z2d2QXh0U044T2kvZ1VJUklINmVSa0pCUmlQZFlGZ3BRWk9ZRGIxN3lVRlF1QzRVb010UVFQcEdVTndnSmt3b3RcclxuICBGTUYwU1RvVGVXMTJqd1l2NGsyeXJ4Z3FjK2VrbUhsazBuZzJJMTlhcURpVGNjMmFYdnF6UC81RmRpSzlKbm41NERJZGlCMWdEK1lUXHJcbiAgVWN5QU5sNmlyTTRoL3BNTGJDVEt5amw0dWRNcFhaZ1hoSW5jR0ltOGdoR2ZkQms3RVJvdllOcXpuRVkrUW5LUURUZ0QweFhLSVBzTVxyXG4gIFNvWUkxY1NMSXdZcVMrUFZncFFyUkpJMnRnY3RTazhxSEtNQ1VVdmcxQ0NDWVFSdnBPckVSQVhoWTJwSHVIUkJVNEJJbjlsUHZFc05cclxuICA4VjZ5SVlPY0NXK0tRdDR3Q2w4SUtDcVhoYUxmSXlGam1rUFd3QjNaek5ITk1xbUFReEZNbHltTFJSeXllekY0RVcvOGZyTGdsS3pUXHJcbiAgWUdZQ1oyOEN6eXF4VkdFY3NiYTJWcHdJNHBjYkxuTU1KSUw4RzBZTFlzWm9SUGFIS0ZMYS9hbFp1UVNKeXVTT2Q0aFBEbStnc1FxVlxyXG4gIGRuSWhJNTdqVUJhZ3pBNWdHaklScVM2UXlnY3c3VzJCb0JjeGJ5eTFRWVRPaEFIQ0JZMEswNmhDeVJVaGs5YW5kNHdLUkMwaGxRZVlcclxuICB6QnVxVktHNjhERzFJMXlhb01rZzBrWDVSNlNGT1BjNFpKQ29lUk9IVk1saDVYRGxlQ2svbDRiTWI4OGVHLzc2a0VPc1RFc2lnVGNJXHJcbiAgQll5RkxFenViQjNyTlVudUhBekM4aWJKUDRiSzNMVXVaZ0puNndXdm9BUXZ6QmhJT1BLTTdJRTNXcUlDdVVEL1FFV0JqVVNWNUU2blxyXG4gIHRPWVZ5eGx5aGhqdENER1JqYkNJODQ3RG1NUU9ZTnJucVRyWmhnMEhCNmE5TFJEMElsNkJ2WkpXem1EQVlOcWw0WUFIUXBjV1hiL3RcclxuICBja2pUS2h5akFsRkxTT1VCSml2SkozeE01UWlYY2RCa1lISm5sNUlXQWhWQ2hFVEZtemdreXNvSXZ5SHo0WHpLQXF0ZjhsQlVMaDlLXHJcbiAgUHNzajJVRW1ST29Fc1NMc1NRSnZFQW9ZRGxtWTNOazUxbXVTbkRsRVpHbStLdFBqWW1hQ3JHMDZlSTVoajlXcnUxK1dyUS9nRW41MVxyXG4gIGZEQ1pEa2Vha2FXTjkzOGFrTkx1RDh2S0pVaFVKbmU4US96SFIvSWdCR01CVVVRTFhEbUEyQTRodGRNOGpXWENteFRrbWJWMWpJaFhcclxuICBZSzhrOXFYN0MyQ3VLTTNTb2swN3JEd0xxNmJHUFlFT1dGb1RhQmtSVW5tQU44aW9sWEZsRmJFam5IM1FaR0R5S044NCs1QmpIQ0o0XHJcbiAgTVc5Y0tMUE53SlhZZnpodEhGaFVIQ3FpS0VIMUFZOWpMUzRzRkFaOVZLczRYUm9xb01pY1EvYTNaeitWa1dRVUJSTW5jRUlOTG5jSlxyXG4gIE1SRVlEbG1ZUExNZml6Z0VTdUJaM3ZoOFk2aE0vbk54RlBNYUNaaW1PUi9Xck9tZ1Avdmo5OHNnK3NzUkszY2dOWFVXNCtBcnFZZ1pcclxuICBveEhKbitDUTBrRlZZQ05SSmJuVEthMTVaZVJGK3hhVFZLNFhpZEo1TytNUmczY3NFL29CaWExWE1HQ0hZS3dReW9oNEJmYXFpdllsXHJcbiAgRUtFRkV3bGhqSkNWKzIwRnNvekpXbzdaaVZoYVN5cjdOQTdpQ0tLMFlDS0JLNk9XVTFSQ3dNNUpSSnFCeWFNOFhkWWFBcVVoZ2hmelxyXG4gIHhvVWl1d2loalBiaE5DNHdtNFpDWkkyV0M1Y090Q0lYNTJkcGV1QTBUWjAvbmdUSXFwcWlMU2dxVjZWUWdJeEpmTnl5bjNMNHhGRXdcclxuICBjUUluRERsS2lJbkFjTWpDNU5FK1RNSWh6dEVnTEc5OG5oSDRSbXgydEh3QS9lVTgvZ0ZjVWd1a0pqbFkyWU51dEVRRmNnSG40ZG1NXHJcbiAgRFZnUlZTZjMvM3NzRjZIUlFoaWZPVUgwQWpER3lRdnNzdm5wUjBqVmVjQU93VmcxVUVwVWdWZUlNQkpGZWxINVBSbEU2RTJVY0VHalxyXG4gIGNFRlhBYkZ2MERTV1ZvaGNhcE5MTUpIQTdRc2ZZUzNBempGWm1Eekt6MldySVZBYURGN0VHeGV5TmhGQ3VmakR0aTR3bTRZRVdXVlJcclxuICBLRUNSbVErOHVjUUFCekl6ZEpFVzV4YTVIcXVOQXVzVytFNjRJRTF4S0NxWGhVSVVHV1pEaEl3cVB0N3hweGcrVVJSTTdPRUVJU2NKXHJcbiAgTVJFWURsbVlQc3Bib3pnM2c3QXdNRG0zUEtwMzFDOC9YRUlMSkRyWThZR1Avd2gzOEFVcHJTZVcwam1iRmNvTDgvSGxpK1FTT1RtZ1xyXG4gIDVYQjBzSXRvQWRPUm5YNkVOSG5RQ2U5WU5WQktWSUZYaURBU1JYcFIrVDBaUk9oTmxJajBvaTVJVXdYMC84amtKNUJNTFpoSW9QdlJcclxuICBqN0FXUE1FaGhzbWl2RnlXR2dLbHdlQkZ2Q25OV3hIS3d4KzJsZDlUbWlSV1pFTUdSU2F1UEhISUdLV2ZySFlsWVlrZEJjYXhpclRGXHJcbiAgMHVKUW9UUkZ2NGUvdVpCRGtaRUxFU0t4KzIvaVR6RjhBZ3NtOG5DQ2tJdUVtQWdNaHhnbWkvTFZLTTdKa0dHenFPVThYcTdQZnpoY1xyXG4gIFJyc3JQbWhHeXdFdmtBdjQ3L0ZzeGdhc2lLcVR5MytmbFl2UWFFY2dFa09uUU5xQ2NuZzdCNll6K1FtSlRaSWZJMlBuR0JGbmJVR1hcclxuICAyS3NLKy9GS2hnaTlpUkxHaU1wK1R6QmdpTUxvNVpDMXM3VEpQZ0hkaDk4VE5oSTh3U0dHeVN3Zmw1MkdRR2t3ZUJGdlN2T0ZKUHF3XHJcbiAgblJ6alV2TllVV2hRWU1LYlhCbjhIdmtUUzR0REhrVldsUVBHTjVZV2NPZnJPOTh6S0U2WER5bUtMUEtoNEpmR3g4VkVQdVNRTmNnWVxyXG4gIFJlTDRISGFmUEx5eEJSTjVPRUhJUVVLZTRCRERaRkdlR3NXNWxPUGwvUHlId3lWMVlhVUgxbWlKQ3VRQy9qczg2d2pFSElRMVdsQlpcclxuICBydmxrNUQ3elNDNlJrd1BaTW5DUXlHZ0JaQ1lYNklta0pySVJxUUoyam85MElvNTRnUWdqVWFRWGxlNG5RSVRlUkFsalJKVzFCMFRoXHJcbiAgelNLaUNtVFRBcm9Qdnlkc0pIaUNRd3ptSlE4RUgzSFFiUWdHTCtKTmFaNlEySWR0NUxnV21zYkNPRVJJVkx6SjdEZDhuQ1FOS1Fvc1xyXG4gIDRqeHpvVGhKV2NBaW1JdnowelE5ZEtweTkwbEIybnpnVFZrb1RCQlFwTldRT1ZKSnZwRmhnbGdSQjBNa2N2OTEyRThXM3RDQ2lUeWNcclxuICBJT1FBTTA5NEpvYko0dnhrQmdOYWdNVk8vT1UrL2dGYzVpL0hVWGFSMGY3b0Evem44UjhpLzFkR0hpSW5BOHJsL24rUDVlN1BGaGlCXHJcbiAgU0F5ZG9xUU1ubmRnMnJOc0x4OGgzY1lBT3dSakhTRmluOG9nUW0raWhER2llZ0hzVmFHa3dHVFZJakhYL1AxZW5BNzVleVlHODdKdlxyXG4gIEJOVnFDSlNIRi9HbU5EOUk3TU0yQ0dLU00zUENBbVdpNGsyMHYvQXhkUlFDTXBvNER4L3ladFdoS0dFK3dHbE1EeDZqeGJscDVzdmdcclxuICBLclhpUEtwQ1ViS2kzNXN6VWhScGtpT2M1Qk1aSllnVkdhV0ozTGtROHM3Q0cxb3drWWNLWEdwUkNjRWJCSlZFTU5uU0lzMk1uc1kwXHJcbiAgT0JXL2dod3UwWUZFQnozNUExd004Si9sMlZRdXJJaUs1RjVwc2NzbkkvZVpSL0lrTGRpQ01vaEpiTWN4ZU1jeUlTUTJ5OWlwREdLa1xyXG4gIDhRcUdDQ1ZTZ0RCR1ZDK2d2UmNIUmxUWUJHVUZxRjJ5QnhHNTlGNXFZRjUzb0tSS09BVEt3NHNLZEFhM1ovMnZXSjh6YzRJNEdCSXhcclxuICBiNkw5Nk1keEdnSXlHcGMyM3I4THBjZ2FWaE9xaHd5U2x3TE9ZMGJKVWhUdGY3bFFncHdwYjF6SUtSVjVUY1FWSFd1UFdKaFJHdXZPXHJcbiAgRmZmSnd4dDZNa0FGTHFXb2hPQU5na29NYUlHVXpMNWkyNWY3K0Fkd2lWMVlGc2tCZDBqcG9IS0VKRERXYUVGVzdxQjVhRDZSWElSR1xyXG4gIE93SlJwaXhhZ1NvZDdDSWF5T1FsSHpHcGJPY1lGWHNGQXdJUkdrQVlJeXJkUjRBSXZZa1N4b2lxV25zVmlBcWJZRkFSemxLc2hlQk5cclxuICBZWHFUUzFDdGhrQjVDTXNibjAra1krZ3Y0Zy9ycGF3NUV5ZklLU0l4YjZMODllTTREWXBJNHRMRSszUWhoNnhCVVNoR3NwdUtJUnlEXHJcbiAgZkVCR21sOHBDdk54c3NxaEhGQXVGekxJbWZERzd5Z09LYWNoNG53NkV5Vnd3b3pTV1AvNzdaUENHMWxRcVVKMUxwV29oT0FOZ2tvWVxyXG4gIFRSeWFrN0JtellhWC9mZ0hrRGdRVEJ1OGNHR1FGcGQ3Z3RrZmFRZEg4eCtCUDlMcmd6eEVUZ2FVeXpVUElKSjdJV0tqSlFvMllmOUFcclxuICBaQk9FREthanZQUWpwTnNZVWp1bmd3ajdjYnpFSWpRMnNsV1YzNE5CaE41RUNXTkVWYjI5VUZCaEV3eXFRMjJkUzh4TU5xM0pKYWhXXHJcbiAgUTZBRW51Vk5ZVDZRMk1meWt1RGhCQmxGSXVhTjVhMmZTTVZCRVVtY2ZTVEtJMVptUXg0K3l5VG9iNG9EUzZzTXhaQVZCTkQ2V01LbFxyXG4gIENUdTBOdkpCWGtHY3l5Zk92endVbFp1L3VWQU1LTXBDQm9tYU41SnBIRkpPZzFHK0lKSFNJeFpHQ21QbDk5Z25Eekd3b0t4Q0daOEtcclxuICAvOFBTZ2h4dDFlSC9DS0dXcjUwMWEvcGUxdU1mUVBMcnEzcWRyUnhkZDlUMW9DdjR3RHZTeXdDbXZabVRtMEFpb3dWS2F6NFp1Yy9jXHJcbiAgWWxITFJsakVPSEVjN2VYWi9NRTdsZ2toc1ZuR3prVzZENjlnUUdpa0VNWkF6TGEyQjRNSXZZa1N4b2lxZW5zUjY4YkxGQ2FMUlVYZ1xyXG4gIENxaXBhNVBFQVphWHBUZU9RNkFFbnMzSURmb3IrTU42TGFNSUl6aEJKUFFpM2tUNTZzZHhEcEhFMlVlaUZMRWlEaWw4Tmo2RThzdHZcclxuICBxQ0tQeTRQbWlmR1BxWUdqSEtNTEM5VVh1bERTZ09ld1d2cDJtQk41b1pEOWJlbnYxOERTS09TaDZmSWhRcUxpaldRVWg1VGp2UWJPXHJcbiAgNzl4RUhrNFFDWTMxWmJkUENtL2tTUVVUL0QvTURwL2l1RkpYNGl0SUhNanlyN09OajdJLzJnejhTVVptNU1waTQrUVdlN21ENXFINVxyXG4gIFJITDM1d3FNeU5pNGsxc1IyUVFoZytuSVJqOGd4UkNVSXJjL1pkeEpHQUE3QktPZFRzU1ZiQUVReG9pcWVuc1JZNVBZQTZMSWkwc2dcclxuICBPZkJkbE0vTDByb3N0RHd1R0lRdGtEUDBGL0FuWkJEQkNUSUtMd3E2UUdsUUdDZDVJd1JSaWxpUk54QUpiMExROG9iakdZZHFVWlEyXHJcbiAgQ21Gbnk0U1FaTmtIMTlpK3BxNWVIK2pONVZNUTRzd0xRN1ZJMDhYSHorMUtBa3dUcUgwYUlpUXEzaUJFZGpHWFNOek9WR2h3Z296Q1xyXG4gIFdDbXJmVko0QTRta25mZUs4MWdXbDlqK2lnKytuandxYzNLanZkekI2QUo1WVI0cVZGcDRSRVlMa0M3UVhwNnhFZDZ4VEFpSmpVOExcclxuICB3TWJ4b2xSS3hFNE9pTUNwR1VZZ1lybmxib0FkZ3JGcTVFbDNNZ2VJMEpzb29ZeUlzVW5zQVZGRVlzMHptM01oTkZPZlhPMERKUkNXXHJcbiAgTndpeG5PSDNrMlpnY0lKSTZFVzhzZnowRTFRSzQ1eWRzU21jTUE0QlBxa0VWMGJZeEdFNVpPMDVoRXd0Rkp2NXNGTEFlZmgwMmwyVlxyXG4gIERlbEtFRlVnVzZaYzRFMGNDbzJXUTJUTGViaGo3ckpFU0dHMlNZamd4YnlSeEM0RVNvTlJma2VtOEhDQ1NHaXNsTTgrS1VScDlDdW9cclxuICBoRXQwSUFBZmR2d0JjcHpqZzIxMGtSeXNKSER5a2p3ZzhLd1JXUnVtTlIwUTJRUWhnK25JUmo3ZXhpbGdnMkNzSTBRTTJpbEVFRmdoXHJcbiAgakdHNWZoeGdoMkNzRU1hSUtyVTJvVGRSUWhrUlk1TzFSOGlrU1hMMVJHV29HYll1T0pJM3VmMkNzNC9iZDZKMmdrZ29MRzhzTC8yWVxyXG4gIG1JUENPR2RuYkFvbnpDdDlNZ2xXdGhMYlBESzJTV1o1ZFdVRXcwdjVvTjk5ZXVna0xjMWpvVDZYRjFvanVCTzJVTE5BTGIzcnFiYXVcclxuICB3VkpWL3dsNUlsUkExbFFDYjF6SUtTc2gyTG4vSnNrcVFiRFZFTUdMZVNNSlhRaVVCcVA4VHBqMU1GMHNORmJLWlo4VWpnOE9QS3pBXHJcbiAgbTdWOStlR1NXeUR5SHdyaWc4ZzBXQkU1dVFrU0dWQ1NoeGNpTmxwa1FlNU93a28yd2d1TFV3SWZGZHZHNEd3QUVNcTRreW1nMkU3RVxyXG4gIFl1c2dBcTlXd2hoUkZlV0xZS3dReW9nWW16SjdMOVk4aFJVNTlJbEJCVVIyaml4STYvWWc1Y21wblNBU0Nzc2J5OHRwRVJUR09SdGpcclxuICBBNXdnRGdxZlJJS1ZxY0F1ajhnbXlTUlZGVU9WeTMrV3lTWkdiT3dUY1FVbHZ3Y1ZGU0RDQ0ZhSnNiZ0dsUmZVY1ZnR3FYbmxUN0FzXHJcbiAgUUt5V3dCc1hFa1VaZ28zN0Q1TXNQSUpkQ0FZdjRvMGtjaUZRbnZPWmk4QUF4Z1dEc1ZJZUw4Y3h4NVJwUEpPalljMmFWdnF6UDM2ZlxyXG4gIFRPTjl1ZU1TSElqKzJZcm80TXVSdDlqTExmWnlCNWNITms3T3NjL1lZbEU3R1ZDdzd3SWJwd0locExkeENvN0JDeHZrSXNybGhXQ3NcclxuICBJMFNNdkwyQ2tiVXpCdUpDV3dSamhWQkd4TmhVdEFjMFR4RmhrMHRUSlpLMGFYckozKzAzVVRtQkNUM0xHOHZMaXpnb2pDdk1EM0RDXHJcbiAgVk9HeWxHTm9lWWRRaEVnZkVudVJoQnhVVWY2cG1Ld2s4S1pTS0VnMFB6Vks4OU9qVEFQT2ljUlFPMzFHSkorK2NEOUpLRTRtSVlPZ1xyXG4gIEt2NVVrWkFEYjF4SUZFVUlldmRmKzZRSmdsMENMMDcxT2M1bEdvUU14M2hCUW1haFQ2RGpHWkRMNk1ENUVzR0tqMEQ0UXgxaEIxNVlcclxuICByMlNZTEpHclFQTndNb2I3UXdWR1pHemNDYVV5WnhQUmlIMCtiQ3NmRmR2RzRHd0FJeUFxelFzd25VUStad1BrcGxNREVDYXVaQXVBXHJcbiAgVUViRTJGUmg3M01WVm1VeE1BZGlhV214c0FwS1VKRFc1UzVsU1ZUTzFvU2VWVUkvUWF4Z1N2SkJVRGJBQ1ZLRk4rZE5PQjVCbjRmcFxyXG4gIGZjSWd5a01WK1UrQnVSTW1nVGR4S0RheXNITFVOYlZaU214Yk9PRDVnemcwVUgxenU0UkxRMXkrVE1qK052N21Rb1FnVGorRnhrQ3NcclxuICBjdnNvcy9WUXZUc1hmRElQbDk0Rmd4ZnhSaEtvem9zbEdDVTJKaFRZT21UeUtBT0VxQ0tkZ1RkNkJZWkxhb0dFQTJteFJQSEJaZHJMXHJcbiAgbkR3K0FaeU1vUUlRRmhCRnRLU0xiU3p5TW9CcHorcXBFV3ljZ21Qd3dnYTVpcFJXaU1BQXdoZ1J4NVlRaU5CZ2hJaFRTeE42RXlXVVxyXG4gIEVURTJ5OWk3SEVVa2hPY014ck84Wm1sbFV4QmQ3bEtPSkZ2SGVJR3hLdE5Qb21Vd0ova2dtTWdEQWhjVTNwUTM0VGdFZllwSTd4T2FcclxuICBLQWRYdnZpVE1YVUNIM2pqUWw3SjRYSlFsRjhhYXVvYXFiNEYzU0p3L2FqQWNIbkdvWTRXWnFkWVc1dytIeTRIQmZuRng4ZEVQaGlDXHJcbiAgS1Awa1JnN2VtRGU1WTE0RTFibHp4U2Z6Y0drVG9ZbDRJOFpCNXpoZlByRlI1NEZsOUpjVzhkQmdXeFRnMUdIN0Nod3V3WUU0Nk1IV1xyXG4gIDQra09xZ2tTR2FCL3RzSVJzSXRvRndWRFJrRTZpU0liKzlNVmVpcmtiRUJITmk0S0ZSWWdnc0JtN0N4bkovQnFKWXdSc1Zjd0lCQ2hcclxuICBBWVF5SXNabUdmdDR6MEpVU09PU292cXBaZ3FpNU8wU0lRZ2M0d1hHOHNiMm5kRXlUT2Z5OGdBVEI0VTN0ZnhpWFFyVHhYbTdrRUNQXHJcbiAgVXZxSkVLY0xPODhxT0ZTTG9yUWM0cnh6WVhrVFlzZS9PTytXS0VHY2JVT2krMnFKRnFaR0N0Tzc0UFpWcUhRaEdHVkN0Y2lrUy9LUFxyXG4gIFZBWmwwMDlpQURpUkJONGs1U3lDNnVUNmRPWWVMcDBMQm1GNTQvTldCQTQ2L0JWRkRyeldsakI1K2I3Q05ndC9GS3ArQ2wyZ0IxazNcclxuICBRb1RZeXgzMHoxV1pzK0hZbXppWjMwanNUZ3FWT1p1SVJxd0dRc3RIMUFVMndnYTVpcFJXaU1BQXdoZzJyTTZPdjFsYnYxOEFoRElpXHJcbiAgeGlhMkJaMnhUM0lEVVNGTjBBU3FLaVNtbWJTT3RmMTZsb09DS2RrL2dva0VZRnhRZURQZWhOOGU5QUVtOXdsTWxNQWRtL2dUd2FXUlxyXG4gIHdKdGtmd2pWSUpQR2w4ZUZBaEZDUG1VdTVCRzB0ZHdDYWVwWUkxS2RmWlZmNzZxbXRrbGFLdnFvVm5HdUljY0tnVGZaVUtqSXBhd0dcclxuICBrYjNQS3hJYmxFMC9pUUhnUkxueVpLRnlkNDU1Y3crWExoSUt5eHN4VkhtZ2lvR3hEMTNDNUpVQmRNQTdrS3FlUWhmZ2dGdnNZYkpFXHJcbiAgRHBuK2tVSEdTUDVWbzZNL0VIRXdjWG9FTDJRd0hka0lHVGFHMU1aRmFlVXRBbU1qdVlndFg0RUl2Tm9USW9hZFZ6QkVHR2pUU1hLUlxyXG4gIE94MGd3a2lrZVFtTGpRUkhPREJ0YVZTald3Mk9OSHBaWk5JQ1BuMG9TOUF5SmZ0R01KRUFqQXNLYjJaNXhib1Vwbk41NXN4Y09kd25cclxuICBnck9Yd0p0a1h3aVZrTEYxNmEwY0dUWVhBb3EwS3drcHVydWE1UUZQQldiOXBDM0pwY1VsbWgwZjQzTEZhYk41cmpRb2lqVHhjU2dSXHJcbiAgUktFU0lqdWZSeVEyS0J2LzI1RVNjS0prLzBWUW5WeWZUSXE1aDBzWENZWGxqYyszR0xXMTlleEVYdDVMdU1md1IySDVwOUFOY216alxyXG4gIEE0eURickdYMjU5bXRBS0NpQllla1pNQm1rNWhoRVJPeUxIUEdLY1hQaUN4RlVyanlNYkpWYVMwd05zQVJrREU4c3AyeG1UdFFCZmtcclxuICBpZTJLSEFjZ0JEWmV3bURhMHFoR3R4N0NabVRWd3FYbDRNb1JjakV1S1M5ZzhraG9XWERJNndKTTdvMU41T0hLNEQ0Um5LMUxHd1FjXHJcbiAgeXBDeGkvYnJTV1dUb01oS2kwS1ZLRXBhRUVZbjVxaDN6VVptSENZNHBFK216MDJNMHN6WVVHSDZKRlNOb3NUWlVDRGxqUXVKSUdkWlxyXG4gIGhzakdaMllpZzdMeDJaQlRjdUJOc3Q4c1ZGNk5NNUcxeUNxdUJKQWtmdGxqWlc3VS8wbUEwY0k2R2FCL2tzSVJ6ZzR3UWlJdjlIK3VcclxuICB5amhJWkxUQVpBSTlsV1FUZHNaSWJWeVVWdUFpQ0hSczUyZ0JCSTVIYkxTSVkwc1JlTFVTeXVodXZjTEFmQ0tLOHZMMnNRSFRscjlxXHJcbiAgZE9zaGJFWldMYUswYVE3RzJYNkR3akZlb0NZUzhyb0FrK2Z5QTdEditCUEIyYnFkZUVFWklodVhKaWFWOVVFUlM3S2hBb3JNSmZDbVxyXG4gIEtCUWJKNkd0a1dqZCtrMDBXODkzdUEwWXNBVndRemZPWVlwRGVCWmhicHh2OXVaTHB2TzZVRlFPQ2NYbWxWR1V3SVdNaERjdUpJTEVcclxuICBxZ3ltOTVtWXlLQnNmTGJrbEJ3OHdTRUxsWmM1RXd5Z1R3K2VMM0FpTXJLbzVDdndXSUVENFFOZTF5cXhCaGZGLzREK0tha054OTRrXHJcbiAga25taC9wbU9EcEdUTVRKNUJIVzVqV3hGVk5rR2tUb0VweENCVjN0Q3hMRWRrTFZUUnBKams3TkZNSllKbnhzMkZleFZvMXNQWVZPWlxyXG4gIHl6RWN6OHFvNGVzaG00TXZZeEF5VW9HWVNIRHlvQXZ3UmdVbXZxVDhpZURzWERvdktJUHBvLzFFcEErS1dCS0hBaFNaK1l3dEZCdHhcclxuICB1SFNNam83VDlQUXMxVFcyVWt2dlZzN09YWjZvdU5LSDJlYW56OVBjNUhMZHpXVW9LamVIN0cva2J5NFVvc2dRSVNQaERVSUJ3NkVNXHJcbiAgcG5mMnhqb282ODZrbklJRGIveCtzbEM1WE5mT2pLR3ZFczRDL3dHTy9TdE9KTWFLV3lBMTdxU1dnKzMrRlBkSE9OcmcvaEhUS3hucFxyXG4gIGZSckE2ZjFHNHlnUCtZRFZqVWl6TnNwRFpMUkFCSUYyY29nZExSQ0JBWVF4SXZZS0JnUWlOQ2dob21TL2dBZ2prZjBPSlZXbm5JRnBcclxuICBzMWVOYmdXT3pLU1IvTncrZ3JnaXRKOGRGNE1sU3NvSW1OeUVRdkZtUlU0amdmNXEvVVFBSThFVEhJb1E2VzBmOGE1Y1VNU1NWSk1nXHJcbiAgWjhZYmhMeUNRL1VvU2gxK2UvRm5YVjhuNzdxRzV1Wm1oRzlzNjZQT1RkZFRYWk43NWlPZjQ5VEZJOXdTR1dDcTdKTlB0VElVNUZCMFxyXG4gIDBCRUtrVFZTdzBUQ0d6M2tub2hDRVV3WGw4R2diUHpMSTRpSU4zNGZXYWpjWDBldm9DcXN6SUc0SXl1Uk84bzQ2THhOWkF3VmdBaVJcclxuICBsNEhVZEtZQVlYcG53N0VqbVJBeWJCU3dqMnhrSzZMSUJuVEdSa1RZdjFlSXdLczlJZUxsN0ZRckoxNVFNSmpPMlBxY3NLbGdyeHJkXHJcbiAgQ2p3WnlSaVNYN0lQd05ra3doUjhFOURVdllWcTZwc3lwdm0wa3IxdXdLa3dnZWx5NVFBYmZ3d2dKTURlTXh5eWlIU1dkN3diQklYalxyXG4gIDRwQkJvdWFOQzZtQ1EyV2sxaVdmT1A4azVESkl3c3pNRExXMXRVbHdzcnJHWm5ZaTExRnp6MllXd05uRDZUZEVvWjVteHM3UjRzSnNcclxuICBrbGNJdk1rRWR6NFhmOWpFd3ZLSXJUa2srNGxVT2NUS1lPUTUzaUI0Sm1nNFpHSHk3SDR0U245WkJGSHl4dWRmSGNJYVdDdXNOcitFXHJcbiAgc2NJV0NFSjgwUG12OGNjL3lJTFFZb21DVEN0YnBYMFVNbUl3N1ZuNyt6UDdUZmVodE9ZYnljRUxHOGxGWkxSQUJBWVF5cmdMTGFETVxyXG4gIHptMGNtUGI3QlRRZlliSFJCT0FNVEp1OWFuUXI4R1FrWTBoK3lUNkF5Q1lpQzdHRXFkb0xtb2NnVFNCWlMwamxBZDRnbzlaZjZqNGVcclxuICBJQ1Y0Z2tNUlRHZjV4cnRBVURndWxYb2thdDRrKzBRb1I3QXErUGpDdUpBa0NPRVNNVGs1ems1a2lucDc4Mis0YStuZFFoMGJyK1hXXHJcbiAgQ0o1R2o4YzlhbWwrYW9xbWhrN0x5Z05WSXk1dkVuaGp3WjMvK1krYVZvYXowcncwUk9JY1lxVWFlSTQzQ0o2SmJQSXdYYncvUStrdlxyXG4gIEVKWTNQdTl5ckZuVFRYLzJ4ei8veWhUZUNKZldBaEh3WCtGWlIzQ2NsVWtVOUxrMEdiMy84M2tqSDlBaEVjUHBBU01ncXRJR24wamdcclxuICAxWjRRc1JjeVJPRFZqaENSMkhrRkEwSWpHWDV2WWlZYmNBYW1MVi9WNk5aRHlGUW0rU1ZsQVNJYmpxU0hWZ1lBRTZNY0ZtWW5lUnVsXHJcbiAgWmFTL0tjZ1ZKc3Z0SDZ6N1JEQnpzZmRNRmliWEhic29ZKzI0VkNwSVZMeEJTSVRGQ0JicEoxZUFPQ3lMb2tUVmg0R0JBUnJrY1BqRVxyXG4gICtVSjlmWE1udGEzZXcwNEU0NUFZRHduOTlMT2pBelRlZjVqLzltVUcxWE5oR1JRbHNXT1UvNmk2SEQ0RFNaODd6Z2xpaFNvOXh4dUVcclxuICBpTENRaGNuai9SaVVkYVdPSUN3MnVJcmdrTk9nYTJDOU1vVTN4aVVlQ1Q3MC9tRGJuK0QrS0VFazgwS1hCaWpXZXhLMkdybU5vbUFmXHJcbiAgS3Fwc2d5ZzlXYkkyeXFjT2hwSExTeG1JSXdXRDZZeXR6MGNpcjJEQURrR2xhb2RnRURhVlNXNkZaVEdCa01yWDhKM29ESllFUjdkR1xyXG4gIEJjeFBqOGxNRThsV2dxWlBZVEszNzBndFpiS1BoOWpBMWhsSE9nK1RXNTc1ckIyWFNnV0pLbUU0NUJHMDZjZVhNUmhvS0VYV3NDaGNcclxuICBPdnJhRytUSjU0NzJqdUtzTGRRMXQxSG41bGRSUzk4MkZzQlo0RC9XbHNmODVBaU5ISHVjcG9mN2hhOE9CVHZKaFJMa1RIbkRJZjlSXHJcbiAgZFRGOFlra2JzeWxpaFNvOWx5YzRaR0Z5SzJOc2twWVV3UEhFMUduTWZJc0RicmhlR1VEUDRoSWNDQjlxT2RieHYrQm94QndrU3ZVaFxyXG4gIGpjbGp2VXNqc0w4eWJEUXUyRWRhNllrZzBHWURXVGc1SURPNXdBZ1JlU0VEQXNjalZscVNpanpTWmZMemU4TW1zUVdZMXE5Skk1MElcclxuICBnd2FRdkRMNXgzcGxWZVkxbU9UZ1orK1VZM0Z1a2habXhwanlLU013Ny9hYnFQVFg2ZDRNemliM1cyT1lqbTBrV3dTVEtod1hKSUpZXHJcbiAgN1BOM0lRL1ZoRTl1Wnk0VUltc1VoMlZRbENRSnZLa1F4c2ZIcWJ1N20zYnQybFdVT0Jjd0p0SzkvVFpxYUVWWEN0NGRFaDQybkJvNFxyXG4gIFNhT25ucUg1MlNrMlpmdDg4alFzaTZKRUxoUWdaOFliRHVtbkRGSENiTmtUcEFyUDhRYkJOaGFLWUlZWmsxQTZPSXFpOEFxeVdLRURcclxuICA0Y01yQnp3KzZvNjJPS05IQmFoY3BQZHBHTzZQNUkzNysxVHZiSndlTUVKRVhzZ290d2xXV1J2bHRYeGVBWUdxQlVxSUtDa1RBS0dSXHJcbiAgVFBoY3hFdzI0QXhNWXorSUhPLzBRa1k4US9JS3hveFVyNnpLVWczejNMeXViWFRQRUZUQTBoTE5qSjZseFhuWFVyR2NrdjBDVWhyN1xyXG4gIEdNdzBsTnRySXJCTTh1SjBqalNOVW5Fd0pPS0U0WkFpYU93VDc4U0ZRc1FHY1NoQmthbmZsd1ZUbEgrY1JUNTBOUzlSUzBzTE5UWTFcclxuICAwUEgrb1VLYm9sQmJWMDhkRzY2aTFsVTdtVU4zRnJxMTFKRXN6RXpRMk1tbmFlcmlDYll0L3ZpY3NyK0Z2N2xRaWlKamhBSWtKbHdDXHJcbiAgQlA4cFN4VWx5cGJOSXhhcVFpamVJRVFFVkJtWVBNNzdGYXdJSzNJZzhqL0VSMWtGSUtJb3lMVFNWVHBFa1N6U2U1V1hBYkF4MGdpb1xyXG4gIHpScWNFeWp0NUN3cnRnR2NEYjVleUlEQThZaVZWcEdUQTB4bjhnc2tLTTh4WUlmZ3BOZ3FwV1RFTTZUVVNkNUF4SWk1YkpTRVRNQlVcclxuICBsSzYrcVVObHkyQnhkcEttaDA3UUloWmVoSG1TUkVvVFJFN3Z5K3cxRVZnbTVjRHZ5Rm81TGtnRVhoenJFVktvTkh6Y2ZrQkt5TUVwXHJcbiAgc3FFQU9UUGV1TUNDL01mTU11RlNNREk0UlAzOS9UUXhnVzZUbGFPNWV3UDE3bnFkRExRSFI2TGpJK2pPR2p6MEVFME5uaFkrUmxINVxyXG4gIE5hUWZrY2JIdzBRK0ZDSnI1RUlHWHNVYkR1bW5DRDZCcFRFMmdST3F3bk51b3dTSExHd1o5NlV3dHZRS2xzZUtXeUErbGovQ2FCOEZcclxuICBtVmVYNkQzSlJGQjVJWlBPQmh1VnEwTlNXbUpIT2dJaXR2SGluSTB5N3U3SHcrOExjRFpxRnlrWUVCckpoTTlGekdJN2h1VXBLdHNLXHJcbiAgaEl4NGh1Umo5Z0dSalpES1IxSUdVMGs2MWVMWmdkcEdETFl1ai9tcFlacTZjTWdQcW9lUFFiTFVmRFZrWVhLMmNVVUpWbzRMRW9FWFxyXG4gIGwrZ1pLZzJmSkhPRUhHSmxvVUhlUlBKVUp2MUVKaHlxUnpabFFYRDd0REIwdnA5YmdYTzBhZjJHbkc0bEFlTWl2YnUvVEI5QWxKYUlcclxuICBhNUVzc2dNNVNjUEhQazl6azJWZGx1VncxaUZranBJdlE4YXdFTXNZSmVwNFQvZ1V3WXpqL1Nkd1FsVjRMbXdzS0xDQzllVEZvN1lTXHJcbiAgTDZaTXUrQlc0Y1ZMcElMOUsxaXhBd0g0QVBwamFJVC9Nd0QrczVmUmV4SzJFbVgxRVcyUlZ1WU9FQmdaMndRaE15VTJ1WHdjajFocFxyXG4gIEZUazV3SFNVbnoraHNSRmpVd2lZWmxtUVJqb2hJNTRobG9rSWpBbUVWRDZTTXBpS3lxTkUwS0o3bzZselhkV3pSUlpteG1ueTNBRnRcclxuICBqV0E1Y1pkZDdyYzVtQnkvVTZQSXluU1JKSWg0NC9ORUNBaFMvZmhNWFVnUUt3b05NbXJlMkg3VFR6Q3BqTmd5Q2k1Zkg0ck5raEJoXHJcbiAgNXpwMjhnc0x0SGJ0V3VvZnJUenBvVnEwOUcwVlJ5TFBqdFNnSXRReGtzWDVTUm83OHdSTjhNM0NFZ2FLczJVdkxDeENPVkxMekZIMVxyXG4gIGVVZEdPY1RLQXFORWxkdERCaWJON3RmRENWUW9GRzhRYkNQREhQb1V1dkZSd093clhZVTNQODM2NVl5VnQwQndQQVZHeU1GMzREOTNcclxuICBHYjBYeXdkRXNkNFJVSnNsT0NkUTJzbFpsck54ZEtFTncrY0RLQ0VpU2VzVkpqU2FDWitIUkpFZGFMTlZLYlpLS1JueERNa3BrN2RuXHJcbiAgaEZRK2tqS1lLa3ZERUpXbHEyL3BwdFZyMXFxaUNtQkcxdXhvUDFjeVQ5SEUrZWRwYm1vazgyeUI3Y3YybnhURDZTSkpFQlhvRENyVlxyXG4gIGp4WGVDVE53d2tKbFJzMGIyMmY0QkhVNVlpc0wyVEpsdzRxUlpuRHk1RW1peGtaNzlpUFZYVzVvWGJWZEJ0cjFJVVJBQjRGblJzN1NcclxuICA4SkhQMFRUSENZcXo0Y0FiTzU3NVVJelVLdm9IaW81bkRyRXlZK0RGdk9FUVBrVXc0M2gvSGs2Z1FxRUNXNGhYcHZBV1l3VkhnNCt1XHJcbiAgUDhCR3lGRlhvT0pTRmhzT0VnVzkwTUxhWDE2cUI1UklLL084WGtSczQ4VlYyemdPc2RJcWNuS0E2Y2pPU3EwbUluYzZnR245Y29oMFxyXG4gIFFrWThRL0tCeklzaXZaREtSMUlHVTJWcEdLTEs3b2Y1TFZ1d25oS2E0Q3NBTzQzNXlTRnVrUnlrMFJPUDBQalpaMmg2K0JUTlQ3TkRcclxuICBXWnlMOXV5b3NNOGdLdEFaVktvZi81dnlaZ3luS0ZER0t0dFgrQVJWTVdJTERsSUdoTHhxZVJRbHFoUlNEQTBOOFIzdEdobEVmK0dCXHJcbiAgOTRzMHNDUFpRVDB5Um9LdUxaMU5oSnVGeWZPSGFQall3elE3UGlDMnl5TDdVeVR3eG81L0d2SklMYUovS252c2M2aWc5Q3FYbythYVxyXG4gIGh4bkcrL0p3Z3JLMHI2QVNMcjBMUzA0Y2hWWmVRa1ZSSkl2MFFlVmtqQ1E5QjN5ai9KMU1ZWVNJSWh2WUwyZWpBb01Ta2t6MjVSVW1cclxuICBOSnFKUUdic1FMTXNtSnNPVWNZV3VjaCt2Q2pTQzZsOEpHVXdWWmFHSWFyTWZoU2lrSW9KN3krb2IyNmwzcjdWS2w4SmxwWmtxdS9NXHJcbiAgOEdtYTZIK1dIY3FqWE9rOFJLTW5INmR4NWljSGpzb2Q3ZXpFQU0zUFRraGZ2cjVMT29XV1VELys5K1NLNG9RRnlrU2xSUGlvdUJnK1xyXG4gIEVYOWRTTVhseUJvV2hXSVVXVXJnalF2ZDllUHk4alpNMzMzdTFNVkU5NEtFYUwvb3YyL3QyMFo5dTErZk9KTEZ1V201UVJnOStSak5cclxuICBUWTVFS2NwQ0NYS212RUZJaEhrRWJmUlBaZ3VmSUZaa2xGN3NjdE1jOHpCRHQ1OEV4U2xlUVRscWx1YWVrcmJ0MmJNWDZLWlh2NXZPXHJcbiAgY0Z5TVdxcHQ3clpGK01LQlh0NTVHTWxFVUJYclhaVDg5VDUvd05uRUZwTEFFRW16NldMV0dEVXBzNHYyVWNGT28wZ25aTVF6SktkRVxyXG4gIGxMZlBwa2dGR2EybHlTTk50M3QxRFQzNjZHTlUxOWhBdDl6OGFucnF5RVZad1hXT1d4aVlnZldpbzZaV3pwY2FiZ1hWMU5YTEhYRU5cclxuICBPelQyYWlwald2UTRwOHhXYk5qVzhXSUQycklzUjJTeHZIR0U2bzF6bGhXVGxpdjNiR2psLytWUk5xbWwzYnYzVWovR3R2OU5vTjFZXHJcbiAgd09UQU1ab2FPTTZVdTRkY29vYTJYbXBidFpQUGw1YklzaHFzd0RveHJad3VhQ083MGlRbENpL21scGRSZWFobWNXNld4czdzcDZVRlxyXG4gIGpCdkZXS0lONi92b2tRZi9odGF2eDQzWUszQVFCNEtYcUR6MTFIUDAxcmUvbC9yUG9VbGJCSFlnTGV4QWF2amlGbkNsNTY4Ukl5UnlcclxuICBRbzRqdmFxOGdKSHFaYXRHUWhmcFZlU0ZqRXV6a1cxU0ZrYW1iQ0ZKeGc0YS9TcnRJR1RFTXlTWFJKUzN6NlpJQlJtdHBja2ptdzVzXHJcbiAgRGRWUEhLUGg0VkZhV0ppblY5OTJPeDA0ZytXb0ZZdDhrY0NKekhNTEE4OE40RzVVRnVWYnlacEtMeEZxMk1uVTFqZHphS0s2aGlaMVxyXG4gIE1wREIrZFEzY294Z2pzaWo2TGpsa1ZnVkpxa3VuMHBvbUR0UC9XZFBFODNPMDIydmZ5TTlkeHBQT3I4MFVFZHlnaWwzckJhb3VYdWRcclxuICBkSDNobVNLUHFQWXRyNGl6cU1JeU1hbHNIN1JHVlRRdlVIcFJzVFBCTTFGanA1OG9jQ0RFRG1UMUt3NmtBT0pBenAyN1NHOTd4M2ZUXHJcbiAgazA4K1YvNUdRcjVicW0zdTRVcE1XeUNoWGpVaVV3Rjc4VEo2UjVTM0dJd1FVV1NUdGJkb09Sc1ZaZVNlalZKWHNOTW8wZ2taZU1rbFxyXG4gIFVwZlpCaWxUa1lraTBncVpNMkRrMDhXL3Yzbm1GQTBNRE5IOC9CemRjTk10ZFBoQ1BNZmQ3REpab0FzS2crZTRpT0JrRUdOdXZNanhcclxuICB2QWgwbUN1dmsrYjVpejUxMk0yTEE1SVg4WHhCT3FFYWNUaTE3SERnZk9vYW1rV0dGVy94L2cyOHdBbXoxOUtqOGVKZ2J1UVlqVjQ0XHJcbiAgUjkxcjExTmRCNTdmZU9reE5YU1NIY2twKyt2Z09PYXBwWGVERE1ibmtha2pqQzJwT1RKWXhpcFJsOXNHalZFVnN5MVFlbEZ3SmpqZlxyXG4gIHgwN0JnZVJueEwzaVFJb2hEbVQ1N2l1R2R5RG9VakNadTlpeUZiV3dWcFdGamNMYkJ0bktuRWVCbnJGc0hndzFLYmNMWkd3RHFKMUtcclxuICBJNTJRRWM4b2RSNlJiYUlHbHdnQ2t5K3ZRellOMkVoZzVNTEFRWnFibTZPWm1kbklnWVMwYVJZcEY5aU1uS0VTaytmVmpFSmhKRTV5XHJcbiAgS0VHa0xUQlVSOGUveHprOGRtNXdYaExEbWNIWm1UT1QxcFk0dzFtNXk1U3B5aFdCWjJuYXFCN1AwN0NqUVF1bnZybERGalJNejdNc1xyXG4gIEt2OGlZTSttVm5yNDRZZHBmbUtDYnJyOWRqcDZQbiszZTFtb1dKSEdLRGFjSERnZXRVamdTT2FvcFcrVGpLRXNqeWpQWXJJQXl4UTRcclxuICBVWmZiQm8xUnBhWUZDcGVFYjRSRzJZRVVuUit2T0pCaXJOQ0JZQnFibTlWakYwdDhRWG02U3VmQlVWcnhSYlMzaVMwa2djSHA4UTBXXHJcbiAgUlRhYWJaa05TR01xMkdrVTZaS3lRaE5zRmJHdGJySXBVa0ZnOHVWMXlLWUJHd2s4cWNUaTRFR2FucDVtSnpKTE45M3lHbnIrUEI0c1xyXG4gIGk3UElaQWFJcUVET1VDbHZpOVdNQW9VWCtkUVZZTnJLUm94eUE2OUpUQ3BuQ09leU1EdkZGY2UwUFZESnpwZDUwQXV6NDF5ejVDc2RcclxuICBQS3paZ0M1ZGJyWEF1V0JkS2huTFdRWTFrNmRsNWQybXBpWnFXN1BYcEM4eE1qOFBqbmhxOEJpSFU4ekJrV0NNYW9GYkkxdW9wV2VUXHJcbiAgMkZTUEtITlhVV3RVZ3NyYW9DNjNDeHFqQ2szelF2enUwVk5QeWpweFdheGZ0NG9lZmVoRHJ6aVFERmJrUU9yWWdlaEZ3aGVrWEpQUlxyXG4gIGhla3JWS3ZTRWozSGpuU0VpTHlRR1VlWDZGVmdLTEZKS25XbDg1VXgwNTZOVXBmWXFTU1NDeG54akZ6cnh5R3lEVkttSXBORTQ4bkVcclxuICBnSkZOQXpZU2xLUnJuejlMcDA5eEpjRGlXMjU5TFQzWEg2OTdsWUdJOG5LVm1Md2dXYUhRaTVMVUpUQnRSYU5pcFpjbTZvb1pMWU9DXHJcbiAgdEpFSXJaZjVtWEdhbnhwbGJrbFdOSjdIOHpKbzdVUm9hT3NUcDRJdXM4YU8xVEllNHpCdzdERnFhbW1oYmR1MjBjRFVDemw5Vnl2RVxyXG4gIHdycnlNb0FuczBPTHBJNS9VeTA3a3EzVTFMbEc5SmVHcUpSR2xwZTd3aS95cW1wU0cxVm9xa0oweDQ2ZjJTOVQxck5ZdDdaUEhNaUdcclxuICBEWmZ6dTcvMFVMMEQ0V1o4blJzRGtZc3F1cktpeWorb2dzeVRScVNWZWw2dklpOWtKcUs5VFd3aENReVJORW5IeU9RalhOZ1ltRFpXXHJcbiAgbzVneDJpQTVKS0tJc1gwRlNkWVdpTFJDWmczeWFkTGpZbkhXU0ZCRFMwTUhhWFNVS3p0VzMvN2FOOUQrazVrN3F3cnBWY0xidklwUlxyXG4gIEtEU3hUMWtDMDVRYk1JcVZYcHFvSzJaVWdreWFTOG5Db0VsMU96ODlUck40VHpuZnljNU5EY3RzTncrK0FWdXpmaU9kN3o5SExaMDlcclxuICAxTGIyS2xPODFLZzBPeWxBSFFsbWJjRVoxckdEYktiVzFkdWtGWmFpbXR5eWlOSVlXWjVMaGZ5OXF0Z21TSmtxeVdiaS9ITTBPNFozXHJcbiAgc3FSWXZhcUhQdi93aDJqVHBuVW1lUVZBZFE0RXJZK21IbkVpTmJJV2pMdmlPSFlrRTBLR2pjYVJYcmFaU2p5clY1RVRMcWNIOGpiNVxyXG4gIHlqaTFpVWkzTWFpZFNpSzVrSUdYSENKMWtXMmlCbGRpWCtvNG9naEljdlJrTmgzQU12M1M4TEhQVVYxZEl5MHljeHUzUUo0NU5lVk5cclxuICBpdE5DYXZKQ2RZSFFpN0svT1VhbFBCMktsU0pOVkJVektVQmt2OUtrakVxL3FscWdUMzFtN0FJdFRRL1E1QmpmM1M2RkZrdFR4MW9aXHJcbiAgeEc5c1h5V3RGbytpM1paVWVpODJZaGVUZFNSTm5YM1V1bVpiMHNvU0pHVmRhY0VqZXliTFUxZkkxNnVLYlZScXVzZ0V6elZOWGp4c1xyXG4gIFhNRFdMZXZwM3J2K2hGdU9HMDN5Q29EcUh5UmtKN0s4OHlqWHkzWlo1NEY4bkxCSWo2OFhNdkkyMVRzUFVKRWRlUDJDa2EwZ1l5YzVcclxuICBSR3JQaUpsc0lqVlRscTlDOVVLSkt2QUJVR2lrUUg2UmpaQ0pnWUY1emkvZUhhWmhMaXdzY0gwMUwyTWhta3cyb25kUWllMG5wM2FDXHJcbiAgU09oRlNsaktETXpJRlNodndIQ0tvUFFTM21qMlhtS2hFaUk3bDBFa0tvT3FpejhyUXJ5dktHRG0xNmIxcTloNXpGQURPNHJXM3MyMFxyXG4gIGF0K2I1SDNuZU1NZ3VzV0dqejlNRncvZVRSZWZ1MWNlMEp5VWJxTk1SdjQzVlFyNVpJVmhCWWlQUjl1cUhiUnE3eHVwdFE4VjZUVE5cclxuICBqSjZub1VPUGNxVjdVbzBka3YzeEJpRVJWa0preCtteVB5M0FTVktwd0t1S2JWUmk4aWp6T25IaVlBTHE2K3JvVjM3cGg3bjFVZjNTXHJcbiAgUUM4WHJNQ0IrSTNHL2hqcjM2Qi9sRU9xbCsweWVxUVBGa1Y2ZklPRi85TUZTdWd1eW0yOE9sY1dmeXI1YmRZT0Z2SWJ2RWdNQWdtOVxyXG4gIEl3Vk1CWVlSYVlSTWxBellJeGpMaEg0TUlDU2hseGlZWjNtU1ZJMnB2cjZlV3lBNnNLdHhtbGF0a0JEQkJCNDVnWWxVN3NxV3NXQ1lcclxuICB0RmpKY0lxZ0ZJNDNtclVuTEZSQ1pDZnBJbEVKWE1ualQ4VUVEbkhlU2VCTnJzejVjUHc0N3RxSlZxMWlCN0ptajlCb2RlQjVpODVOXHJcbiAgMTRwRFFlaFlmNFhvY0NkODhjQmRFc2JPUHNzVjlCR1piYlk4aXZlZkMzRzVUWlFMRllEcHZjR1J6SENyNUNRTkhQd2NUVjNFd0hzSlxyXG4gIGt2d1Roa01sbUkyVk55NTJBRGdYTXZEaXZONUozSG1BMW1CTmZkcWFtdWViTUZ3L3VKNWVRWXJxSFlnY1lJc2R5WVNRY2pJNE9EMDJcclxuICBTaWZPdy8vejJDZ052WWdFS2xNWUlYb25oRDZpVFpQZXpYTWMyZmpVWVdPQW5aTmdhN29rTDFCTUI1Ymg3QkJrRTZtWmdzd0xWQytVXHJcbiAgcUFLdkVHRWtpc29MZ01pbEFaaG5lWkpValpWa29QV3h3SzBQUFBuZDFkVmxVbWVGaEFncUMxQ3RoMk94TC9ra1dvTkpYWDQ1QXljTVxyXG4gIEN1RjRnMkFiQzVVUTJjWDdRaWlBSzNIOHFZZzRQeDk0azVRdkc2cUR6THJxN2VXNzJNcXptTENLc3F4ZnRlTldjU2c5TzIrWGh5WG5cclxuICBaeWE1Z3I1SEhNcDQvd0Z4S0M4Y2luNFhCL2ZiSTVFUEJuVWtiNkNXdnZYTXpVckxhZUM1aDlnQlhtQ3paWTU3a21mQ2NLZ0VzK0UwXHJcbiAgY1JFRFRKK1JCbkd4SGh4bW1UYTI5cWtnd3BOUFBXZlVLNGl4QWdjQzhDSDJ4OXhPQy9rekRQNmZOSm13R2IwU1BzcnBoY1ZHNWNzNVxyXG4gIEY4blM1d3VrTmtKNkc2ZmcyUGFsRXBNalN2SUM2NDBZWWhCSTNnUUpiMHRzUlN6NWVpWEQrRWlFM0R3cmFyTkp3RHpMazEycHNaS0FcclxuICBzRFVZeXhVMGN1WDF5UE9ETExZOXBJa1prc0NDd2JNK1ZRWm00UExLR1RoaFVBakhHd1RiV0NoRFpCUHZCeUVERmFlZlVzVDVTT0JOXHJcbiAgVXA0NFhEN2FhWmdtSnlkcGRuYVc3MlJ4ZDF1MG4rSlExOURDbGZSTzZ0eDREVHVVTjFQZjNqdGtkaGVtR2JzV0NzWWxkSFZkbCs2RlxyXG4gIFJsb21DZTZZR2R1MmVnZjE3WGt0TlhldklscWFZU2QzbUVaTzdKZHlBdkgvb3A4Q1dGNGFFb1pER1V6UDluR1JBa3lma1FaeFhvK1pcclxuICBjMWs4K09DVFJyMkNHQ3RyZ2RneDlpZUFISHlEcDcyUnN6S21rcDVScEkvejF3UUdKVlJkYmhQVWVSdEkxTUowRWhuTmdDNjNmeGVKXHJcbiAgUEM0OVU0RmhSQm9oRXlYRDdMMVk5dVpJRG9uU3dEekxvUXFhakoyd2tXeHBpUm9hRzJWUlJjay9VaWx5QWhPcFBDcFZCRXRqVVFvblxyXG4gIERBcmhlS05aT2gxQ0dVd3ZpUUtiaFlyRHA5QUljQ29mY2dJT2w0T2kvTktBVlhmbnhzZWxSWGpvM0pRL0hwY1NzSnc0S3V2T2pWZlRcclxuICA2aXZZb2V4K0hlOEQ3MEkvenM3a2t6UjA5SFBpVUh5Q2d2TGt3K1VnNUlNSEx0dlg3ZVBXMDAzVTBOWkNjMU1EWEo3SGFTSTdQaUlJXHJcbiAgLzUxK0NoQ3k1aEF6WlRBOTI3cWZuMXFiUGlNTklpVXc2U0c5OW9rKy85aXpzaXpRSzBpeHdqRVFSSTZJRHJDbk5kWS9McEk1MGhFNVxyXG4gIGZVUmJsSnhTbXFGQkNVM2loTkFqT001U2g0MUJiVlJpY2tTU21mRU1TZTNaU0NlUjVxMFMzdWJLWmhwUkJWNGh3a2lrSlkxWXQ0a0FcclxuICBlNFJZQXlwd3ltWmtCdlRiTmpUd1hXK2l5dGc2bHZOdzVZbTBESk80c2lkS0p3aEM0WGlqUlhJNmhES1l2akIvaFlyRHA5QUljQ29KXHJcbiAgQ1dOaHBTaktnNFA5UUl0S3d6WGJ1M1g4cWI2Ujl1elpKNmxmU0tBMUFvZlN1L00yY1NpdDhtcGJvb3ZQZmxJQ3VycndZRnhSMlZ5SVxyXG4gIGlKS3dNdFExdGxIWDV1dXBZOE5lZGlwejdOeU8wc1dEbjZYSkFYWWtwZG1GLzFZL0JmQkY4Z1NITXBpZWJkM1BTNjFOSDB1TjNidHJcclxuICBFOGVSbkhIaDRoQTkrdmxuakhzRkRpdnF3cEsvVlE1eWRIQTlyYkd5a2N5UmpoQlJ0WHBHa3I5cTBvcVpZMGVLM3BpY0RXc1FPZDVIXHJcbiAgUmpNa2RUQmlSSGFXbjFlQkNnd2owZ2laS0JtcHZlekxhQ0VzL3dEajlXdWFRQW1FemNnWW1uY04xYlBqbUxLdUU2ZEpiRDNyVW1SaFxyXG4gIEJ0NHVSaW9VampkYUhLZERLSVBwSlpHeEdiaFNhY2tLRFRJaEs2Z1cyWFFjN01kWWxBOW11Unp3dm5NNDhOYU9EaHFZYVRJcDRISjRcclxuICBJWU8rSXgwT0JjNEVnOXpBME5HSDZBSTdrNGtMUjJRNmNSWStCOTRVaFlnb0NPWEFlRTdmbnRkVDZ5cTgxR3BLV2tZWER6ekFqa1FmXHJcbiAgYnEyY1RmanY4Y25CcC9VRWh6S1lubTNkVDBtdFRXOTQ1b0c3cUxzdlArUHFMLy9xbjR4NkJRNVZPeEQ1RStVWVI0ZGUvandoZEp2b1xyXG4gIE9YYWtJL0FIVnRUakcrc2pHbHRFWGdiQXhrZ21oQ3l4VVlrb2hkTElhRWI0ZlFBSVl5VFN2RlhDVytTdkRDUFNpQ3J3Q2hGR0l1UmxcclxuICBES0tjUGNBOHZob3BIOXNJbTVFeE5HZVc4ZmZXZlhqb1UvVjQ3MFJpQzlMU1c0b01XT0oybmlpZElBaUY4NkpVbDRmcEMvTjJvdkFwXHJcbiAgaEV2bmR4cUhhcEJKWTJXUktBNW1VUjJjZFQ1Z0xiS0ppUW5xWUFlUzZsNE14UG56RWF5dFoyZXlVeHpKNml2ZUFnTjJJb2NyT3BNaVxyXG4gICtCeDVFd2N2REJZV1VtQlNBQ1lFcUNPWlprZHltQVlQUDBMejAvb2VmZ21TcWJFRkNHY0ZQaG00ZEVsWnltQjZmRFdLWURyRzVJV3pcclxuICAxTmNiSnA0QS8vVFA5OUhRVVA0cDlaY3pWdGlGNVE0M3gvSm5HWTF0VG0ra0k5akFpd3IwcU95Q1JaRSswSXJVSnFqek5pb3hPU0xKXHJcbiAgekhoR1lhc0RNTHZJTWxFN1Jxd3llUXFkeVRmK2hVcDR6Z0I3dGtGa2tzUUdaRzQvNEN6blNEVStQazV6R0xTdHI2Zm1acXc4eXhDOVxyXG4gIEdrV21CcE9rT3plWXppQWN6QnlSMGFjd25jczNZNllpSzcrRURKeFlRc3hVZzlpZUE2ZVhZc1RCdEpYaHJNcENNZlp0YnBYbmI4WUhcclxuICBCc3lCdkxTQU0rbmRnYTR1ZFNaWXl0MDVrNFU1TFBWZi9XOER2QlZ2NG1DYlRJZ2R5UlphbkJ1Vmw1Tmgzd0ZtS3hrRk5nOTN4dUNUXHJcbiAgZ1UvbkNRNUZNQjNieWU0UVZDRUEvM00vK3dQR0tTNE9ETlBmL3QzSGpYc0Z3TW9HMFYzc2o3UVNhZVZaclBlaUVuMUFrVDdRQWdpTVxyXG4gIDlTZFJpWTFLVEM2UjBReEptOTIzaTFndWtRZ1kwVDdOUUNraHZjTEFmQ1R5WlFTOGZXUUEydklQVWxER2VUSm9BUlh6MXVzZFdGcTdcclxuICBSTFgxTmJTd05LK1ZsKzB6Witva2VRVWpGUW9YTmhhS1lEcjdUVmt6UFI3NnlTa0JKMDcyZzdBY0lsdE9LN3VQZzlpVUFkcXlzRUpZXHJcbiAgc3NPSEQ5c0RuRFUwc3RnZXNpc052S2s2RktXdkloamdUSHEyM2VLZENWNXZlK0haVDBnTEpVVlJKaTRVUTdTOGlZTnRKR0JXbVRxU1xyXG4gIHJUbytncGxrN014U0JIdk54Tmdjd3JtRVR3S1hKdHAzTVV6SGRtTEsySHJkYmZROTMvMXV1djVWKzFSbmFYLzVWLzlZV3BXdlFMR2lcclxuICBNUkE5eUVZYXNYemxIK2xCQzR1TjBpdHpIdEFIMnA4d0lrdHRWQkxKSlRLYUlUclBnakJHSXA4emc2bHNHUTFhOW93T01pOUNQc1lnXHJcbiAgeXRrRHpPdlhOSUVTQ0puS2xPTnRzaTlBTlVLeFRydXVpS2FtSmlLTmcwbHlDaWRRb1ZDODBhSUhlUjZtYzJYS21PbVIwRThPemw1Q1xyXG4gIHpDeUh5SmJUeWE1ZEVIMFpvTTJHS2xHVTFBZmVJREJ6emZZdU9mNW9DU29TdzVLd0VoU2xyeUxFQjhoQzI1cWQxTGZueTJqMWxleE1cclxuICBtSWNqR1hqK1V3WE9KSXNvRXgrS0lWcmVoRU9ranFSbngydGtaZU5KM3RmbzZhZkV0aGlTeURJSWJCYmhMTXNvZlJwUGNDaENLdityXHJcbiAgUC8vbFNGSkRSNDZlb3YvN0QzY1ovd3FxV3d1cnRvSHFXMWRUalQzVjdBNXljZVZ2TW1FanZiZGRUZzhvWGNtNUNCazJCclZSU1NSUFxyXG4gIDhnRWI4MFpMcEhUUU11V1pTQ3BrNEJXeExjaUVjWnNJYWgra0diMndxVXc1M21aTWN3Sm1yOXBVUi9mZmQ1K3duVDA5Vk45N3RkREZcclxuICA2WUZVS0p3WEZTWXdtSzdBUkVVbGFSTnhpVTBPYW9mVmI5SGxJaSs3V2x6UTkzemduUi96TThvanVIZUZZS0VqZWZFVk8xTzhOeVJhXHJcbiAgbWwzK0kvNHo1ZFc1ZFZqbkRXODF0TGNiMWpmS014aUlrUlk2dklRS3R0aFhidTJuRE5vWEw5S3hZOGVvdHFhT05tN2VSRlAxWDF6TFxyXG4gIGdPTlk0aVZUa3hlT1VPdnFIZFRjdlZGZndoV3RHMVU5bGsrRXJpejNjQ1M2dW9wZlpGV0VLTy9TM1pRc0dPbUZxWGJpK1h1bEJYTGdcclxuICA0ZDhYL3YwLzkzdjB2dmQvUUdoZys3WU5kUENaZjlUWmpTOXoxQ3pPUHJsVThYVzJOYlhpUFBqc3NZcFhMK0lYeDNsb0xOdkMvQUZMXHJcbiAgR1RZR3RWR0p5U1V5bXFFVmhqR0MxQzYyakJoR3BESGJnTHl0WjNPMmdQRWNCVTFrSTJURU01VGpiU3BtWkFUQ3FtelAyZ1Y2OElFSFxyXG4gIHFLYStucnE3dTZtbTY4cUM5RUFxREZrVUdodE1WMktTL0xjeEVuR3hEZGFGZ21QQXlyWllMaDN2NkZoY1lJY3hFMTRjbmswWjg2RGpcclxuICA2cUJvTDA1ZlhJSnlKRk1SMkRHSWsybGtKOE9PcHFZZWJ6cHNsQmRReVZMdWsvMTA4Y3dabWI2N1p2Zk5sdWlsUTJFRldpWFFFcGtaXHJcbiAgUGNmL3dUZzdrNTNTL1pYTGNjVTdLRTZBZmNsekxJeTJOYnVwcFhlcjBOWHRJTElwTVM5ZGU5aUxsOFNCQUZPem9VVjB3ODN2b3NjZVxyXG4gIFAyRGNFdjMyYi81WCt2N3Yrd2JqWDc2bzZUOTF6MUxGMTluQ2diU3ZrenN2ZC9tOHFNNURva2l2Q1l6eWhOc29MSTk0bTdXUnRKNE5cclxuICBjaVhqRXNWMmdETDVjZ0dwYmZxNy9DYUMyZ2RwUmk5c0trdC9zME41T3FmWjFEbE9UejcrT0xXMHRWRnZieTlOTldiZktKZm00ZitHXHJcbiAgYk40SlRGZGdrdnoyTERKNTQ3MGFDN01Uc3R3NUF0NHVPRDg5NnMzS2NvSWNaNmpUTDZIbHdCVTVGbzFFak1xYm13WnNVRU8xdGZYS1xyXG4gIHc1cDV0RER3ekVSNDZWTjJMNXh6cHFXQ2xnN0txaTBkdk5tUWFYdWpJV1Fza0hSeG1iSzV3cUt6bzRzVzZydGtqU1Y1RVZWcnJ6aWJcclxuICBmM3NVWE44WkxHY2hGVHlINEVoaVpGSXZ2N3NJd1JpdHk3SFRUOHVTK0MyOVc2aHQ3WjVNWHRWa2JEWVZUQXVkQ1lzbW5yOUh5TmlCXHJcbiAgbkRyVlR6djN2SjFtNTNRbDVkNmVEanAwOEtQVTA1UE8xSHE1b2ViTWlidVhsbHZLWFIySUxpVDJ3amtQWVF4S3FMa1hPb0VnclVpZFxyXG4gIG5HUDlHb3lTS0piR1Jua2Jyd0xsbVVncVpPQlRPeUQ2MVRsYlFPMVRhY1FKV2FUbGJTcG1SQUpQSmtkZDBGTjNqbzRjT1VLTmpZMjBcclxuICBldlZxbW14d2QzTEJVcWdvajNLd3JrU2QzN1BCeEhPVHcxd1JqTkxjeEVWcFZhQlNoaXFiS3I2VW9hdHY0UW9YNXg3ZnpkZUI1b29mXHJcbiAgRDZqaFBKUXVKKzhJQ3BBclVrNVFpRlVkZFhUMG9YOHhyanE0ZXk1RUxqUzJkZEhNOUJRdDRFVlQ2UDVpR1FKMGpuYkFiMnRxWHlYMFxyXG4gIG1sWGRORmFyOUlzS0szTXh5cFd4Qm81a2F1QVlPK2xXZWJsVTNwazRaUEtydUc4SE5VSkx4STNEb0ZzTHo3Y0E2WDF1TlJtYVRZbHBcclxuICAxcEdzYXBtbTQwOThObkVnd0YvODVUL1NOMy9yVHhxM1JOLzFIVjlILy90MzMyZjh5eE5WT3BEMWV0SEd6bU9GemtGRjVmcHk1eEZYXHJcbiAgenBFZVV2MHE3WkRZZ0kxNW95V0txejZtWWpOajFDeFJNRkxicEFMVkJFSUdxSDJRUm5vaEk1NmhIRzlUTVNNakVEYlp1MEVsemJOSFxyXG4gIDVTRzJ4Yms1MnJCNU0wMDM2Y1VIV0ZKRFBnZUZ5UXZVUlh2RnVNUDh6S2dzNzYydGkyRnZoWmthdUVTejF5OWVBNHZGNjVyeG1sUnVcclxuICBRVFMwOVpnbVJsbjVJbVJNR3VwcWFNN1dBUnQ3VnFkZHRxL2RLSVBhV0U0RTYxSmhKZzJXQlhFdERUeDBXVDlqNzB1NVJFd3ZOVkZ6XHJcbiAgVGZvKzdhWG0xVFF6aGVjZEZyZ0ZVc2N0bUJtK2x2Z0kxaXhKMXh6Z2lvOFlBY2Vwb2JtZG1sczZxS3U3bDZaYlYvb2EyUmNBaFpWdFxyXG4gIFhvamZNRGw0dkVLckpJdE1Ib1g3U1RGeC9ubVpwWVVXSkJhWmpNZWZKTG5QbzRyTW5FMkpLWnhKbVFNQnZ2WGJmNHIrOU04L1l0d1NcclxuICBQZlRBLzZHYmIzYmppeTgvVk9GQTZxUUZnc0ZGajZoeWQxR29WSVF4VktmWDdMelFDVUJFcHBFZVV2MHE3U09qR1pMU3MwR3VaSlF2XHJcbiAgcUVqdG1GeVpCTEZ0WERhL2lhQzJRWnJSQzV2S2ZJNkp1RGhkUnNwSTA5YU5QMGNYTDE2VWQ0RnMzcmFOSnVxM3VxU0dmQTZLTko4WVxyXG4gIGJxK29kUEVxVjNucjNzU2d4TTdjeGJnK2hXWUhVZC9FcllpR1ptcnMyaUJkU2ZVdG5kNnVHSlcxVUYrenNVR1dTRC85L0g0VC90dGhcclxuICB1aGFEeWZ3TCtTUnBiV3BsaHpTUmN4elZBRm5nT00zV3RLaVhYWnhsZ1hrK2hvZ3NsaU5TeHc2cXRadWRYU04xc3ROdGJtMmhkZXZXXHJcbiAgMGNFemc5QkdLS2tkWHdnVVpxMUN0QllRNEVUZ1RLcERKc09Tb2s4Tm5xRHhjd2VGamxzak1TU3BUMStTa1lmcEM4ekduN3RiNGlJSFxyXG4gIEF1emErM1k2ZkFUTDFpL1I5bTBicFNzTE55TXZSMVRsUUJvNlFoZVduTXB5TnR0RkxxelJ5aGlxMDZjVmRhb1BLaTlrcUkxS1RDNlJcclxuICAwUXhKNmRrZ2QwNG90aXl5eXp1UDJBNWt3cmhOQkxVUDBrZ3ZaTVF6bE9OdElrNXRsRTMyYkRCSlJ0RXdlWWpPbmNVS3Jkd2tYN09HXHJcbiAgbGpveG54M0k1NkFvemdkWW1wK1R3VzNNeXNGZ05zWUZZT1pNM1RWWXcwNmlvYmxUWG5QYXdCVmRMZDZ0NE04YjFwZnRXbEN1dkdwRFxyXG4gIEhaMDdkMDRDTGxTMEpBYlpPZGJXMTFQai9DUk5jOFVLT2RhY2tsWUc1dWx6N2R4TTRjMS9aWmptNnJtbVhzZFFHdWRXN2dSaXpOZTFcclxuICAwendmcXpwMmt0emVvT1pGTjRXM01oYjRCcTJ6azQ4WC80YkJ3VUZaK3IyVnc5am9BTGRlSnRpTDRDRS9CWTRTanJlcnJwcmErbGhZXHJcbiAgUjczcmQ5RDh3cUljQTR4NU5UWTMwYW1MdWdZV0hGVmxMR3V3UEtJc0ppNGM4bzRrYnBGVXQ1ZklxaUFCOHRYWldqWFVzLzNWVk04dFxyXG4gIHRTS2t2M201UFp2ZW9wM3JtK2lKKy82bDFJRmdQR1Q3cmkvbjQ2M24xNC8vMkxmUkwvM2lmeGI2NVlZVk9oQStHK1U2dDR0ZFdLT1ZcclxuICBNVlNuL3pkekhtWVRyQmhKYmFhMG1pVldET1lqa2M5RmpZVU1VTnNnemVpRnpXcDVtekZMQko3TWxGOVFuclo1NWdpZE9hbXJvSzVhXHJcbiAgdTVZZGlMNm9LSStpUExneW5CeVdQdWk1NlZHK3NMUWZINVVXcmpHRTJ2cG1xdU9XUkNOWFlPSXMySGxnekNMQU1pM08zbENzMmJONlxyXG4gIFVhYkE0aG1LRWE1UUcxdGFaRVZodk45OWFXR0I2aHNiMmFGeFpjLy9WVFBwT2wvVFZMK3N3Nmp2WEVkZG02L2laRFUwdjFSamxRd0dcclxuICAzR3VJNjE2cTQrSXZzc3hWUHJVMVMxTENoYVhsN3k2YmFoZnB6TE9mcFFVNFYzWnNHTVR2MjMyYmFTOGYrelowMGNqd0JScTZlSTZQXHJcbiAgeXpBTlhqaHRtbkFVNWY5cDdLVG1sbFpheEtCOUhkOUY4ekhzN3V1VGxzcmc1UEsvSXc4N0dKZUFpZk53SkVla3RkQzJlaGRMMHJ5cVxyXG4gIHl6bXlNaEkzTUlOSEhwQ0pETm9hZ1pNcXprMmtYbFZzRTZENlBSdGI2Zk4zLzFPcEF3SCs0Y09mcEhmKysrQTBYcTVkV1N0d0lHNUZcclxuICBWenRkT1FwVm1qQ0c2dlRGZy9HQXBRb2JoZG5IMjZ6TlpZMTNtRjJLMkRiS280SnRrRVo2SVNPZW9SeHZFM0ZxbzJ4Y2RvZHNPaUFWXHJcbiAgZEN5ZXBPTkgrRTZOZjlqNmpSdHB0Z1VYY0l3MEQ4eUdtcng0akJabUovbkN6TFF3MkRISWU3czdWbE5qKzJwOWExdmhJTGFsU0xQT1xyXG4gIG9GaHp6YVlHT24zNnRIUzc0ZWx0akZOZ252M3NsSTVMMVBNZHVUZ05Sa3Q3dTdRMFp0Z0cyVFVUdHpqUWd1amJSbTA5cTZpMnFZdm1cclxuICA4Q0o0Um4zdEVzMGJYUm5WMkZURytmMzNxaGRpRDlUVjNVMU5HNjR6ell1SHBjRWpWTTkveGJuVGgvbVlhUGVYK3lXSUYydGJxWTd2XHJcbiAgMGhkcUdxUWxDc0FSYjlpd2dWcGJXK25pZUEwMU50VFM3Qnc2eTFhSzVTcGt4ZlR3R1pvY1BFR05yVDFTNFljeGpEVDk4cmxGRmt5NlxyXG4gIDFnaTZTTHUyM0JETmJDdk9TYVJlVld3RGpCKzhLM2tPcEF3LzliN2ZwcC8vUmJYWnVHRU5IVDMwc1pmZHN5RlZPcEQxSEZrTFJHVDRcclxuICBScWVwSXgzQmxaWVhGZWd2eFhrb2w4cGlyTng1UkZLekM0anRRQ2FNMjBSZ2kwUlVicThVYnlPVERHTnNzbGRETmgyUUNpd3BkZGVjXHJcbiAgcGNQUFA4L1h5Ukp0M2JHRHh1dDBtZTg0RCtjMDVxZUdoWWRZN2xIWllkUTJ0VkVqMzdFM3R2Zko3S2ZLMEF3emYwbUVZc1dPdmprNlxyXG4gIGV2Z0lUYkdUY0lQYlhBdXFFczJBMmxwNW44a2NPeFMwUXRBOWczVzkxbTdhU1JNTHJkd3lVTE1GYmsyVTdLSUVLekl1UmlZTGJzUlFcclxuICAvMVAzY0V1c2dWc3hpN1R2aWl0b2NFa3JiT0FGMkdOVndJdWxNSUVCRlRaYWpnRCtVK3kvb1kxYml0eHlYQnp0RnpuUXNPNEtQb2JjXHJcbiAgMHVJL0QxMW9UZDFZOFBCeVVGNHh6MDJOU0t0V2xxQmZzMXRhYVNsQzJ2SmNITlFDa3plR2pqNUlDek1UVVdza1JuRk9PRzhVZVgyMVxyXG4gIERnVDQ2bmYrSUgza0gzWGE3emQvNDFmU24vM0pMd3I5Y2tGMURxUVRzN0RNcy9LWkdLbzJZUXhHOElub1JRWDZsVGtQMVN2blpJd29cclxuICBEMG5sMmRoR043RmxZQ0twMlFYRWRpQ055ZGtCYWh1a2tWN0lpR2VrZVRsazB3Qnh1WUdpZEVBUUNCVTIxRVduNmNqaHc4elcwSlZYXHJcbiAgWGtubnBsZHgzVHduZzk3VHc2ZGxFQnlBTlVJdE80bkd6clhTeXFobjU2SFF2SXBoT282S3JZcWxWNndubVY2TWxnYVdtVitFRjREVFxyXG4gIHdCOWhNY1kyRnRtaDlLMWFSZTFvYmJCSks3Y3VoakNaeWFFNCt3SlViWmhIYWRLZ2NGUkg3UWdkZS80cG1wK2RwNWFPRHVyY2RLTnBcclxuICBYanFncTJlSy8rdlo4UUVPZU1Xc2xoZHVwYldsblN2MGNYVXVSYit6WXhmZGNzdXRkS0Qvb3ZMRjlYQ1ZTQk5qUEczaTNQTXlSYnR0XHJcbiAgVGRReVRzelNOSlYzdjZTdGtRdEhxS1Zuczd6VXFoajVYRVRpeFVxc3hJRUFXM2U4aFU2Y1ZLZjhmLzd5VitnL3ZQdkxoWDQ1b0VvSFxyXG4gIHNrSEhRUGhFQzFXYk1BWWorRXowb2dKOW1mTW9ycVJWcjV6SkpES2FJZWs4RytUdWlnaXFTR2RTRmNWeWdIa3ZpbjVMQmRzZ2pmUkNcclxuICBaalc4alV3eWpMSHg4WFBJcGdPQ3dKSzVqVWZyM0RFNmVmdzROZklkK3hxdWlNK2N2VWlMYzFOaUphR3VnZTlJKy9pT2M2TjBBZUJoXHJcbiAgdkpCRm1sY0swM0ZVYkZVc1hkOHlMT01hbzhQYzJuRzNmL2dUNERQWVllRGNXSnlmcDE0dUs1NWI2ZW5wb1NORDBmc3ppck10UU5XR1xyXG4gIEFZVkpWRmh0YnBObkhwVVcxTUxNSEYxeDNYVTBPSjkvci9aTGpkbXhDelE5ZW81bVJzN0luYnNEbkFoQ1hZVWYyM2tWS3NWOEJWd2tcclxuICBXaDZhYUhaaVNON3Yzc1EzTFlramNVanlEa3paTHZFdzZ2Q3hSMlJhZHZ2YWZkVFNXOWFheXVjZ0VoUDNOVStVVHVNdHdwa3o1Mm5MXHJcbiAgOXJmUUF0OEExWE1yK2ZpUmo5T0dEYUgxK2FXTTZoMUlIVi9rL25MaTJKOXNSbkFGRU02L3ZINTU1NUhYcThUcC9VWWc2VHliMnNSV1xyXG4gIEVjTlFSbmNWSzFLN09BY2w4N1pCRXVtRWpIaEcrSDBhS2ZKcDBsUUFTM0xDSUxCa2JwTmducHZ6TXhmMjB6UzZoQXhTU1RUaW9hLzFcclxuICAzTkpZSStzOGVmZ3M4bmtGcUM3NW16ekswMjFvSGVFTDdBeGRPSGVPTDFDK1F2a0NRMWNKemdkMFNjMU9Uc3NnLzVvMWE2UzFjV3lrXHJcbiAgcUZ5VlVKVlJRTTVjQlN2TUpZZHp6M3hTZmh0eHkybnRsVzgyNmFXZ21wS1VWYUhWQTkyWHMrTVhwVXZKT1JQc1dXYlJjVXNVRmZyZVxyXG4gIE5hdm8wT0dqTkhqaWZ0RTc3TDc5bStqODhNV29GSm55ckxCNGVNWURqa1JtYlJVNUVpREpzM1RQQW0yTjRMa1U2OUtxV0o2OHNyZHBcclxuICBaUTRFK01Rbkg2QTd2L3k5UWw5MTVVNTYrb2tQQy8ybGp1b2NTTmNHdnVqZDRCQ2ZadjRjTjBKRVRwalh2L1RPSTVLYVhVQnNCOUtZXHJcbiAgbkIyZ3RrRWE2WVhNYW5nYm1XUVlZK015TzJUVEFVRVFEbGVRWWZBYlhWTXpZK2QxbVEyRzArN1l2WnVHbHZBc1QyYUFyeUNmRkNiblxyXG4gIHFOaWlKQjJMbThjUDA4bVQ2SWRudmhZRHRZMkVzZXo1YWN5ZUltNWg5TktHelp2b3doeWV2STd5S2NreVJWVkdCV1lxcURKMTFkaXhcclxuICBlbzQrZSs5OVZOUGNKTS9kck4xN2gybFdpSlVVckdLbHVCelN4QXV6VTN6dW5KSlpVekZhdWpmSXBJa21qaDFhT2UyRndRR2FQL3V3XHJcbiAgOEZqQkY2OExHQmpYeVE0aDUwd0JxeWl2enRvNlZObVJBRWxleFh1Y0hEaE9FL0xjU0kyc05Pd0gyRXZMRVJSakJ6NjVvaTRzaHcvOFxyXG4gIDdnZnArMzd3RjRUK252ZStpejd3djM1SzZDOWxWT1ZBR3JzMmFoZVc4TzRzdDVpalVBVUtZMURpaThkNVJPbHpkb0RhQnFsUkVnVXBcclxuICBvQnh2RTNIRUNCbVgxeUdiQmdnQ1MrWTJ0REEzSTkwUk02UDlzajRUQUEyNnBIcDdXdWxjUDkvMWM5dmo1bHR1b2FNanJhSVgrQ3c5XHJcbiAga1lISk9TcTJLSmJ1NDRvVTR5NW56cDdsdTFxc1lGdExkUnptdVZKMXdETUtXN2R0bzlQVFVSZFBXVEU4bGpWUTVNeUtqdkhsb0RpM1xyXG4gIE5ZMFhhUDlUKy9rL21LTWJYLzFxT2pYUmFab3ZZSlJVcERKdU1zaVY3L25uL2EvRm1Fa0hWK2d0cTdiN2VtQnpUeDA5ZlgveEsxNTNcclxuICAzZm9WZEdFc2RKSHByakk3TEszSVkwZXlpeDNKTWc4a0p2a0V4bEZqWjdnbHpqZFd1VVVnUy9lL0pBNEVXRWtMeE9IN2Z1RG42UU8vXHJcbiAgOXpkQy8rV2YvWGY2ajkvd0ZVSi9xU0p4SU9qbXlJRWRTTDF6SUMrMTg4amEreWl1S0pqeVRDUk4wZ0twWFpva3RsVzdJSWwwUWtZOFxyXG4gIFEzSktSS2xlMmJpOGdIRWw2U3lKYkxEWUgvcXk4V1F1bGd4eEt2eDM5YTA5MUxKbU45VTF0ZEdtMWlGNjVwbG5hSDV1a1c2NDRRWTZcclxuICBQbVl2TkJLRXZGT1luS084UlVrYUZsKzVlcDZlZi81NUdSakg5Rm9jYTFraWhBTm1WK0Vaam8wYk45TG16WnRwL3psM0k2SlJPWlkxXHJcbiAgS0RESkh0ZExSVWt1SmVMNjBRTjArdFFacm1rWGFlM1ZsOU45OVFVRXJtRG5KZ1pvZG1KUW5Ba2c0eVROblh4RHVaNHI0L0FrZUVmRFxyXG4gIEhKMTZYQ3ZkSWx6M2xxK25ZMmQwcGgrZ2RYZW1CaStvME9GSTBMMkY1VXZxbS9EQVlHbXRyL0RxWUFmS2RXazE5MnltanZYeDgxQm1cclxuICBsOG4ycW0xdDlMbVBmZmlTSEFodzU5dStpejV4MTJlRlBuSGtFM3plcnhQNlN4RTVCNUsvSnV1b0RnN0VkMytZQlVmaGNoWEdvTVFYXHJcbiAgaXZQUVpNRWl0UUVaTTdFZG9MWkJHdHY2alVBcDNrWW1DU05rVVFXWFRRTUVnU3NTRmlSRWY3V2JjZ3RBMWRqU1RjMnJ0b256Y0RKc1xyXG4gIHI5bEU5T2lqajlMRStCUmRmLzMxZEd3TU02dHlPektZbktPOFJVa2FFOC8zUDBaVFV6TTBiYzlyeEVBTEJFNER6eHdjUVF1b0pLdUFcclxuICBaUTB5SmtYSGN5VW9TYjJDVExkMmpORkRuOVhLQWxONFYrOTlvOUFydytYOGlrenQ5eUpoOHR6ek5ETTVSUFBqZkpQQVBPb0tXVzZkXHJcbiAgV3dsNmJXbzUxclRYMFBNUGZsVG9JbHo1eG5mUzZmUHB1YUlwbzkrUitVbFl3Z1FyQmFUZFdzdjhicTlXQXU5d3VYandYajdVTmV5UVxyXG4gIGJvdG1HZ0ptYk5IWWdVOUlmS2tPQk5pMDlVMTArc3g1MnJaMW96d2Y4cVdLNmh4STl5WnJ1cHFXbzNEcENtTlE0c1Z6SGtIbWJMd2tcclxuICBteWUyWmhQQWRNU0c4dmhOQkxVTlVxTWtDbEpBOGtsRmpFaGdhYktwNGtnUkdGQllQaHdQWVNFc0xZWnhEY3lmeDkwVUhFZU1lQTgzXHJcbiAgYkcrZysrKy9ueVlucHVuR0cyK2s0K01kcG9saDloeUZsQTU1aVlERjEyMnBsWUh4STBlTzBiVDFmY05ab05zSzZPanNwQzFidHRENlxyXG4gIDlldnB5ZE9ZWmlYaUVsUlVLaEtUN0hGY0NUSXBMejBqajluK3o5TVF0N3d3ayt6cXE2K204L05yVGZPRmptVXE0Qkpnd0IxMzgyZ2RcclxuICA0UEFoTkhhdGsrZEhNSnNxWUlsRzlvZVZqV3RXNzZXbEM3cVdWWXpyN3ZnYU9uWXVMTldpcFlyS1ppU2VWeG8vaDRGMmRHdGx4MGNxXHJcbiAgL0paRXBkTjlFZUQ4OGkrdFV1T3haeS9mZ2ZUM1g2VDFtM0V6VVV2ZjlCL2ZRWC8rcDErYXo0ZkFaMVFKdTlvNENwZXdNQVlsWGtqblxyXG4gIGdUVEZ6Z08weTVHMzJUeXhsU2dqOTZ6azdFaTNDZURFU0s5U2JFMHZrZEVNMWZBMmlCZ3FEYVR1S3pFQkY1a3BsTUVXcll5Ums0L1JcclxuICAwSkhQU244MG5BZmthRzEwYnI2QnVuZS9MbkVlUlh1WW5jWFQzT2ppQ24zUkFiRGxnSzlHRVV5WGhZazc1ay9RUGZmY1I4L3NmNWFtXHJcbiAgSnpoL3pxRFdIdkJienkyTm0yNittVm8yM1V3WGx0YlNrMmZLbklmYlI2RXlWZnZqNXo3VklzbEVRMWEwWXFRWjdGMDFUeU1qSS9Eb1xyXG4gIHNzVEtTcHhIbXRNTEUxYUdvaHppVUF5c1FJRDNjNnk1NXUzVXZ2NEtxdTlZUXpNai9UUnkvR0c2OE15LzBpUzZ1eVI1bW9kekhudGZcclxuICA4dzZhNzlsSzAwM2FyZlBFM2Y4Z2ptYmJXaDNrMXIxSC83YWRvSzJydDlHYXE5OG1OdWYzZjB5NjFnSTBsWVlNRWxXTk9xRFZPNlZiXHJcbiAgYnVMY2N4QkdTUE9ZeEpUelM4UzZkYXZvM2svK01WT0w5QmQvOVZFWllQOVNSSlV0a00wMkJvS3ZzeERHb01RTDdUeWNPQ0tZRENVUVxyXG4gIGVZR043aWJ3V2J1SWRCdUQyZ1ZKcEJNeXErRnRaSkl3UXNabEJZd3JTSU03dTVuaDB6UTFmTXJQb2dKcTZ4cDFOZ3kzQW12cjAxbFVcclxuICAyZHdGSXFxaEs5Zk4wcWMrOVdtNXFYcjFyYmZTNGFHb0M0dWpmTXF5dklBYXVuRkhFKzNmdjE5YUhndXp1djZVWUttV2V2djZhT2ZPXHJcbiAgbmRyS0tjZ21vSUl5VVJYK3NtV1FTYkh5RENKVW1YamdhVHAzOWpTYjExQkRVeFAxN1hxOUtTNFJLeWx6aFp2dWFuRnBXZVJUTFV5UFxyXG4gIHNlTTRURk1qWjRSSFBkTEtkL2h6RjNUc3hLSHJxcmRMdks1cmdVNmNPRVVURTJNME96cEt6UXRwUmIzdjlyZkpNaXVIejVSM2RjbU1cclxuICBNU2JMWjJ0VitIV211bkRnTGxtV0I0c3l4bldUZXdYQTRNQm5xS1hqOGlaRS9QNGYvQzI5OTN0L25xa2ErdHo5ZjA2dmZ2VzFxdmdTXHJcbiAgd2ZLRDZGeUIxVmZ4SE1pTDdqeE03OFdnc2phTUY4ZDV4SGJRSklhTVZLOXNYRllnbXdhb2tZRndQRUU3TjVrdXlZMzUrSmc1VXMrdFxyXG4gIERrRnVGem1CMndqZ1FCNTQ0QUY1dUJ0ZFdFZEgrRUpnZFNZVkl5OEpvaHBhMDZCclU1MDhlVkxYcGNMVFpuaWVnek51NytxaXZYdXZcclxuICBvSk9GM1dNT0JmbkhpUGExakdVQm9oUXJUOHlvUGxHUjVZV0Q5OHBMby9CY3k2M3NwSThNVlRQT1V5MktNcXBRS2E0RVZXYXpzcjB0XHJcbiAgMGVMY05FMFBucVJ4bThHRmdEb0ZwMHpYMWVvOEV2QU90cXlwb2JObno5TFEwSkMrbzJVUXk2U242SktIR0ZPZ2JMTHE3N25uUzdxMVxyXG4gIFlwVC9FcDN4ZFppNnQ5NU1qVzA5WXVrY3lPVjBZY1g0c1IvL2RmcTEzL2dMYW05cnByT243cWIyOW1oRzVCYzVhcytkRzVDWk13QzJcclxuICBTVURybzUyYjVYaVpsRCtoT1hha0VaZnZQQkE3aVZjeW5GNDNYZ3dxYThQUWNnUmU4alVXcWIwbWF3ZGF2MG83blpCR0c5THlBUkZqXHJcbiAgOXNtK0JQazBXSzlvNVBnakVyeno0T09OcFJnd3lOZTU1UVoxSHBLbnFvRmM3bDRmeVJpNEdERUxDa3VDVEV4TXhJZkM0Qk1HZUpFU1xyXG4gIHpWTkhhUDlUVDhsN04rQTgwTS9mMXNZdEdUNWZPcnE3cVhYakxSV2NSMEgrRGs3bGoxWHlpeXJBSjlRUXMxVWhUbENjS0d2aGdrY2tcclxuICBsSllZSHd1OHRPdklzSE1la2NGbGhTSVUyVjFDS0JBbHdWQ2tRaWhHRGVIZDhLM1N2ZlVPMnI3bmFxbU0wWUU2eHdRcStodzRzeE1YXHJcbiAgbG1pdWZoMjFyN3FDcnJ2dU9xcGRzNDJtRzdwb3VxV1BwaHYxNXFscC9oenQyWWpYRXdlZ0hPM3NPTlplemM2Rm1iR3oreXNVRG9waVxyXG4gIEpSd1B1clNHano4c2pzUlo0VG1RU1hSUHZnRDQxVi8rRVhyWDE5MUo0eE16OUtZN3Y4T2tYeHFvKzhqL3UvdG56cDhmTFBiUmVCc2hcclxuICBsdXEydWQ4Q1g2RnFyR3drTTlKWENkNGVVTDFLOG5wSjQxbW4xMDFzRlJnbHNFMmRHQ09icnhLSlhNRmFGcWswMGdrWmVGQnArWUNJXHJcbiAgRVRJdUp3QjdCR01aMHlQOU5IYm1hVjFPd3JxcXNCUTY3cUxhMTEvSmQwRzlmTmpSVlpXbUE1bk5YVm5WWk5HNE1Fam56cDBYdXJXdFxyXG4gIGhTOVM5OXhGZ2IwWEtYSDF4bHE2Y1BJWmVmOEdCc2Q5bHhYL2x1N3VIdHF4Y3hmTnR1MVdXUUtYa1dTV0lsSGhsK1IrVFFtaWhCRXBcclxuICBvU0t5eHZrRXBSWkZDaGVNd095cjAyZE84ODJ0WGpudGEzRTh4T0NMQVBFUEtnZ0ZJaDhpTWlOT2NPSEFaNlRsc1VDTjFOalVRTk9qXHJcbiAgNTJYY0FVY0xDM1Rtd0xZamszaS95V3E2NnNwdFZGOVhUeVBuTDlCQ2F4ZU5YTGhBSjA2ZTRncitCSFczMWRKaVE5cXRoRmNLWUYydFxyXG4gIEM4OStVdkpwYk84dExwUXZiYXJFTmRmVXRaNUdUejBoL05Ja3Q0YnFHdW5yNzloSHZSdGZtTGRCL3Z1dmV3djkxVi8vTXozMTlCRzZcclxuICBjR0dBM3ZIMkx6UE5GemRRdmVWOGh4ZndIWEZUenhZZC94RGVIWGlObFkxa1J2cXF3ZHNEcWxkSlhpOXBQT3YwdW9tdEFxTkVXZ1lnXHJcbiAgdGdGcFRJbGRrRVE2SWJNYTNucFIwQW1FelZhSXdSNHRBYncvZW5wSTMyTG1VTmZVd1JYUEhqbjVBMEk2aDJ6T3ltWmtIaXBmMTNpV1xyXG4gIG5uNXFQelUxTjhvMDJ2SEdnZ3JmWjZIRXRxNXhPblhxakt6cGhQZHdlUEJCN3VRV3g0NGRPK2pNbEhXcEpTZ3JDeVBhUndXckRDTExcclxuICA2aE14eW8xTE5TdFhDR3FHbnBhdUY3UkFWcTlkUzNXclgyV2FMMlhrcWdwRlJyeHZReU45N3VQL0lIVGpxcTNVc3U1cW1wRW53NS9qXHJcbiAgRnZHczlHNWdqRVNkYmptMnI2N2xDbmUvdGdRd1VXSGFabXMxTlZGbmU0Zk05THN3RzAvSEplayttNThhcGE2dFdNelNDbFpTYkVXcVxyXG4gIEhENytLTTJOWDZRbS92dWZ2djhQYU9jdHQ1cm04akU2T2s2cjFyNlI1dWJuNkUvLzZHZnBQZC84NzB6enhRdlV2N25ENndXMTdFQzZcclxuICB6WUg0eWw3anRPTG0yTWhRWVRzZG9IcVY1UFdTeHJOT3I1dllLakJLcEdVQVlodVF4cFRZQlVta0V6TFdKSWFNdkcyaWRoeEhjQnk0XHJcbiAgYUdiSDhFUjRRRU5yTDdYeHhaT3NSeFdsYzhqbUhOaU0zSVBsK3FXMURlcEFHaHJyWmFtSnV0VTNxWW1EWkJIeTJkUTJMS3ZreXF3aVxyXG4gIFlHR0o4QTZPK3ZvR1dydHVIZld1MjA2bmgzRHB4d2pwRXlUaTNLOG9RV1JWWFFKR3VXR2hwbnBoUld6dEdLV0hIbnBJL2wrc2ZYWExcclxuICBiYmZSaWZFdTA3NGNrVlloalZPbjZNVGhRN1R1cWpmUWpqVTFkT1M4NnJHZHZuaVVKdm9QOHJGYmlCekpIdE1Xbzc1MkVYNmFHbWJPXHJcbiAgMGNrVHgybEozZ3RUUTEyOXZkVGMxaXJUcDU4K29RL1ZBbGhNOGZ5emQzR3Jmb2RNMTAzeUx0MU5VQXpzLzFmcGV2djRCMytCM3ZLMVxyXG4gIFg2WENGd2hQUHZrY1hYZmp1NWxhb3VlZStRanQzcjFWRlYra1FDdnpaNHpPQTExWXpWMGN1WmNINmNWMitjN0RiM2pybFl4VTc4V2dcclxuICBNamFWblFmU0dsTmlGeVJHSVpKTVl3M1RnV1ZFakpCeEdRR3o1ekRPRjhsRS96UCthWEdnZ1p2S1hadXZwK2J1RFpsMXFVSTZoMnpPXHJcbiAgeW1hTVBGakdaVWZ4bmJhamZvTE9uenRQZFhXNmxFaFR0MDM3bFN4a0kyeFg4encxVHArVTJWVjQwUkFxUkhUTHRQVnVvTldyZW1uMVxyXG4gIGxpdG9iS21IeHFiZEJlYlNhdm9FWG96U3UwOGx1QVFjSXJJeWlnMWpxZGRVTDF3Uk9odW01T1ZYY3F6NFdDNTBYMldhSW1UMzkxS0VcclxuICBGeHZwL3ZwUEhwQm5naWJ3YnBMbVRiNElpQnJ3VXFrMXU2aVdqOXY4eEFDSFFXazE0T3hxYk0rc2kyWll4TnNqV2I1UTMwRnRmWnRvXHJcbiAgMDlwT09hZEhCZ1pvWW1LU2poNDhRQTJMazFUZnJzK2g0TTJZN2J3UFRQV2RHVDVMeloxck9iV1Z6Nkk4bklMTGRmRVFkYXhlVDMvd1xyXG4gIDV4K2gxcFptdXYzMjY4WGloY0RhdFgyMGJlc0crc2ovdTVjKytEZi9Rai8ybzk5aW1pOU9WT0ZBdWprS0UzeWw3dkgvQU1lT1pDS29cclxuICBVcjF5SnBQSVNieVNrZXE5R0ZUR0ppMERrTnBFcE5zWTFDNUlqSklvbGFabEF5Skd5TGlNZ05yakRXbGpwNTlLSEFjR3c3dTMzVVROXHJcbiAgWFhpdlN2d21QK1NnNlJ5UWE1S3ptU1JHSHFyRThVaTFOZXhBeHVqY3VRdTB1TERJRjE4RHRmYnhuVTRtbjAzZDgzVGc4Yzl3cTJPSVxyXG4gIFptZG5KSjhsdHE5dmJxRjFXL2JSVE1NYW1wNTNjL09RTHQyTGgxZmxTbDhDUytEU1ZVd1FHNldHT1drc0VHRldJTUxMUnRQaUlGMjhcclxuICBlRUdtWHJkM2RWTmpGMTdXVmJRdkJFT1I2c1VPSGtYS2JIaGhzR2Q5dlU3MTVwdVF6cTR1dm1uQ3N1YWNmMlozZUpVQUJ0eHhkc0dKXHJcbiAgNEQwMWVJWUU2Z2J2U0Z4SU1VMHQ4dnpKNnZaNm1oNDhRZlUxOC9KK203bXBZZXBwWHFKZG03dnA0dmlTakkxZ1dSOU0xd1h3L25nOVxyXG4gIE96a1VaeTJZdVhDSTVpZkg2YmYvKy9mU0QvM0ViNHZaRzE1L3N5cGZBTHpxVlh2RkFYN3M0NStsUng1NW1yN2g2d3RtcUgyUkFMVlpcclxuICAxUTdrUzhkNVlHczZpWXhtZUwwWGdUQkdTT3dqTGlOUVF6T2paMm4wNUdQeVRnS0grcFl1NnR6OEtwbFpsYjR2SE9BY29xeUJiSzdLXHJcbiAgWm93OFdJWnZvZ3EyN1hXajNBTFJCVEx4Z3FZMmRpRDZobS9GcXJwK09uYmtPWnFabVpJVlpQRWdYR3RiRzIzWnVvMmFWbDlEczB2dVxyXG4gIDlhQWh6d1JPek1FZGtRS3JDRWtDRGFXSWJDUEVVcTlaWG5DWmlQUFRNSFRtV1pyQ1E1U01IYnQyMDNSdFY1RlpHbDRLRkpXaktBaUtcclxuICBGQzVVajFOSG5wS3V2WGsrUGozYmJ6RXBrTW5QeUlaMmRpUnIxSkhBaWFEVk1NV09CSUJPa1Vscm1HL3NwQnV2MmsxVGMwczBPVFpJXHJcbiAgUzdPVGRIRndoTTcyOTlPdWpkMjBZMzBublo5QWEyUzM1SXNBcDZJNTJSbGJrRFVjQ1BEclAvdWQ5QlB2LzJGNjE5Zi9LTTNQemIrZ1xyXG4gIFR1U09OOTVDQnc0Y3BYLzR5TDF5OC9hbU8xNjRzWlovUytDd2xmWUs2aGpJVnNJNldMbUsyOWRjVm5Fa2VvNzFxN1NQbk1RckdhbmVcclxuICBpMEZsYktwM0hyRU53THJJemtQSXdLZmxBdksyaVpvNVRNRWRPL3NNSDhVd1BnREgwZHE3VFY0aG1zblF3TElrNjR5Tlo4dlQ1aldwXHJcbiAgWkczREtYcjZxV2ZaS1RUeFRVQW5kYXhucDdCUVQxZHRXS0RCd1VGZGhtUjZtaThNTEsrT0taak50RzdITFRSUHNlTW9nQmZuU2wwQ1xyXG4gIHM2cktPRytVa3l3dnVFUlV5Q2RTdGM4Y29rUDJxdUQ2eGtaYXRmZExaUEhFTXBUWERveThzdi9wZTJXUUcrK0ViMWtkTDF4WUNTR2ZcclxuICBxWFBQK1NtL2tLS1ZnbkdTUFBMNzN0UXdTUHNmKzV6UTAwc04xTkRjTEcvajdKL3RGUm1tNlk1ei9xdjMzU0d2MVkyaHVlbDJkTCt1XHJcbiAgWFJVL0IzTGREVjlMVjErMWkvN3FMMzdaSkM4TWR1LzdLanAwK0FUOS9ZZCtqZDc1TlY5ODV4SXVqZncvNFNBT1pKcytSQmhYeXA2MlxyXG4gIFNpUnNOTmF2MGo1eUVxOWtwSG92QnBXeDBWMEdpOWdtcWNyaWNncFk2MFd4bmQ4STBuSUJlZHRZTGU5MzVqc1Z2SWZEQWZQZzIvaHVcclxuICBxbEVjQjVCa3lHQStJMHB6WlFpYlRRZW9MUGZ6aW14WnRLN2hMRDMxMU5OaWp3ZmQrdnI2cUt1bmo4NmNPa1ZUTXpPME9MdEF0WTBOXHJcbiAgOGd6RHVvMGJaUnJ4MkN5Y1IwRitnQmZuU2x5QXlHSlo0N3hCVHJLODRCS1F6d092V25YTDRwZnVZL1NRT0dDOERLdWhvWUc2ZHI2ZVxyXG4gIGozSGU5dkpLV0NsMStlVzZIQzQ5WlFFS010dTJhcEVlZXVoaFdweWNvSFZYWDhxaWtzQ1NkQTJPbjMyV1pnZU95NUdvYWV1bDd1MjNcclxuICB5bkV1L2cxQnVtYXBuNTdmLzNuajFKSGcvSVlqMlg4V2tpVWFPdjRvTmJSMFNzc2tDK1EwYW10NFpSOGsvSlp2KzBsNjdQRUQ5TVRuXHJcbiAgLzk0a2w0K1JrVEhxWG9VcHZZdDA5dVJkc2dUS0Z4UHcvNVNmVitaQWtpVTAvTVZpRlVuWWFLeGZwWDNrSkY3SlNQVmVEQ3BqbzdzTVxyXG4gIEZyR05UNW16WVhEQ0lJbDBtUXMrTFJjUTIrckdTZkMydjRueno5RUNWellPbUtXRzlZR2FNSWhuOW5td0xCSXJtUk13SXBrSHkvU2JcclxuICBRVWJpMlJyYTBuS0JIbjMwTWVHd1RoWDZYR1UySGQ4NXl4Ty83RlNhVzFxNDFYRXRqUzlpcWV4ODdvSW96eEtMQ0dheHJHR3hRU0l0XHJcbiAgWjVZRkh0TFVoUjN4SU9VY3pVK1BNVjBqOC8xbkp3WTQ1b3UwSnB6MkRhM29wbzNIcHNweDdwbC9sUzYvUmo1MjExMTNQWjJhN0tHRlxyXG4gIHVTaytMK3hHZ3ZjN3kvdEhseVVtVGVDdGYzanVBZThseC9ISHZwcnduTUpMaXVXcTRVdERIMW9Bano4cHgzYmRGYzZCWEhxdXVOYkdcclxuICB1WFcvT0hwT1prWGhWUVU2WTZ0U3JxcFpYWHVSRGozNWtOQXhycmp1VmpvejMwdmpmQTNqSE9sWXQ5YzBBVzRSeUtJbjBYLzIvUitnXHJcbiAgMy9ydHY2SXpKKy9tNnlwdHhWd3FIbmpnY2JyOTlkOUtPM2Rzb0VNSC85bWtYeHpBbFZuK1gvQkYxZHl6WFZvZ0NqYVhhOWtxazdCUlxyXG4gICtBcmJaQmw5dUZOTDlaR0ZWem5pMHB5SDJnU0pVUkpscGJ3TklrYkVSQTVvWVc1YVdoeDRGYWdIVnhJdGZkdDBqRU40djRsZ2ZDU09cclxuICBmN0dnTUIyZ3NveS9ZeFNsQjRKOFM4dUFMT2VPWTY0T1pGRWNCd0IrMTY1ZGRINXBQWE81ekJWUm5pVVdFY3hpV2NPOFFTSXBaM0pBXHJcbiAgaFl4M28yQ1plMXBDOVlJSHdyVFBYR2Z6WkxCczJmTElKdG03ZXBvKy9lbFA4N2t3UjgydHJkU3o4MUx2c29sbTJMSE1qdU5aR3o2K1xyXG4gIDdNemhjQllYMkRHeHMvbENkRERWdUlHNmlTTjArc2dSSnVwbzNaVjhiQW9UVlpOVENneXVUL1lmbEdtLytFOWExKzJUcDhjZGluTmNcclxuICBvcEduZFZuNTlqVmI2T0s1YzlSY282M0xLNis5bFU0djlNcmJPNGVQUDBLcjlyeUI2aHJEbFBwS0RnU0FFL21abi90ZE9uL21QbHE5XHJcbiAgK29YNXIzN25BMzlEMy8rZmZvbmU4MDN2b0QvOVk2eWQ5Y1dCNVFmUlczcmtCSmUvenE0b3FWS0VOZ0hnSzF0djVEYUNMM3puQWNJWVxyXG4gIElYVVB1S2l4NXM0azM3RmdyUitIcHU2TjFMbnhXcjE3aFNCc0lqQVBVU1NPZjNIUVJUSVBsdUdicU1Ca2JJWE55enZxSnVqOGVYMFNcclxuICBIYTJQaFFVZG8ybnJXa1VidDJ5bndScXNocHJKQy9CWm9hUkphUXRneGo1TkVad3lHT1FrNVl3NEN0elJ6NHljRlljaC93SHU3bHM2XHJcbiAgNVowT2FGV2cwb1hUd01KNENBS1hEWWZGeFhrWnE1TFgvbzcwODUzbkhMY2dKK1RCVHVRUFFJZFZaVkdwNEVFMGRHVXRJTXhPK1REVVxyXG4gIGY1akdodHdOQkxwYU1NTnRTZEs2VndwakFCbjAxT0JKc1FKZDc4b1VBYkltY1JaY2R2eUd0aDZoNjdraWczT1praldoc0ZZYThqb3RcclxuICBMMVNxOVRkeUx6YWlnMmZCblF0eGlMR21lVVJXTHBpZG5LUlZHelpRYll1MXhuTUpjb0psNFdac29kVmZ3NjNKQlRoZmpwdDc5Rlc3XHJcbiAgeFRueWpkT2FQUkpxMjlaUVQ4c2lqWTdQVU8zU0xGMDRkNHE2MFZ2YnZVVzZzVVpPUGNISGVjTGZnTGhCOVAvMlU5OHJjUllZVE1lK1xyXG4gIDN2SHZ2by9lZk1ldHRHVUxic1F1RDdmY2ZEVmR1REJFZi9qSEg2YTFhM3JvNXB1dU5zMFhObkFjeW04SnVNbmQzSU14a0FiLzcvZ3FcclxuICBKYTdackxLTmpOeEc4TVhoUEF4QzZoN3cxajhzcHg0RFV3d3hYdUFHNGZMbGRHQlpKSTUvcmFCU09teHpxcUwwUUNvSGQ4TVdvdWVmXHJcbiAgUDB4SGp4NlZZNCszQWpZMk50T3FWYXRvemNidGRHWXlmWHBYRU9XWDJWTUJ6S0tpWVY2WlNBb1lWT1o0VWhsZFRxRTFVYkRzaFNCa1xyXG4gIGdHNGl4eUlQcEVFL3VuWkwxZVR5U0hZdHlFdUtNSGpvYnByaENoSXZqc0xUL1F0ZDE1aW1PbWlyWTBBbVY3Z3VNMWZlcHFKV1V3WXpcclxuICBiRHM3UHNUMjNSSjNyQ3NZWEY3NURmNWxRbmM0ZnZaeG1zSFlHanZWVlR0dUU5bXl5SlYxK2NMamVHSFNTczNVQ09GRnlYZ2dGOTNIXHJcbiAgZ2loNVVVNTlkSTZlZS9ZQTFTK00wL1JTRXpVMjFOT3JiM3MxUFRmVVRPTTJjSS9uUjVacmdUajh2Mys4aC83ZE8zK1EvdmFEdjA1ZlxyXG4gIDk3VjNtdlR5Y010dDMwZ1BQL0lVUGZIb2gramFhL1BkYTE5b3dKVlQvcTg1QjJKaklLSGlqaTg0cHVYcmRINGp5RGtQZ0dXUlJhUlNcclxuICBRcE1FaTlpbWJEL09Ka2lNa2lnanpaYmZ3V3p4eWxoMFYrR0pWb2U2eGpaNS93Rml3RXpkSmdPV1JlSmNsYnhNdWxSVFlDZWl2QnlTXHJcbiAgUGIzamRPTEVDUm9jSEtieDhYR3FyNitYRnNqdTNYdHBwREg3QWgyRDVWZXdwd3pNb3FKaHFzeVplZ0VmWjFTSUV3T0VwVnl3YkgyNVxyXG4gIHMxREFIaTNDK2VrUmNlRDF6ZTFVeDNmbWRRM3BRbnRaNUl0YkkxMWZjRllPMm9xWWt0WUFXamhGR0R6eVdkYnArMDllOWFwWDBlRitcclxuICBic2x3dXRvR0xZdEROYzZnQ09vZ01HYkM2Zm1xeEYyeFBMOVRDTDFzeC9vUHN2MXFuMjVGM1YvbFYvNktzSzFubWo1NzMzMThkOVVnXHJcbiAgNzRTaHJsRHhWYjJMbkdIbGxLNWJDNmpsbG1qM3p0dkRXRzBtYWN6dVc3MUlUei94SkUxd3F3NllxV21rOWV2WDB0WFh2WW9lK1B6elxyXG4gIDBuSnNtSnVReFJRUFBQejdZbE1KanozMkxOMXd5N3ZvMTM3NVIraEhmdmlGZVNpd3FmVm1hbWxwb09HQkIwenloUXRjVytYL0ZCeElcclxuICByN1ZBMkZRdXhHemxxMStsSlFwNlNlSFpvSTh0c25wTkhpeGlHNSt5eENaSWpKSW9saVpHakloaEV0MGE0LzBIYUhFdXZJZkFEWkRIXHJcbiAgVDhuS05td2lNSjhSeGI4MmtObDBBRnZteExuTURLbmNjZnRXVGNxN3lkRjF0YkN3eEsyT1JwcWRuWlYzSzdSdkwxaTh6UkltWlN5RVxyXG4gIE55eEJYcEZJakZHSE1TaFA0aS9PelpRNmpIbXVsQmU1TW9kendaUExHQi93NHhxbFpWQklhMFNnRGdyZHIzRDY4YlROUzZuZ2E0WWVcclxuICBseGxzOGlmeFhmYjY2NzdTTk9WQWl3TkFPWHo1R2E2eWI2eHk4RjViTHBvR2NkdXFIZng3M0hUckZGTkRaK1I0emJHVGJlcFl5dzZ4XHJcbiAgYU8yeXlwV3pvQW9UaCthWlkzVDBvRmJtTjk1Mkc1Mlp5TDVESTJSV1ZiWTVvK0pVT0U5R2p6NkVBeVFXVFh5ZDVwWkZLU2FwZC80TVxyXG4gIEhUMmdrMHltbDJxcHM3ZVB0bTNiUnVmbVZ0TzVwejVLbTNkZFNSdlhkdEJkSC9rMWF1MHFPb1lCazVOVDFOWjFDLzNNVDMwUHZlK25cclxuICBpN3U5Vm9MSEhqdkFUdWsvMER1Ky9IYjZwLy8zT3liOXdnUXV4K0ovQi9BT3BGR3YyN0RSV0w5S1MrUjBrSGdsSStoamk2eitwWEllXHJcbiAgaTR0emZFZHppT2E0d29yUjFMVWhlcytBMnNzMmJDSXdING1VekFvaTNzTXNjNnFNb0NDOTQyN2VYbWV0amtGWmptUnNUQjl5dzJBNVxyXG4gIHVoVXdoYmQyYmJRV2xpVjhzUjBISEFBcVNQZXEyektIZ1FwV3hodTRJa0RYVlZ6WkNqSzdjVTVDQjZGRHZubkhrQytmVk9vbWRwVXlcclxuICBvRE8zNXNYWnlCcGxtYVNEUi9YNUFscFlwT2EyTm1wZGY1MTBrMkc4QkxPdEJFdUw0aUJsdk1KYVJkVjFUV25YVm5QWE9tNFZ6VW0rXHJcbiAgeloxNGdyc2NTRE0velMxTWJ2a3N6RXh5U3dWUHcrZUJGZ3BXUUpnZU9WZmM1VldJOGlxaFNEWFYveGpmTGZPMXM3UkU2NjkraTBuTFxyXG4gIEVES29zSmVBbkZFKzFjU0ZJelNGMlZwTTQwYWhiKzhibzRrL1poOGxjMlFmbmFValQ0Y3B2MHV0bmJSMjdWbzZmL1I1YXVydWxadXZcclxuICAvWGY5Rm0yL01YNGdzaHkxRGRmUSsxNGdKL0o3Ly90djZYdSsvK2ZvRjMvdUIraS8vcGZ2Tk9rWEhuQ1o1UDhSQjNFZzI3bko3c1pBXHJcbiAgM0ZYRnNYNlZsc2pwSVBGS1JxcjMyNHorcFhJZTAwTVk1emhobkFMcmY4bGloekw0R2VValpKS1JnV1dST0ZjeEw1TXUxV1RzUEZ0c1xyXG4gIGRlMkdSWHJ1dVFOMGl1K084V3dDV2gxNFFCQXRFSFFmdHJTMFVHOHZYd3hkVnlkNVpmYVNnV2xMamZJS0o1Rld4aVNlK01YZ2RuSGxcclxuICBLVGFGWFZkUnZrYWlrc2NVV1F5ZU96dmtXMVMwbWVnR0lIWU9EbFcxUElveVp1SFpKLzZSTDRkNkxzY2NYWEgxMVRSY3Y4TjB5d04zXHJcbiAgeXFqa1habXdqRDlhOVk1djZ1QnlGVnlGcnVVaHIyQzljRmh0UzV3d01NYXRaMHdsbnhtL3dNNWluMGtERnJqVk56bUFjMzFSK3ZxclxyXG4gIG5ib2NrQzlrVjkwSUhYanlFWGtqSThiYTF1NVo2VnNaUTU3bEZaRWhNY2hiRHg2OGwycXNOZExvV3lNT1poOGxjMlROeGNkcHVGKzdcclxuICB0T0JFYWlaSCtjWnhBNDBNRGRMM3YrZHQ5RDgrOEhPaVd3NllRTEZwNjV2b3U3N2o2MTRRSi9MZTcvazUrdjAvL0JCOStwNC9vOWUrXHJcbiAgOWdhVGZtRUJ2YjI1ZjBMdkZ4bnNRRnJZZ2VnWWlMdXlPTmF2MGo1eUVxOWtwSHBuNGNTT2VDbWNCNmJqeXZzSm9uNXdBRzhCYk83ZVxyXG4gIGFGeVVqNUJKUmdhV1JlS2thdlprY1RyTk0wWkdJR3dxQzF3TlhiKzFocDU0akUvKzRVRjJHck5VWDE4cnJRNmN5SE56ZkhjOHozZlVcclxuICA3RlIyNzk1TkYydDF2YWJjTGhPWXR0U291Q3lwMDBBRmw5cEJMN09hMkFrMHRIU1pqVU93aFZQQjNUZGFBN0RKT2dCWXpreG82Mk54XHJcbiAgZmxiR0xEQUxEcmlrY1FmT2NHYk1kWGtwOElBb3VxZ2szMmdzWlBEUVoyUjE0bmx1MFYxNXpkVjBhcWhHeW9BNzNRYjMxa2dHbkdKZFxyXG4gIHc4cWZEMEE1WXFjSHVuWFZkczByYzRYQ1VjQkJ1RmlSR3VFY0dEK0g4UkhOcitqNGpQVS9MMDRSclQ3TWFyc1V0TThlcCtlZjErNnJcclxuICBtMisrbVU1TjhySEkxU2pWSWlSY05vdkVJREI0MGh4UHMwT0M3cytlWGJlcndpTktHSkU3ZWlicDg1Kyt4emcrL3R3S3hZT2kzLzMxXHJcbiAgYjZRelExUDBvUS8rdW1tV3g3NnJ2cEsrL3QxZi9vSTRrV3V2LzFwNjl0a2pORFA1cUR5NzlZV0dHcjRIeWYwVnpvR2cveDh0a0pxNFxyXG4gIHY1VnJQYjNrN2NLWHlFazRObkZXN3l5YzJCR1g3endpdVpDQlQ4c0Q0S0xudTdEenowbEZBWlg3OFZoK3BHUEQxZEZkbVNhVWJkaEVcclxuICBZRDRqOHVVRkN0TUFtaTdWWk93OFcyWlZRMXZiUitqYytiTTBQanBHNCtPak12dGx6Wm8xdEdIakpocWE0N3VvOFJPeXFCM2U3WUgzXHJcbiAgZUV5MFZwclJZVGxuaWhHUUw0ZTJJdGhwdER1bkFRUTcxOHJRTHFtaXUrWXdpQzVUb2ZtNFp4M0dMRHNMdk14c2V2U2N6ME1lMWx3R1xyXG4gIDBrMWxRRVdzQSs0ZHpJWHl5VjIvUitrUEYyeHVPVThQZmZhejhud0QzMmJUbSs2OGs1NDVIeS9GbndlNjdmRGJBTzhZc053Tk95WEhcclxuICBwMlVvQm16aFhEQnVORDE4SnFTTHJscjNlOUVGaUdWclpDSkFlbG5UNU1WajFNanBwb1pPRmJaTzRFelFZbTFiemRmN0Nsb21ZOGNmXHJcbiAgb1BHUkVYbXdzbS8zRzFpUzdsZFFJRm9lSVZIRjVJa3lNQmVlL2hlcTQ1c1IxR1hOdWRZSUVDVTA4bXErYnp4MDZCQU5EQXpJZFlNWFxyXG4gIHFmM2hiLzR3N2JwcW44eTJHaDdnYzZCS1hIWHRWOHRiQ0MvWGlhQTdldFhhMTlIclhuc2pmZUpmZjEvK295OGtlQWRTNk52NDRxM3ZcclxuICAyeUhOYmNGbE9RK0cvL0VhWDc3ekFJeVNLSlltUm93YW1aSTdQWFRTaTkwcDFMcDZOMStnOFZ4dXRaQnQyRVJnUGhJcG1SVkV2QWZMXHJcbiAgOUJzaFl5ZHNtVVVOWGJlcFJ0N2JnUmxXODl4NkdoMGU0VlpIbzAzUjNVbEhoOVRaTjlYTjA0WG43cGZ1ckhYcjF0SFNxcUlscVMzblxyXG4gIFRCRUNVc1djY3hwb2FYVGtXeEhMT1kzZ2RPQUVGclZTTmVCWmpmbXBZYkVKenNMcDh3VjBsU2JHSURCb1hHY3Y1VXJ1dEt2OFhRNHlcclxuICBNNHR2TUhJWWVZNEdMMXhnQjFJclhZVHRHL0d5b2dBOHd5RlArVjhDME5yQ3pZdzh3OUxRTEJXOE9vbHlSNGxqT01OT0ZUTzBKZ2VPXHJcbiAgVThkNlczT0tXeDJBT3pad1BrVXRGRHhQQTRlQ1dXaGx6Z1QySGV1eWxXNktsdm9GT3JIL1Bwcm5jNnlHNzliWFhWazAvaEgyNjFFZ1xyXG4gIHFneE5zR3l5eEFBdHNPZG9tZ1ArYlRnUlA5MDNRWlRJeUwxcjVxUkxHQzhNV3h3Yjh0TjVNY2J4OUJNZnBpdXZEQTh4VnNMZUs3K0tcclxuICB2dUUvdk8yeW5jaUREejVGdDc3MlA5SlAvZVIzMGZ0LzV2dE4rb1dCeElIa0xpdStLT3E4QTJHdGZNMUtvcEFpTjEzWDlONGlxMmVrXHJcbiAgM3BUcFlLeGsyQmpVSmtpTWtpaVdKa2F5MUxON0d4cCtwMnRob1luYnZ1NEsvbjN4eGE4SlE1WlJSZ0xtSTFIMEN4V0ZhUUMyekltWFxyXG4gIFR4dTRHdHJkT3lYT0ErODR4L1JjcWxta21hbHBibUZzbzNPTG04Mk93WWxhMklHY2ZPcHU2Y3JBR0VqOSt1eEFvT1djN2k2Q0tqQ29cclxuICBPM1h4YUhBSzNsNkp5azREcll5THBsK2xEc1BTejgrT3k3aUdjeGpRNVl1aUVsU0lTd3Z6TW1VV0xVVWM4eUlIRldlQTM0MjhBYXp5XHJcbiAgaWtvVHdINmtCUkRkL2RmV05mRzVVUDVDcVBQN1B5cjVvUXNCejMvTWRWOW5taFJ6a3lOOHZOUUJZUiswaEhLdWtqZmN1ZjFxYTZ1K1xyXG4gIG9vTndtQm03UUZpZkMybndJQ1ZlamxUMk1PSFkyV2VwcFhlelRFTU5Ea1V2N3JIK1o2bDl6VjdPNzV3TXFDdEN4WW11TVBCWlo0SkpcclxuICBCVE9qRjJsdWVveDErUUg0aGJIVE5JWUI3TEV4V3J0eEk5V3VLajR1S2NKK0JSbDJlV2lDaXNraUpjYURSbzU4am5EVU1DbS9aL2ZyXHJcbiAgcEJ1MUdKYlFvcTJkWS9UTXN3ZG8wNFpWOUR1LytnUDB4amUvbHQ3NHBtK2w3Mzd2dStuZDczcWJHaTJESGJ2ZlR1LzVwcSs0YkNmeVxyXG4gIGgzLzA5L1NkMy8xKytxcy8vMFg2aHE5L2gwbGZlbFRwUVBpdWxwV3FONnVvTnF6ZWVRQktMK3M4Z0FLYklERktvbGdhaktUeU8zOUlcclxuICArdWZ4Ky9CRDVjZnlIU3NlQm16cVhCY25aU2dqMjdDSndId2tpa3FxS0V1RGJTSXVTZ2VrY2tzcDI3WDE1MlNXRlZvZTZLNkNBNm1wXHJcbiAgWGFJOXUzYlRrVEhyZzdma0tKYzRrS2Z2Rmp1TWl6UnZmbzBxZzFFSlZJSEtGNjJDbHM2MXdnZjcwUFZVNURTY0RsTkkwVzBrZCthV1xyXG4gIEZsMVNzY01Bc3NYQXN4QUFLbjA4Z1Z4cGJBTmpJUE96RTFJeEE1S25aYWdWZERiM1M4UFp4ejdNTFlSR09lN1hYWGRkNHF6REhsYStcclxuICBMemlJV2E3ZzNMRVF4OFowSmVlaWFaeER1aENjUlFad0tOQ05uZEhZQWVreGN3c3RrQTYrZVFMd05MM0QxUEJwZVpBejIzSVo2MzlPXHJcbiAgbkJmZTh1ZHc5dkdQY2FzTXYzdVIxbC96NVNwY0VjSitCUm0yTW9KeHhXU3N4TGpheE5sbmFHYmdtUHhMK1FIMkxDeEhqcloxVDFKL1xyXG4gIGZ6LzFIM3FXUHZJUHYwVjN2dU1PK3VtZitWL2NHSzJ0MmlsczJQd1dldTkzZnMxbE81RWYrL0ZmcC8vNTIzOU5qejN5b2FwYlFTODJcclxuICBNRXdvUnd1OW5ybExRQnpJVGhsRVY1MVpSTFZoWEdISCt0Z2lxLyszY0I2emZNYzJ5WGZPK0hrUStWWUhWMHA2SjZkT01VQVoyWVpOXHJcbiAgQk9ZalVmd0xsY3phQTVvbTFXVHNoQzJ6WUlxL0d4b3YwdkhqeCtXNFlXb2hacnRzNUR1K25idTIwMk51QXBubDQ5STIxUzNSd0tGUFxyXG4gIDA5VFVsQXlrOSs2MTdvV1FlUWFxUUxNZmpzSFA5akY3ZFF6b3ZpcDNHcXF6Q2g5bDVZb09EcVMyc1ZtbjZEb2R3eFVEclF1a2IrM2JcclxuICBMbmZiWlE1RDdkUlJBRkxSZG1ZcjJ1SWZWeVJkV3VRV0NwY1p3TTBGS3VQYWhsWjVLQTMyQ05EM05FN0lzWGQxeXRadDIyaGt2cE5iXHJcbiAgUXVxMEljYWQrcnl0a2RaZ1l6UzFqZHlxc1c2MUdKYk5zcGc0ZjFpNjA5UlJWSFlzM2xsSW5PK1NncU9kSHUyWEZsL3NUQmJuNTZRTFxyXG4gIERma0h1Wlp3WnBRZEcrOXZtcStqMEdwUllOcHNWLzBVblR4K2pBL1VrbzUvN0xuRHRKZUt6SkdwOWtBSjFMaGlFbGFpcFRWdDd4cHBcclxuICBXYjFUSGd3dVI1UWJrOE5QL3pOZGNkT045T1l2dTU3ZS9McHI2Yk9QUGl1cWFwMUNlOWRyNk1kKzVCc3YyNG04OFUzZlRrOCtkWkFHXHJcbiAgenQ5dmtwY1d1RTdrU01YenJEemdRRmJ0NU1vMjBrcWtkRnhoQjMxY3RlYjE2aGVjTU5VSDBsTU10UWtTb3lTS3BXcUVod0FuK0VSQlxyXG4gIGQ0ZlR3bm1nRzA2WFdzY0FvOW9HS0pPV0xVWnFILzlDSmN2VHBKcU1uYkJGRmliamFFdnJzTHcrRmQxV1RVMU40Z3p3WE1lRkpWMEhcclxuICBLSmltK1FCMWcwL0lRRHF3OXBxeXQ1NjVGc1VnMzVYdERya1lnVzRaM01GbG5RYW0xazRQbnlwMEdyNlZrUmtrUnBiT1lXQnFLdnIrXHJcbiAgaXdiRllhTlBoay82dkgzbG1mdVoyVjllSTNmWnJxdHlYdTd3OGFRMjMzbHpYTXZHRFJYdThMTllPdjh3WGJpQXJxUVp2aDVxYWVPclxyXG4gIHZ0bzBCY2lWalk4Zmx3VlhHTXFFQ2hrWEc4b0dIdVhRM3hVcXEwRGxJYTBQeVllZHlsaGM2YWRZenFGQW5uVkkrRDl4VTRXWmlWbG5cclxuICBNbllXWFZ6a1d5V1FObzBkb09OSGovRzVNVWRiZCs2azJZNUtsZkZLa1RrS2xRNUtnbUJZbGdUUHpnd2V2RWU2dExDMDZLcDliK0xXXHJcbiAgWmFVSkVWRk9UTUtSQVAvdkk3OU5Eeno4ak5EVk9vWGFoaHZwZlQvMTdaZmxSQ1ltcHFpOSt6WjY1MWUvZ2Y3K2IzL1RwQzhkY01yTFxyXG4gIEVTcHpJUFhzUUtRTEN4QUR0WElWdHNJSTB6c0xKM1pFcm9LT0hJV3ZCaExud1dBK3RncFJMR1dhdjlQY1JKM2hKamlBaTFUWGFPVzdcclxuICAxYzUxMUxwcUI5OE5XenZMSjQzeUVETHdpdGhXRVpkR3lXd2FnSzF5NG13NklEVlN6bVFjcmEwN0owK1ZvOVdCN3BPMnRqYmF2bjA3XHJcbiAgUFQ4VUxSakltelNYZ0w3RjQvVGNjN293WE44VjJaZlZxT05BZHdabUtjVjU0TTViV3hRWXQ0Z2Roem9JdEZ2VkVZdEk4dkZPQXhWK1xyXG4gIHBrQ3F0N3RvNTJ3aW83aDFrYTNZQkd5YVpna25jVkgvWXl5d3lHV3RiZTFoNTFwZjRCd3loYWtDOFJFOS9kai9wU2ErdzhZYVdDM3RcclxuICA3ZHlTZTZ0cExnZHA5UVluZ3p0K2xIMmx6bVhzekRQaW1PQllkTnB2ZmxrWHRCalFtbEhIa09aUzVFekd6aDVrWjdHWHNHeE1HSE1KXHJcbiAgNmRBcXdYN24yS25XTlRUUTVzMGJhV2ltbGZkdjc5MFhGSlgyVXBESnArcHMxYkRJSE1kaTlPUVR0REI2VHY3cDVidTBBTXVKbzgxZFxyXG4gIFU1ekpGTDMzM1Y5R2gwK2VrL09qV3FkUTAzQVR2Zjk5MzBFLzlkKysyeVFyeHdmLzVtUDA5ZC80WCtpUC8rQjk5SzNmOGpVbWZXbUFcclxuICA0eWRIcHR5QjdKSzdkMVdxaGF1d0ZVYVkzbGs0c1NOeUZYUlV3L29MdHNBbXRncFJMTVdLcGVNMHlSZkNnZzJTQTNBZWNIenRmTmNVXHJcbiAgQnMwNG5VOGE1WkhKVXhIYk9qSXJpSGlCV1NYaWpFMUJ1c0F4eGQ5WGJTWjY3dUFobVVHRkpkaEhSa1pvMWFvMWRQWFZWOU9UWi9qdlxyXG4gIHNnVHgwVW1oOHRVMXArbnc0YU15QnRLNE1UeUpqdGxHR0pSR2hSL240THAweEFsNFdLdENIRXB3RU1nRHE5ZVdPUTBJRnJCeUtsK3NcclxuICBXYWNCaDRIbmNMUmxrM2NZWWhVMlVxRmlhWlBGMlFtcVoxdjh4OEZSNUhaY0FaR3RrVUZTbk0vcFIvOU9wKzh1MVZCSFp5ZDE3bHBCXHJcbiAgVjAxU2V5WE1NZ2kyNDF4Um8xdk1PY3RtTnlabE50bGNZNGRTMUVKeERnT3p2dXFiMGxXQ29RUGlkQmhEQVdMWjJ2cXo5TmpERC9IMVxyXG4gIFZVZWRQYXVwYlhNMFFjTUtsUCsxZWNuS2tjbWpxaXpWcU1oMDlQUlROSE5SeDBWYTJJRVV6OUxLd25MaXFHM21CUFgyTk5PWDNicUhcclxuICBCb2JHNlUvK2FQbGwyTWZISjZtajUzWDBWMy8rL3NzYURQK3FyLzVCK3NkL3ZvOU9ILzhFYmRoUWVkV0NGeE00ZG5KRWNKK1J1NFRZXHJcbiAgZ1RSNEJ4SmRhcDYyV0tLb09zdm84eFUwMDhaZXJ2T1lIanBPTTBOWStscGJIZWkyUUdqcVhHK3REdWRTT0oxUEd1V1J5Vk1SMjRMTVxyXG4gIDZDdWtTYVVaRzJHTExFekcwUlZyWnFUTDZsei9CWm4xZzNXczBQTFl0V3NQZmY0RU43b3RqelNYR0NHdjFvbERNZ0NJR1VSZHUxNG5cclxuICB6MVBVMWpaSXBXOG1nc25CRTdvMGVxYWl4NE4vZnV6Q2pPRk1aTGtQZVVxZjRUSmg0STRWQXJRRVVuQ0x3Vm9acFE1RHdCUi81WTZjXHJcbiAgYlJzNlZwbXp3QVVTN2FnUXBxOWdGbFF4bFVtUVljODg4V0crWThYdnFxWGRlL2ZTVlB0VnFxZ2E1UldZaDFkV3RQSVlQN09mbmNvYVxyXG4gIFBrN241YlVDOFF5eU5JY2w3MUFBN1M0TUZuQVltTG1GRm1oMmRoZGFqVmphM2prT2pLTmdpUmRNVEdrWU8wQm5UcDVneDFwUExhMGRcclxuICBWTlBjeHkyV3RQTEZPYmM0UDgwbUxRVy9xcnJmV1JsUkhsVmxwMFpaVXl6dlAzcnNZVG5QNnZrODY5NythcWFxeVZCdHJseTlRUE56XHJcbiAgNDNUVGxldm80YWNPMDZmdS9YT1JWOEl6enh5aHE2NzdPcnIvM2oraTIyOHZtbDVmSGVvYXI2ZHJydGxKaitNbTV5VUNMcGZTb3lVUFxyXG4gIEVySURpUmR1a3d0T0xqSzcwb3cyamtsSGFYeEp6Z01hejViWUxDN1N4Tm1ucFlKekxrSmJIUTN5d3BuRzZPbGdTWmZOai9HRjVqeFdcclxuICAxWnlTUVcrMFBJWUdSOFJ4WUlHM2sxTzlrVm1hUjBESXg2RjI0R250djUrYm9XdXV2NFhPendmSE1jc3RBSmtCNUFmRkljMjBObXdNXHJcbiAgUTJUU1JXVlRjUUhiRHdaaDhTcGZkSjFFdXhiRXE4dkdUaVBZS1RYSDVZQmRQZTlQN1p4Rk5rZUFaUVZpRlJYWlI1Q2tzQ214eTRnM1xyXG4gIE5weWloeDU2U041QXlDY1diYnJwYTAyekV0amxWVVdkVkdnaXdrcUpsOFRoeW8zVDZIbXE3OWxzVDVWcm1qZ2xuRW5IaGlzNTNzK09cclxuICA0VXFUS3JCRU9xWUxaNmY1d3NtMDltMUx4Z242bi94bm1YdzF6MWZlVGJmZlNhZEgwRFZjWEVhTXJVbVhKNTdzQjlnc2IxbWN0anBFXHJcbiAgYWF2S1JvMWlVNXg3WThjZm8xcDJlQmdYUVhldnJJZTJiSVpCWHpPMG4xcWFhcWk3dllrZWZmaHZUVnFPKys3N1BMM2h6ZDlCeno3MVxyXG4gIGQ3UnZYL1hMNHNTNCs1Nkg2RTEzdnBmK3kvLzNIdnJ2di9CREp2MjNCUzZaMHFNa0RnVHZ2ckF4RUxuNC9FVm1CTmZDWGxTZ0w1dHhcclxuICA1Vk5KbE5vczV6em0rYVNjT3FjRGU2N1ZBZWZSeUhjUXJTaHY4aVF0cDh2bXgxaXg4eWkwQnpSTnFvazRUd1paUWhuVFBIR0Fob2VIXHJcbiAgcWJ1N1c1WWdtWjZhbFNWSWpvNXhaV0EyU1hrU2VJTUVDMmNmcFlzWHRWdHExMDEzMHRoTWpUME1PTUN0czYxeTU2bUoxSEhNODExbVxyXG4gIEs5K1J1bndnZzNOQTZ5VE9IT21kWTBDSWQxdmtOSUplS1ZSNDB4T1JUWEtPQUk3bk9LTlNObXZQRUZGZUhpU09zamh2bXBNTkhmZ1hcclxuICBtaGdkMVM0c1B0TTIzZmhPVlJTaFlsM2psRVU3ZFdDYndqemlTYllHRVJRYU01Wm8rdHp6Vk12SGRuYjRETFZ2Y0MwbXRYZXBKczRmXHJcbiAgb3BhK3JUVEJ0dG11TGpnVFFKMU0yQThlV3V5cUhhYmp4NDVUWTJNRHpjN01TTXNqMzFXV0x4dGFMcWhQa3ZxQXpmS1dlVW4xaU5JdVxyXG4gIG00MGF4R1lEQis3QkNTei9Vdk9tNi9oYXdQSS8xWlJIYmE3YlhFZmpvM3h1ancvVEl3OTlTR1NWOEs4Zi94eDl4VmY5QUY4TG41UEpcclxuICBNWmVDSC9yaFg1Vlg3SDcyMDM5R3Q5NWF6WE00THl4d3JFcVBVT3hBcFBMeS83MFJmREo0VVlIK1VweUhmWlgya2RKb0ZrOWZQRUx6XHJcbiAgWXpyNGhRREhzY1RsUlA4bHB1aGFLZ056WGhBMEw2VHp5TlY5eTZRTEhGUDh2WHI5dkx6SkRVKzlZcVpWWjJlblBMdlIwOTFIRjJtalxyXG4gIHp5UE5KWWJtRXdPdEJXQmR5NVFzNzQ3L29XUGp0Vkx4dC91dUJpU3lRWEdHYTIxZ2ZTZE1mL1pqRzVZNUZ1S2JHandtTXBXSDNaWTdcclxuICBqVkF3dERMbTJhYWViYVJMS3FnTUxNZ2N6TUpmTGFJQ3VVRGx3U1MxUzgrNzVYSHlvUSt5MzZpbCtvWUdic1V0ME9hYnZzNDBLMFVOXHJcbiAgWDJRRmwxa2lLcnNNV1Y2WU5DTVV0aWdQZEdQdHA2YldYbXJvWEJkZGt5RUgxekxCWUh2YnF2RE9HSXc5NGYvRVE1aDQyaDlwT21ZT1xyXG4gIDBjSDlUd3ZkME5KR3E2OTRpNHlIU2FzbnQvdWk4cFNBVFZQckZhVE5JVXE3YkRacTRNeEdUanhPczBNbjViRUdIVngzU3dCVlV4NjFcclxuICB1V0x0T0kwTlhLQ0hIL3diNFN2aFYzNzF6K2tEdi9kQk9uWllYNzk3S2RoMzFWZlR3TUFnWGVqL2xFbis3WUN6eVIrWjNIWEZkL0xOXHJcbiAgcTNaTEYxWTQ4U3lXeUYyU3ZIVnFKekc5SXRVSGxSY3kxRVlsa2R6MmkyY0VwczRkQkNHdERoUWF6cU8rdFlkYStVL0dWT01vRmNOblxyXG4gIHhnaWF0RndPc1MzSWhIR2JETmdxRVdkc0N0SXBaektMbXNhZmxSWUgxdDZCQThHeUl6dDM3cVJuTCtoc21xUXNDZEo4QUV4UmRNOE9cclxuICBBRjJ6eCtqRWllTXlXTjJEZWZwaXF3bWNrOGwyVTdXdTNpSEhVdTFjbDlaRm1ZemdBRTNxTk5UUmFNNjZSZGZXd3Z5VTZLR1JjVFJBXHJcbiAgMVF3bUlqcE82NUVlNEFnbWo5VHhjVklxVnVidEswTU5UMy8rYi9uT21jOHlUbC9INWQ5d2ZWRUxKSzVZbHRtQm1NYjJBU3FOZEo0c1xyXG4gIHR1ZGEzUWlIakVzUkpwOTI0c3pUMU5pNWxoWVhsN3l6ajlQQ21RQndLUEUrWEt1a1lXRllKblVzekV6VHRwMjdkSlhuQkp3bXQ5dDhcclxuICBPYlJMTkowYTdwSExJcCsrT2tUcGxzMUNEYkJGNjJ6ODdMTlN6K0JWdW0zcjJJbjQ5TXRscFByYjk5YlJNMC92cDMvNFA3OUNlNitxXHJcbiAgUERqL3MrLy9BL3JVcHgraXV6N3hCeVpaR1k0ZVBVMDc5bndGZmV0N3ZvTCsrQStyV3puNGhRTE9lSDlFY3FkL0RUc1Fib0dFcVlGbVxyXG4gIElWRjAwZnVFSmpHOWg2OElvc3M4cVJ5WTFxL1NEbXlEdTUvcHdSTTBQM0pHTkFqU1pjVjNSQmdrYityU2QzdEhxUmpNZVVIUTVNb2xcclxuICBpRzFCSm96YlpNQldpVGhqVTVCT09aTnhkTU9XZWpwNDhDQU5ERjZRbGxWclN6dDFkSFRRS040YWFPblRIR0t3SmxKNlorREhNbFEyXHJcbiAgM2Yra2RPZGhNTDV0Kyt1OEhJZ2RCK0NjanFhM2xnbVRRYzRzLzJpOCtoTkx3TGlGQUxXVW9UQjRNaHovV1VOelpuVlhITEJnWnVtVVxyXG4gIENsRmtJSWgxaXVLakV2OGZzWjdwWW5ORFVHYk50alNkb3M5OTdnSC8vTWZXYlR0b2FVM1pxMW8xZFZxMUdGZGEzeFFvUkpTWEo2N0JcclxuICBrMWs3NWhQUjhnNWxrcDBKV29QMWJlemsvUUdNbkFsbVpmRzU2WnpKbFd1bXVaTDdPRmNMZGJRNE8wc2Jic0FVMGpUUEJMbDlwcmFZXHJcbiAgTGd4MHJLK3cwQ2NuU1ZPbFhIV0kwaXliWEEzR3VUVTJ3UzAzT0pHbTNpM1VzZm02VE5ybE1scVNsdG5VK1FQMDdNTi9SbHUyUjBzTlxyXG4gIEZRQk9aR2g0a0g3ek4zN2NKQ3ZELy9xZEQ5SVAvTkF2MFQyZi9BTjVaL3UvRlhEVytDT1J2WWd3K05XQ1FYUS9nTVlXWWhSZHh2N0VcclxuICAwMWhacjJVd2JheFBsZGlvWGprbll6Q0pKUlVtc1JoYU5EMFh6b09hMm1VTksrbkQ1eDFHcVJnK00wYlE1TXNGeExZZ0U4WnRNb2dyXHJcbiAgS3lCalU1Qk9PZDZhK0tadGpmVEVFMC9JcXA5TDNJNUNsOVcrdlZkR2crWFozK1JnVW91S0hBZUFkYi93VE1ENVp6NHBmYXZJdjIzalxyXG4gIHE4VEVPUVIxRU5IekhLeWNuNW1nYVN6bXg4N0JPdzVPTXp1V3RqWjBUOWdxcGQxVEE5VEUrM1F2VWxLdzNzelVVcmRCNEhnSDQzMVVcclxuICBvSTlFU2pxQnhSSmwvNk1Za2FMVWhpK0tzNStpazhlT0NZMG5yZC93aGp2b3dMQzdZNjZRMEtHS3lrYWx2TTJwTXdKaFU1bXY1cjA0XHJcbiAgazZaQW4xaGtXakRqN0V6UWJkT3lQcDVscG1ta1ZjSk9kR05QSFIzWXYxL0doSm9iNnFuM2l1eDZVR3pQK2FMRm0xdXpLeXJId3R5a1xyXG4gIERWSXJ4czdxMCtFZDZ5dTg4SXJUcHlWT3Vlb1FwVmsyT1ZZcUdLVGhRNS9SVlRyNDNPL1phVGNRUHUzeVpVQWUweGVmcDMvNDYxK2dcclxuICBIVnRXMGE1OTViL3h6cmY5QU4zK21pc3UrVUhETjc3cE8rait6M3llNXFiRFM3SmViT0JLOEVjaGQxbHdCZFBNZC9uNkhuRFRKaFUyXHJcbiAgVTU1Ukl0ekpBRUh2VTBrVTJXVHpZeXd0TGREVXdIR2FHenNuanNOMVdjRjVOUFpzb1JZWjNHSWthUUhtdkNES1ZjalVNclVGbVRCdVxyXG4gIEUwSDU1T2RsYlRMcEVzcVlxOVl1ME9IRGgrbml4WXZ5dGtDUlhYVVY5Uy9vL1A3c0x3b3d1VVZvQ2VESmNZVUtwNFpPVXoxWDRPSlFcclxuICBjR3d1UE1iN3VjQmtEYjM1elcraHo1K094ang4eThLNnFkZ0JZSWtYM0YycXVJWm1SczRSRnFERXdMcnV3WlVOMDNKMVRBTlBlU2NQXHJcbiAgNzBVSEtEa1hoTVFta29IMmJPYVh4MmtGeXN2V05wRkU0ZEpFSXNlZ1ZUUXplbDVvUUpZZm1SbW5ocGFlakwzaS9OTWZZMTJ6UEllRFxyXG4gIEpkeTN2c2E5N3pvWTQ1eEVaWW14QWdmd3ZKSHh3eGk2NXRWcWVldWdwalI0TXBJeGxPTnRJazV0WXQ3Yis2akFOaEtsRGlpMXhYSENcclxuICBGTjVPRE1CNzFSTDFQLzFSK1UvbnA2Zm96Vzk1Q3owem9PK0J4ekx6YzFQRE51Z09MTW1nT1k1Vm1TUFJaMDY0ZFJNOUtZK1hYWlc5XHJcbiAgV1RFQjU1R1dPT1dXUjJTL1RGTDhEaXdOanc3WUpiNlI3bzBmeVBWcEsyZUM2d3RMQk8yNjRVMzAwVC84WnRxNkkzN2dNc1ZyWHZldFxyXG4gIDlCUC81VnZvSzk2eDBoZHpjU25ZZWRjMjNrRHYrcm8zMGQvOG4xOHo2WXNMWEEzeTYrTnJ5QjJPMnNaV2F1N2VKR3NFQ2Rnb1hPYkNcclxuICBHSlJZc2ZPQXhyTkt6RTBOMGVTRnc5enFtUFBPUTZZbzFqVlNHN2M2OUwwT0REWlBxeHdSUkZCRzgwOFVqTlEyeWFmTUh0dEVuRTBEXHJcbiAgQkZsQ0diTzNiNGFlZWVZWkdob2FrcFlCbGdhLzhzb3I2VGhld3NOSWYwK01rRWRScXdPRG40MytSVTFxQzd2bWFid1Q1S3c4U05pNlxyXG4gIFVXZG9aQjBIbHJEQXN1Q1NsV1JYUStObkQ0aGQydHBBeEduNGpncnZ1Z2o5NTR6b3dNaHZjS3pFTVdNMFI3bmZtaHpjaU03WUtnVmhcclxuICBaS05HTXFmZkFZNFBGZmJDOUtoVjJnNXhPa3ZqUk1qVDdzelBQZlV2ZktmTlo5OEN1dU9hcUhmM20wVHVBQWVCYzNGdVVsK3I2N0F3XHJcbiAgTysyN2ZJdFd2Z1hBWWI5WVlWY1c5R1RNalBhTGZWUHVWYlloclZLOFRiS0xtRXlyUXB5RUY4VzZXRzUyRGxFZVU2ZjN5NE9iRFZoelxyXG4gIGpNVm5uL3dua2VPdGpPNjVEK25lc3Z6UzJWdEFsSzhCUytQSWN5dW1DbzRFTTdtMEJUTisvaEIxK0p1akN0RGRSc2p2cnpJaSt3cEpcclxuICBjVk53ZnYvSDVQMGkvT2RTNzVWdkRqY0lTYnJ5VEhBOVRnNGNveDNYdnBiKzUwL2V5YTJSTmJSOWQvSDBYVHl0L3RBRGYwbzMzNXdkXHJcbiAgWDFvZUgvN0lQZlExWC9lZjZaUC8rbnYwcGp0dU5lbUxoeHIyckxsRGdNZW1jRlUxcjlwTzlVM1dseTBYbWJ1VWVlc3VPaWN4dlNMVlxyXG4gIEI1VVhNbGdlMmNqS3VSZVB5QVVwVFVZTEtBK21KT0tkSGY1Rk42eElLeUFSUkZBbUxaTkRhcHZrVThFK2xVYWNKNE5NS2VNdDJyZHFcclxuICBWbVpFWVVWZGpFbmc1VThZTUQ4Nmp1T2IvcHFBa0FkT1FBeEVoemZId1FFTThOM2dxTTJjWVNPend6Z0VuRUxiNkg0NmZKU2RTME1EXHJcbiAgM2ZIR08ranhjNWlPSGJkQ3VHS3dYU0FkNU1GeGhIMWoyUkFzU1k0SDBYeHJJNnJBWTF2WkJCVUR2QXJTWXgwYkdTMVJiS1ZVZko0QVxyXG4gIEdOaEdXZWVtOFNJamRyNHNWaWNSVWk1Z1R2L2tzRnpvYUNIZ25SMm9vTEVNQjlEY1pXdUpBU0daSjQ4OThDZk04SzBMZnpkdjIwSjFcclxuICBHKzgwVFI3bGRVaGdzRiszTUNIS0dzcVJkekpUY0dwV2tlT0o4czVOMXpCbGVtK21oTjltNUlMSUdWUnFjUlRhQVpHOGVlUkpPdno4XHJcbiAgYzFLQnRyZTNVNWM4a2I5RW8ramVZck9WT0JKMUd0Q3owMGhVZ1JrN3kvdGlWT3pXaWhBVmxaSHViM2xFOWlWSjBXSWRPUHdBTjVQNFxyXG4gIG5LcXBwUzU1VmlSNjg2UlBWNzV2bkllWUNmbWVyN21KM3ZyVzI2aW51NU0ycnV1akhidkR6RGZncWFjTzBiVTN2SXVXNWk2dEsrcXJcclxuICB2dm8vMFQvOTg3M3M2Sjh3eVl1SEdxNVNrbDhNQm8xUG9LbG5xd3lZNmxVVlhkaitpdFpZV2E5TjlGNmFyVEQwS3pSZWpvTW55cmxtXHJcbiAgOEswT1lKRjFUV3QyY1lYbWxtOWdTS0pNSlJNWWh1VnFkaWxTMjdSQzg1c0lhcDlLSTA3SUlxM0pMTHBpOVp5TWVlQWhRVGdQdEFqMlxyXG4gIDdObFR0ZlBBSFJuZVlSM0FyUVJ1RW1QOUhwY2FKNlp6SE1KekJidDA4Vm1aTVlOWGMrN2R1NWRPVFduclRSd0h3QWNKZGdod0d0bzZcclxuICBzUng1SXdzQk1xRlBnZ01zMU4xeFpBVGcvbHVKQXEwMmpyZFlFR3ljbFlJcHp3VDU5T2g1K1gyeUpBclhGRkxwbWhLcnpPSXVmdVRrXHJcbiAgNDFJeEErSWM0cXdFTmZKZWk0WHBjUm5qd1dLRXFDeTExVnhEOWV5WThYSXFZRVBEV1hyc3ljZWtwUVZjZitNTk5OUWNsb0p4d0hMM1xyXG4gIHMxRzNHSUFGSWh1YTljbndwcTYxMmcyNHlLM3BXdWtFOFM4dUN4ZWRVdFBENWxCWWp4WWxXakhxWEZRdlRnV3dtakxwQ2d1Wk1abVZcclxuICB4Y3BBaTExRm04aVZzT3pDL28vUzdQUTAwNHUwZS90Mm11eTdQa3Btam9TaEErNHE4ek82VnVCSVpDcng2bENoNHU0L3JDWlJCVGlmXHJcbiAgc0pkMGY4c2pzaTlJaXB0Y25HZHo3UHh4Szl0MUJSWmlUSmVEQ2VtSzk3MDBjWXJlL2RaOTlGdS85WlBDSDl4L1VKWTN1ZTc2cTZpK1xyXG4gIE1UeXdmZGZkRDlQUC84THYwejEzWGRyTXJKcUc2K25kLy83TjlNRy8vbFdUdkRpbzZFQWFPemZ3eFlZNSswVVh1VXEwWGdqYW9FZmtcclxuICBpTHdlRWl5UE1IbnhzRHhORGo1Mkhud1Z5b0NlZGdkWWVvbktLaHhBbVh5WmdOUTJ6a1hKWXZ0VUduRkNGbWw1RzRsMzkwelJzV1BIXHJcbiAgNURrUFZGWjR6Z010ajRIYVRXeVdwZy9RUE5BcUFMUnJDcWlSWm5COVUwZFlYNHJ0NEdCUThkUTN0Y3NLdG5pcFVQdTZ2VFIzNGpNMFxyXG4gIE9EUW8vMmxMY3d0MXlaTHV5RHM0RHUyRDFuTElsamZUZzZmNEJHeG1wMktPdy82L2VPdU5KUXF5OEp2QU9CcHdObVgvbnhMWVlza1ZcclxuICAzRlJnM1NldFJOVU8zVDdnUjA0OXdVNkRkZnliZlhLalVCRkRQbnppTVV1cjBJbzdXS1BmSGl4ZW1RdEhvSUNlYjFwR242UVRwMDdRXHJcbiAgMGp3N0VENGhyM3ZWcTJpb1Vic0FjU2NLUjVUSEVyVjBiNkFwNUF1T25ZOCtPNEY5dzZHRnl3eEx4T0I5Si9oalVLN2dQTlFCaXFWdFxyXG4gIFVFNjBvckJmSVA1TitJMWRtMTlGSTRpM1lFa00yMGZJd0VpVE96MndyRE5KWmFjZStYc2NMQzc4QW0yODZXdHA2alNlQmVIemFpUEdcclxuICBTYndoTzVMOUVtdUxoTUU2akcxZ3lSVDN6NGNXaWo2QWlPT1AvMEhBV1FYSG91TWpPbHVyaHZucVdpT0N1UGdSVlIzTXZpVFowUEZIXHJcbiAgYVc3NHRDei8xTEh2RG52UU5vSlBsOC9ndFRmdnBLczN6QW9kRDVZLzhLa0hhVzV1bmw3L3B2QU9kOHpNT24zbUxQMys3LzIwU2FySFxyXG4gIFhYYy9TRzkrNjN2cDNrLytBYjMrUlp5VlZlaEFjS29pYnNCcXJOMGJxZFl1QkxuQS9EV294TXJHUFZTUGhmeXdhaTc2ZmJFbjVPNENcclxuICA3dm13N0hZekJuUWxiMHNyVVZubEF5aWpab21Da2RyR3VWZ0NJUVBVUHBWR25KQkZXdDVHNGoyOTAzVGd3QUY1dm1NS3E3bTJ0c3FDXHJcbiAgaUJqelNNcVFRUFBReWxJckZHQjJmRkM2WlZxNjRYaE14bmZsWU56WUJ4d0hscHh3TFluYWN3L1RtWDUyWE13MU56WHpIZFBiaWgySFxyXG4gIFpZaXVLa0FkQnd0Tlh2eGZNcEJRdmhtWjhDWkw5TUlZZ2d6bkFSd0dXaEl0K00yaXFwRmpnTkM5NVFiK3JlaEM0OTlsaFJWSDBiT0JcclxuICBodmxpN3Q1Nm96a082NVppRTFTOExYenV3cm5pTGhIT0NJNEpNbWNUa0RBMDlPUUhhWGhrU0U5R1BpbHZ2T2ttT2oxajZRb0F4MUVaXHJcbiAgZW9rNTV3SzBzT01RbmxWYWJyWEJnNXlqcDU2aXpzM1hjdXRHQitmVitiR0ZtQ3p4Yi80OC8rWWIxSEd3QTFHd1hKem1CclpidEhOSFxyXG4gIDg5Ukk2VUpuVWVoTWdteEgyd1c2Ly83N1pld0QySGp6MTNrYnZPMFRiNG4wOWlZdmNpUUptTTA2RW0xOTdQQlpCYWdBNjZPRmhUbHpcclxuICBSc1ZnczJCWlpSb1BzeTlJTm5qMElacm44eFoxVnZmZU4xSmRzMDRvU09EVGhRemdRUDcyOTc2RG5jTUhxTG01aVg3OC8vdDIweEE5XHJcbiAgL01DajlNbFBQVUUzWHIyVjd2d0tIWFA3aG0vOEtkcTdaLzBsemN6NjZuZitaN3I3bnMvUjZGRDE3M0pmS1NvNmtEcStvMjN1MjhGM1xyXG4gIEJ6WXE0YTh6SmZSYWRzS2dMNnR3SkcrdTlQQnU4aVdacGNINzRBQUw1endhZXpiTHZHdEZtay9JaWVGcVBZSFNadVkyQnFZak5xM3NcclxuICAvQ2FDMnFmU2lCT3lTTXZiU055emNGTEdPeTZjMXk2TzVwWVdlVUR3QW0xZ3N6UzlRbVhpRkJpaDFZSFpWYWVrY3RVVkFheGx3b1MrXHJcbiAgbDV3cllLNzRjVGljNHdCUWdkYU5IWkV5Tk5RM2NOcGFxdS9aTG9PMFdPZEt3S2F3eG95dXB0WWVIZCt3bXdYTlJiZTVZdzJXWlY3cVxyXG4gIDlhS3dieVFUMHZFTXRsK2FuK0VLNUlEOEx0eDV3OTQ1REN5ejBpUmx0RFFjWVhCMTVDUXFURjE4RHJQRm9KMnl1M2NGUy9pYlZ1aWFcclxuICBCeXByYVJGdzVZcGpnMG9iWTJxdW13cG82VkVuY2VTK0QraUp1Y0N0aXZaV1duL2p0NGs4aitUUzhjQmIvWUJwanJHZmJOMEp0TER6XHJcbiAgOHhEOWtuY3dLUC9Rc1VmWVNhRGJUQk9QOGgxL0o5L3RUNXkzU3BibGxzeWM2QTM2dTZ5Rk1qMXlSdGEyd21xNjJqb0IyTmdsRW5BZVxyXG4gIGpuUXlFL2d0ZitkUDN5K3ZGWUFEV2JOK1BUVnVlcTNvTElWUG96RGFvdEV6MmxLSkhRbTZndlJoVlVPVVB0dXRsV3VOOUQ4bjhvNzFcclxuICA3dUc4a0xZaTJDeFlWcGxHRU5sbWtnMGRlMWhlWEljcnBxZEtKL0kvZitKTyt2ZGYrMGFoOFdiRE43M3gxVWtMNGVQL2RCYzl1djhFXHJcbiAgdmVhbXZkd2EwYmVJM256ck45S3YvZkovdXFTV0JMcXl2dnU3M2ttLyt6cy9aWklYRmpLSUhoOFgwSGpDRzhCeTZDMTkyN1dmTDZra1xyXG4gIEhPdGtqRWdmVkVHUFp6cW1oMDVJZHhVQURRNjhpM0VaTjYzYVNZMytydHZTV2o0aEo0YmZGNkMwbWJtTmdlbUlUWExKMlFKcW4wb2pcclxuICBUc2dpTFc4amNmZjhDWHJ1SURlN1VVNCt1bGdHL0lvcnJxQmpFMmg1RkVHbDZNL1B0anJtWjhZSWIrdHo2ZUJnOEt4RmZYT2JPaEpHXHJcbiAgMW5GZzVRRElaay9jUjBOREkxeFIxbEE5WDdCOVY5dnkwV3lLWXpHQkpVdjRKaUVzTFFLcDdjbDRoU1F3eXVqTStRRGVwM1UyaWM0aFxyXG4gIDZGQjU0K1lFZDh5ejhyNXVyVlRCbzlzR2F5L2h0NkNsZ1J6Q0hiem1vWTRpNUl6ZjdtTFhHc0Z4a0c3UVlNWjMrWE15b0JrTDBRcENcclxuICBOeEZtSFo1OTdQOVNmV01kelM4c1VrOVhGN1ZzVFpkd2wrc0ZqZ2d0YU56dDkyd1NPWUF1Uk5jdmptZHFtczBwaVhQS1ZDYVlkcTFPXHJcbiAgWnFOY2hLQTdOMTR0clVpQjdrZ3FxcDV0TjJ0c1RzVWZDMDVZMTlRV0psZElQcXFUTGpITFk1SmxhT1YxUnkwV3A1UEk4NEJ6VGlvNFxyXG4gIDllamZNY24wd2dLOS9vNDc2UEE0enJkZzcxMkpSRVlMZ2sxd0pGZnhkb25HVG1kYUtBeFpVc1ZhSXduaUxJMVptTlBWZ1FNU28zS0VcclxuICBJakdxVENPSWJDTVNyYjZab1pQcVJLdzdxekJYRTNiVlhxUURELysrTWd5OFkvMjMvc2Qvb1d1dlRSK212Tyt1QitqODJmUDA1VzkvXHJcbiAgSGJYMzluRkZmY01sRGFwLzdGOC9RMS8rRmQ5SER6M3dsNWMwcTJzNVNCVm50RWNRMU9oeTBXMnJwUkp5RjV6V0hlSGlpeXNUTHpVWlxyXG4gIDV0clA4TWs3UDZXdi9BUndzSjN6QUxBL2pIZlV1eFU3TTNsSEhJTTVMMUJDdG1GallEcGlrMXh5dG9EYXA5S0lFekx3Q1JXWnJhMDlcclxuICBJODk0WUgwck45dHF5NVl0ZEdTOEp6YUxnS214K1ZhSFB1ZWhKeFhTd1FidjFuQjNybE5EM01MZ2lzbzlDSWh1S1VDY2lSMzc0V2MvXHJcbiAgU25QejgxekhMVkZiV3l1MTc4SExrSGgvWEhuaStGZnJPSUpPZVVXc3M0QklOeHk1VklFSDBNTFFLYXZjOG1DSG9VbTQ5Y0V0Q1oybFxyXG4gIHRNRitJMW9rWjZXaWhBT0puUVYrSzdwNlVGRjI4RjM1M01Rd3RmUzZMcVlhV2M3RmRjZWhVbTZKS3ZoQVc3bGlzR2hQdzNOMDk5MTNcclxuICB5ek02amMxTnRHWFRacHJwZTdYa0dRTkw2UGozYVNDcndsb0RDQW9NQ09OM29rWHBuTTQwT3hFNG1lQmcxSDdvNkVQcUJDMjViN0V3XHJcbiAgNzFvNDRyeXNTeTYwZXM2d2s3bVJLYTNXaDQ5cDYwUmdEZ0hMOTZNN3FNaVo2RGJsVDN6MnIvZzM4azFJZlQyM3hrTDNsYk0yd2tzMFxyXG4gIFdxTFp3WlBVaU1VNUlUQVZ5dGRrWFhJQUhFbnI2dkFpTERnUlRITEFOUEhzdTBoU25wMVE0WlBzdHFQbEVJckVxREtOd0d5akpPaFNcclxuICBuQmsrcFU3a2lqZnp6VWZSRXZZTUZtWWRDSEREemYrZVBsK3dndS9ILy9sdWV2TDVmdHF4dHAyYTJqdm8xMzd6cnk5cFVCMFBHSjYvXHJcbiAgY0pIMlAvbGhrN3h3d0dXZCs2MnhvTDY1aTVyNFpBOHJ0eUpSZlBFeGJheXJNbkFIaVpiR0ROOVZ6azhOUXlCeWFKM2pzQ1N5cjdiTlxyXG4gIE42UlB1enN3NlNzdmdRZ01Tc2cyYkFLaU1pWjVGTm1DMTIrRWlCTXk4QWxsekkxYmFtV21GWndIM2lBSTlQVDB5RU9DencxM1JHbGlcclxuICBxUE9JSFlkTXA1M0E2MldEOHhnL3J6T3V3RUNQNHh2UFRCdnZQeWlENXU0M1N4NFk1eUE0c290eStOdmJtNm1tWXdjMThMNWtqTU1LXHJcbiAgNUIxQXdYL3FqeHQwUWdaZUtjaEJwZkpwZVFCeGhsdE8rc0JVY0JxWXdzcVZCOXVoQzlPdjhpekowY0l3SjhJVnArdE93cm1HTzNYY1xyXG4gIDJlTzVDL3gyMWVrK29WT2JVOTQ1ZUNkaCtUcWdzcTVyN3BRWFhVM3pYV056ejJhK01hcmxlamgwWTIyc08wNlBQUElJNFEyUWVGWUhcclxuICBLeUxQYnk1NEhiRFBOcjE4cGdiMTNUU2NBZHZnYkYvaTYyY2ozNlZ5YThNY1IzTXZseTlKcGd4K0E5TDM3bmcxRFI1NVVINW43RmpRXHJcbiAgNzk2Ny9SYlI5WEFjMHJHVDVHT0dGb3AyZTJuM1NzKzJtMlIxZ1hwcEVYRkxCbU1uQmQxWlEzd1hYZFl5cWUvL05CMDVjb1FwL0JhaVxyXG4gIExiZCtnOFJaSndOSUswVXAzWEkwZGZvcG9WdTRaU1Z5TThFNTJ0RHVWa0ZnWk5JcWxNWU5rSzl6WXJVeE9OK2F1NktabW9MRXNCeHNcclxuICBGaXlyVEJQYkdUbDAvQkZaL1JoSHFmZktPOWtoNmhUZmJJNWROWGtIQXR4NHk3dm8wWklWZk9GSWZ1Vi9mb2cyckYxRlc3YXRvNTkvXHJcbiAgLy9lYnBuclVOTHlLZnVzM2ZwUis4QWUrMFNRdkRMQ3MvODhZWFFpWklWRlhMdzhUYWg4eW5yVEZIMnF1d0YxSWZNSGdMZzNQY2VCQ1xyXG4gIHdVTlNlRCs1QTZ6ZGVJZExnbFYwMjdlOVdyb3BBa3dyVVZ6MU0rV1pTR3AyS1lKdG5JT1N4YmFwTk9LRURIeENSV1pvTVp3NmRVb1dcclxuICBSa1RGMDl2YlMvdjI3YU5ESTUyeG1RY3U3RmsrVnZHRFkzSlJ0YUtDMTJtMmMyaDE4REhFREJaa010Ny9uRHlGajlsV0FDcU9wWVZaXHJcbiAgV1pZYkJ3Sk9Bd1BwcmIxYkpZKytwZ2s2ZjM1QTlyL0lkNzg5dTc1TXVyNXd6SEJjYXZDdjRIK1Vnd2doUWkxSHFsVStCSkdiWHROcFxyXG4gIEFJK25sL0VBS0dIOXRPNTFNckNLVldCeENhRnlnMVBBWW85NDV6YnNHL2tPWHZMRHpCNk9zWlE4QmtoYnVZSkZ0eDJjSWh5QnZEZTlcclxuICBjNjIwck9hbnhpU05MTlRJeHc5dm1zUkRhWWh4akJCam1pNjZTN0VZSHRaSm14bnVGeHVVRzNwMGU0REhjVVNNNmJ1U2g0UnVHajMrXHJcbiAgRUkyTmpVbGxpQWM5TWYxNXJJRXJmTjZ2dkZBZGNSS2lZOGpCNTlYV3JYRkxONHQ1MzV5MzdoTzhIa3RjSi9oTnNJTnp3ekh2M0hpbFxyXG4gIHhIajZIOTFTc0J1Q00yRmVIQVU3SHh3WHlLZTRKWUhqaUxFa3lPQnNJQjltNXdGSHM4REhFVFAySmk0ZTBaWXEveWJOVSsrYThhSXBcclxuICBkQlZpUUI4RDhvaEZDWEFNOHZoVDkwcExHcjhSc3dmcmVuYW9Ua3owTnd1RFVndHJPbXo1MjhEL1hRUGY3RXljZnBxbXVlV0wveEp5XHJcbiAgdEo3UjJwakZTN0hraHFhR2Z3ZDRUQ25ITmNHODZKbnY1TlpJL3dGcE9jdTF3ZWt4Tm9JVksvRDdjRTZqTmVMV1oxTm9LWllGbTZEY1xyXG4gIGlpclR4SFlXNFJ5Zm14NlZIcGZwaThlb3hWNmhIZWUycFcyUS91OXZ2b2Q2TitiWHhicngraXZvUDM3VGo5TzN2Q2YvenYyZGU3YlRcclxuICA5azE5TkRXM1FILzJGLzlDSTRNWDZmVnZpTjRDV1FXMmJkMUEzLzE5UDA4LytzUHZrYVg0WHlqZzJPWGNibFlBNTRHbDB1RVE0Q1R3XHJcbiAgNTB1bGo4RjFQaW5SbllEWGplSXUwVTAzak1Hbm45Mi9oTCtuaHZObzI0VDFtZUpEYkxSRWVpSXFtSXJOak5Ha2lZSVJiT01jbEN5MlxyXG4gIFRhVVJKMlRnRThxWXE5Y3VVSC8vR1Jsa3hOcFdxSFRXcjE4dkw0SjY5bUxjUit1QU8yMitFK2JmajRmYkFGMjVkb2FhTzdWcGo2eGhcclxuICBJM2Vmek1DeEFPNzVEVGdmL0JlNklLSVdCQlVReGtiOEUrSjhjSHFtOTlQQlp3OFMzOEFKWHZlNjIrandwTjdaUzZXbmhIMDFuL0IvXHJcbiAgcUJ5OFNveFhJWXMxbGp0Y1AzaUlCMEw1L0tpMzliRE1CcXVib204WVRnUmRPSGlkYmR2cW5kTFhqM3dXNW1hbEMyT2FXNnpvNW5FdFxyXG4gIERIUS80YTRjenhIZ2dVbHhwQWI4WGxTbVE0Yy9KMnNVNGM0ZGZDZy9vTFQ4QWkrTzlURlUzdi9BNzhvTHZYQWpnQmQ2clg5dE5QdWxcclxuICBLR2x5c2VRdUpRWVNtYnpNMXQ5OUEwdHlFd0ExV2lwRGh6K3JhekI1Rzliek1RR0w2dzAzSUc0cDljR2pENHJqbU1TeGtHTUlXMjJkXHJcbiAgU0ZjZ3QvNzArYUhkU1g1ajV3N0piQ3JwNm1JNTBxRDM0SXFOemZKQ0xRRmVxSFhMMTJNM1NWcU5OTTYxU2lJN0o4WnJaRHVrTldJQ1xyXG4gIHlQaEdvM1BEbFdvalVIa0FtRVRnMldtK1FYQXp6aWE0NGw3a2N5a01zTWZJcEMrQkwzS1Y5b2tkazI1MlZqM1hqNzFYdWJYQ3pHYndcclxuICBDZnIwQjMrU2R0NmlnK05aM0hQdlEvU3BUejFTY2NiVnArLzVMSDNablQ5QS8rMG52cFZlZC9NK1AxdXJHcnoram0vbmU2QkZ1dWV1XHJcbiAgUHpISjVjTzNRQ29kcnFYRk9Wa1NZbkdPSFFUZjhTNndzOEJkSWs0NkJOenBTQi94VXVnS2NFQ3J3MVZWUHVhN3NyYU5lTHFXOSs0dlxyXG4gIFNpTWtpcXYrMkFaUVJ1dUpSTUVJdG1ZbFcwRlNzVGlnSWpSU0VOdjdqU0NoSXJQeDg0ZlpjVnlVbDBHaDJ3TXZoTUtBK1RPMkhIc0tcclxuICA3ZGRIZjdZYktFWExCWGZGcmtzS3JZNnA0VlA2ZERudlIxc2RXOWxlNTVxamxRRW5yYThwRGEwT1ZNZ3lIeDFsNHg4MXdYZG9HMWExXHJcbiAgME5temVLV3RKS1crdmg2YXFNVWRIUDRKL0E1MUJGckJXb2psRnNUZVltMkIxTkxJeVNlRVIvY2J1cWZnSkdBcmQ3cXc1N3QxMTFxcFxyXG4gIGIrbVFyanJjYUxUMmJwUXB0VmhMQzVVWkcwc2VhSW5BU2VENG9CVXlQUUlIc1ZsQ1BSOGYxNnJBWGJ3NEQ2eVp4SG1EeHo0YTJyU1ZcclxuICA0Y3FzZ1hscjRXaFFPckZoZlp5dS81bDdKTVovMmRMU1F1MWJiL0c2NVlQbHhXZTZwNzA4c3NNbjVwMmVQeWlqYXcyQmQ3L1B0VmIwXHJcbiAgR1JSdW9mUnRraFliemgwNFdyeXZCVGNpMGhKcjdXVDdNK0pZY09lTzFra0Qvd2NZZjhCNWhXT01sdGZRc1VmbGVMUnhDeFpPaGtuSlxyXG4gIEcra3dkZmo0ay9kSWR5eU9SWE56QzdXdHYxcHNZSVl5Q1lHTkNrcmx5dkdIU2JSQWhEWVp2dG9LMXhhSDNnQmhyVFUrcjlraE9CN2pcclxuICBIK2hxeE0yS2pvVXNTY3NEUE5idFFxc2NyYkdtRGo0ZnVkV1NmZCs3N0VoQ1pmamlWMm1mMkhHRWFlSlQ2THJuRzZ0NS9zK2FaY2FjXHJcbiAgMmd5YzJrL2Y5ODF2SzJ5QkFOdTNiYVQ3N251WURoNDhTamZkaU1rR2VXemR2cG5lK1BxYjZPZC80UTlvdzliTjlPbjdINmVwMFdIYVxyXG4gIHVidDhmUzJIMjI5N0ZmM29qLytHcE4vRyszb2hnUHE5WWhmV3BRS0h6SFZaQWFpeTRGN3dqRWZMdW4wc1o0MVRCb0pKUGJrODdBUlVcclxuICBLQzNiUkE0d0g0bVNYRFNCa0FGc2tZaks3Uk1xTWx0WDAwK0hqeHlTNXp6UTVkSFUxQ1JyV3owL3JFOTh4OEQ3d2pHMVV1OE1GVHBRXHJcbiAgdmtlZEErY0w1NEdXQ2U2b1pOQjhGdDFYNGNseTNISENjV0RXRFRET2xZUHJycEp5OFErYXVvZ3AwdlBVdW1vYmRkWU0wZW5UL2ZJN1xyXG4gIEVWYXZYa1dUZFh5M3hreW9zQ3dZTFhLdXhMUzdCdjlha0tHYmF1TDhVZW1pUW1zQzQxd056UjFTR1drWDFZUjBVVUdtTTU4MEhhWnNcclxuICBOckdUUVBNZURoRjV0dlJzbG00YWRHdWhrc1AreEdISXVBUzNiS2JZOXV3elROZFR2WFVMQldjUnVvRkNXYlc4VGliZEI1NDNtZEd4XHJcbiAgdmNZYXRzNC9JdjM5R0N4ZVdGaWdWYXRXVWRQNjZ5Vk5wY0FiQzlpSEM2YVBqcCtYT2Q1MHZQSEJ5V0lieUoxVGNkMTIwQTBmK1J3MVxyXG4gIDhQVWs1d25mbE1EeEl0MFF0MFR3bjlUVU5zaFQzY2dEemtQUFAzVW13OGNlNGRiS3plSXNlQWR5UXpoeSttbHpKRFUweXM0YWQvUTRcclxuICBEc0NHRFJ1cHRzdWVFR2U5RkFzZmprR2JnSU9VV1BMSXlwVUwvT1RwL2RxRkJhZkNNamdTMTYyRjh4YzhIR1pkZlpPYzQrb3NMc28wXHJcbiAgYnpnTXpLVERUWk4wWWZVZmxHc0V5KzNBZVdEMWd0d0RmZ0xadVpKbFFCRVJITE9jdmNCc09NSnFFTGl4UksvQ0lsL0hUWHhlQTZ0YlxyXG4gIEorbkhmdnc3K2Zvb3VybFVZQ24yLy9uYmYwbTlQVjJsbGZ5MmJldjVoblZDVnBsNDdTMVgwS05QSGFQN1AvTTRPOTFSMnJGTDY0c2lcclxuICA5UFYxMCtqb0JQM1huL3pONVBtVHl3RitkYVhHeHlVQm1jSjVPRGpuMGRDNVhwYjg5aWVSd0JOQzZ1bm5rTGVUYmRnWW1JN1lKSStjXHJcbiAgTGNBV2lhamNQcUVpc3kxTmc3SzIxY2pZc1BEcjFxMmg3ZHUzMDVHeGFHRFFJTytGWnJqQmNobmtsb0Z5TkxVMVg3eHExdXY1cEl1blxyXG4gIDVtTDZKWjU3Y0YxWWVHTmdmWE9uWEN4cWdqczJuVm5WYUdNcU9BYXI1cDZoSjU5OEJxdHZDM2J2M2tWakhiWWtoejhBMkw4ZE1TZVRcclxuICBxOGNkUmE1OGVQOFk4RWFab01LZ09PVHU2VzVVRnFpZ01KdElLcXJoczlURGxST2dQS2JWYm1TSG9ZUGJtRUdtWFhTYnhHa2d6Nm5CXHJcbiAgMDFKQk5MVDFpS05CMzdic0gwb0hUMmZLS3pCYVpFR3VGRytEaUpFd0hnM0hQMHo3OSs4WEI0SzdiclFrNTdiam5SZkxnSytnNGh5QlxyXG4gIDZQSVMwczlWTWpEbkJiR3Rzek5aNkZzcDFXRk1CRjE1UFR1eGlCN0wrRHQ0NUxQVXUrTldtcFN1TFA2L3hGUUg1REUxR0RUR1E5Q3FcclxuICBCVDk0RklQdm1NVkZkT3hUdnk4M1JqS1o0TmF2cHVuYWJwOWVJMnc1Rk1rOGJScFZDcC9JR2JJS3IxV3lZc1BmYVJrYldTMFd1SEhCXHJcbiAgYXNadVNSUTRHWjMrdXlST0pCNzdrQUYxakxOd1Fvd040WnBLeDBheTBESlVnaFdYc2J5dGduOFpKK3AvOHFOVXQ0UXUyVTEwemRXN1xyXG4gIDZIVzM3YVpmL29VZk5KdktlUDBkMzBMMzNmMm54aFhqalcvNmJ2cVpuLzUyZVQ3a00vYzlTSi82bkQ2WWVlTlZlQkF4blhvZW83WGpcclxuICBGdnF4SDMwUC9lejd2czhrbHc2Yzk5VWVsYXFBU2d6QndUa1BQQ0NJSUJkYTRZV3ZtNkJoeWpOS21JbmJHSmlPMkRnSEpXTmJBQldlXHJcbiAga1lKeSs0UXk1cWJOOVhUOCtIR1pwb3VYUVRWeXE2T3pzMTNXdGpvMDRxWWhCOEJSeUlON2xoNnREdkRxTEhRV0ZsVGc0Vmd3RUtjUFxyXG4gIGlta0MzRlZwZDVVQ2c4c2RlRHVncXlqNWk0dW9sbm5YclNVcG1XOGJlWVNkM0ZGcWFLaWh1YmtsMnJLRld3M3IzRExSU091T2x1WWpcclxuICBlVVl5M01YaERoVXRIa2lIVDN5ZVcwYzJJRDQxTEU4T0M4OTN2MWhsVlFiOFdZZTBjZ2NLeXVMZ05OaVI5S0Q3Q1RLYm1ZU0JZYlF1XHJcbiAgTklIWWk0RUtNbklnNlB4VzlNcUhtQkdsVXlyV1dReXczWVhQL0M4Wnh3SlFhZDU0NDQwMHV1N0xoUytHTzFZTzBhV1VYRld1cWpTRVxyXG4gIEdva1JwNG50bUJLbVNKL1JGY2lIRGo5QTdWemhvaVVpWUJ2blROeHNxWkZUVDFLWGpVZEFoaVZXY0xlUDlIdWFqOUxIUHZZeDBXRXRcclxuICB0VDJ2ZVJkTkxMVktQZ0tPc2NZWFdvZ3FDL3ZXeUdTZU5vMHFoVS9rak1sVFQxRnJORDR5eWkwVWpPdnA5ZUNTcWkyNk5ORjEyN0hoXHJcbiAgQ3UwSzVSWlorNXFkb3BzWnRjRjJCcTZwbVZHc3ZGQTBMaExEeWxRR1ZnZUxaV3dGL0t1V0Zxbi9pWDhpVEJIcTdGdEZ2L1RUMzByZlxyXG4gIC9yM2ZyT29xZ0dkRWxodXZxR200a1pibUhqV082SjZQZjVvKzk5Z2hvVys2Wmp1OTVlMXZFRHJHZmZjOVFtOTQ4N2ZTMElYUFVIZTNcclxuICBuUitYaUJlMEN5dDJIcml3Q3AwSHR2NnFNMEtpK0dLTWJRQmx0QzZJRmFsZGNqbm5iQUZVYkVZS0t0c3J4OXRJUE5iL3ZMelBZMkp5XHJcbiAgZ2hyNFRuVjJicGJ1dU9PTjlQUzVmTE4wZG5LWUhRUEdCSlNYNWpkWGxPaW1Ra0hnUE5DMUF4NFhRUjAzdmYwQU10L2xZMERhT1k4WlxyXG4gIDhOd2tsdmNseUkvUVZzY00zM1cyY0hNZlRYcjhmdTA2VVAwMjlsSEhqNS9reWhCdmR0UXhrSVZXek5nSzNTbWd4VjVrS3AvbUN4QjlcclxuICB1QzNkMnBVMndjMXhPQTIwSXRCdGhTQ3phVkRPVVR5N2dYVzQydVNpbm1BSGg3d2F1ZUpDUzBTNnB6alAxcjdRWllXeERKVnRrYkVNXHJcbiAgblpuRTViQnVNeW1iakUyZ2pCazVZdVpkV1JISVpnbDVQZUtNamRneEg3cXZzSzdZY1hIWXNFTXJhK0RJdzlMeUFPVE9lOXVkTXRGaFxyXG4gIGNwRHRwa1kwc0tORWpMRy94ZGxKdVVId09nNFlBNXBBdmt6clRLRkZhbXp0OVdYUVlPV1MvMHRwM3VodkVGbVE2M2hLS0hQUUsxMG1cclxuICBiK1pqTFpNVStEUE1qZ1BIR2QyRHpuYm82T2VrMWFFeWt1ZE9NSmFBTVNvSW5udjRvL0l1Rk9kc1pwY2E1ZHlVMU5nbllubVNId3RGXHJcbiAgc2hNUkdjVFFTNWFSVEdtTnZES1Y4NmVCVzg5d0dyaGh3U1Fkekw3QzhjU0NsR2lkd2s2V1ArRTBPdDZoTjB4b0dZdWRqSDIwY1dpVlxyXG4gIFk0OXVWSnhiYUlHb0xqc3VFa01LVlE0VTE1c3NZeXZBY2NETXYyNmE0QnVuMmFsSnVuclBKcnJqcmRXLzV3TmpJbi8yNXgrcCtJYkJcclxuICAxOXgySFgzSGQvME1mY3Q3dmtyNDdUdTMwdXRlZXoyZm54UDAwQk9INlRPZmU1SU9QdllrN2QyemhScWJkZHgxMjdZTjdFUStUMy96XHJcbiAgb1k4V3p2cGFDVjRRQjRMRHlaZG00andRWXVjQnlLbmlqNzBSRXVsSnBJaHRBR1gwejBzVWpHQWI1NkJrM2phY0FFQmxlK1Y0RzRtM1xyXG4gIE5tTk00YlIvRVJRcWg2dXV2b0tlSDliVlZ4MXcwYUh5Yk82S3ArZ09XbE1hZVhLTGdPK000RHdBbVJtemJxK09oYkFlclF4NXVJb2RcclxuICBDM1lQSG9PZmVnSGdLTFB6R2UyWGFhcTRpUERiNWJlNUg4Z3hMdFRCdVM2YUh6b28vZGlvRjF0YW1xaTJhNmZvcERLVmRCeFFXWFBGXHJcbiAgaWhZSFprRTFkNjRTSjRFV1E5dnFYVnh4YkJBSGh2NTMzTkhDdVVoZlBBZFVLamdPQUNyYlZ2NnZaWUlGTzVQZ05IUUFIR1VQVHFQSFxyXG4gIEtuT3JLQk9Id2NIbzJCRTQrN3pPOU5DSmpjcmhJRkFtcVN5NWpIRWxqLzBoeG91UTBGZDlaY2RaNlpJRTBJV0Yxd3MzcjcxSzdEbTNcclxuICA4TEg5WVYveXUyVy8zTnBiczBNY1BONFZyNzhEZzlFZC9MOXRrMzI1TWs1ZVBPYkw0QnhONm1EVURoOG1mSkNQMStreFFCbFVib0UvXHJcbiAgS2dkbHRoeWErYVpGWmVwTVFIZHN1RnE3RDgwT0V5RjZ0cjlhM3kzRExlU2hZdy9weTdRWWZYMTkxTDMzVGhvKy9naWZFNWdFRWh4SlxyXG4gIFRZMDZEOTIvNXNXQ1NHWmxBa1FsRXJVenNlamx5MlZsSndMbk1jUEhDUTlyUXFvRDU4OUlseTMwY0JMb3hwVnppS0dENzVDM3lrUUNcclxuICBuWlN5bW04T1JtaHE0SVRRU0lNYnJucWJqRklNS1ptU0pRakZYdDRXa0c1WmRpSzRsaDU4Y0QvdHZXSUhYWFZWdkxKMk9UQUdna0YxXHJcbiAgck5hN1owL3hJUG5Pblp2b256LzZHWHIyMmVjVFI3Tjk1eFoxSkh5aisrRFRKK2lKcDQvUWhWTW5hZXVtdFRJRzg3YTN2a1plZ1h1NVxyXG4gIEErbzRBdFcweDBxQkRQaDA5b2ZTSGRhcW5BZGdKNVFIL2lFUHBWV1VXREdZTjFHU1F3WGJJSTMwUWtZOFF6bmVSdUpkSGFQeUR2UGhcclxuICBJUjNQYUd0dG8rWldydURYcGN0OFZ4enY0QjhDSHJQWTBCTEJ5WTY3UG5rSWtIZUc3aXJjOGJlamkwclNZdUhEQVc1K3U0VVB0ZFdCXHJcbiAgTndHMmJkRG5CUUM5YUlXeUx6YVExVkJkLzMyeUVqQzZzRnBiRzZuMzJuZXJwZW54eGQwM0NQU1JZL1lMWnVsMGJicE9iSERIWGNNWFxyXG4gIHRMUncyQmI5MGZJU0pHYndzQnBtbmFDUFY2ZmNuaGFIQVY3QU5uQkkrbFk2VittSlF2SldSTEtJRnBoTlRoN3grR0N3RjRQRkZ3N2NcclxuICBRNnYzdlZGNW04VUdHcWFvY1BDYVg1YzJYakljV0Qzd2NiNVk3eE1hWFRacjE2NmxybHUrVnlwVTIxa3AwTVdpZG5vcHVTNFhnWWhVXHJcbiAgUG5IaEtEdnpXWmxVZ0x0M0hFdTBVUFY5THJxWUlPQXV5RFo1RU5OeEhNdlhlR3NacEhLbGJTTTNNa3E0RGJwVmpHWUNYVUJZWHFoN1xyXG4gIGg3NnFkUkR2dTJCczcxMmt4eDk3MUErZzc3emorMm40eEJQaU9PRDQ0RnlRRHg1VWRPWFFmVmtRRWZhbE9yV3hraWQya0NFV0JUWWlcclxuICBrNGcvc3Y2WExIMml3RmdndW12ZGxGOGQvMWd0K3dHTjUwUXdOb0xuajlyWFgrSFBNZWs2dFdWeU1DN1NJZGRiTmJBeWxjQ0t5cWhzXHJcbiAgQjh5YytEUU5EZXE3anZidi84ZFNoMUFFZEdWOTZJTy9UcXRYNThkWEhiRFV5ZU9QL0IrNjdycnkzL2FKZjdtUEhubnlLSzFaM1VNOVxyXG4gIGJmVjB6LzJQMDhmditpd2RmRVpmRkhZcHdCRmUvdGVYQUltenpnTkFocW56d01acEFhTTVrc3JCUXdRR0pXUWJOZ2FtSTlibmtiTURcclxuICAxRFpJTTNwaHMxcmVSbWJYYjFpU053bGkzR05oZms0V0o5eThlVE50M0xLUm5yWFhlZ0xvZHRJbnJaVkhoWUc3ZEhFbS9QdlIwc0FpXHJcbiAgZ2VEaE9GQ0p1TUZ5dERMY3U4aVJITE5LUVB0V0N3ZFU3cGlCVkdkUGNDTlAzUlZ2NWF0MmVxeFZ0bXI2Q1ZrUmVHWkdLNFBOdDZFUFxyXG4gIFZuVndIT2pHZ0RNRHNLNFBWcmJGaFlkK1pPU2pNMlR3N0lyT0lNTll4c3pJR2JtRHhld1hUS2xGT2ZWcDUzUmNRL1BGdnJoa0tCTUNcclxuICBJTEdWM1dpQjZVV2pTZzBxNWlqSUx4eTRsL3AydlpacUczQXNjR2QvRkFxaEFYVGZ5SDlod01OMGJXdDJTaVVOaTFEcGMrdUI2YzR6XHJcbiAgSDZIUGZRNHRsU1Y1Y0c3VHBrMVV0K1B0VXJuUFRneXhJdzFMOFhod2VkRUZoTUZyZHhXcDh3aVgxTGc1QmNqYVZybDlHdThjRGU4VFxyXG4gIDV3cFN0YTNlUmlOWWpSY1ZJSjhmS0RjVUxzZmdWRlJvMWJJWk9OcEpZUkRMd0FzalFWVndKQ2ZrZDRpTVA0T1AvZ1dOREEreUh1TWNcclxuICBpOUl5Z2E2WFk4MUQwdzhkZlZoNHR6Nlhmb01lWDVGaytZaDJjWkpPUkJxamRUalYveHkxWWRsNEFWdjZKOU9YYUlTZEJWb2ZtTktNXHJcbiAgRk02cDRQcHlEc1hEOHNSRGg0M3RQVG9KWlZsWWVjckE2bUJSYkx1OWE1Sys3WjAzMEVOUEhhWS8rc08vbzQ3MlZxNUw3bC9SQTMzN1xyXG4gIHJ2cEtPc0NPcHd6MzNmY28vZENQL0JvOXhrNmtHamhuOGhQLzdUZm9yLy9pbCtqci8wUEJhZ3RWNEpLN3NQRDNsVHFQM3Ezc1BQUXVcclxuICBWT1c4ZFFhT2tNZ3FFVUhleGt6Y3hzQjB4TVk1S0ptM0RaSll4eEEycStWdFpIYnpsam9aV0IwZEhwWWwyWEYzaXNvRlMxdzhlVDY4XHJcbiAga1F5dGpIaUpFRlM0bU03bnh6dTRKWUc3Yy9DZ01VVlJkSnhnL054QnZtUGE1N3VzNER6UTZ0QnBpTGlMWDVKVmpCczdWMXQvTTdMRVxyXG4gIEx4Y2lvVjFRV1MyMXpKMmwvdjd6MGl1RTY2ZHJpejY4T1hMeVNYa3RLUndjSEIvK3QzYXUwTkJWaGFmSXNXd0krcEJ4MXdjYkdiUWNcclxuICBPQ1ozYitqNndBV0tiaTQ0Q1htb1ZMcDBGdVFPRlFQaWJseERwdE5pNTc2N3luV3RRTWJCNkxnN0NyYmVUcnAvYXVqaVFXNGRzQndPXHJcbiAgR0YxVDZCckNjVVFMQ2Z0RXdJQnJTOWRhYWRtaExPaWV3aDArMHJ0dUkraFlJRHJFQ09oS1hPai92UHpQc0FWMjdkcEZkUnUvalBsYVxyXG4gIHFZaWtnak43RjlEMTFORGNydnZuL2VoNEYzVDRYVGdlV082Y3k0SldtTndzYUpjWjl0RytlcGZFQ0RKOXRtOExIODhKS1o5ekhxeFZcclxuICBwNzd0UmhvNThUaFgxRGVJUGJyQmtEOXVBQnBiKzN3K3hWMWJUcWEwSG1mSGE4QzBZUEFpNDgrWnArNml4YVZGS1Q5dWxPcjY5c29pXHJcbiAgajNoUUVjK1g2R3c2T0U5dWZYWnZraW5CVXpaRm5YT1Ivd2ZkUzhNbkhwVnp5NjF0SnNCdThBRXJJaEVJNmNvbEVBRk9rWG9aRzhITFxyXG4gIDBuVHBHeTJ6V3k0ZTV3SEdURWJQUGtQTmZIMmdpMHFkQ0RzVkRqaFdPQmNCM0lCQmoyZEZNUFY1Ym1xVXorMkNGWFFUV0VIS3dDcFhcclxuICA1REs3aWNIajlMN3ZmVHQ5ODN1L2tjNmVHNkFIUHZzNC9kTS8za1B2ZmEvMkJsU0RhNjdlVGIvMEszOVUrcTUwakd1YzZ4K2lUMzNxXHJcbiAgWVhyOTY5TmVrU0xndVpIWHZmWlZ0THFuazc3OXUzK0czbmo3cTJqYkRyM2hYd2t1eVlIZ01DR2hPMXd1OXM3REZuZ0RjTEo0QTBkSVxyXG4gIEpCcERiQU1vbzM5TXJFanQ0aHlVakcwQk8xRTl5dTJWNG0xa2N0UG1XbnJnZ1FmOCt6eW1aNmFwdTZ1YnJyMzJXbnIwREYrWUJ2U0ZcclxuICBTOStxcGNWSkszZmY0TGtBNGpDc1N3dDM4TzdGUVRDQW84R2RLRXhoSnpOTG9uZDF5UHZoK2NoaWVxNGVTMndsNDBEalI4b1BaVTRxXHJcbiAgajFCcDFJNGZvNHNYOFE1MnJhLzNyVytpaTJOTDFMNXV0OXpkelk0TnlJVS94M2ZaV080RTNWUElBOTFZcUJobGFaQ1pNWEYrbUxhTFxyXG4gIHdWYm93VGZ5aFRuSmQ5UzRHTVZoOEU2MGtrS2x6enNUeDZHMFZsYU9aenFTSnpaTW93S1NCeFdaYnVJeWFJWFVTZTFyZG12M0ZMY2tcclxuICA0RnhSUGxTd2J2WU5IQjVXR0hiaklHaUJvR3NOTFQ3WW92SkVCZDIrZHBjc3dDampPaklkdW85T1BmN1AvbmtldEVEd1BNOTRxM1k3XHJcbiAgWW1xeDVKRUptUFRBbWZLZU9TQm1XemdMR2VmZy9jQnBRUTVIalFrVldOZ1E2YVM4K04yc1E0c0VNNS93N0k4NEY4NExaVVdMYXBaNVxyXG4gIDNOMGpQM1FYUVFkNTI1cGQwdDJFUlJOeHpQQ1NNZGpJcXNYTTYzSFVHUHVSajhYZ1ZXYkgyMlR5NFhqTC9CTjA1TWhSNXZndW4zL1pcclxuICByYmZkSnNjQlQvekRwbS9uYllrandlL0ZiS3d1YnBIQ2tjenhUUVdPTDJqT21KM2ZUZUpJNnBwYStCcHBzZjNqM3dJcGUxZUFjRHhzXHJcbiAgVkdDeUdqNUdqVFI1NW1uQ1cwcngzK01HREE0WDUwWXpPNHBtYm5VNGU3U0czVU9KY0dUNFQ3RXZwTU1nUE5MQ0JtTldVd01uMlk1YlxyXG4gICtiTGpTcWhzZ0NLclJkN3UvSW45OVAzZjlHWjVnQkFPNE0vLzhoL2xZY0V6Si92cEs3OUtsM1pmRGhpbmVQVFIvUlhIUTk3dytodnBcclxuICB2ZC83aTNUcnE2K2lEUnZDK0dzbDNQTHFhK251ZXg2a0N3TWpkT1dPRGRUUjJjR09HclY3ZGNEWnZ5SWdRWnk5TzF6cVBMYXg4N0JWXHJcbiAgUXhseU92amptUjdZaEN0ZzVCektwSWtSblhwbWxyVmxpMFJVYnE4VWJ5T1RHOWdIM3Z2cFQ5TEk2QWlkTzMrTy83aHg2dXpvbEpiSFxyXG4gIEk2ZURJUWFVYTJyNGlJZ0l6bUpRKzlxTmwyNHJyalFBMEc3VldJeDFJTGk3TnJRNkFGMXBGSklhbXVnL3dKWEZibjIyUTg1UXZaZ2tcclxuICBqbWpZb2pLU0N0cnNsT2U3NnladEpkWFcxMHRvYThORlROSTFnWXNJKzRlendETWNlRkljOCsxZFhwZ0kwTktuejJxZzN4dlBjL1R1XHJcbiAgZW8zTXN4L21TZ1NPbzQwclI2ekZsVGdOcEFjZnlYQ01QQy9IUzJtNTB4WVpWNDdzUEZFaG9JSmRjK1diWktZTkJwcmhNT1JkS0piSFxyXG4gIDVNWGpZai9CRlNjY0dkSlBzUjEwV0tZRFBHSk1XOFViTmVGVWROL1lMeDlYcnJUbHdVVCt6Wk1YajRoK2RGUmZad3RnRVAxYzN6c2tcclxuICBuNm9DOHVhQWZLYUdUZ3JOTlN2cmFxaUR5NEh1S1hRVHRYSEZLc3VJNEhkd09zaEI0d2JpL0RPZjVGWWZPMG0yNFI4cnY2K2hwVWVjXHJcbiAgZzl2UDhPa25KWThMQis2bU5WZTlSUnoyd0tIN3hhRmdxU0hZb0tXR0dPbmRmdnh2bHpnRXNYRXlsSmxqZVhNbTAzVTRYemovUncrUFxyXG4gIGlhUHQyMzI3L1BlRFI4MlI3SUlqZVlpZHcrZTVOYlZUeHNOd1hrbnJpZlBCWW85NEZnaXZDWWJ6UTBzSitjdFppL05UOW9lWWVYSDRcclxuICB4blB3TmdqSVZPaGFhdHQ0clp4N1UrZDFzZ082VjlFeVFtc1lkckRHdUJMc3NhWVlXbzRJS0E5YUpRQzZ0T0JzMFJwQkZ4WnUxdHo3XHJcbiAgMXlXRGlyRHlsQUhGZEVSa044YzNKakUrL2krL0wyUEVmL3luLzBDLzg5dC9xY0lxZ0NWT2Z2MDNLajhiOHI4LzhCUDBubTk3bjNIVlxyXG4gIDRRTy8vVlAwdS8vN1E3Um04MFo2K0tHbjZKRUhxMytYT3Y5cjFRR0hBOFp4QW5lSWd2UFFCOHVBY1BneUVFV3N6ZFB4Tm9CNUUrbXBcclxuICBZaEF5Ynl2bm5rZTV2VktKc2VEUW9VTTBOVEZITFcwTmZJN3pYV0Zqb3ppUFF4TTY4d05BdDVVc2JHaDV3a0hnRGhNOEhBbGFGQjFyXHJcbiAgK2U2VFl3UWRMTmZCVWp3VXFPTWROYjdMQ25kTUFQcmNKL3FmcGZiMVYzRmVuSm45R0hkUnllOTNjdkFpd3dXSWY4ZngwUEdGM05QRFxyXG4gIEZRRlhDSFY4RjhmaFUvZmZMeFVuN3VqZ09EUVB0RGpRMWJCSjd0cXhHSjg4RmM1M21HaHhpT1BZK1JySkUwOC9ZNVpMNzY3YjVZbnpcclxuICB1REp5dEZiVXFMeTB3aGU5VkJobEZWcWRPQTdjWGRmVTFYc1o3Z3h4bHdpSGdVb1M2Y1FHdjQ4cldiUkkwRzJGVmduMmp3b1pOcWlrXHJcbiAgVVptM2NZeEZBdVhKWUttc3RUV0FiampjdldJLzY2NTVCL1dOUGVRWHdVUVhaVmRYbC94SGNVRDVjTGVOL1FJNGRrRi9XQUphblZJMlxyXG4gIERoam9SVm5HTVliQisrbmNkQjJmQzN0bG41Q2pmSmhNQVFlREIrbFFaa3lWeGpFYU9QU0FkQVBpZ1Vyd2FDMmlDWW5KQ1BLNzEySW1cclxuICBYUjFkZVBZdVdyWHZEVkloT2hrZUJyeHdFTXV4MUxFenVWZjJoenhpUndGZE9QWWFVRWJFbUdYb1ZpZkd6VWZ2N3RmSmVlSDBmZnkvXHJcbiAgaXlNNThxQ2NEOW9pZVVpNmtmQ01DUndKZ3NzWHJUZE5xOGNGejU2ZzFZaTA0Rm1aNktYMUtBNUZlWkVoQUJMWFVPdmFmZXdRc0Z5L1xyXG4gIHl1Rkl4aS9nMlFmTTRsb3IzVnZRbzZXQmF3cXRFYlJTM0hMd2VNb2RnTE5IbXB3VHNkMlZvNElCcTF4eHdWeXhkcDUyN3RoRTYvYm9cclxuICB4QmhnNTg3TmRQVDVqOG1MKzM3b2gzK1pQdk9aeDFSUkJmQmNDQWJWeTREdXEzZDkzVnZwbDM3NWoweXlQSzYrZWhkOTI3ZDhEZjI3XHJcbiAgci9sQnV1MjFOMHA5VVMzd1UxSC9Wd1NNRU9KczNURUszVlpSUHljREowaGdqWkJJTklhOGpabTRqWUhwaVBVNTVPd0FuSFJHQ3BLRVxyXG4gIGJpTklxTWlzYi82NHJLdzdQcUV2ditycDdxRnJycm1HRGd5RktZRG9mMjd1eEd3a3ZzT1k0cnUwMFg2K2lOSGxvYzREUU10RFdpQWRcclxuICBhMlh3RzVEK1dUN0pzYnZGaFFXdWVBNGxYVllZb0s2cmE3SjNkYkJNeFBxYjlKaXFuY3BBTzVuR2FxTjYzSTF0YnpsSFR6N3hPRTNQXHJcbiAgTG5DRlgwY2JWcStsNlZXM1NHVUlSNEkzMytGdUVSYzdua2p1a243Mk9oa0lSMzV3SkhoSE9ycXhjTGVIZkhXL0lIVy9jVGwwLzFGUVxyXG4gIGlhY25CcmppbkI2bnJzM1g4VzgvS2c2aGxlL0FNZjRDUjRDdU1IVGh3QjdkWTZpZzBRTEJkR0lBM1RyRFhHR0JiMmVuQWozZUJJY3hcclxuICBnclhYdkUwcWtnNTJMQUJlWndzbmMrN3BmMkhkbDlPRUxSMmprRkpKaEJMdS81QStJVHczdDBENzl1Mmg1aHYvay9BclJSZ2dqaEVKXHJcbiAgbU1UeS9FRDdtajAwQnBwbDBqSmhBbVdtcFNWeFJoY08zRVZycm42YjhPZWUvbGRhZS9XZGZENGQ1blE3SkVkWmY0d2RDaHdrYkNBN1xyXG4gIHYvOFQwbm9EOFB3T0J1Rlg3M3VUT0JzNFlmeWZza08yZHpFb3h4Lzc1Ry9ROU5RVU5mQU4weFd2ZXhkTk42SEZiUFppYXpRb2p1QU1cclxuICAwT3Fvclc5Z1h1VmlaL1RRRVYyTUVWMVowa3BoT1o1MHgrckxzdVE1ekMyTk1SS0h2Q0xlYUFIejQ5d2lxK2RyUzIrOGROWVdhSXg5XHJcbiAgekU0T3lld3JtY1hGdG01d2ZaU2RpYlJvTVc3SGtLZmE3UWwzY1RvZDBVd24yMVZsVkRCaTFickdjL1NtMTExSnYvSkxQMlRDZ0QvNFxyXG4gIHc3K2o3LzZlbjZYR2hucTZlT0V6OHM2ZWFvQ3B2ZmR5cUxUbzRwNHIvaDNkL1luL1RaczJ1ZTd5eWhnYm02RE8zbHZwaVVmL1RsNXVcclxuICBOWGhoZ0hwWGE4OUpKZUIycXVJWWlGNzJ5emdQVEpFVG9XcTBFaEdTNFFrbXJUSVJ4RGFBTWxMUEpJclVMczVCeWJ4dGtFUTZJWXMwXHJcbiAgVEVWbW1LNkwxZ2VjQjJaYnJlcGJSVHQyN0tERDQrRXBjd3dvdTZmTHhWbGd1WUkrdmpDWng1UG11RWpSUFlUbktuUWdIZXRDb1dXaFxyXG4gIEErM1lIWjRYbUpzYWtrcFFDNEJuUS9nRTVtTloxOHlPU3U3Q0lPWmZMTWNOdk5vNW1mQVNvanM0NDNHaG9Ddm9JcmVlcHk4ZW9vWVdcclxuICAzTmx6R1dibXFHUEg3ZEwxaG9mNmNLZU1yaXJjN2FMN0RNdnc0L2ZKc3hvdFhkTGk2TmgwamR6WnVidEszWi9iWjh3empUdDBkRXRFXHJcbiAgc2ttKzAwTkxBSGJvN3NCS3I0dGNnY2h2NXp4d0I0MDdZcFFYWTBtNFMwYjNtTTVvMHk0bkp2allyWkxXVUdQYkt0bUhqbWZzNW5KMlxyXG4gIHlsMzYrYWMveG5mQnQwa2w3R2F3b1l4d0dtaEZZcWFPbEVudXZrTVoxdzkraEE0ZXhETHp2QnZHOXUzYmFISFZqVkxlOHVDT2RScGNcclxuICBudTcva0krWGFVRFhDY3JIakpRSmc3cXduV0Rud0xsSUsrbjhNNTlncC9kMmxmUHZoMU9kNC9PbkE2MFJ2aHJQNy8rNGRNZmdQMnhxXHJcbiAgN3hWbkxPTThuQUhPVFRobXRKSlc3MzJqNUlGdU1qekhnVVUzTWRhQ1ZYN2h1SkdYSzJmTDZZL0txdExJQkMzdXR0MXZ0ZktqVlBiN1xyXG4gIEluNmVqNytzdFdVUEVzWTZsNmQ3V2RZc1h3c291N3dBaTNXWXlveFgyNDZjZkZ4V0wwQXF5QVhZbGNXT0FhbDVHNWh1eEFLazg3TjhcclxuICBvOEgvZDhjNmFYSG91SWlPUVdKY1JGWis0QnM1UENNQ0o0VG5TRERlaDBGNUdVdEJDMFhHUlRBQTM4cm41b0RZNmo0c1ZFUUZBMWJOXHJcbiAgY0ZuZStkYnI2WVpiM1B0V0FtNjg0VXA2L0ltRDlPeXpoK25qSDd1ZnZ2TzczbVdheW5EUGgyRFBaYzl3WEh2TmJ2cFAvL25YNkZ2ZVxyXG4gIDg1VW1xWXltcGtiYXVHRU4vZXF2L1lrOFhOakN6dXppdVF2VTJsN3B1Um1jUFJXQUFzSWdObkswT0krZUxRWE93NU1wV0ZZa1ZsamFcclxuICAwc1FLbkpBZUpiWkJVcDVQQU50RVpydTdSdWpRNGVkOHl3TjE0ZVl0RytuNE5LYlNLakRyQjMzVlNPZGFHcnFzdXZLb3JKQWx1cXhrXHJcbiAgVFI0dy9NT3dpR0RjWlFYSVFEdkFlanpmSVJlRTJZTndGNkZjT0luTUtqQ09wVkxpajFScXpLUFZnU2QzdTdqU1I5ODFMazc0b29XRlxyXG4gIFJacWZtcWVwcVVtNUc4TUFLTkxpcmtzWEtjU1l4eGx4Zm5qWUQ0NERkN2U5dTE2ciswRCtpSzNySSswU01aN3RjMTBrSEdNcTdPb3JcclxuICAzeXdPQW56M2xodTA2NGt2THJRUWNHZXR6aVNrbCs0eHBubkRkOVIzaWpORFJTcmRRT2FnMnJtaUhiL0lsYTd0YTkyMVh5RXgzbEFuXHJcbiAgWmNIK0pTQmZGNHlYb0hvc1NnY3NMbUxkcDFwcWJtNE90cVhCNWVlQ3llTjlKdnZGTWRIamtoNHJaNnZsYnNmYjlaaVczOEo2dkFNZFxyXG4gIC82L1lZWmtSdGtXckFvNFRUZ0NWTXJybndNUHBvRldEL05IYVdKeWJrVHdXWmlicFBNWk4rRGppTmJ5WXlZYi9BMTJEcmd4SWczWEFcclxuICBabWRtN01GVGpPR2duUG9mYURuTjFtTE1Lc09TS2NOY0RpZDNPclJNMExVRkd0Tjk4UlpFNk9EVWNBNWpnc0hvcWFla3l3MUxza3M2XHJcbiAgK1oxNm5qUEJXK1FWZUpFaGxwc3JEZlZjaG82TjE5SWN4a0dZMTNHUmEyUXhTQlpJRjdLT2YzQmEvaTJ1SllJeE5jd3dCUFRaRVR6aFxyXG4gIHpoVXBYOHR3SXNJNFJHUXh5ZzB3cHZTR20xMnJONDkvK1B2Zm9xdXUyVU9QUG42QWZ1U0gvcnRKbHdkYUh6LytFLy9EdUR6UWxYWGpcclxuICBqVmZSUDN6NGt5WlpIdC81SFY5SGg0K2NGT2NFckZxclhlcVZnRjllMkFhRGdrK0g1TkNBaDdFNmo4M1UySTIrVVdpQ0ZmNzJ3QnBoXHJcbiAgTnJGVllKUXdFN2N4TUcxc25GckoyQTdBeVdXa29OeGVLZDVHSnQzTml6UjQ3QkVhR3NKc0pMbWU1SDBRdDkxMkd6MStSdWRyb3dVaFxyXG4gIExROEczc21BYWJlTmZQY0l3SG5nVGdmbDFPZEJ0SHNMQStVZ2NLZUpHTys4RU1jQ0pRT0RlWGd3TUl4M1FJcmZvdnB3QVlrVUF1UEJcclxuICBCUjUyZU5pcmUrdjFzdi9HMW03cGw4WUZPL1QwUC9MdnFaVSsxOFc1UlhyN2w5OUpuM2wrbkcxdjRvc1hyMEt0WmNmaFhsS2tYVmM2XHJcbiAgaTh5Vkk4UWlpL2FySkRhb1BGU0hpN2V1b1ZWYVhsaFNBbmUvdVBNRjRueE1JR2tjRGQzNGhjTTB5YTBJVENCQXhUaCsvbm1xclc4V1xyXG4gIHg0YVRUL2VISUltd2tkaG42V1JlNzJ5QVlLZmdGdENEdjBJSERqd244b2FHZW5ydGExOUx3NXRmbURlMzZjV1Z2Y1NZOXlLemtNZ0pcclxuICBuZDUwR1Y1WE5PYnpFd1B1TERyMzFFZlpDYjlOV2w3b25zRmRON3F2MWw1MUoxdHA5dy9HYU9TNUU2WmRmdWpXd2d6QzFWZmNJZkpuXHJcbiAgUHZ3K1BnWmNLZGZYUzZ1N2RzKzd6QmI3MVh3a0lXS2ZqOG9Hbjc5ZlZEMjdYa01EaHo3RE1wSXhFWDE3NHMzZURubGd0V0E4YjZUL1xyXG4gIGkrYUJteGQwT2VrN1NjUlM1RTZ2UExOZWpnaHhrR01oUmJSQ25CNE9BaTBMNkRHV2hnZGlWYTRMTlFKb3FYZHV1RUt5OEcrMVpFYTdcclxuICBzMXdYanVZbmlNaGlCSU5OalJmb29RY2ZwRU9mK1FEdHZFVWYxaXhEWjgrcmFYSjhrdjcyYjM2RHZ1YWRiekZwWlR6OTlQUDBQMzdyXHJcbiAgTCtpUC91RDlKc2xqcGU5U3g0eXNuLzZaLzBYMzMvY1hKcWtNK0lRRTduS3I2RHpZY1lqenlFQXVYSjhvVHUwdmFVWnNveEEyYkF4NVxyXG4gIE8wSE9Ec2hYQ2g0WmU2VjRHNWtBTXhlZm84RkJkUjRBbHJMQXN3QjU1OEVWSEZkb2FFMEU1NkVyNmVKWDR1bnhNdWVCZGFGazNBUktcclxuICBzK1Y3ejNTd25JT3JaT000dERwaVhnTXVDSXpKNE9KRDZ3TlBoOWMxdFl2elFQY0I3bmJudVFWQzgzaWZRaDMxbnpzdk0yUDBwVXhiXHJcbiAgdUdMZUxMUThTZDYzVllMY0plT3UwQUwyRTkrdGlseGkzRlhYeXlEenhRUDNpaDI2QXREYXdNVUl4NEh1RkFuYzRzQnNJenhqb09uMVxyXG4gIHpodHBNS2lNYmhuY1hlT3VjZFhlTzZUU1EwWFlzWGFmelBlWE8vVTZDN1p2bjQ4dnI5SENvOXZPYkVTdU90NVk0TEp6UERrNXlYbytcclxuICB0QXhNT2hqWitzMW11MXl3L2NpK21FZCtMRTliR2dpcTAzS1lyZWxjR1lKZHJEZWQ0eTBQakpsaFFnWm9IS04xMTc2REJya1ZnTmJ2XHJcbiAgeExsRE1rbEF4bFE0RGFhTjQ1aWpwWGYrbWJ0OGZuQWVXR1pqelpWdmthbmpUY2MvTEpNSVpGcnV3anpWN2Z0NkxUL3NPZFowSVhnZFxyXG4gIGFBNFliTy9kODFxbU1VUHJkZzZ2b2VHVGoxUHZ6bGV6U005ckJKeVRUSEFTTjFtQ3k4ZzNQRk1zbDlXQkpUK2MzM3FldzFaNTJBWWVcclxuICBjWnd2QWw1ck8zYjZhYTlIYXdRTEtZTEhLN2t4SXd1QWs1RTEyaGpvd2gwOTh5eHlsZk5WV2l2TXBDMFJCRU5FRmlNWTlQZjN5d0Q2XHJcbiAgaGl2NCtsNEc5OTcxSjRSSGZkLzk3aC9tZWtoYnhNdmg2cXQzMDViTjYzeUxBVkNuR25EM0ozNmZ2dXFycTFzQkdMampqYStXbG5pY1xyXG4gIFp5WHdHUnJHUU54UGh6QStUdnlYcHM3RG5qQlhJN1ZVTWs1bE5FZjQrejBLYkZTVWtVZHNtdDV2REdvYkpKRk95S3lHdDVFSjBETjNcclxuICBtSTRlMVNlWjNjS0RXN2R1b1FzMU9sc2pkUjc2Zm5JTUdnSTR5YVN2SFRvYi8wRCtPbVYzcTFTbUVLQ2xJUlV6d0Q4WXM2end6bkFNXHJcbiAgQU1zQmtJQ3YwdTdpU0MrU2NNRTZIUndHbnMvQUdsWG9zc0t6QUxoSU1hYUJDd0pyRnpYLy83U2RCNEFmUmZYNDMvVmVVdTZTWEhMcFxyXG4gIENRa0pKWVZBUXVnZDZTSW9xSWdvUlpvRlVleUNGYkVnQWlxZ0lvS0FnTko3U1dnQmtrQklJYjIzSzdtN2xPdnQvejd2N1h5L2V5WEZcclxuICAvdy9mM1g2bjdNenM3TzdzZS9QS3ZHblpLdlgxVFhxdE5CUFI1T1hreXE2T2ZNbnQ3NXN6dWQrcVlhYkFqaU9HY0MxSFhsRTg1RWQ1XHJcbiAgaUNZUTZ6SHpSUkVPa1VCODB0Ym1ubDBockZsRmc0UzlURUJpV3NsdDlyVStJaWtzdm9pekJ6d2lxYUNuU00zSXREd1QrNFUrSWJyU1xyXG4gIE9HMVlYMHlVeGFIbENhMmNud014MjdsSTNPWGx3cEZxNzRmWktSNEE2dGE4SlkyTlRab3ZNbmp3WUduT0dHaVRBcHVsYWlhTEVwbmRcclxuICBCMnU2Y0dDQkIyZEUvNWtoTXphWU5EQTJHcXJYNnozck04aklNU0pJdnUzbmt0Y25lc2QrSDZFLzVNWDdxSTFHNThPNTZONnNibFJPXHJcbiAgeTVpSnVNWjVmK1NoWDhGb29PK293MlQ3dXZtQ3Q5cWdhNEtvOHhIVEZ1OExxeVRNaHVGVzE4MTd5dFk2MFQ0bXZCMTZ6K2ltakd1eFxyXG4gIGEvazFPYy9oMTQvNkV2MTFMNWVqN3ozRStXTnJYamdlSmpya0FwaUhGeXBCWk53QzVOZXR3N3VzY2tJNnBxbEh1d1pFb3pBa3VxZXpcclxuICBpa3FsZnVNaXcxVVFTRi83c2RUZVpYcG12dDRUSnR6dWlKSEZoNFFXMTJmQnVLUThSSVRRZFNMdW9OSEJMdVJCRk8wZC9HU1RmZ3MzXHJcbiAgWHY4Wm1UWno3OXZQRGhwVVlzNVpYMzd0WFhucHhUZmwwbjNVaCtELzZ1Skx2cGR3aXVqUE93a2pocGZKbisvNmo0WUQ5OW5uMWVoUlxyXG4gIDVYTFZ0VCtUcjF6KzZTaG45NkNqMUNFOEU0aEhIQ2pRSy9Fd2lIZTJsN2dGZXk0VC8rME5iQUFGc0dpOHJNYjlQNExZT1l2MmVxWUxcclxuICBETW5jTEpzMmJUQ2lvUk93eURYN1NLbkxkRXNlSng1WVpxUWtpRWRvekpGTUlCN0w5QndJVWd6WjJBelJDanJuWWNnSTBCZmNwZ01VXHJcbiAgVjl2K1llaWhJUy9leWtlaHB4MkpVQ1orSHVRREVrQkpqK2tueW1TNEVOdVBRNG1JbTEzNmJNOThVK1htdVI2a3FWMWFHbHFsdWFsSlxyXG4gIEVjN1FQWEljZGtSNWRyMFFqMEl6YTlWcm1GNURRMWVFcDluSzVJWnRhNlJGT2FMS2oxNnlzaWk1SVJhWXRKSTJUa1BUUEV0bXo2N1hcclxuICBvTjFveGgzRktadVloWk1YWGR2elF6eE43NDEwVk43cTZhSG5keXFSWUx2V25Wc1JUeW5SSU5SeXZDdG1uaEFQK3Q3WTZIdjNNd2FLXHJcbiAgaW9ydG5PMU5IbDBUaTUxQ1JjVGsrVEhCRGxicmgzNmdGTWJpaDdxMmY0cys4STYyUnAzZHI3TThyc1BDVFRNNTFqb1FzRjFiVjlnNlxyXG4gIGlacVZiMXUvYUtjTFIyTDNrNHg3ZnV3K05kL3lvbmdvRzNSQmZZWlBVMkx5bkYydmN0SHpOaTR4QmE1WThvSlphMkcxQm5mU1VMdlJcclxuICB1REFzci9qU1MwcEtqRE1wM2Y5NE13bmV0dnoxMkxYOEdvbitSRWQ4L0lSOGREUWN4R3ZRcWVtMWk0WWNtQ2lEMkVvalVSemRpTlpSXHJcbiAgNHNHM0ErZE1melhUeGozUHo4dVNvdjE0T2pvZjVlV1hIMmhiclpwNFZ2TXdEc0hMTDhYeitrTTRmZDhNM2hkRXhPUE9pUUFRRXVPVVxyXG4gIHREemZOOStaSlF4Q3FCQ0w5Z1NkSk5iWHkxRlRIWS9zQzN6M081ZktqQmtIeS93RnkrVDY2MitKY3ZjT0R6N3dLL21VY2k2N2c2ZWVcclxuICArSjFjOTYxYm85VGVnZjFGK3ZjcjNpY3VoT2Y4STU0RGg3N1dMa0E2RUkrTTRzR1NaY1FqZW1vV2VKd1hHTEpqRVkzYW1RaDZsckhmXHJcbiAgNUU4RUdvK1M4ZG9lalpjREdEaFIxR0QzNVQybXY3RWloZG1kVXJGdWliM29vUGNvTFZYMk5zZk4rdHhUS3VzKzlJUHZoWGdFcGJnVFxyXG4gIEQ1U2ZLVGJUdE1WdFdnZXVnd1ZraWNXQmVwNnRablB3WjJRZDk3ekU0Q2ZPWHl3ZFBzYVFKZzdYZ1JXSk9UOVVncEdsckx0dFdhcURcclxuICBuZzhQcmlDdi96RGpRdUF1aHZmcGxQVWJOOWw3QkZyWmc3eGdjQS9Da1VBSWNRVFJEVmxBT0pqWlljMUNITzZEV1N5TEFObW5IZXN1XHJcbiAgT0EyM1V0UFpyTTdTV1hPU3FqTnhPQlI3WnByUHJOeXRZL0tqYS9pOU9hSUtjUTA1RitWcHhNdHAyamlPcUF6bmNMT1BHVElXVEJBR1xyXG4gIHhJTWdpRzByWHBmKyt4MnA1NWU1WHlRdEd6Z0kya3RiKzIvYjloZmdFdm1Udm1qdmtIVUQxbjUwTUFsQXp4WHEwajZ6ZjBmbzlNVVBcclxuICBacnNhU1J5bW9NVm93dHBCcWV1aUp4WnQ3dGlJem1xS3JRZkJLZytPYU9zSFQ5aDQ0UjRRdFdpclZwZTJyQy9SK1BEOGJubVVTNXozXHJcbiAgNnpGbVF3Z3k1RHdUSFV5QXlZTmI3RlA5c3F4ZnQ4N015ak15bFd2TVNEZUNBcGVDR0FpeEszb040MGhLc2R6U2F5ZXUweTBlaGZ5WlxyXG4gIEMza01ORUtjaVkzR0tjUEtkbHptUUpocGdVa0dzMzNXeFdEZWl5NE80d3N0NmtDMXFHNHlIUUVSdTI0VTF4ODRlN3dNMUc5YUpKbjZcclxuICBmWEFmbVBreUR2aytjYmpJTys2TkV5SEVpSU5uaEtHQWN6SDZQdXo1ZWZzSmlFWGpVTks1UWJJeU91VzY2eStSVE9YNDl4WE9QKzlrXHJcbiAgVzhQeDl0c2Z5TkZIN3B1bjNQejhYTFBrb2l1OWxjZm4xdWJOVmJKMDZScVpPblh2NGpRQVYvSmZ1dXlIY3MxVkYwWTV2UU92bzlPSFxyXG4gIFhWY2dMeENQOU1KQmtnMnlDYVVzOEhqaU56cVZpRmhXSWxNVHNYaVU3MW5kOG1QSlJQMGU1UUE5MnlXclM4WHdZK0F4L1kwVklaRzFcclxuICAvUU9wVk9UUjVuNEdwVytmUW5OaHNYUjdIMFhRRFFueEV6b1B4Q3NCQXZIZ1hIMFg0Z0ZTSWQrSkIwZ21TVHkwSG9vNWxIb2tMSTk3XHJcbiAgOEpDMGY0UkVrMmxDUzlzNTVTcmdOSXFjY0hBS3MwaldvQVRpUUJrVTR1YUxTMFA2a3I3MkNWbTVjclZrNVdVb3N1cXdXY1BnWTYvelxyXG4gIE5tUFg4T3NUZCtTVHlOYy9MS1pJKzNvTkZ1VnBYQkVNTTloU2xMV2F4blcyTDlMUzhsV3NWeGh0TTJBVzlLSFh3T1FVS3lCSGF0R29cclxuICA0ekwydy9XVGNRL2llUVRXT3lJV0JtczIwb2hxVEphdFpYam1sTml4MVdlVVFLRnlmQ0FLRHorS1pweExaTk5ydnpiM0VCa1phYllHXHJcbiAgWk9LNU43c0JRUUwwU3RIbEFUaFNqQ2RzeTk0WW1KSTNBdHBOZ0xJMTRWb0FDQk1JYVpzZGE5enl0UW5iNzRMOGdlT3NuNzdJYmFraFxyXG4gIE1jeGUwUVc1bUZ0L1FxaEhJaStXMzEzSlRIcnJoMDhiOXdseFpjYzg4cHMydml2YjYycnQrV1prWk1xaGh4NHFkUU5QTTA0UndHTExcclxuICBGbEhxSDF3bEYwUHhidTEzb2pTTXJoVmRyN2M0bmdLWVRQVVpoWkw5RFpzNHNLN0lYT0lyd0tHZ3U2TThlNHp3RHF5dXRvRVZGLzdBXHJcbiAgYU1lTzBLNkdwSW1GZkU4VFdxWWR1ellzbEx3aEV5MkppRFV0UGNlK3crRHRsL0lzUG1Sc0FJbjNFY1Z0NHFHd2MvTlNleDlSNHhIRVxyXG4gIDRyRm82NlozNUNmWG55K1hYdnZGS0dmZjRjbW5YcE16enI1YUVKSzN0QzcwekgyQXZXMUExWC9Bc1ZKZDhVcVUyanZRM285KzhCWGpcclxuICBTSFlIek8zaTM0ZEJGK0pSb0RNUUl4NXhpTmVJZjJCUnhJSnVaUkxnOGZodkFtTEpnQ3A2QnozWDVYU1hpdUhId0dQNkd5dVNsZDRwXHJcbiAgeFMzTFpPTkdSYnpSU3kvSXo3RXRhU0VlSmdPTmlBZXpiUGJtQ0xDdnhBTXc0Z0VHMUgrc2lzeEN4RHFpZHhlUU5JZWx1V1BTL2tZU1xyXG4gIDU4aVB6cUVvaCt1QU5VZG1ETGVCbDFpSUNPZlppOE1XL20ySGVKU2JBcFd5L2ZyNjZ2bU85ZzdwMUZrbUg1L1ArdlZhOUNPSzI1RVFcclxuICBwU1R6OFhqSytnMzZZYWEzU2hCUWlpTnV3Zm9IZ2tJNTVPYUlwbENFdzJIUUZzOEhwRXQ3dUE4Qk1aSnY3ZHNSaVdRWWliRjRPSklpXHJcbiAgblRUWit2N2pKb2FDNDBNOFZhQWZQem9JeEVrUUUvb0VRaUMrVTU4M2NhMHMrZjFIR2dmQjdudmgvckM0SVd4cThyMWRBakJ4WUpNcFxyXG4gIHhIR05TdXgyVkh4a2hHaG5kTENHQlJGZFNIT09JNGpPUVBhMDI2a2NCaUZtMUZ3N1BFdnVoUU16WmtMeU9LeWUzVytxM1JmM3gzM1JcclxuICBKcTQ2NEJaeGdNbnpDT0t2Wkp0NjdTZ2VucWUxYlhsK0xxUUhIWFM2aVpGSUR6em9FeWJ1d21SWE15UTlQVU1LQ3ZKbGVZMmJNZk51XHJcbiAgU3llZUpGVTZTYWhlK3FwaEN4TnRUVGpCWE9lenRxZkx1d3pYNlNYT3BtZDl4OHpVZUlyMDA1Q0ZwT1JUSDkwSUs5b1p1NHd4aUNRVFxyXG4gIElPTDQxQXBXWEhDWW1tbUhmUi9hWjdzR2Y0bTBwWkpwUFJCcHRTR0cwcVJOY0RURTJ6UUVERy9KbEM4c205aUxPTXM5Q2dTUkZ5YldcclxuICBpRU85M1FDeGVDeUs2NlBqcGpzUittL2g5Tk9PbG11dnZ0Q1U2aWZzWWRWNWQvakpqZGZJajI2OHcrSjRWcWl0N2FxTWYvVGhXK1RFXHJcbiAga3krUFVudUhtMzU4dFh6NThqMjdTa1FBMEFYMHRTZUpSMTUvMjhQY0lTclovWGtsMHZHV2VDVUJOTmF0alAwbUMwU1F6SWpYN3JXd1xyXG4gIEp1T2xFOUN0ck1mME4xWUV5Ry9iYUE3akFJeVRjckxkUGZ1NmxqTGJ4Ti8xRlJDRkdtV3pjUzRXV1dMOUY4VEQyckRCTENhMnl0TlpcclxuICB0d0Y1T3VnSjdkQVNESFliOE5FUkVBRHRFWWZyY09JeFdKcVV1SVYxRzFpdjBCOWZ2NkZjaHhJT2lBZm4rU2pENWsyTmlpUWhrTGdvXHJcbiAgU00rSlZneHJmZnVBQ2ZYQXpCZGtFOCt2WjUyQWhzV3NHamZDNGU1RVFDUk9PTnhOQjRQRjNJalFqaUpHdUkyUzhjZllPZFkyOUdjdFxyXG4gIENmVTA3UWd1UW5JaEw3cWU1ZUZHZ1hTRTZLM042UHpnS1orMGMzenNITWptT3pyYXJBMmMrWFhxREoyMklCUW9aaDBwcDBtOXpuelpcclxuICBmR3VIcGpFclJ2ekZnck5kaWpCNEEwQ1lTTEIrQnRFYTVkQlBJQW9xR255QUlocy9NQzNPVldJYTB1YWpTOHRRbm1kUC9TS2Q3ZUk0XHJcbiAga0hmYW9zZ2ZzUWx4Q0pNUkUrMXZaM3ViaGNsNzkyZlBZV0l3YlRVUUZUaE9SSU9tbDlIenU3UU40aERLaXNVdldsMDdESm5yWWMrT1xyXG4gIHc2M1FuTUJFNmFpTXA5TWtmZm5mSXgyUXUyNGZkL0RocHBlQys2aFk0bTBQbUhpS3JZaXZXdkp5aE1UVGJFMEpIZ3lzclhpN0hJbTRcclxuICAzNXRtYUpnYzEzZzJRRGRDdkdiVkhIT0xveWR0ekVKRVdwVlR0UWxRM1JicE14SXJMbDlYQWlGQng2YzNHTFZKR1A5dWVKdFJXc1BFXHJcbiAgTjZXUW9lOGZJa0lLa1M4UkpvcHcwVTVFSUJ4ZGlZaFpaT2taSm9KWWNERnVjQU9QcU0wYVNFQXNIa1hMQnZhVlFUSDNKZjh0L080M1xyXG4gIDM1YUpCNHlWVjJmUGxmLzhlOS9XY2h4KytDUzdQTG9MVExINzlDa3k0NUFBUngwMVdibHNQNzh2TUhQbVpGdGN1S2Z5K2dhU1FDSVFcclxuICBqN1NjWXNrcVZZVEJpZkJVTElqaUJ2RjRCSnJWSmJlWElwNFhQOUc5VWdROXlnRTZNS0xZbm1CM1pTYVdOa2pWMWszQ1hqbloyZW1TXHJcbiAgcm1POXJLeE1LdE5HR1p1TzdKUGFObXRXQUprQXR2cThOK0poc25EUGh6MEdrc1FqeFhiaXk0OW13cDdYYzlDSGdXL3hxRnc0WjRwRVxyXG4gIHpUUGlzWjFkRGdkYWlOa2paYzNoSVZ5SGlheGNSNFZsRlIrbDc4MnhTZElHVDVlK2Zmc3FRdlFkNXRyYk8yWHdqbGxhTkNDdjVBZkpcclxuICBnWnRyNU4zV3J3U0NnNkQ0Q2wrNGpGQ2UyVGhtdGVaalNwOEpjdXRkeW4zNEJsVGVycGQxNUpJa0doR0NzVFJJUitOS1BCd0JvWE5ZXHJcbiAgSmx2Z09QUlprMGQ2MC92LzBkNnpNSzdSeXZRWk9jM2IwR09ISWxWYjBFbFpmZVp3QnlEelhTYU9tQ0N0K3RGRENMU2lyYXkzY1BDQlxyXG4gIFJsUzVUUmJQWVlFWDJtT1dIZzdyYTNTd1VqNGpDeDlnM24vY2VEalJPTUNlRGUzU2gzQ05UbzYyVmtYNEI1bytqZnJjQzBRR2QvZ1FcclxuICBOYVp4d1Zxc283WEoydUwrdkwvTzFiQ3JIU1l1OUlHOVdHaURHVFF1V2lpN1JaOE5laUI3anRvTzVmUW45djZpdE1YOUlMNXF6UVpwXHJcbiAgVTZ5QzdnTngwdVlOUGhFWWNJQnlKd2VjcW9Ua2VWTzZXNTRTa1lEUVEzMGZKejNiOVRqdm0rZmtSNGpuNkJqQjdKY3ljQ09NTXlja1xyXG4gIE15d1BxekJmaEtnY3lJWUZOaW5ycThRcTdJWm9Zak5lbWg3MlIxeERTMGY1NGVEUDRocENSRnFOaUtRNEVWRUlSQVJSRmFXY2lMam9cclxuICBFMUVsNSsyZUZJaWJCYUVXWkRKcGtRVDROWUNpNWxWeS9WZk9sdHppcE4rOC94OTQ4UDVmR1JmeXFmTytKczNOTFo2NUYyQ0JZZUJDXHJcbiAgZ05Xck4wcEZoVTlxZ2R0dS9hYWV2eXRLN1IwUVlWMzc5VjlFcVo3QWZNK1U2RHlpUUR4UzllUFBHY2hzUnhNR1VjUUNqL3VMc2FoQ1xyXG4gIDEvT0piR0xkeW5pUlpBbURXRHBldTBjNXpuYkppcGROL0JoNFRIOWpSVWpVVnk2WHJWdmRIcHdaMStEQkF5Vm53RGhwYUhXRVFCbWNcclxuICB5YlUyMVpsZE9jQmc4ZTB6ZXlFZUViZUN6SjhWNm9GNFVLZHAyN29ZOGVDZmo0dUlIMEhSeVpuNHdDZk9IMXdIQ0xtOXFkNW1vQ2doXHJcbiAgV2JWTGlEOHB1QTRRaTNNZ21PUXFFVkdPQTNOY1JGZUlQWWkzcE9SS2Z0TmEyKzlDMkZ0RUNVaHhjWkcwOVptZzMzcnlZMGQ4WTIwaFxyXG4gIEdtdmNiam9NeEVLK2Q0WTdLVXhKenpDcnI3Q2ZCdHdHeWtVY0Fqb241c3BJdTQ4RU11TytRWDUrdjU3Mi9FUmFEMmJuTEVpalRwSE9cclxuICBBQkhobU9zWFRiUDRFck5UbEtIdU5pWkZ0bnp3aENuejJSU0x2bTdIaGJpV0xWVGtqSG0xNjV4NGh4Mm1MT1phN3BLRmNLQ1VibjNZXHJcbiAgM05ZRTdxT2twTC8wT2VCc2E0UDI5Mzc0ZlNUUzBYdjBnejZYMnZVWVIzN05VclBvSTZRZTNHNUtaNHB4VE14cVFWZ1lJakN1c1B4cVxyXG4gIFV1NEZSUzl0azVmSlBpMTZnRkJaUjhGejN2eitZeWJ5NGlETmRTQW1tQkN6RDRmMnhQcVM2RnNVa2s3dGJKTTFjLzdGclp2anhMeThcclxuICBmQmw0ekxkTU4xSmZ1Y0xlTGZvclcwT3k2RGxiNEVtY051Z1RmOXdQZXBFRzVVRERXaDlNZitObExLNFFybXQvRmhlcFhmR21UY3pzXHJcbiAgL1VUbDBJZjBHM1dZbWZHaVYyTmRDM29RaUxYcFluVENnb2t5NGx3REx1V3hLQjdMQ05Ib0IrVjZxMzVYWnR5Um5XZWNLT2JWYk9TRlxyXG4gIHBWWjI1RnZMUEVQb040K0JBK2NaaDhSNUwwd3lHZS9CS0tFcjZHU3ZmYXY4L2pmWC9WZks4OTZncEtTUHJGcTFRVDVjdUZ6ZWZHTytcclxuICBYTFNQKzVlakFNZFgxc0VIajVQUzByNUtSRFpJYm02T3VTc2gvZWhqcnlwbjBYZWZGUFNVZWVqaDU2ek4zc3FiQ0lzakVBOFNPYmF3XHJcbiAgalFRUVJTendlQ3phRGNJUUFEVFdyVXp2OWVJMVlpZDdLOWNscjN2WlpOcGoraHNyUW1KWXpsYno5UVBDVUE3UExLL3lTc1pJVllPdlxyXG4gIFVQVUtTZ3lxVi9sTVI2R0gyRW9ITXg5R2tuajRCanJwY0d6aFk0ZkZiV3RXNG9IeWpYNXdaMGxFMCtWRDFvL2JQbkQ3eUpOeDNGTWdcclxuICBQMmZXSC93SndYWGtHaEZKY2gwUUNpTWVoUDBqbHlUS2RaaUxkWTE3ZTJtU1dqeENXdHRUektVSjBOVEV1b2ZvdkNKdlpwSll3b1E0XHJcbiAgQzY5d2ZBalJvRC80bXFLc2N4OTZONmtaOW1IVFA2eFZRQnBzeFJ2YTlCa3dSTU5ublVtaTRZUWFLeU5tMGVSM3RMZFlHb0l4ZU9xNVxyXG4gIFNqemloSTMrcGZsTVhhL0xNNGV6b2sxRVNKeHZhOXlwZzdkVFNnL0NCVHZQRlE3aUFDVWtlcFFmb004UHMrYlFIbjF4a1V0TlRZMk5cclxuICBBU0E5UFZYMjI4OHRwUDc3dysvSitoeU9lTDRlbW1uM3dmTWx6ams0aktKeU9CdzNiMlhtVFo5QlhnVUR4MHN6cHExYXg3Z29MUXZoXHJcbiAgZ0hnN01WMWs3ZG96MXpaQmhOczNMckM4c2lubjJrSlJ1N2JXcjE3K3VoRmJUM045bm9IMlpjTUw5a3hSRXZlZmNLb01QdWdVNjl1Z1xyXG4gIGcwODNYY25XaGM5S2hSN1VHM0NnY3lTNFJlRWUrQzV3blVJY2JuUEFoSlBNbUFJZENlWEp0K3NSSjdUcmRzdlRvOS9ZSTAxTWpGaUxcclxuICBQQlpFc2hBUnNTMk9HTkdOa045WE9SK3NDbGxqZytOTW5ETXk5cEFNNk1VUzdSRnFKUGw5YVJqU2hLU05FOWxaWVhuT2lmZ09uRXc4XHJcbiAgZHZCY3lkZHZtZmZnZWtzSDhsanJCUlNXNFJIWUo2SjJqUWpLMHJiSUowNmVJZmw5WFhMeGY0WDc3djI1REI0eXdFUlpQNDF4Rm5zQ1xyXG4gIGxONzMvdjN4S0NYU3QyK1JPVXNNOE9UanY1R1RUdDMzeFlWd0lYR3VKZzVHUUFMeFNOVlVaaTd5Zm52YzNTQ2UwMHRjZzU1MUFpVExcclxuICBkQzIxbTBvOXlqa2tjMkxudXBYMW1QN0dpZ0NETXpiYWJMT2x4VmxCM0hZUEhUWkVHbHBDUVEvTlhEZXl1RUpaR1lnSGpnN2RIWHRYXHJcbiAgNG9INUpiTVpKeDVLY0pSNHBIUzJTMVprc2hpSWhRMWU0dDNEWHM0aDV5MFlNTnBDWDJlQnZzT0pCOHBGT0kvQWRYQ3VxVzZqRVF4ZlxyXG4gIFRiN1JPQTlySy9ZUk54UWZMTDVQdEhYYm5vUGxWNjh6aEJ6SzJxSXpIUWQ1Mm9aRzlEK0pCSm1CMGw4SUJ5YWViZ282T29IRUtFTTdcclxuICA0V08yZEF5SmNzRDEyZm9MTFFmQm9IMU1nQkV6cFVabHZRMFgzV3lhOTVpSnBGanJnUXdhVi9kd1gzQklUaVFPTktRTFp3UTNaaUluXHJcbiAgUTVCNlBldFQ4dnFHd0Zuc28vbjlWdDloSHBjaEhBQ3JzTnNuZnpkUnRzZGhiZTNwNERyeGE0VWpJcVNKdzRsWHZHK2E4TEpSTzZYalxyXG4gIGo3ZnppSXpJUXh4R09aQWw0dzVQeVFXSXQ3Uk12WTVSRjNFVm1hNGx2Qzg0RS9RczFHOXRxQkZjM1BpMS9EekhwbFZ1NGNPWWJhdXZcclxuICBVa1RUeDY3cjVXS0VaRkdTa0tUbkZsb0lFVU44aHE2azM2Z1p5b1VFWFV5cXhsKzJrSDFMYU1kTnJiMWREdnB0M3dYeEtBOGxPM245XHJcbiAgeHh4aGVVeGlFR241WkVISHZ4SlRGK081WjEvR1A5d1lUamQ5elViMERjVytKMHNUUm5rV2k5SVp5b0VtaVVpcFdiaWhlekVDcnB3ZlxyXG4gIDVZeUlzRkJZaVVpd21tT2NCc0xCRG9pTVRRZmFWWnE4WVlPTUhsUms4WThMWnIzeU44UFBQN3JwVGhPMTdndkUzYjZ6dG0yV0VpQTNcclxuICBsbkQ0L25lL0xIZmY4KzhvdFdjSVZsaTk2VUpTQS9ISXpzNlVJWU1qMTcvK0xCU2lTQ0pOVkJPOW5vOFY2cVZNL0RjQnNhUy8zZ0RkXHJcbiAgeW5HMmU5Wi9CU2xTWFYwdGRYVzdERkVBT3RRbEpYK1lLUE5xNXdIMEhuSGlZYUlxUFdmaWc0aGROZnQ4aUlkV2dYZ0FnWGpnNWJPelxyXG4gIHRWRXlJeSt5OGNHYlNCTkdlWWt3Rm1kMmhiNkRqOGk1RHR3OGJOYXovaEdaMnhFakh1V21kSVROaDJDQVZDQWlibVdTL0RBRFFzbHBcclxuICAzNjdSTkZPdThUMURRSHpWK0NoanhTQWNjQnhtb3F2WFl0RWZlZzFiOEtjaDdzU3hvS0xkaElXVnpwSURZclRyUmNpSE1NeHlTYU9rXHJcbiAgUkt4Q1Bqc3Nna0N5bEx2YVBCL2lzTlJFRTZFdVlpeDBIeEEyUHVieWFaL1dTVTFmaTJNQ3lyT0NxekRYTVZ3cmNWMi9saWFzZmNMa1xyXG4gIGVUMm45NTdvbng3Y2YwMXRyY2IxWVNpMHRMUjZ2ZWpZcmpQUmNJVDJjQkVlOG5aVzZrdzBYbmFUSDNiOTZKa2tEaTBUdnphSGxZdmFcclxuICA5Ynl1L1F2bmlic2VKbFVKeTNHV2hwRER2VEFPNkQ5eEZpbGlGR0E2Q2RwbHhKZ2lQMVc1dWsvWnVBcGpnZk81MitkTHhRWjlGOHE1XHJcbiAgdFRmVlN2b3VmZmVGN3NvLytlNDhQdWlnTSt4b1YwNlIrcGhtVnl4K3p0dGk3Q3J4UnRGT21uNFBtSGlTOW1PTktkcmIyNW9zejhzbVxyXG4gIDc0azh5NmV2ZG83dkFBN2tUUXZSamJBZ003ZS9UbVEwalg2Sm5SRGgxbkM5d3VRcE15SW9mQ2ZzOW1qdmtuYjRJeDU5VXlIZmpuQk9cclxuICBEeWNpcmhNeEk1UnQ2Nnc5dUpJa0VjR2xDUlpiRUk1Z0lLT2NpT2ttSVNqS0tXby9IVktrcXFwS1RqeENpZnZIQ0NOR0RKSGYvL2JiXHJcbiAgcGc4NThjUXZlZVkrQUt2VVFmb1FrRk5PbmlrUFB2UnNkSVpGaTErVUwxLysweWkxZDRBTCtlNFBmaCtsa21BRWhJZlpudG9oVzJ2OFxyXG4gIEFmR1l3NjhIWFhKNmhTN251aFdNTlJHRFpBWXZNQUc5bGV1UzE3MXNNdTB4L1kwVklkRy9kWVZVYk43S2ZOck1ydkt5TTZSMG9BNllcclxuICBsRUk3RDlpaXdVaGh6c3dmYXh1QUdVNlFkVUk4ekE1Y3E1aU0zVGdSSng3Y0E2dXZ6ZVJabjZmZFV6UlFMUjNDS0QrUnR0QXRyVmdnXHJcbiAgaUwwN015cnlJUjV3SGVaVlZ3YzQ2enA4ZlllN0lHR0d4a0tuTGx5SGZZeGREejdhcGt4bDFldFdTMU56bXptVjIxcFpMY1d0NnlJaVxyXG4gIG9zUkRQL2pnYW9URlhDQVE2aUVUeGlNc1JBVEM0WDZZSWxGVitQZ05LVVNJeDY3cHlCQVJGVzVBVUhxNkoxazh1UGJUajNHaU5oMjVcclxuICBBTmM4cklvMnpYM0VsSmVJYWdaUE9kYzRHK3U3SGxpU0VjL3JQOUpGUHRGMU9CY1FVdUtJcFczMkg5Mkg1NldaN1QveHpjVW5LOUZvXHJcbiAgazlab0VSQXVYblpzOUhNVzZtakJGUXNoYVE1YkxhMXBEaFRqSVo5MDhkQkppc2lHbUJ5ZGEzQnNtSE4vRkY5czdRWkNRNys5UDNwMFxyXG4gIDZ6OTlUWjczNXhqdU54RGtvWWRlb01YMGVlZzRHS2lJbmJ4R0NJZUdCYWJyU1pXTTdDTFpQTzhSNDl5c3JqN3JiY3RuV3ozU0s5NTZcclxuICBTTnZUOGFMVFI1VG9BMHBMazMySlFvMGs0eHFhcTMzdHk4Q0RUalB6WHdoSnlZUVRiWlU3U0pTSkFtSXRUSHdaejlTMVZmbGEzN2lSXHJcbiAgMEg3c3NHdEU0NEI0djdGSGFaZ2l0V3lxcFJNcFZzbHpIdUlCcDRPZWp4WHRqRnZiQTE4blVoQVBMTUxnWlAwYmlIMWIrbllzSG9XSlxyXG4gIGMxRTZRem1wUUVTWXBQQytBSFJuNFR0MFRnUnhGaXZVblZqd3JTUTRFU1U0VExUeUdwYkwyUDFHU01rSTVlSS9acmo2cWd1bFQ1OUNcclxuICBlVTA1aVh2dWNyM1YzZ0NGK2s5KzltZUxzNWh3d0lCKzh1SkxiMWthZVBtRk8rVzczLzlEbE5vendJVlVWdGFZUGlVTyt0WkUxcXpHXHJcbiAgeWlKRlNncXdRTm9UOE5DamFJaFlrTWhVNkNYZVc1bDRNa0NQY2c3Sm5OaTVibVU5cHIreElpVEc1RmZMMnJWdUhaV1Jqb0s4VXdZUFxyXG4gIEdTWVpmWklMSXpGSE5UOVFta1JNNE51bnVwdzNQU3ZIeWpGZ0EvRkFod0x4OEpYTi9LZEUxbGErMGprTVRqL3BIMGc4M3dkMjhnT0NcclxuICBZSEV1K0xFQ0VRWGlBY0hvTStKUW0yMDY4V0I5aCtzNDhGN0tpdDNBZFNRK3lqZ0NpT1doS0dYQzBONm1pRk1KYVZFdSsyLzNNK0poXHJcbiAgT2cvOUNDamIzRkJqL1lGd1pMRFhCQXBWSlJyQmdSK0lvVXZiVVo1Zko5MUZWTkU1Mm9YdFJ4UmlKcXdaL213aGZPV0huSy8zaXFMWFxyXG4gIHhWTmV4eEcrdHg4UXFLZDdJS0FJb1laemZwNDZTaWcySzlMV2NNTTc5MXVaOVlyTXJaeGViZnVtaFRLODJSZFVVVTJ6SkRzblM0bkFcclxuICB3VW9RRm1wNVREZkhSYWEyL3I0NDJQdUNNa1lBbFFqSCt3TGljUVc5cC9HRVhLUmxpOHI5Mks3dG11OHNSWDRZUkd4YjhVYVN1R2duXHJcbiAgTnMxOTJPcVpxRTc3N1NJN1A4SXpzQ082UjdzWGpiUGFtanpFZVVPbUpSMGd0cmZza2lKMG1WRjZpRDVyeWxLUGRGdTBIZ2lDa3BPVFxyXG4gIGJTN3R0N3p2ZXBKQWREaVhpRWRodUQ1eExNc2dzcGo5c2hZSmpoVTlDWHFRL21OZEZBV2loU3RDUDJMMTlkQWZENk8rZVo2M0hmclhcclxuICBkK3lSdmhwZHgvazI5Q0pLUE53bHZHK0RBUExtbStEQU1nemludHR2aEg0M1RyQzA4ZWc2Zkd2UmR4ZUYzZE1RRWI0dDBoQVI0Z0J1XHJcbiAgZ2hLY1NLRVRrZXppZ1JvbU9SSFc2d0RvRHpkdVdDOWYrK0twa3Rmbi8yWjl0VHRBbElVUTZ2S3Y3Tjc3Ym5mNDNuY3VOUzRFSlhxYlxyXG4gIFRwWnFhbmJZd2xuZzJHTU9rYi9kKzVURjl3WHUrdU9QNUpJdi95QktPYVMrLy81amlWMnJxbmFpa0FKNHlDSHdlQ3phRGV3MVJLQ3hcclxuICBSTUlqdlZhSlFieDJ6OUo2ZG04TktPeXB5T3JWcTZXNWhZK0Y4YW96eGVJaTJaa3pTbXBiSUF4aXE4ek4xWGpVQ01pY1diSTUyNHM0XHJcbiAgRDRoRmVsWWdyaW5PaVppQzNIcTRCK0pCL3dsakgwazB1RDNmOVIwZ1VJaUhpNjhnSHBHeVhHZHhFQXdVNU5RMU5uNzFIUDFRVUpvN1xyXG4gIDF4RlkvSGo3Rm84aDE1RG52bzZVZ0VTcmY2dTJidEI3ZGRjaUxON0N2UVpJb0EzM0pFb3dURW11ckhxWTVjWS84RVE4UWdMRXpkY1VcclxuICA4ZWdjYkQ4cm56R3hSZmxKV2V6cE4rbk0yRVFueXQzQmRXa2xLUmh5VUtTL2lOcVAya21rWTlleG84dTVOQ084RytZOFlQY05zdFlUXHJcbiAgUmd5S0ZYbFRKb1NoSFhOZndpdmdRZWpZS0N3c2lPcDUrNGgvaW9aTjhudUpEaEFZSEFRbXdzWlpSZStRdzRrRUMvMDBydHdJejVUclxyXG4gIDdGQmlCZUpoOVQyYmFISGZLTXR4cWdqeXBWLzBzMnpTMlJGQjhZUHJkZUZXNkhkMFlEc1pUM3RlUkd4RFdxOWZPQ3hhcktmbmtOWFhcclxuICAxNnkxWjQrNU5DSmRjNXFvRTZyU0FRTWxkYjl6WmRDazAyWHpCNC9yb1lTRWV0R3pDUEZ3T0RGSmsveVM0ZVpLSHU0ZEI0NG0ydElEXHJcbiAgMDEvS29SOWhXMTFyUXc4OEFPUHJDb0lTZjMvaHZJYzhUMCtIc1kxZXhEZ1JuWnlnNnlIdXl2VVVuWUJFRTZySXFDU0lmYTA5UFB0RlxyXG4gIGJSRmFQUG91OWNmQ2tLYmVMbjFYcElsakFRbVlDeFRsSEsyY1F1QkU0SFpvQS9FcWVSUEtzeVFuTzAwdStOd1pWdTUvQVhqZlpidGFcclxuICBlT1o5WFdBSTV4QVU0SWkwM3B1N1NKNTVkblpDSC9MQWZUK1RzODdwdVZ0aWIwQmJjRUJidHliTmdsUHBGRkErWnFxRlhjRWZta012XHJcbiAgY1o2OXgzWVBWcUJiM1NnWlhvcEJ2SWhCc3B4RDk3TGRLL1FzWDFpLzJQYjN3RllaUVA4eGF0UW9SYUE2c0JSTWJHVStteXlwWE1ZR1xyXG4gICs5Q3hxZ0o1aGhQb05veVk2RUJEWmg4bkhueVl2UkVQUXlEUkxDaWVSenlFd2ZWNjREek1YWVBtTytlaG5FanhJTFA2Z0hEUUFoOUtcclxuICB2OUV6OVJ6RUE2Vmo5RkVReGovNGJua01kajdhZ29JOFNKY2ZxU24yUEV5QnJtVXdRMDVUcExsTHVRNFdUckhWTHZtK2Nqeldianl1XHJcbiAgQi9Hd1ZrTXhpK1ZoUzQ5K2czTm0rcXY1UVR4bDNBYS9hUm1tdjZFTXE1SWhIc1M5ejA3OFF2c2NJVzJIbGdISndsV2dseUFQVi9Kd1xyXG4gIEIrRThZUmF1OHpXRU1MQlY3L1pOSDlxaVBEMXBNekpqeC96VjJBU0Q1OG81YzNPaGRXemxOKzlRRVJGclR3d2hXVG82dE8xd09QRklcclxuICB4bDFmNU8rNlpXZUZ6VkFSYzVISGVlSXNncVNmMUxFOXZYbTIrcXpnWERhKys2QVVEenRZcWxmTVZpTDhsQmJwUmxEczRKbDcvZmg5XHJcbiAgUTBUTEQ3MGdVWTd6aG9CNTducjlpdWV1dHh2R2tBUmdqUkNJbUluS3dBTlBNUVM2K2YySWtFVEV5dDVMUEc3WGN2MElQc0hLbE1NY1xyXG4gIGRPQnBkc0NSY0YyNGtaTHh4L3NZMEhUcGhKT2tyM0xUN0dOaXVwcW9ieFphZThsMFBBK2RCNXdJQitPSTBDWlMrbDNBaFRPaFl1OStcclxuICBJeUsxVEw3Y1lqRVFJMnVUbDJ4cFl2NWVOSkZJRStickdHd0owZ0RXVysxd0gybG1BYWVjQ0J5bWczNDcrcTBZTVZFdWhIVlRIMzc0XHJcbiAgb2Z6MnBzdmw3dnVTZW9iL0JmenovcHZOOTlVcmlzaGYzOE1DdnpqODRtZGZreDhyRWNHTTl3dWZQMU9lZitFdFdiYk1wVElzTHR5K1xyXG4gIDNaMko3Z3Y4NWE0YjVhYy9kN0VZb0UvWFljT0t1VkVzQXA1dkJCWk5wR01udXNlN2xZbi9Pc1RMeE1EeWVwNUk1c1RPZFN2ck1mMk5cclxuICBGU0V4UEd1THJGbTd3UmJOWWJuS1F5OHJHeXlyR3NNZ1lEWlJhZHdHZ0dpTGdZZzFCcUtHMENEY2hpbldkWURCdXNhSkIyYVZMc1pLXHJcbiAgRGtJN1l5RUQxL1BzanpDS2t3ZHlnbkMwdHpZbHhGYkU3WU9CSFVkVXBUTXFSQ2w4Tk9ZRVR2dkh4d0R4c0hiNU1Pd0Q4YmgvY0xTZlxyXG4gIFJNQnNKK3RPNlZKa3lHQ1U4L1FOL05GcEs1QTdPNVRyVUtMSjRqK3VGU3htOWtnNG9qajk1dm1FZkFqSHB2bVBXaHczNXBURE5ES3ZcclxuICAzd2lidGRyTVZkc3ZVTTRrSUtCQU9FSzdoS1FEOGdqNWxoZmxnOXgzR0JJKzJFUUxJRXd0YU9jaEVnRlJZNFlaNGlBaHMvTXZ4bTE0XHJcbiAgcW15cjNrYmdvTVFEWkpyYjF5M1p6RXhhMzBlZllWT2lQcVM0NTEwTmQzZGtaTE53TWtyckgrOFhZdWtYMFg1cEdzSVJ2eWZLV24vaFxyXG4gIGREVHVmZlZ6VEZnb2gzNXIwS1N6WlAzYi83RDdOWjJMNXE5L3gwVnl5YmFpNTlNOUx3b0hIZlFKdTBhL2NjZkkxZ3JuK2pEbExpcFdcclxuICBidWpRYjBsV1hsL1RoZkVzK28xbWRxL2RUdW5VaVFBTEZOMXFMbHpENG5wWTJ6R2lBaEhjdW9nMUpLc1MzRWhEOVNvVGpTSlNoSnVsXHJcbiAgSEs1Uk1OcG9iMnZWTnZWQ3RHTnQ4L3k2eHJrZUlsb3puOVY0L3pFelRkZGlFeWw5TmphNTB2eSt5cEc0U1R2ZlViTlB3aUFpL0hFTlxyXG4gIExXUHZ3K0oyYzU3UGpYS3RFR3BmVEd5bGYwdzIrQzRjZENLQTJ5QWxJcHczM1djRWlPbHF0MVhMNFFjTmw2OWUrMWw1OUxGOTN3WHdcclxuICB2d1drS0U4OWZydUpzbzQ1ZnQvOGJCMTY2SUcyTGdUWWI3L2hNbUgvVWJKK3d4Ylp0cTNPOG43MGc4dmt0RE91dHZqZTRPSXZuQzEvXHJcbiAgdU9PZmhqOEFmYUs3QXg1dWdIZzhBcDUzRkRYb1ZzU1N2VlFMWUM5c3Q2Qm45M1E2QWkvU2UwRnMvT1BBUGc5MU9iZ1c4UEptY2FXSVxyXG4gIGt5VGlLdnNJRkxBZUNTYTY2RUJjNytIRUk5aUUwM2U4NGJvQ25aUTJZaDJtM3g1YWZuVE9CM0RJVjJTUzJEbXdRbWN2ZFlhc1lMOXhcclxuICBtSmNrSGpxek1wSFZPN2JRakJsUjhOOWtIeHo5NWFPSWpoQ1BpNjVNVk5EWm9SeVZLOGczdGd3MFF0U2hXQUlXbGcxdkdBSndINGhnXHJcbiAgbUVudEMrRWdqbFVWNXN1a2JmVXUrZzJOMDJmeUJrMCt5NXpQa2NmYUJZMVl2QWhSbFY0clFlUzRGdzFEdTkzekFuSUorWWpaTEQ4NlxyXG4gIEIxTG1HSGI0eFk2STlYN3FBdWVnWlFMU3BnOFFLM09Kd2NaYnpjMlNtWkZtbkFmMHA3UzBST3RQTm1UZGQ5U01pRk5KdFR3L3BuU0xcclxuICBUekVDRXc2ZVd5S3RuR1NmNFpQdFNNOW1qM2U5ZCswT2FTUFFlbGdmeVF4OTFQNDYwWEhpdzM3b2RaclB1aGgvN3Y3OHFFdWRZVE11XHJcbiAga2cxei9tRUVoWU84OEl5c1hIUUVibzQ0WEVscDFYK2tTU2NPN0huT3pmZnI1OVpzNFRsbjVEcFhPR1RxcCt6UVRKdkloRGE2dks5NFxyXG4gIFhBL2N4d3c2K0F6N1psQzBEenI0TkgwdSsra3hWb3IxdlpQUEpJSTJLVit6OG5WVGppUEtERzNFMnc1NWhIREZUVFhyVFMvQ2hJZUpcclxuICBFU0pjNTZCcEQwc3FYdy9GZ2t4VzFRY2lvZ1hzdkpYVDV4emFUT1JyNk9kMElxRGZHV0ZJWTh5Qkd4KytmYjVSVGtGRUdtcHhqK05yXHJcbiAgUlhKM0xwYlJvNGZKOGtyWExaeHgrbEV5YXhaN212eHY0TWdqcDhxUlIwd3hCdnFtZlZ3YkVzeDZtU2doeXZyTmIrL3R3b1hVMTdmc1xyXG4gIDgycjNrMDg4WEw3NXJWOWJuS2ZZRTNpbUVmakRqQkloWWtHc1VHL3gzc3JFVHdYWVF6bUhXS0pIMlFpNmxTK1ZOVktwTXdMOWRneUtcclxuICBpL0pscXlSZDBlT3UyemdQVFNiTmRTT0NnZWdoaXNmRlZ1NUZseXErSnNSMElsby9ERGFMRWRyQklQVjQxeERpd1NLb3lUWjdCd0x4XHJcbiAgTUxQY05lOFo4UUM1RzN1T3JIZjA0Zlp4UTlpTTh3QVpSUjlBNEJiQ2h4Y09CcnlMQ0hTMmoyV1Z2bWJNY3BzeVNxUVRVMHk3Y3FjMFxyXG4gIE5PeVNnZm50MWlidTMyM2ZreGozRW04N3hPR1NtSkd5aVpXNWNORThuZy9YWW9aR2Y5RVJXSjJvcjZ6eU5VNGpRamh4NWJlbExjL1RcclxuICAzZk5DdVpBUEFnR0pENXVKREZqekRmRXVzTEtHZ0xVZitLRkM4UStoMkw1Qm43ZUdlc0tSL3ZCRHJDeHFJTmFkTUpVcnlNdVZrbjdNXHJcbiAgK0pQMzN2UHdld21jbEhGVHZSMzBtZnUyMEJGZklEaWE0WDJ3ZmlpQjBYNngxU3FodjB0L254d1FGUWdEaW0vdUN3SkpQbVBGMnJaeVxyXG4gIEx1N2lnSmlRaCtVWDVSSjlvVndVa2w2eHdoZkNNWk9sZnAvKytoMkU4NVNOUXNvU2g0Z01uSGhTTWwrUHJ2SGtSQ0RrRThKeFlPcktcclxuICBZa1E0a2pybHRDaUR3Y3BBM0s5b0dkYTU5TmZ4d3NwdTlDT2hibnhjNjQrRkhEa2xJNHdid2NGaW5uNExiYzBOeHBXekZ3N2xJWWhPXHJcbiAgUkRicnBDRGRQQ3NraUlpMUV6M2p4TGNhK3V4NVZrYi9jUCsreS9SaG5zYjZESEVWeGhNc09BVHlsRnRGSndaaFdiRjhtWHo3eW5Qa1xyXG4gIGxOT09NNFUxU0xxOXc2MzcvbGZ3L0ROL01pNkV0U0dyVnE3M3pMMEFoR1BwMHRXbVMwRWk4K0REenlaOFpjR0ZuUCtaNnkyK043ajdcclxuICB6eitXUC83cFlZdnJFK3dOZUtCN2htUUpIbndValNLOTF1NlNHU1VzNkZrNm1STTcxNjJzeC9RM1ZvVEU4TndLV2I1OHVlemMyYWlJXHJcbiAgV0c5UVdlekJZNmRJR2p2SEtZVHRhRU85akZ3Mml3b0V3NGtFWXBuZzM4cDBIb29FaVBPSHdqd2pXZ2RDbWtGbU1SdVF4S01CR1R2c1xyXG4gIFE5QjgzRmxEUE5oWGdyUXA2eENYR1BGNE4yTEROMnRmTTJ4bXhReUxBVzdXS0pobnhqNTBhNU93eTRlYlpvUUQ4UUFmRmx3SDdMNlpcclxuICA1ZXA1Wm9MUzJhYXpUNXpzYWQ5MEN0TzRtVDAwOEJyc2JjWGJqY2VEcUFwUmpVWWtJNisvUFJ1NG8wQW9zR1NyeDVZK3V1ZGlKUnFFXHJcbiAgOGNPb2VraEhmZWR3c1pRZW14WXE4blJsZHBlNmxGWENnOXYyZ1BBNjJwb01VUXcvNG90U3ZYeTIxbkVpd1lMSjhrTS9ZMldHSC9FbFxyXG4gIEMwSGFkazk2NU16L2dXelpza1dhbWxxTUE4bk56WldHeVQ5TjlDVit6WENZUlZJc0hjclFseTRIZWJHamUvbjR3WG1iSUdqb3hNMkpcclxuICBDdStHc0dqb1FRbE9oVFlnSkRsOUVObWtXWDZmRVlkcFBnamNueW5QZHVpTUw4VHkvSERDNkFjTDNiSnpjb3dENCtZenAzMUg4NlArXHJcbiAgeFBwcDErU0k3aWtlMy9MQms3SVp2MlM5bExGUTB6amdaREtHOVIwT05TRVNIYTNOUmxSd0E4STZHb2dKWmJFQ0hEamhwRVJiRm5ZN1xyXG4gIDlDY0s4WUYycUhJdmJ3cDc0SkNIV0pKbmhua3ZpeUw1bnZCRXpUWE5jaEVpb3QrWjlVM0wwWmIrZU55KzRTZy8rcDc1dzRPdnJlL1FcclxuICBkQkJiY1Q1WVl3RzUraTdTcStiSjJMRWpwR3hvVnpjZnh4NHpUUjcrbDd2RC8xOUFkbmFXZWV3RkxyM3NoeGJ1RFREcnZlTEttOHlrXHJcbiAgOTV5emp6ZTM4Vy9QV1dEbmdpNGt2dGh3ZHpCNDhBQTVaT29FSTViNlJucENuMXdlSm8rTEIycFJoU2hpUVNLemQraFJKaG0zTm5jTFxyXG4gIHZOUW91Z2ZZWFpHRHk1cGwvdnozOVNHZ0lQU3RhWXVLaXFTaU1kcVNVaXY2MXJRT3lGVWhHcmJpUENJZXJMa3dMa1RMb3VNd0gxalJcclxuICBvTnFUd3J4SFhBL2lOdWcxbjNhWlBaSHU2R2lORVk4aFNlS2hnNTRabEJNUDUwQ2FhcFJWcDE2WGo5VGI5YmlHMFRsOGVFRm80RmJZXHJcbiAgcnlMc0FHamVSclVPOHR4eDQ4WkxjMHViNGdydEJ6eXd0UGRvcTN2Y25NdHBmWWlzNTRPTU1IbWNhTS9FNnVzZkd3R2xwcnRiamdRaVxyXG4gIGlQb0c4amNrRm04L09pQWE3RzVvNWZUQUpRY2l2SkN1VTRMQ3pKcnI0dzlyL1p0L2szVnYzV3R5OEtBNEx4bDNyQk1KYlFlaTRuV1RcclxuICBiZnAxL2JsaGdkVFkyQ3c0VDhTaEpzZzA5TVg2Uzltb24rRUk3ZGhCR1N3ekl2bC92Rnk0Um84ODZtamNEKzlYdkU4SkpLL1BxWGpZXHJcbiAgVkQyZnB2Y3pOYm9uUDg5MTRhYlc2ZjJqQTdJRm1IcHUwN3hIM2ZJcjFwZjFiOTluTGw0cUZqOXYzQWwxdDc5eXZhMWtibTF0dGJFeVxyXG4gIFlXSndiOStWMElSM3hkcU5qWE1mc1hqMThsbDJIZHRESkxKQXMydEY5eFd1Ry9xUXlOTTB1MElpeXVLZG9tUm5VNnBDblFod1BqRTJcclxuICBkYXdpRmtxMFk0ZGZ3OXBLWE1lZkhTNVEwR3NSYjhQOWZuU09SWUJZVFJvUk1UR3c2eEo3SlNMV3ZvWTZkajFmcjJGeHpkYy9QRGkzXHJcbiAgUkZhQ0xOYU1FeEh6eXFENXVHMy94cVduUzI0QmE4cmNVaW1zMkQ3dlV5Zkt6Yi9hL2Y0Yy8xZkFZeS9vSHN1b2ZWV29YM2pCYWRhL1xyXG4gIFQ1MTdraHc2N1FDNTd2cGJiRHdBY0NFWFhmeDlpKzhOV0ZoNHcvZHU3WjJBMURaMDhoaDNBenphQUR6c0tCcEY0cjhKNkpZMHNMdzlcclxuICBsWXNsZWl0THVsdjVUWnZjeXk1SGEydW45TzFiS0NPR3M5N0RUaHZCQ0tJcmZ0Q0JnSlR3bFVRV2g4dGpTYmo1THFJYTdoaWRoM3ZpXHJcbiAgOU1GRlNNSEVZTFE0Zzl6VDRTTWczemQvOGpUc05LYTZTZUx4WHBKNG9NUnZaYnRaWlkvUmQ4Q2xHTkdoVGEzZmhiWDNNTVJacDhLTVxyXG4gIENlS0JoVk5ZMHdIWFFYM0VkSVFEQjhCWmlXUmxJNFlScWRtcUhFUDAwWGR2RjFHVnV4L0g3OVJFZTFhR1lMUWRQcWhOYy85bGk3bnNcclxuICBlWUJRdFE0Syt5RGVTYllGUXZJMGRZbUQxT0EwT0ZBZTl4azZXZnZoaW1URU5WamFhR0VqNHN6TWh4NytCVU1FN0tITmJIMzR6RXUwXHJcbiAgSFg4ZThTT09ST09IbjNkRXlRNlVXdE1NTEJxYjJxUmRLU21XVG5VYjNoZjJ1RmczK3k3VGxlQS9pcEFEcXk5cnUxdjdkZXY4UEFjbVxyXG4gIHNtdG0zMjNXWWJXYTVwcUVGVXRlc2pCWkw0bXNRZURlcjlnOVJNL0lEcjFlRUg5QlRCRFh3VldaV0U3clFreHc5aGVYN2E5NzYrOGFcclxuICBwa2p0dXJreThNQlRqU3ZCNG5EOSt2VkdPUHk1NmJNdVp1MVRkTTNvdnVKakFiY3hHclAzakF0N1BTbGxrODZVd1llY0wwT21udWZsXHJcbiAgOWRnOC8vRXVkYTA5RGswVFJ6ZEN1SXZ0aFN1V21VaUxBK3NzOUJsbSthampGbjlxT0dZMEVTaHRSUWNXZzlaZTlMN0ROWEoxcktFWFxyXG4gIFlaSVhpQW5uTUwwbGhGdERsT1pFeEsyemFpT0htOVlHbzhDZU5hTWh4TW1uZlkzclgyYnhRTm1seEpwMG5CTkJ0SmhUOTZFTUtPMGpcclxuICA1YU9HZFNFYzhUaElPc1QvRi9EUGY5eHNST1Qwcy9kTkNmNmxTejVwWnIxd0lleCsrTkZIcStYdjl6MXA1K0JDTm01TW11anVDYmhIXHJcbiAgZGpoTVUwcGlPNGJjOStnODJWSGpDMmpTOG4yREl2NGRvb2dGZGlhQ25tWHNYY1JLeE12RWEzcTBhem12R3lCUktmd1llRXgvazFrS1xyXG4gIEtWS1Nza0UyYmR5Z3MwbW5wdGtacVRKczZERFoxT0VFQkx2OTRJSWtRVWdVbU9YanRCQndpeXRmalEwTHpFeUpENU0wRzBJaGcvWG5cclxuICB3c1hwYi9kNE5QQnNnQ2J6a2RXeVlJNlpmRUhKYVBOTmhGTGNpY2RoQ2VJQnNQQ3VzWGFEMW5RN2VCdlF0QmQ5aklrdzVHdjd1RFNCXHJcbiAgWFdjeEZ3c2h6WDlXV3FaOU1KUkJsMk4rcTNRV1dMZXowWlJsSGMwMTB0N1dvVWVMOUp0NFJoZkVRUnl1ekNES1F3bk56QXQzRHhnUFxyXG4gIE5OU3NzN1VNTEdBRHllT1RLbEUvQ3AzZ09YSWtqWWlLRHhBRk5ZUUNXM3U0aldJbEhuQVVPVVZsMWpZdVYxQWcyeHFDemphcCt1Z1ZcclxuICBxdzhDeGRRWm9tNXR4aENMSDF3NytSNDR5SU13NEgyM2JzTUhwbnVxWHZ5TUxhWXltcWRjV0w4K1JUTGl0SjhZVWVmNjdBVk9uQTJ3XHJcbiAgSUpDTUhaU3kxTzErY0kwK0k2YmErOFg2QjdOc1pQdm1QVUNmUCtuV0J0OVhoRFQ3YVd4WjhKUStsZ3dqaUxSQkdlOXV1QThmTy94elxyXG4gIHd2NmkvT0NCMXNRMlJuRFI3NGc5VDF5Z1orWDNWUzV0c1Q2cnlTWWVzM3I2bDczNDE3SnM2Vko5bnQ0bXBydjlULzU5NGp4NU5CUlBcclxuICA0NkN4SlRLQVlDMkdpU3VqOC94dG12OXZuZXdNMTdHMTNDM3I5QSt3c3hiMWNpR0dLSXR2RUxOZjlBYzhJeVpzS05JSEhuQ3lsV0xzXHJcbiAgdGlybnhFWnA2T1RvRDAzRTIzSHdXSHB1c1JFUlcxaTdiWU85TTh6dU1iUGxQSjRVM0ZwcmlCS201U1pXaFRQQnJEclJsZ2FoMVdUY1xyXG4gIEk4VFR0VTBtVDJ6bGpLRUw2MEx3aXJCcDJkdHk0M1dma1U5Ly9wTkdKQUxod0dzdFI4aTc5KzlQbVA3aGZ3SG9NM0JSc25sTGxlMWpcclxuICBQazBKMXQ0QXo3cnIxbTJXSTQ2WVl0ekx2Ly96c3BuM3NxQ1VjMy81MjJOeXpOSFRvdEs3Qis1UlB5R0h1Qm12UFVCL2l0MGcrZm9TXHJcbiAgVDlmQUkySFFKQ0ZlSmdaN0xkZXpFaDl3ejF5UmpMUk9LY3Bva0txS3pZb1UzT01rL2VBRHlTakNvYUdZM29ORlNBRDZCMnplQWJ4N1xyXG4gIEJxVzVMYUpqcHFSWHdTb3BweTlFMUJFUk1zLzg4SUhZVFdyTUJuWTg3bVVUU0N6S3IyTnhvQ0lYRmxDRkR6QXp2OFJtdWtuaTRmMWhcclxuICBOc3BnWndiRndqNUhqaUJLMnZRNDlUMnRSSzE2clppM1hrWEl1RjdCQWdXT0E3RUFpOVVRV1VFNHpHOFBSRUhEclBJWjBsYm5pbFJFXHJcbiAgZkdaNWtXamJmVkdoMndEUDBGL3lJV1FZRFNCZlpxVXVTSmQ4NHo2MFhVUld4blZvUE41ZmlBZHBSRlNrYldHZWhpaUkvWHlLY2hKZlxyXG4gIDlEb2FKKzJjeVlleWM5TmlXNGpZZjcralpmaVJ6TGpSWWZqekRZZTNrVHk0THB5QVAvZjNaZTNyOTlqTUg4KzA3Q3NCb2thSjN0clVcclxuICByRy9XMThId3B2THpYWlpPUFZ6UzE2MmZwMjBwa2gweHpSYXV4YStaUFB6OTJyV1VLQ1R5dFErNGFTRmVxL2tjdHFPZWxtTU1FS2NQXHJcbiAgS09qNmFyOXdpVUtkaGYrNjN2b2FqdVIxYURNNXZnamo1MGp6Yk5nS2w4VjFPUDBicHMvVTZVUlVSdHZIWkJ2ZEIxeGVSMXU3cEtmaFxyXG4gIDFERjVQcFMxZEJTeStydjhzQXYxL1I2VUtNZTNBRWRpWWszOUpqRllHTnlGRzhIbm1YTlZ6cTFHN1dwZGo2ZVlTTXNtQTNxWXl4cjlcclxuICBzN0dxNDVZeTZPelE0MEZrd202WDFzZjRRWjYxNTF5NmkzcUgyVVNIeVdGWTMyVEVBM0d3Zmh0d1FuQWk5TUhGV1Q2ZU5CTEZHUTN4XHJcbiAgdUY4RGszVExCelNmU1VaaC9STDlmbEpsOFJMM2lSV0lSNXo3Q1BEREgxd2hkOXo1VUpUNitPRyt2LzNjd211LzZ1SGVnRDdDaGVUbFxyXG4gIDVjb2xGNThqbXpkWHlxMjMvU002TjFuKzljaXJGdDhid01IdzlBenE2K1luRmhNMlY4UWZRSGh3aVpoRGwwU1BaQTlna0NTaForbGtcclxuICBUdXljUlVPYVR3TFFkS3hJbXVidnFONG9kWFYxaGhBdEx5MUZTa3RMcGFrajA4b205QjRheHdMTEZzenBESnY5T3dBNEQrVDNGQUNCXHJcbiAgSnZZbTBQOVdGZ3Zwek52VGVoQUxBeTNFRS9rTU9NL2pnSGhnMG9uWUNtUmtkYlFNaUw0WUpLTDloWGd3NkkxNDFHeTBtU1ZXSDk1T1xyXG4gIGFJOFB4ZXQ2bm91czRGWklRenhNZDZNZkhzU1Bzc2hvaWJ2N2VVUlo0K3dENHVNYk9OQTlEOUNraTdPOVRlNWRJMzcvbWdaSjBCWmVcclxuICBVT0ZzNERiWTNoTnJLMHdsemJKS3k0VVBPclFUNG5BY0VETm14MjVPNnlJcVZ4UnJHUjErSUhhT29kTS9hODhxRUF0RVZrWTBZdTNSXHJcbiAgZGppNmNoL3VxUlprelVkZnUrNTl1NCtSUjExdTUrMzVhb2pGMjZaM0g1U1c1aVo5OUozbTJnRVlPS0JVa2ZaODZiVFhxSnlPdnF2YVxyXG4gIHRmTms5V3QvdExVTUlDOFF2KzB0b3UzNGdmZUFjak9MUnVDNytyVS91WGhFNDdWS2dDaURFUU45ZzhBRVhRWnhHd3Q2bnY1Q2hDRXNcclxuICB0dkJQLy9CdlpjOUYrd01oWVF6Wi9jWU8wdUVJOXgvZVJkK1JoNW1ZQytzejNrdlZzbGxXWnZQbXpVWXdVWHhsNlV5emVNb1hUVS9DXHJcbiAga1doWHkzdWJ5ZXQ0Mjc0NUZuRVF0U1pzMGpKazJxZVZUamdoUWovQ3hNTzJFWTc2NUhXU1lqb25LR2syRGxHaVU0OUpEVnZyVWg1UlxyXG4gIEZrNDdUUytpNTJ5TEFCMkxUa1JDbXg3eS90Mm93ZE9CaUVBOFNMdUpyenNZNWJ2Q1BaSHJSSmhVYWozOXBhM1Fua2FpT0dmOFNNVDFcclxuICBQQklEcy9aU3dQZlZ4bzNyWlZqNUFQbkZMZCsyUlhxOUFZZzZuUHZLRmVjcllmbmZtUFllY3NoRTR4Z1FaVjM4aFJzOGN5K0FEZ05DXHJcbiAgZDhicFI4dUJCNDZWMisvNHA4eWQ2MzdBL25qN2QrVGxWK1pZZkcvQWswdEFqOFdFWFlDSEdhQ1h1QVhkOGhPbll2bnhJZ2E4cUNqYVxyXG4gIEE1SW5QS2Evc2JJWk9oN1RPeFJ4Vks1WFpOQnBoSU8yc0hHdlR4OGsyeHFkbStoTjcyRituVFFIZjBjUUNNNjFOZS9VOFoyaE1hNlRcclxuICBJcnMyZnlRWnV5TWVHaVlIbTM5Y0lZOC8xbmlBRVBHUzZnbzh0NlgzeFU1WTBtZ3AvZmlZS1dFVlpvTmNrWWtSTWkzbjdmR0JSR0hzXHJcbiAgZ1BNQXlUUGpnbml3Y2g3eld1NlZ2b1NGZzRNT09zM0tRenlTN2FWSi8vNnVCOEhnQWtWNlNzVTdYbGZQczFNZThtano5NFF5V3RzalxyXG4gIFRUOU1NNmJ0NHREUUZsZnlBZE5tYURzV0Q3b041UE9rdzhwNUxJa2dHSnJRNXhNUkVvMzdmaDhnbTlDT1BoKzdkNjRacGFNUTdtTE5cclxuICA3THNTQjRpWS9xTlVCamxUanJCbXpSeGhveVZrNUJnVlZIMzBrajZML2FTK3NVWFM5RGx3Nzh3NU1MdkVOTlRjeWVzZnp2bW96ekhxXHJcbiAgMkN1VlV6akVGaUhpaGdYa0hnNzI2NENyUVk3UENtdXJ3eTZKL0drL043MzNrQkZjVFJvSHJabEdaQ0F3b1ovaFFCekkrUlI5LzNVUlxyXG4gIHAwSTdJQzdPdjMvZlpmWWNJSFQrakxpR2h2YU13dlAzUENQRVIzeko4dkRndS9HUkw4ajZ0ZXZjOGtvaE55ZFh4OTFtV3h5Sk1ucFBcclxuICBoQ1RSZHZSZUVIa3lvN2RKbGFhTkc5SHZoUEVDeDRwaGhlWFAvN2VGb1graExjK0RpTEJoblU3L2RCQ2ltQTkrMW53VmU0b1NFdDhGXHJcbiAga2EyU0ljU1ZTMTd1MFk2RjlFc1BPR0RYaWJndUJKMUlJQ0tFYkRyR085T0svSnVTZlRzVERSTFJjOU9JSFZ6ZjhrT2NmRDBQMFdSSFxyXG4gIHcyRlpsVkplUGtnT216cFdjZ29LVFR6MTl0c2ZHTUZnSDQ0NEY0TGxVNGl6c1BsL0JYKzg0d2MybHUrOS95bWRUTy93ekQxQTRFS0tcclxuICBpd3VGUGRocmFyYkwzWDk1TERvM1djNDQ2enFMN3cwU09oQWdyZ2RKejhjc2pZZm5nVDVLandQMlVBTkVaNUkvRVdnOFNpYnE5aWdEXHJcbiAgOEpLaWFQeGNMMlY5MEVRSmhZTE1acDAxTDVOZE8zY3A4VkJFa0pXaGlDRlYwZ3VHU0xwK2tMdHF0K3JnOFQzZDNYdzNxZmRnNXp3YVxyXG4gIHE2OXlWeUVBN3N3TFRhU2xiSDVIdTM1SGFiNHFQVEdJdUpNb2pPZFp2eGpVVWI3R2tiSHlRdkYzVkx1VzNkUjhabWE3QlNyUklBeURcclxuICAyNVRzV2hwbG43V2pzNm91WWRRbTE4SFRLU0tRdHFaZHZ0N0JMSzMwV1VBWTYyc2RRU3JDSjl4WnNVTFlzOEQ2Wng4YU04QlVaYjhYXHJcbiAgeWNaTkc2V3QxY1dDN2R1V1NOYVF3d3dCNFBhRVBpTi9SbHpCekJZNVBUb09aT3VJTXdMaDZMNFdBdWRBMW9VQUFQLzBTVVJCVkFMQVxyXG4gIHltcG1hdWdwalB1SXVBMDRQbk5PdHdza2pOaG5uaEs5UnVNeVRGZWdSN2hQUC95NStqTjF4SW1pRzRJR1FrY2NCaEsyUldQNnJ1QWFcclxuICAyT0VQcXpEcW9qK0JnSzUvL1c1N2o0aGJVSVJEMURhKzg0QmtaV1ZMYTV0T0h0TFRaT2pGVDF2OTBBODRsWERRRnYwQmtjZnp3NEZNXHJcbiAgbkQ2RWVwUVA1MmdUS3pIaUVHTXpuTkJ5OUh2aHc5OHdjU0NFWXNzSGo5czdLMlBGK1Z2M3lzaGpyckRuUTE4Wkp5YjZHajdWaUJXSVxyXG4gIDBaOXZtUkxQUDFzKzc5Q2VFekhycjhmdGVXcFl1L0FSMmI2OVRqcmFPNHo3Z0R2dkxCaHVhNElRRTlraVRQTVY1dVY1UHM3UlJPM29cclxuICBuN1dySWVzdm1OV1RCM0ZzM2xtaFJPcll4TTZKbnVmNzViRHo0cFlGVCt0WVpJdUVxQ1dhc1ppSDFPTTdZZXkyTkZTYi9nSk9Ha0FQXHJcbiAgWWh4STVTcDdUallaUkM5aVo3dTFSVjgxd3ZPcVdUN2IzT05nTGd5eFEvZkZkc3V0VGR0dDhvWHluZ21EN1NzU0VWSWFDYjBDdk8wSVxyXG4gIFFseERGczl1V2ZxMmZQOXI1OHBQZnZGTitlblAvaXlmKzl3Wjh1NTdDMlgvOGFQazRJUEd5ZDMzUEdwbXNyZjk0WDQ1ZE5xQnBtOUFcclxuICBYOEFPZ1QrKzhZOUtjSHB6Ry9WL2czNzlpbVg1OHJXeWVQRktXZjdSYWpuLzA2ZEdaM1lQUVJkeStJeEo4cTlIWDVBbFMxYko2TkhsXHJcbiAgTW43Y1NCa3plcWhVVjIvcmRSZkNPT2lYbW9UQWdZd3ZUeTY2YzloTDNJSnUrWWxUOGZ6dUVBWkJON0M4NUFsaXp2NTYya0UvMUk1dFxyXG4gIFVsWEJuc1hNOEtKc2haMlZhNlN0Y3FGK3JLNWJvSUFOa2lpT28wQURyV1JySUJSTUVXenJQUlMwVEFPbXZSRm5Zb2ZtMmIxd01ZNlFcclxuICBGeUU4UjM3T2VSQkhiQVhpZ3ZQb08rSXdZNThwNTdzRjZxRFdBUXp4b0Q0SU1PNVIxMEpGMGwzU2VvQms4SFNLckpqdE5rSFF0dVduXHJcbiAgRWc4K0xvZ0dJZ0U0RG9pSDNZKzExYldmeldVblNXYnhhT2dBSW5IWjJkQmtNMGpLc09OY2Jza0lFK3VSeGwrVFJpek9SeGxtb29ralxyXG4gIDZpY1dRZXZmL251MHdCSTVjWWxaVmlGT3NhMWJOWTg0SWh6T0R6cjRUQmZyV0NlaU5oTHQrdlhhbE1EQVliQkJVVjlGSUNPUHZ0eENcclxuICA2c1BKckpuMVoxTmNVMzdOYTNlYWxRekltV2ZicnRlRWt4aDU3RlgycnZCb1BQSzRxOHlqcnIwOXJxRWhNN0F1OXhPN2Z0ZjA3bzU0XHJcbiAgdWZpUlBCL3VqVDNjV2NOQS9NRHpmMmQ5NVR4RUJVNW4vdCsrWklnU2dxRW45SkZtNkQzK3lZZ1FaWW56REZIYVV3L2t1bTM1NjRuMlxyXG4gIG5iREhyNmx4eldQdFIwNXVycWJkckwzOFUzOVhEdVVTZXk3OHJYL3JiOHFOSWN2VStscCs2UFRQOWVCSWVzWlRGUEYzSm93bjBMMXNcclxuICBldTloRXhjeUVlRmQ4RTJhMGorcVM1MFFqNGVNVThSYWZJdFlhcGxiSFIzTElIckdPaHc3SVp3STM0RFYxWDUwYlN1MGpidVdvM1Z5XHJcbiAgdHQ3MGlEd3ZEQTJ3YXN3cUdHQ1RTSWdHejltbEFiNlFWeXZyUDgvT3c1QzJ2QkRYY0Z4eG5XUm5pSHptQW5lYU9QUHdTVFo3LytRNVxyXG4gIEp5UTREWkF2Y09BQkVFNmY3ZDkxOXlNVy8rRVBMditmaWJJZWlDeXlIbnZxTlZtOWF1L2NUdUJDeG80ZExoTW5qSkdxNmxwNTZ1blpcclxuICBkdTY4VHgydjUvNWs4VDJCUHYyZThKRU91QVR3N0tLb1FaZEVqNlJEYjVtV3Q2Zkt2YmFVeUEyK1Z3S003N2REMXF4Y1lUZVFvVmd3XHJcbiAgVTFtUTV2cFduVkZtYUZwa2l4S1drbXhNY3JHbzJtanNaN0Fzb2sxRGtHQlBCV1QvdnRKYzB3eElEZlAxSXpDZ0NOa1dKNUljVUluQlxyXG4gIEZoM21UYmRQbWM3Q0Y1cllpcnpNbkQ3bUJJK1BvSGIxSENNZWJOc0pJZ2tmSHF4MzhtT2czU2prSTRrK1dENGNtNDNCMHV1SGhYMC9cclxuICAxeDh3NFVRalFJZ0F0aTU4eHVwMUlSNjBaVzBnZzZaZG5VMjNWa3RPYXF0eU1HbDZLbFdhbTlwczVtNmlpTEpJdE1EejF0dkNZaTBvXHJcbiAgVWVNZmJXZ0xVUlZ4MXJJd2t3MG1wZWhuRUZXaDcwQUU1ckw4RkJseHBDSkpJeHc2SWVqU1h2Syt5WVBRYkh6N0g4WnRjWS9rSWFvQ1xyXG4gIGlYS09HVE9UQW9pRm0yWXExN0VjZVgrcWpGYWlNVW9QRXlkcHV1OG9mZFpHUkpVRG5IMlZaQ2pYZ1I4bzRNQURmYVpOKzM0d1VYRk9cclxuICBqY1A3MXZWSWx1MStKTWRDUE4vdnplL1BqMlNhODJXVHo3Rnd5aGYvcG9SQyt3cVhwUVJqL3Q4dVVXN2tTamNHaVBhOEdIbk1WNndlXHJcbiAgendHazJsK1JaV2dUQW9UZVJCTlJYblF0NWI2YVdYR3NyN1EvVzYxcVBnZktkcXlXeXFhZXAxd243dW1UL2VaZDhvMFFEMjBsNDE2T1xyXG4gIHhZSllOUkhIWEJaaTBuL3NrVmFtYXZscnhuWFJaN2hsOUNOaExJZDJQTlQreGNZQnJsQ3d6R0lGTytNUWtUT0ludk80d0RlaVlrUWtcclxuICBQTC9rYzR5SGZGTVFFY1NrY0cxY0I5MG5LQSs5STZJenhGaE9STmhUeFBWWFh0L2ZJWCtFSHZmVDgrZlBsODljZUpyTVhlQ0dLQ0RoXHJcbiAgaFFzZHJ3VFJWZmNRK1BLWHprM0VYNXYxam9YL0MyRGpLWDBLY3ZVMSs3WloxRlZYWG1EOU91OVRKNW4wQm91czUxOTQwODVsWitjbFxyXG4gICtydzdTT2xzWFpqQXpPTU91VFRCaFdRTjFKa1NFQjZlQVE4emlrWVJubThzVXlGWkpsN1RvMTNMZVYxZzkrVThwcit4SWlUWTMzemhcclxuICB3b1dLcUJRQkt1SEFKQk9uaWRDRWRzZDlTbFhIeWNycURodUVaSmdJb2RoRmN3d3VuT2NSMzFtaGlIT1FMeEJFNzlIRjRzcnVQOFIxXHJcbiAgY0VYeDhCR0ZBUWNTUjdjQ0FXRy9CMFJZckJGZ3hvTzcrTUI1QkxFVmc1elZ0R0VEblI0ZkF6Y1N0VzNFb3lSSlBPQXlRTUJ3SHFFZVxyXG4gIElqcU4yRXlPanlUUmxpSE9xRTM5UTJTQmk0ZVVWVS9JK25XTDdkbDE2a3ozMEl0dWs5YVVmRHZQTGFMSWQyVzYzMjlvanpZOExjWUZcclxuICBJR2FCVUpDUG1BZlQzSlJVbmFMcGpOYlBLZUZRZ0dnWVdGM2FpZUxXbmlWc1l5SjJmb1JvUUJUcTFzMlYwZ2tubTN0d1pveG12YVRsXHJcbiAgV3VycnBITEo4L1pjUVZDSTFveURvcGtFYUVwdjI4SFA4RnYzNktmbC9mZmZsODZVRENXUzdYTHlDY2RJeFZCM2pWMjdKdmxoNDRNTVxyXG4gIGZSZzZNdmJqTm5mdDBiMDRkSnA1TnMrSENRUFRiWFJQV1RwUmdmTTBuMTBLVEJRUVlTRnljb2crTndzU241NkR0dUU1WGN1c2Z2VjJcclxuICBJeHpvQWRnL0hQTnZuZ1hpSzg3WHJwbHJPaWxiTUtndzRxakxFbTF0ZnZqVDVyNGtYUWtFZnEvMisrSi83QnpnazdKT0pWQjNXOXJjXHJcbiAgcFZCTDh6Zk9mVmdSUDFhTm5lWjNhOTJiZnpQT2hIU29aMkYwNE55UjNTT1pVS0R2Z1FzaGhBdGtITkFiOUVobTZhamxUU2RrN1hSb1xyXG4gIFFCc2VRbWdZNDRpbStaNGdwSlRGK0FYeEo3cEM5aHBoWW9PUzNldDVXOTFEdmhkMjhNUlNrWFI3UzVPTzZWRW0yc0xLRXJOZkhKckNcclxuICB4Yk1XekkxWU1KTk85c2ZhaTlKajhpcmxyYmZla3QvKzhBdHk2YlVYSjRnRUVPTHh2TWYrL1pLSnNwNTk3blU1NWVRanVweDc0c25YXHJcbiAgVElIOWNRT0xBck55SjF0OCtaS25aUFNZYUIzY0hnQWZXYzgrL1VjNWVNcTVzbXo1V2x1Nzh1YnMrK3pjOFNkZUpxKys3T09qTitpaVxyXG4gIEE2bXYyaUN6M3NLU0JSMElNMmorWTUrbGZmQVdTZjRtOGlLSXBSTjF2YUJGSFRUdS94SEV6bG5VMDRsZi9lZGxHakxUUkVsK2g5UnNcclxuICBYVzJibzBnYkM2TmNGSUdManNibVZxc0gvbTF0YlpHTUFRY1lzbVVBNHQ2YlBtR3F5Wm9EQU82RFdiZjNXODlxR05kN0pCQ294UU5pXHJcbiAgOXJRaFFwdFZ1WGdHTzNjK0dBWTJ4SXFQQlVRQ01jRktDTk5heERtSW45QTF1RlBCMEM3dGhGRGJqbVpyek54WnRHZEVaS0M3SnVHYVxyXG4gIEVBOTBGT2duc0lwcWE5eGhIMnF5VDRTMDdiTnAyc1Rob2VsSzlNUHMzREpIS2l0cUpFTXBMNnVUMloyd0pXK295YjRoQk1HYWhicWhcclxuICBMK0ZaWUZGbEM2bzBEM2s4b2lvSUI0c1Z6VmVURmtQM1ViVjh0dlFmUGNPSmRyZ25mUmZoL3FnUFY0RWRQKzJ3Q1JNRWdiSndjRUh1XHJcbiAgVFp2YzUvYU5pL1FESDJ4Nkhmb0pZcVl0eENXaGIzYXZkdC8rWEQzVWZCMC9FS1Zscys2VnBwWlc2UUE1S05SdTN5NWxNNjh3UjVLSVxyXG4gIFBMRWl5aXdvbGRISFgydXpXTk05NkhYNmp6bGNpY0ZoK2s3M045ZncvWlh3ZzhqNmpUbkN6bVA5aEdpVUNRUklhUENVVDlvWXdUQUNcclxuICB1VDR6M2NXUGZrdTUwSGZOTkhqTC9IOWJYNm5MVUxLKzJ4Z2pHdldmRG1vWW5nbmpDZ1E5OUxBTFRIVEZlZ1MyakRVT1RDY3dPRjdFXHJcbiAgbzBMU2U0TElnaWR2Rmp3ejhQME1IejVjOHNhZFpkZUovdTA2aUhoNFg3akVSOFRIR2J4U04rL1k0a1JGQzhMeDBTWUphOW5hVDhheFxyXG4gIDFDSU9SOTF2MUdGR0xKb1I0NlpsbXROQnhGdDhnM3hyRlNqTmJmSkRlOTVpQ0JsMzdDdUQzZ1J1MXI1Ym5WVEFsZmptV1duNlBHdU1cclxuICBHNjloMTBLeldndTFIVUtNNzQydGtmSHp4a0xLL05LUjl0M1p3a0lsRmlhK1ltSm40VWFydzdjYUlPcGVvdDFOUzkrV2ZzWFpjdWZ0XHJcbiAgMzlHK1pDZldlaEJXVmRYS3lwWHJqRUJnZVlWaXZiTFNkUWliTjFWYXlCSE9iZDFhbGRDTmZKeUFwUjNiTnJ6dzRsdXlRb25CaFJlZVxyXG4gIEhwM1pQU3hmc1U2T08vWlEyYksxV3Q1ODgzM0ZCeDF5MUJGVHBieDhvTno3OTZma0N4ZnR2ZzM5aXBOdzNGSFJMREVCNGRFQjhYZ0VcclxuICBQYktTR2NuWENmU3NHeStaQUl2MkxOc2RtcXVYeWJadE90dlB5ekJMR3ZiOHJkY0IxdFRlWWo3dklSN3B5cGxzcTFXa2tKRmlvaXZiXHJcbiAgT0VuL2RsVXNqUlRvY2VKQlNqbVJMVXNNZVNRK0ZNTHU4U2h0aUVvUDBtd0toVndhb3VFZnV5SUdIWlFzN0dLUll0Z0VpcDNWVUVKU1xyXG4gIEIva3NvU081Z09paWVJU3djWHNOQWpQNUw2eDdwWnZvbXFKY3VSQ0lFdGZTSDBOZzhUNjVXTURGVmh4WU9TR21DS2E1dzRaRytpRmNcclxuICB2bWl3ZVd1bGNVYWhEV3ZIRUg0eWJZZW1FVTlCTklKVkMzWGdNQ0NpV0phaGcwR2NWenJ1MktnOStrTmZJR1plSGpFVXBxcmIxODJUXHJcbiAgdnFQeEIrWDN2K2ExUCtxNWVkYlBEZTg4YU1nUllvRklhc1NSWDA3STFFTjVWK1JIejg3NjYrM1g2Q3g5NVl1L2swV1Bmc2ZpYysrNVxyXG4gIFNFclczbTFyaGZ3TnVnei84RU1QTVJGSHFyWUI0a04zUW50MSt1NVFNck8yZ2dNUkhYbjFPbWJxdFcvRXcwRTk2bmdiMCsyNTFPazFcclxuICB5ZXRqUk4zN2RNaWwvNVF5UmZMb1l5Qkc5SUozUFBmdXp4bFhzZnFWUDloOWhQc2pUTnhiRkdLbFJQNlFReTh3SlRPVGkxSEhYSmtnXHJcbiAgeU1FQ2o3S05MMTZoeE1NbldJVG1vZHJhU2g2Y0RQR1M4Y2VaUlJSeHVLMGkzbkgwL2xuWXVmNnR2eHNCNjZJZnNkRGJJSTdWRjJFd1xyXG4gIFdOQVRwbGpINUpkMUpZaEtjNVVRd21Gd0x0bEdNc1QzSEJ5R2NTdWF0dlZMNXQ1ZXkvT25lWEFYTEc0a0pKMThUc2w3SW9RZ3NzOFBcclxuICAzeHQrMmlBbVNBSHkrcnZMSUNDVURXNVBhSXZyNm8vbGM1U25yWk9DL0F5NTQ1YXZTbTZSNzhVT3ZQRzY2ek13cFEwdTA0UGxWWndqXHJcbiAgSWV4K3JodjYvZGdBY1JuT0VwOVRJckttMnhhMHZjSFBmbkt0bkhEU2wrVzBVNCtTOGVOSEdpRzUvTW9iYmN6ODZBZVh5Kzl1dlQ4cVxyXG4gIDJSTzYzTUhVbVM2MkdsV0tTMjc3VDBJaTRaSDRid0s2SlExNjVQRnlvMmdQU0o3d21QNkdMTmhTVGVEdkNqZmtPTUxyZ1B2UVhLeEtcclxuICBDa2FlSUZtbGsyUmdhWDhtbThLV3JaenIyRHJQWjlOUlErYlJWb0dCRXF5dmFMZVZSWEpsdnRDUHRBK2llTndIbExXajZYRGVOb1hxXHJcbiAgTTFobmExVTJtMFFCeURuYUI1bFlxQWdTSlI0RDN1V3hERmdmN0YwSHZLWWpCTmhRdlZwS0o1NWtSQW5pd2U1dTVEdnhXQkVoRE8rZlxyXG4gIGlhMm9hMzJLMm93K2ZNcUU2d1JUU1Y3N3hxSVR1Uk5OOHl1eWZWdUZ6cXA4VHd2OXNYSmUzNUUwaUFNa2d0aXFVem1XaENtdUVZNFBcclxuICBJbEZWcDZVUnMyRGhRbHZXbmhJUDJxRThoQU14QlIreGlhUXNiNTZYOHc3WitncEVJRzA2YTBRbjBIKy9ZeEwxdlQ4ZzYzQy90QS9CXHJcbiAgZU5mV2JieDNGOGpZa1RxK3NzcW5uVy9OVHJ2c0FkbFN3VDRQT3JuQVpJOUw2Vkc5RGFTcXhFU1BMUjgrYldGaCtVR3liZlU3SnNhcVxyXG4gIFdqNUwyMzdIOGx0Wm1hMTk0bWpXV1RCNUhGeWJzdFJaL3V6TjFuQmhoRHc1Uno5QlRyakFaMHdnYitjZXlPY2RqenIrcXpZQndDS05cclxuICBPaTkrZDJ5Q29DVDFNWVJoUXVEaHlHT3ZTYmpVTDlGbk5PK3ZGeHV5aEt2aldTeGV2RVFmamJ1c1IzbCs4TUVIeTlyWmY1YTFyOS9sXHJcbiAgYlVaanhNZWM5d2NkQk84U00yQmJTMEk1eXVpWTRYMUJGT0JLUEQ5NnY2RU1vYlVKUitLNkVSTXZ3cDFvbkFsR01QZkY5RHpSZHRSR1xyXG4gIFBDd3NHeTliRnp3WmlXUlRqSWhnWWNYNEo0MmxGdHk0aDJGenFxN2pOdVJCUkRDMnlGZkNCUWNDRVdsUURnUWlRbi9oUm5DTTZPdEVcclxuICA0a1JFMitObDZyRjA2Vks1L3JJejVjVFRsRURHNEx2ZnUxeCsrNXUvV1R4dXNoc0FRdkhVMDdPNkVKRm01WUNCbzNUQ3p2cUxqeHZnXHJcbiAgUUs2OTVyTVd2L1pydjdCd1grRHd3eWZKQWRFR2crOS9zRlFXTEZpbWZad3N2L25kQTViWEczVFJnUUI1eFpPbElEVkhKaythS3U5c1xyXG4gIDlodmxBZHB6TlBBSXp6ZVdxWkFzNHc4OUFpOFlBMTV5Rk8xU0x2Rmo0REg5amJMUU1iQ2FmRURLV2xtMGFLbHhIKzJ0N1ZLVVh5RHBcclxuICBRNlpMVS8wT0cyQ0ZzazAycjFrcXpidTIyOHdhR0h2b3FWTGJsR0hjaDF0ZDZheG9xeXVNNll6cEZwUWw5bzV4eldqZ0VKSm4rV0dBXHJcbiAgaytjRGRMdk9vRTFldjI2dUlUb25TdVY2WGYzY2RHQ3lKVzNjQ21YYnlqZE05QkhTWVlDSDlxeDlyV2QrZ1V6LzRPZEJ1b2dsK0hob1xyXG4gIHM3MlpyWWU5Yjl5UDl5dldsb2x3b2piMWo5azhIeTJ6UHZieXhwcUZzdS85NFV3dWh4UlEwcldKUTY1OFZEa1NKU0w2Unh1VW9RVUlcclxuICBSM0g1SkVNQTVPbVBCNVRUQ053SUh4L0tTRDluSnkxdUNFWC9XcHQyMkt3U3ZjYUlvNjh3VVE1YnJkcnpVNFRLYkJNeHhlWjVqeXBpXHJcbiAgMUJrMWM1dm9HdDRhMTRxeW9raU50b0hlQWgwRis3c3dVU0MrOHFYZkcwSm1QRlF1ZWs1R25mQTE0K0xTM3ZxMnpIN3JYU25JelpHZFxyXG4gIERld0hraTREcDEyb3MrYmpwVnJmVFZ0RG5lMEhrZ1MvR3ZmRkpLRXJKRCtibWxYSlJWY1lTSUF3RVlQaVN3c1JYTDdlMitqanYyWmpcclxuICBqdlBHTFVadDB3NHhrRHg5aHdpQnBOa0NlTlZMdHhxM3NrdTVudGFHN1RMcXVLdWpxK3F2UmFJK2FHV1QweXRBZFBvTW42YkhWSG41XHJcbiAgUnhPc1hhQ2twRVFPL01yTFhzNHkvWVRKK2JIZElRenRST2NKOEhpTU9Jb3hpQStzOU14czJmRGVRNlliY2kvVm5VNHNxR3YxZ2g2aVxyXG4gIDB5Y2JaaGRFc1U3OTNpYlk0bEt1QVlIWWpyY0JiU09oRHdsNmg1aGVwR3JwYXlZcXRIVkNXcysrVXozSFdDYk9udVNNOVE3dFQ3NFNcclxuICBDbS9MOVNLaGpkNTBJbnluOWRYcnJFMmJBTzdhSml5WVpZS0hHQklDZy9TQXVpMnJYNURjbkRSNS8vVzdkN3ZmZWVBcVdOVzlZb1dMXHJcbiAgc203NTlkL2t1bTk4SVhFdXlYbkVkU2J6Tk93dStmbS93NDRkdTJUUWtHT2tvYkZKTnE5L1JRWU5jcW5MN21EdDJrMHlhN1pPYlBSN1xyXG4gIHZlYXJQNWU2N1R2bHN4ZWNKbi83eTAva2pUZncyTnVlNkhzYzlDdnRDdVZqcHNyT2prYVpOZS8xS0VjaGpQVUlQTmxyWmxmb2tSY1FcclxuICBUemV3dk9RSmorbHZsN0lwTXFXOFRTcTNiTFZPby94TjE0RXpkT2hRYWU5MEZ3dVV5Y2pycHpQZ0lzbkkwRUZsOVpRYnFmd29SandRXHJcbiAgWFNXSkIzVTY5U05KZ0YyV240QUkvWEFrM1RYTUxQQ1Z5UzdIcHB3aUVFVm92QVRFVmhBUHhGWU1jQWFtRXcvcTdwNTRXTnF1NS9tR1xyXG4gICtMTHlmT2FsNlNUeGNGYmZSVlZleityRWlBY3ovUjE2cnhBUExLejRHT0Jta0ZOak5kT25UejdmbFhrdXRtWWFxNk0ydkMxbStSQVBcclxuICB4REFnTVYvVEFkZUIveVVxT0FkaTdscVFSV3RlZUQ3V3AwamZnWktXR2FTSjk3VHZjQnc0a0NST25ZNzJacE43WXltSHFhM1B0UDJjXHJcbiAgdCtjaGFjUlJxMTY1eldiby9VWWZKaU9QdWR6YU10R090cmRLaVFkV1RWUkRMelQ2aEsrYnI3QmxULzNFdVEwRjFuK0F4SEFtT1A3TVxyXG4gIEgwcy9SVkQ3bmZvZG1YRHV6ZHJXRE9rN09oelQ3VUFjYVExMk9md1o4d2xaSFR1bXkrZ1R2MjZtMXNRbmZQTG5NdTN5ZjhuK1o5NWtcclxuICBDd1VMQjZIb3g1UjdzMW5rc1k4NGJVQTBLTDlOODB4L3NQRjk0NklncEZ3ZnZWa2Z6Y2ZBWWVWTHYzVlJGd1NlbHhhRlFYd0hrZWt6XHJcbiAgYXByVVAvZEZlN2RBaGhKSzduWDFyRHRsemF3L2F2ZWp2dXQ5K0hOMTdzYWZlenllWWdpY2NyejdqR3c4Sk9qN1VrSS85TEFMRXlLcVxyXG4gIDBGNTRWeDUzczI4c3RmUlJHNUhCU3E2dy9BRFRsMkNhYmVOU0p6ZE1MQkp0MkVEMCtvUWw0NDYyZHg0NGtjb2xMeVhPbThuNmdMR21cclxuICBHK0xTOFhxRTNwL1F2NjdpTERnUnpydlg2MDNtbjR0MVNVd1dXR1NwRmFLNitneXFxdVJiVjV5NVcrSVJoN0t5MG9TTDlEanhRUGNSXHJcbiAgd2poQVBGZ2I4bkVEWXYwckxuZnUrNGJ2L05Zejl3RG9ZdjUyNzMva25MT1BrMzc5aWl6dmdYOCtMWldWTmRySHliczE2ZFVuMnhXd1xyXG4gIHdzcHNqV2ZUaFFCUlBKNWxrTXpRUng3RmdCNEZZOUQ3dWQzbGRpcVNtZlg2TEttcHFUT0xxK3lzZEozWjdTKzFhVU5zQUpxbGxaWmJcclxuICB0MmFsRENnZkxWazU3c0tkNzJ2dG1qWFNyOFNWNWlCa0l5UTZNQUEyOUNrSW9pc0dERDNnbEoyUDhxSnpuc2V6VVNTd2ZhdXh3c3pLXHJcbiAgSVNBb2VobU15SGtad0VteDFVeXJCOEx5dHNJZzk3Z1BkdHIyZlBySE9kTE1YaEgxSU9jTzV6VmlJVFAyUkR2MjBjWGJUalBpd1RvQ1xyXG4gIDZ2S1JvdURuSTRaNFpCZmp5aVJWK3ZmdlowZ0dyN1I0OWRqeDlpMmE3VzJnS0djR0NYZkIzaE04SS9KeEc4N0hEK0VBR2RJdlZqNG5cclxuICBuNUhYaDNqd2dTTk9jWmNreWdsQmpJeUlVRWJUNWlNTE4vQTVDYk5tRjg5NE8vb1Q1U2tSbW4yWEVXVVFMT2FuV0Q0aEhzS1ZpQmFJXHJcbiAgeEZZZzhLOFpnb0E3UVZhUGFJbDJwbnp4WHNuSnpqSk9xNjBWUXdzbC9EazVVZnQramNUeDMvekY2eVg2RHdMMlo2TUpQL1NlTVprZFxyXG4gIGZkTFhaZkMwOHpUOGh1eC85azA2VHFicmFlLy8zTHN1a01ZZFd4TUVaZldyZHhxSE5mcUVhKzJlV0ovRE8wVTh1RlU1SzJienExOUdcclxuICBieEk5citoNjlBT1JDNEJoeWRDaDVUTHM4LytKeXFVWUljRkZDK1Y4NXBDOEI5b0l6NFJ4QkdIR3JUd3U1cG5SSTBxRm1GQ084Y0dzXHJcbiAgUGRRUFk4ZnJhc2pIcDZHNzNHZkNWWktZdkF5WWNKS0dQcm1CQ3pIZFhHd2NKME44Y2sxUG1LWmoySURGWVJESE1zWkNPZG9sVEZ6ZlxyXG4gIDNrWDNOaGtPbkZQaW9jL1V4RmNSRVlGYk1VTE11WWlRd0gwTUd6cFF6djhNRTVUZEE4VGhsbC85eGVMZi90YVhFdnFRbGRGNmpDRGVcclxuICBpdXRBZm5XTHUzby83dGhwbHZkeHc5ZXUvWnpkeTczL2VGTHE2MzIzeEQwQjdrM216bDBzUDdueEdrdGphUExiVy84dXRiWGJOYzZEXHJcbiAgNnduNlZIdENjNHU3UEREb1ZxL1habnJMN0pFWHZienVZSG5kVDJpNlcxYmoxdm5TMGN3K0ZvelRGR25UV1dSNllabnNhZ0VCK1daUlxyXG4gIG9jNzI5andaTXJqTWJpNGpJODA0a2FKT3JJWWdSRGl2ODRJbzlNeFJtblZNKzJmWDdScTNENFBCRjhzTG5sWTV4OGNFOFdEbXdreVhcclxuICA4NGdwcU5PcWJERWgzSWZQa3NMZ3BsMUNINndXNm8xQlBEaVNGaW9wSmw3QkFvdnlHQVBVbTNMUjkxTHcrbEhvRDBiVEVBOTNMUUdSXHJcbiAgNFlPRmlFQms3UVBUTnRPeUNteG1PR0tFNjRPY0M5SEJ2bktscExidVZPS3h3TGdPN3MzWGNrQUFsQnZaOElIc1VLVEJabHU0RThFelxyXG4gIGJ1TDUwQWNqREc1WnhXSTR1Q2JNTUhscy9DQm1vSHlvd3d5VjBOWStSRzFZWVEwcGd5SjY4V00zeUh0M1hXaUVxNTl5QmR3amlIamtcclxuICBVWmRwU1RpT1crMVk5K2JmakdqVXJISjlCSnpBd1orNzArcHcwQjVyUDNCYll0dTVLdVRsdWMreCtBRVhBQUxmOE82REZuSzg4OGRQXHJcbiAgMmJId1g5K1VaYy84WEZhODhHdFovdHpOc3ZUcG4xcCtLSWUrWk1XTHY5SDRIT3VESVNNZGEzYlBoUFordU05d1BlNDMxZm9LcDNIeVxyXG4gIHJ6YVlCMlh1aXdrS0JKUHpwbC9STVFXUkdYM0NWMDJYTmtnUmUyN3BTQ01tTDN4bmpCS1MyNndlYldiTnVkWSsrdXpzVEdscGFaUFJcclxuICBveEhQb2pQeDlUSDBCMi9LOUlIK2NLeVovU2Q1NWFiSlNwVDFtb2I0T2VmbnFVdklLdm0rbzJZYXgwbDYrNGIzQmUrNUVKSU43ejVrXHJcbiAga3c0djczVkR2UkJuVzFzbURVeGttSlNRemY0dW5NT0ZEbUtxK1BXU0lYcSs4U2F1SW1Rc0J5TEM5eHc0a1lRN24xaTlPRUVuRHdVK1xyXG4gIEhxVnRuWWh5ZExnRENrU0VmVVg0dGhGellUVTNycVJGMjIrUzMvL3Njc2xuL2N4ZTRMcHZmakZCQ1BUV2JHWDRKVjg4SjVHM2RwMTdcclxuICArUWp3emV2Y0ZIam16TW55NWx2T3RYeWN3TVpQWDRXSWFQeVdpRmp0Q1NCcXQ5NTJ2NXh3L1BTRW5wQ2RCeGN1WENFMy92QUt1ZkxxXHJcbiAgbnM0YWU5V0JCTWdlRkcydWIrQVJYbm9zVTBIalVWSmZsMGNBTHhnRFhtWVU3Vkl1OFpQOGpaME9pVjFyWHpheEZRQUhNbnIwS05tV1xyXG4gIDVWdlJlcG1vbmg2SVE0WU1IaUtWYXhiSXJoMDFpcmc2cGFnd1Q0cjc5cGVtdnE2b3BPQ3VMVXVrZ05tOXhuMlFlMzRZOEtUdG5tendcclxuICBlY2dBdzJZY1dUNHk2MEE4a2dQV1F4dVVPc1BwbXUrRE9Ca1BiV3Rha1l2SnkvVkRjQ0l5eHR3dUlIYkNxZ2szSG9ST1BMcjJLZDRPXHJcbiAgaXhaTmJLQjVFQSsvbHM3Kzh2cVorU054UTl5RzdCVUIvK004cWF5dWszUXR4ajRxTTc3OEo5bStzMG1KeHlUamZsZ3JBK0hRSzlpelxyXG4gIG9YN2dLRUxhbnhISkZLbGU4WWF0SVdIUkZtYTlFQ09JQ003MitvMVJycXg2blNuWm5hdWlFa0FmQ2IwdEZxRnRXelpMeHAveEkwT2VcclxuICBuS05vNERRZHNTckhwUGVIUTh6aFIzN1pSSkxXandDSnRwT3c5bytIeStvMTYrRUZwVVhIUkg1K25neWNjWmtTbmJjVWFRdzNtWGVBXHJcbiAgTVNkZHAwajdMWXZEVlhJdDlxOTNTTFp0SEtjQ1pXbVh4WE9JYW5BZkR4R0FFME9FaCtJWnNSaW1wd01tbm1RRVBpRmpVakFPMVNQaFxyXG4gIEo0Sk8yVFQzVVZuNDBOZmtrTXNlMUxSUFVPakJLT1ZNc0RRYmRmeTFWbTZWY2lQRERyOUl0ajkxa1N6NFlLRk9zanFNaUJ6eGZlWDBcclxuICBBTDJlWFNlNkx1UEx0aEhROU9wWDd6QjlGSk1DUDY4bG85RFNlcmhPb1ZOdzVJbkkwaFowS25kUnRldzFJMnEwYlpaMVNtQ0dUdjk4XHJcbiAgVkRmb0l2emFqRzFFaTNoYTN2RE9BL3JlOURrb3BHWm0yeDR3cmhjWkY5V0o2ekU4Tkc1YXh3QWhibVJzZ2ZEV1pXWTlpUkVJUklaeVxyXG4gIHJCSHlldkUya3ZvUlZzempudDJlZ1g2L2pFdnljYlpZandzVUplU3JaOTBsMTE5K2hsejd6VXRsd0lDOUV4RGc1ei83czl6d25Vc3RcclxuICBqcmlxcTlWVnovVWlLTmhQKzhSUjBibVBYeCtDVG1id3NPTWtQeTlIZHRhOUcrWHVIdWdYU3lKT09lMXlzOGJDMkFOQ2Q5T1ByNUw5XHJcbiAgOWo5SFZxL3d2VU1DNkpmYkUxSWFJKzFCdDIrdzV5ZXAwRnRtanp6OXRIZGJydGRXdThEWWd0b281cVh6Y25PTWVJQlFISFJHdFcxTlxyXG4gIElnNTBwT1ZJMzlJeUU4OEFkVHZxWmVlTzdScmp2TzlyYnFJcjB0WTVQeHdaUi9Ib1hNZ2pOS1NnWWVCQVVHb25PUTlGYkJvRzRsR2pcclxuICB5SlIwa21ENDBSM3A4MkdGTkh0RFF6d3cyY1hNR0tMQmZmWWtIc2syTFZRQ3hNelFpUWZXTDBuaWdjd1o4UkdFSTh6NlF6MFdsL0Y5XHJcbiAgQVV3NnFsNzloZFVoRS85RVRqdzByVU9sU0FtSCtWNks2bExPKytPZVpYRXR3a2ROY1dhRE9JYWtMS3VtY1ozUEdnNjRBVk82VXQ4SVxyXG4gIGg0dXNLSWU0aGxsMmVrYXU2U2JJRHlJZWRBd1FKQWdLL1JxZ00vQXBYN2hIRHZyMDc2U29iSUxWMTUvb29HMzY3QndGU3ROMzdqeFhcclxuICAxbXpZYk5aNUhLbjZOM1JJdWJaL3VCeHcvbStWd3psWUNkeE1HWFB5TnhYUkgyNUltc1dsbkdmMkQ5SnprNEpVWDdYTm4xNnJadlhiXHJcbiAgZW8yM3pUaUJqdzBMdFg0NlM4ZWFpYnBqbEx1WWZOSGRGcWMvRUJFOHpxNTQvdGN5NnhjdTNsenh3bStzLzZITkx2ZWkxMk45Qjl3SlxyXG4gIHo0NjlZdGE5Y1k5MGNrckxqejdoYTRrNm80KzcyZ2pxNHNXTGRUN0NjeFVaTnN4TnMwTjdkaDA5OE0rMjljT25aYzJyZDFvYXA0cmtcclxuICAwUmJsNXQvN1pWbXI3OVA3NGtmZ2NoR2xlYjV5aVRvK1dOZkNlYmpTUGtPbkdMY0lOOEo1cXhmcWE5b1cvMmtjeFR3cjE2Mk1BbTBFXHJcbiAga1ZaWFRpUzA0U0VjQ0hXUU9yQmdGKzZEZEtaeXBTN09jb2VwY1U0azJVWm8wN2RmWm4yT2k3RTJXQnNKNnl3bHFzMHJuNUh5UWYzbFxyXG4gIHU5KzkzUFlSMzFlQWVJQ0VnVGp4Nks3N0NBRHhDT0t1MmE5Ly9HSXNkREpISHpsVjZ1c2I1VitQUEIvbDdoN282MWUvL2d2NXh0Y3VcclxuICBNaTRFTWRhL0hubEJ0bTdkSnIvNDJUV0pld3VnVDdRbmRPWjB6L2FYN0VFVU4wakdHZnhKaU1lN1ErL25QRmQvdTV6MnhNYU52c2duXHJcbiAgSFU1VVE4eDJrK0JsV1BqRUlHQTJndWhrWjB1Nk5PV09rRFE5blpXSjAzZGxsNVdBOUV1cGtKWmRWY24xSHY0ZnhZbjU0WU11K1RHSFxyXG4gIGtQVWV6R0p5emMrV0lnUkZxTmowYy84Z0NXYVlzTVhVNzdmZlViSDZ0RWU4NjRDdVhQS2l6Vm9yRnVOOU5FVktKNXhveElNNmd3NDZcclxuICB3NGlIbSttR1BvUVBJZFkzL2FpWmtWbmZOQS9UU1VMT2dheXJsczJPMWc5UUp5NFhUcEhDUW5mNkNMQ0dwazBSSVBsd011WjJYZjhvXHJcbiAgaXd3ZTR3RGlvVzdvVDlNT1p0cXBlbjFtV2V5ajRTS3BCa1YyVklmdytMNGY0UmtrNzU4OHVCUGNWSGlhMHk2YW92N0tsMzZuYmJvWVxyXG4gIGgzd1E4b1N6ZjJMSVBkNlcvbGdjRTFzNHAzZnUvS1E4ZTEyWjFLNTgyOFFzWTA3NnBnd3E2YXZjcTJsdUpGdnZGZUpacTV3RGF5ZnlcclxuICBTOGNhSWEzUjhtazZHOFk4ZCswYmYxSGlNY2VzeE9Bd1FJb3RUZHIremtyelhrRGVObjNmaUVJUXovVVo2Y1NPZm9BTUlVZ1FIOUp3XHJcbiAgWDV4akRSTGpaS3dTcWxISFhXTjlSOVJJdVdldkcyeHJGWFpMVUxUblF3NDVYNDYvYVlrNS9TUWZJckJTbjlYS0YyK1YxUy85WGxiZFxyXG4gIGRhdzBOYlVKemtEVGxGVnZHM0tLckg3bGRtc3IrYng4M1JBSzkySjlaM0FmblcwdG11MWxXRndITnpMaW1DdXNyUGZCNnlYaWtXZ09cclxuICBSNUxrMnhxZzFIUWxLSGdsUU8rQndVWFhzVWJicEl2TGZRSmhUaTZ0TFJha1ZwaWpSTVMxUWJudWRiMk9oOGsyK040SmczR0ppYkdJXHJcbiAgNjlXVG5Md1RrV1JkK3BGczAvUm5OdmgxZkN2MzA3QU40akZNY3F2ZXNEVXozL3ZhK1RMM3c1VVJ4K0FlT3ZZRjlBbzlvRHN4OFRZZFxyXG4gIEdXdlBETDcvdmN2bG9ZZWZpMUlmSC96ei9sL1piZDd3WGI2bGZZT3JyN3BRQmc1MHI5MnIxMnlVcGN0V3l3bkhUK3VoVE8reUVoM29cclxuICA0cEczSUZwc3ByZG9ONW44Y2VDbFJCQ1Y2Rm1HTS9Ia2JzcDVUSCtUV1FvcGNtQkpvN2xpNkV6cGxJNFc1WXoweFE4Y3NiOVViTmxnXHJcbiAgTTNWZTE2N0s1V0x1eGJVODhubENuQ09tWmVaTGR1dFcyZFhRSktuNkJEdTBlbHBIZ3pTMHNxL3hBQ3NYQmhidEpBY1pZWlJtT0dqSVxyXG4gIEJsRFp4UzY2UWw2S0ZSQnNQQjhiRmpZZ0FCWUp3aHF6eWgyVFhaQnVHS3doak1kWlFZNXJkTksyUWx4blJEZ2hSTm5Jcm9VUU9iYlJcclxuICB4UW9GWlRiOThQcXhNQ0llUVNUazdzTjlmM1RFQ3hBQ2xKQit6ZWlEdGJqM28wSDdYN1dPdFIwUWFKMWRhM3RseDN6RDFyZGtLNWZsXHJcbiAgYnVtbm1pVllxQmZxb3VmQVZ0OVg3NFpuaU0raTJaS1ozOWZFRTZ4ajZUZnFVQ3Z2OWJYUDRsekhxcGQvcjNrK2UyUVRKbi9Hdm1yZFxyXG4gIG51M09pa2hzTmRydXdjUXQxbi9rczRUK0hPQUNXT2tNQjVpZW5XZWNHb3NpaHh6eWFWdkFCbEdnZk8zQ2Y5djZJU2hGY1ovK2tuZmtcclxuICA5NDJqWFBuOHI0d1lJTXBhK2NJdFNzQlhTNTIrVHl4MW1DeG96KzFhSUMxY3VyUFZNUndXYmNKMXNQaVEvYnhYYU4zYVZXOHFNdit0XHJcbiAgYkhyM0FXM3pUYTJHVy9jSE5mMlFjamZYNi8wc3Q3YmdKTmh1dGxhdnczb2tPTGVCQjUxdXlOVkZaeWt5NjZlc3kySmlNb083dGJac1xyXG4gIFRPby9DSklRcEZtcjk3M3gzWDhha3NoTDNhSElyOWJFdGlqUHg1Ny9Sek5RZ0VnYkJ4dU5aMnRRQVdVeGhnMXcxSVNjd29vUklneVJcclxuICB4bngrN2oyZnQrZnBwc3pVNVIybTZMc3FNeDl5N2sxYWRKeE1zampXV2V2Zi9LdDVmdUFabXFkZWFrVFhKSTczQUx3WDVQVmxsYmp2XHJcbiAgZXRqUjJxamowTGRYU0V2UEZ2YTA4YnBXT3dyOWwrOGMwMXZlQmM4QU0yNVdyVk1PdkJCRVVsbEtsQnhDQzhrMjB0SXliVDJLV1dVUlxyXG4gIDZ2akN6UW1FSnl1MVhUNTc0YWx5L0FtSEp4RC91Kzh1TkwzQzNtRFk4TUZ5MDAxM1doMnNtNmhQdUhUWkdoazllcWl0UkEvRWcveDRcclxuICBtVzNWZFJvbVJha2ZCN0NvOEw1L1BDbHJsQkNjY2ZveGV6WHB4VXZ2eG8xYnBiQW9YN2tpWHlpSjE0OGpaazZXdS8veUg3bnFLK2RiXHJcbiAgSHRCREI5SzRjNGYwTDNjZkxkbGxibW9KK01zUHJ3RFFlSlJNdmhxRjVDaUpvT3ZBU1lCRlBaMzRqWjBPaVlHZDYyVEprbzhVU1dmb1xyXG4gIEFHbVYvRDRsMG4va0ZObXl3V2NaTk01SGFRcTFEcFRzR1o1bm5NaDQvY0RicFVLUlhHZEhwM0V3RUpIOTl4OG4xYm1SKzJyckhIMGtcclxuICA3Z2pPODBMY3c3cDFIOWdNSDRUdENEVEZ6REZCYW81VVVVeXlPQ201d3B5WlZTZ2JWK1NGUE54UjVDbHloQ0JCZ0pDYmN4OFZPcXZFXHJcbiAgWlRhenVGMFZ5K3hEVHZZbElBQy9wcHZwdXBXV2NSNzJISjN6UUV6Z0JJbzNSRDJ2WS9VMWg3VVp6WnZlbFUydjMyNERsOXpNakZRWlxyXG4gIE8zYXNwRXhDcnE0Y0Z6THhxTHpWcFpTR21PS0cvSUI0OE1uVW9zaUFXVGFJQjJlR29Ud2x2Ynh6RTVadFo5MDFpdXRsdEMwbE5nc2ZcclxuICAvS29SWTJid0lEOEhiOGRydU00QndtRGJ6ZXBmL3pGSEdhSkYzZzBSNkR0NnBybFJnVU1BdGovL0RWbTFkbzIwUm90UGMzTHpwSGpjXHJcbiAgU1ZJKzQvUFdJdVc3QUlYK3Z5RDJPVVZSZko3VjZJUUN3WEQxNGhkbGw4NnloeDkxcVJMYU4rV3dxLzVqRmxGc2c3dE55M0ZaT0NGRVxyXG4gIGQvU2QrOFFpNjkwN1BpbWpUL3lHY2xMZjhBSVJjTzkrblU3NTZQWVpzcDQ5Si9SVksrNDBJNG5VVVdlWkZSZDFLQWFSdGZkaTFjZ2hcclxuICA0dUdhMS82czNPb3J0bVlGY2VLSVk3NWlJa1VBdlJldVJjeGd4ZHBLMW5NZGc4ZHgrZ2dCTVkvQ2xtOGx6T2xpb281Mnp2VVJuY2F4XHJcbiAgNERxSE5WUmUyTSt6andzS2R5TmlWdFoxR2FGZXlHUHlGTklzS21SOUNNU0pDUTk0Z1RvbU5yUDZzYnFLQ0VJYXZRemZJTnhQWmczT1xyXG4gIEtOdms1emQ4VHM2OTRJd0U4Y0R0Q0dzbGlPOHJoTG9oQkJCWFFVRFlzT200WXcvclZVL3lsNzgrSmwrOCtCeUxmMXp3MHN0dnl3a25cclxuICBYeW9uSGo5ZG5uLzJ6MUh1N3VFYjMveVZuSGZ1U1hMWXpBdWpISkhmM25LOU5EUzB5T0V6RGt6MFZZZGFWOGdwU1BxQzJTUDA5b0gxXHJcbiAgeUFQcFJORTRXRjV2SjdyQ21Qd2EyMGxOaDVSQnNWTEVrVU5LcExKeXF4TVBiY01XRUNuU2hXQXdpd1djZUNEMkVYUHRYajU0a0NuZVxyXG4gIFFZQTZYbVQxNnRYU041MU5WK2dEZmRRd1FrNStKQkd0aDRobnB0aHNtcnpHN2I0NUZGNDl3LzRUZk96SVVMZXRlTjNPR2JJMnBFMGJcclxuICBVZG9PYjVlWldrZEhxdzFjemlGamg0dmlQSXNJWFFTQTlVbFA0cEZvQndKbDEzRGlnWVVKNXlFZVdNWWtpSWZWQzlmMmRrRGF6THF3XHJcbiAgdHNvcndzMkxBM3VFTkRZMkdkZkJFY29uMjBnMTVhbEd0TFMyclgvbUVWZUpCM240K1lMb1lHQVFyaG11VzdQNlBlVTZialZ1b3ArSlxyXG4gIGUveCs4QW1HM0h6TGdpZGs5WXUvazRNdXVNM01YTTNkUjFUWCtxQi91SENCRTBDc2hLNWk3Q25mbHYxT3ZjR3VzZXI1VzZSdTlSd1pcclxuICBlL0szVENTejdObGZ5UExuYjdhanZyN2VQQmRFdkl1TUdUMVdEdjc4bnhWUkh5bDl4eHdSWFVldllOWlMzdWQ5UGZRbmVkZ25SWmpNXHJcbiAgNjZ1RWNMVDJjK3dwMzVJWjE3MGtKLzVpbGZXeFJQTlhLUGN6VDJmNGVONkZFM0w5aXhLTzViTk03SVdvcTcvbW1RSmQyMktpc1Z6dlxyXG4gIEV6RVhhZnVMcm9QdGYxWk9lcUlIQUdiTmlMZFlIME01ektCWHZYeWJjWC9XZitzbk5WSmx4TkdYeWJSTEg5VG5QazFHSG51MW5rODFcclxuICBuUXF0RWNlVmlTSDY2SDJFZWwzamlQN3VNY3M5dkNrVUQ1K3N6NzFSS3BhOEZKWHo2NFVKRlRvN2tMemRnMTRIRnlqa001N2RCSDJKXHJcbiAgbWFSN0hlOUhDRU5lTUduSDFCZHVKRFV6MTVUajRBak9ReUM4ckY4L09abnl0SzhQV1M4RDByYkl5aFhMNWV6akQwNFFqd0NCZVB3M1xyXG4gIG9peDhVUUhVQ3pxUThGNGdIclRmbTU1azFNaTlPMEQ4YitHb0k2ZktzS0dENUlXWDNwWnQyNEl4eU83aGpOT09scHljTE9Pd0E4eDVcclxuICBaNEdjZGViUlhjUllQVVJZYjczNnB0ejMwTE1XVHk5d1Z4L1dSS3doeTRtU05nQURlRUdMT3ZDaW8raHV5aVYrWTZkRG9xbG1wYmxsXHJcbiAgeDBJb05TTk55Z2FXU1dYNmFHUDNFNE1CeXFEbE1abGxyM0h5Y0JhSUtLaWp0Y25rcXJsRkF5U2xxY3JNT0NFZ3JXM3RrcGZXS08wRlxyXG4gIEViZGcxNmV2VVp1eGtKazI2enhBV0ZqNjFLNTkxNVMyektKaDY1RzltdHhVT1EvS2MyVGs5WW5haUFacGdoUHgwR1k4V3A2WkYxd0xcclxuICBmWVVJZ2h4ZGZGVW5yY3FPdzc3Ymh4WGFpZmROMjZSUHpBeHhrZEYvM0RFMjQ4TDErc1ozL21tV1BwUzE4ckdQblBhQ0c1Syt3eVpMXHJcbiAgN2FhUEpLdlBjSjE1dnFFc2ZZcDVNbWE5Uk44cE92T3c2L0V1L1Bud0xFRHlaa0NRYURQRnpFbnBNL0drVDY2b2JuUjlFQmFpTHNSUlxyXG4gIFp2S3NNMXc5YWNlbWVmL1NlMThoNDA3L3ZpRlF5dzl0YUYxbXpSOHFWN0x4dlllVjJFd3lRczVpd1JaRlpwdmZlMGhuOTIrNXVFbWZcclxuICB5WVozL3lrYjMzM1EyaDkyNklVeVJoRjErYlFMcExEaVdkT2xaV1ZsS1FGcWwwRURCMHJCWkZ4eWVEL2hFbENtZ3NCUWNsY3ZZMS9vXHJcbiAgRkZuNDhIVW1Xa04wQ1lmUS9jRHFiTVZ6TjJ2ZkhqSzlHT09CblFvM21UZmJYU2FLVEM0MDVRQzRQeWNzUmlST3VWN0tEajVMT3ByclxyXG4gIHBmS2psNHlRNVBRZlladUh0ZTZxc1dkcmpodjEyU0J5WW0wUmhHVE5xM2ZZckJuT0szM1dKZVpsdUxHeDFTWmNBd2FVU003NDgrVzlcclxuICBQNTF2SEF5YzFycFpmMVlPYjdxbUQ3UHgrOUhqUHpSRk1tbnJXZlREODJDeEl0NTkzWEJEVEp3Sm9NU0cyRUhjemZXTlYvRlFBWkVnXHJcbiAgOTA5TzZmN0gyYk9EUThWdkcrZHlpZ1p4QlN2cllZcTF3MEpnVmt1VjdIKzhPZW8wNHFIdkFuMElhVVNIN0VVZWFvWmZ2bmt6dmRYSlxyXG4gIEc5OTlpejZyYkp3djZnUUNaNDRBWTg2K3JieCt3bjcrZ0xjUStxQTRRZXV0L25DV2xQWXJsTWNldkZuZWVtZWhJWFU0ajhlZmVGWE9cclxuICBQLzhVZWVlZEQyMzVBS0ttZllISlV5YklBdzg4SlFjY01EWWh0bklpNU9LcTZ1cGFVM0wvNC82bjVFaEY4Rm1aR2ViQUVCRldLUE54XHJcbiAgQVU0V1Y2M2VJTysrdDhpTWtPakhub0JyZi9vQ25ieVU5TkZKUEl1MGZYWDdrQ0VEdFkyUDVOSXZPWWZVUTRSMTkxMFB5YlhmL0tYRlxyXG4gIER4dy9VWlp2WjhNZFV1R1JBeHFQa3VFRmVOQzFqTmNMMEhzNWorbHZNa3NoUlE0c2E1SjMzMzNIWGhpUWxaRXA1ZnROazRxR3NNRjlcclxuICBWRWN2RXVjNDhFbUZLSWo0THAyNUZFUXJ6ck8ydld1Y0N5d1l3T3JycVZPbnlvYk9vS0NtUFVkYUlEelA4OWsyeW1IWVhkOHpJVlZhXHJcbiAgRlRGazVvVUZWTGdvZWJPWFZlWkpCR3V6cllpSUJCTmRrRDN1d3BreHNZOEhDOFFHSEhDcWJGM3dsTG5rS05IMmtuMUs5b2N3Y0QwbVxyXG4gIHB0S1ptbG16Nk1mSHZlTy9hT0NCYkdWTDNhaCs0bjRnSGxqSGlCR1BZR0dWV3I5UlB2alB6OG1XZEdYaXFEYmpCcnd5ZXh2OElTcG9cclxuICBiMjNRRHhVN2VtWlduTk5BZi9qNDZEUFBpYktoSG1DK29DeE5TbWZBeW5sZ2hvdjVNekwwaHBxMXRoKzQxK0hmNjFGLzI4cTNaZDJiXHJcbiAgZjVWaGgzL1J6aUUrNldodGR0R0dJaGl1dC9xMU93M1JBbU5Qdmw2UktaWk45aCtCeDViL1RnbnJ4azNTekM2TW1qVkFDVWpob1YreFxyXG4gIERiUUNCNHZJTElDN3prbEw1S0hrM3hQZ3JCTjV2Q25PdFN3SHhLR3YzcThUbTdmc0hMMUJQd1kzWWg5ZThpY0dtdFovMXBxczFtT2tcclxuICBjaUZ1TmVSaVJpeTVhRE1Bb3FIaW1wZVZnSHhnRXlURXRJY2ZmcWdVblBXb3RiUHloVitiWG9ZeHlrNk9vNC8vcXBuL3dpME9uZkU1XHJcbiAgcVZSaVdUSVdzVFhYcFRVUHJXVU5qTmhiTWpxbkI5d3B5dmNSUjEwZWxRdDFPa3lNWldVdDdRZGNKdDhTS1ZPaVJ4NkNUYlJFcm9ZMlxyXG4gIHNkRVFvb0VIQkd0UDA3aEFjWmY1WXR5RzFiSDJYWXhGSE1lU2NFZkJ4SmZDdURyQnBKOXlYQ05meDI0UVd5WHJka2pwcmpka3lhTEZcclxuICB3cGJXRDl6OUF5VlVMb1VCeVc3YVZHRjZEeEI2eUh2cDVUbHkvSEc0bzlrN0JLSVJqKzhwTHluUyt0KzRPRW5KT0VCS1MvcEt4ZVpaXHJcbiAgVWM3dUFUZnY5T1dZNC9YN2l3Qlg3ei84L3BXU201TnQvVlBNMGhWUXZnYkl5RXlQUGovL2RkQjRsRXg4N0h1RjNzdDVickk5QjA5VVxyXG4gIFZsZktqcDJOMHR6Y3FweERxL1FyNlM5YmRpQ0FjR0EvajRDa2t0VmRPVWRHZ25oNHRteHJ5WmVSSTBkS2JpNUVnQlc2bWJKb2tjNXdcclxuICBNcHVqZG1LSHBrRzJLRXJOc2tqam1HbmFnTmM0U2w4UUFvZ1o5cHBOZE9LaXExRGZRODhMeUQvazBiY09SY2lrQngxMHV1VGJURS9qXHJcbiAgazg2Uy9vb0V2WDVQNHNITUVWOUxDVlBZcUF4V1A4ekFrc1REOCtQMXpkR2pKWjBMMFZ3NzE1RS9UUEp6TTJ3dzhQcFpEOUs1QzFFRlxyXG4gIDlURFJuYWZqb3RYV2M3Qk5xWjZ3dFRBUVdtYVh5TzlORHhJUnFuQWdLcUUrTTJETVc5RnJRRHpJdzRBQVVWRzVjZ25lVjNyajljM3lcclxuICBhYzA4V2ZIOExUSjg1aVhhcVRZOWc5c1VUSWlaRFErUjVUcExmK2VQNXlraW15YlRyMzVDWnVqQnpOemIwVUljdEtXSWxzMjNLcXRyXHJcbiAgakhqb0d3Ui9TRkZob1JRUG5hSkkvUWhUMnU3M2lSdHNsa3dkWnZ0NEZUYmpDRVArVEJDT3NBUEVDYkZrSFFOcDY1QWVLSEJ4aVlKZVxyXG4gIGcydlRMcytIKysyL243dCtwMjlXWG9GeWMzNS91bkUrS01EaG92eGNkR2djSW5QeXJkVW03c0lYRnB4SnA1NkNTME1oajhreHg5aVRcclxuICByamZGdWIwM3ZUY21SNFZuLzF0YjhmZUhPUERrWDIyMGhhRnd1NHdGUkZ2NWc3QmdVazVodjJQbGhSdEdtWmlMdEw4SFJvTy9GOXp4XHJcbiAgKzI2SzZMcThmM0MvN0ZGQ2Vhc1RoZFN6WjZSY1FEUFdlVkY1eGliUGpDVGlWWnRRNmZ1M1VQK281eTdqbFl0VURwcTg1QmozUG5sOVxyXG4gIDd4dnR4dVA0aWlNMEQ5c1FHYTNoSnI3S2dTQWFKcTJUdCtUM3dEWDl1dHVxcTZTd01ETkJQRURrbkFlcGR5Y2V4Q0VlSVc5dkVJaENcclxuICBpTWNKUlJ5MjYrd2V1T2JxQy9VYjdOQXlVMHhQOG5IRGpPa0hTVlZWalJrRTdBMVltYzRFZmtCcGNnM014bzBWMHE5dm9mem9SdGVqXHJcbiAgTUVxNndHRlRJNlFiUUoveFhzSEt4QXZ5WXFKb0hIcVUyejFzcjYzVHJ3SFQwZ3piNzdkODhCQWJoRjdma1R0UXJ6TkgyNkkydE0zZ1xyXG4gIHNETVJhSHJYWmhZTVRwU2FuSU9WUmUxdmJHeWFscXBYQWxXejRsV05SZlZzUUlVd1ZkS3pjdlZEd1RiZTF5aGdibXVMMkdKbG1SM3hcclxuICBHSm5GaHZ6a3dFNE9jSTFZdWdIVHdrakczcWlzUG5sNHV0MFp5WDYzZnZDRUlhOWsvZENlaDh4cWc2VVZvaG8rTWhaa2hjV0RvZThoXHJcbiAgRE8xQU1OcGI2eTJkbnBsckMvMXMwWmdoQzVHeVFRT3BiZ1FFcUpwenA2UTJWZnBzVWs5QUFOQTNXU0U5bXJadmxvenNBbTNPVFRYOVxyXG4gIGVuNU5GSy8walRVS3RNODZHVGdzZEM0OFB5eXNSaHg5cVlsa3FCZnFJcGFwV2NXcTY3ZVVZTFhKOUtzZXR6SUZReWJhOXNJUWpXWFBcclxuICAvVW8ydkg2MzdJYytJUkNONlAzNS9UclJXUDdjTDgwekx2SDByRUpwYkhCWER1bjY3TG5GMHBJU1BZZHpTNUQrRzFLdENCMjkwUEpuXHJcbiAgZmk3djNIR3VJcjlLV2ZUSXQyU0ZwbkZ6d1huYXcyUVdKNG1zZVZuMnpDK1V0c0hScGxpOVJmKzYza1IxeTUvOXVmWER6YW05UDRST1xyXG4gIFZBaVB0UFFCbjNHRXpicWhmbU5uR2tHQkUwSWtsbmllMGIxQlRFNVZZcExiZDdnUlZuUW5yLy9xV0MxN2k3USs5MmxwYkd6VXN2cTBcclxuICA5UkhnOThycVJzL0QvalNFa0F5ZGZwRnR0OHc3UVJlRlUwdktzQmlSOXdYeXRqclJRZHhFamtvdzV2M2xDL3B1M3pQOVZpQXkxY3RuXHJcbiAgSitKV1IvK29nMmswVm1VaEg2c3V4b0o1dzlZaTdwZ3pHamNSZDA0OWlJaHRYS1ZwTXdJeExwdng3cXZXMFlsNDJlamVvamp0bUxoTlxyXG4gIHg2TXZvUFZ0RDVCTXNHRVUraERHSUpaZHlUcjZMYXg5VE5hdFd5ZmZ1cnlycDEwbWl3SGhZNzRlUi81T1BMUkQrd2pIYUowQVljMEhcclxuICBJaTBndElkMUZHR2ZQa1Z5MDAvY04xYTY5dmZqaGp0dSs3NU5vcjd6dlZzOVl3OUEzOWp6L2NvclBoM2w2TVJuVzUzYzhVZGYwTW8rXHJcbiAgUWoxRVdFQjhOWHJ1NEJtbWdHN3JpQjRZTDV3Zzl1dEJGRGZneFViUmVINnNYT0kzZGpva1J2ZXRrZVZMbDhtT0hUdWt0YlZUY25JeVxyXG4gIEpDVnZ1QTBDSUxneEFPcVZSV1VteGN3TDUzOWNPQzY2WWlCQlFOaWlsZ0V6TEdXRnZQUE9YRTdabmlGTk9pczk4TUQ5cGE0d3lPNjlcclxuICBqWjBzZEZKV0d3VXhjbjFtTnN4UVFXaWhYUEN1bXhpUWZMMTJMajZ3WFZsWXVlUUZHWERBS1dZaUNPdU1sVW00bG52ZkhXUHArTUc1XHJcbiAgZU9pMjhiNTRFVms0OXhoV25rTkVoaDcyMmVpYVBGYzNsZFdJY3h1S09GSE9OOVZzTVA5ZmNBd3MvT0k4TThiVzE3OHQ3Ny83cGpRcFxyXG4gIG9rV01WVmd5V01wUCtMNDJrMlZsUVNEMHc2MXl0STRpa1g2bUtQZHJFQklEd1pwalFYMW1JQ200RDNmdG91OUJrZU93bWE1M01JaENcclxuICBSRldtT05aWnVJdWhlTWJray9lbUtVUjVmbE12K2J1THFBS0VkaFR3dElyTUhnUXk3clR2S3RmeG9pRVVUR1R4dFB2T3JhZmFWc2M4XHJcbiAgbHhZZCtLTkhqWlNhMURJWlBQVThKWVl1SzhjdENPOGJvZ0tpWkkyRTM1VkV5RDlBMTArbUd1NVRRM0t4cktQL2lBZVo4YTk0NXBjNlxyXG4gIE50dHRIUXJFRTA2MWZOcG5KQWRyUFFYdXg4VmpuYmI1Rk85aXVSSW0wb1c0L2xDaWxoUjN4YS9icVlUcWwwNXNOSVhQcSthV051VStcclxuICAwbVRrcU9FeTZ0STNiVytQQVFlZTRoM2pKNnFQT0dmVjg3K1dGUy8rMW9nRzdsRzI2emVDZmdPVDZMQzZuZlU4VnBwNlZyZFR6Nk83XHJcbiAgNnBTV25kVTZuaysyYzNGTHJWRE82eUFtMHZPUlJSYmlJaXowMkEyUWhhZmttZldkaVpLaWVzeGdOSTRvbGcyK21IVEFlVUNvMmE4blxyXG4gIExUUFBGcVhTVnhOTjJUV2kraHBDUENBY2JwM1ZZWHFQakx4aW5iaXROWkVwWXkvVUdiRHpOZm5nL2ZsU21Kc3VDOTYrVi9MNnVNbHZcclxuICBJQlR6NXkrUm5UdnJ1eEFQNE1NUGx5bk8yRS96NW1vZXUwTHVIVzVTanVQN09xTUhRbHRKY1pXbm4zenFOVG45dEtQbG80OVcyNzRjXHJcbiAgd0Q4ZmZFWSs4K2xUTGY1eFFWYnVKR2xwYlpNZE5YUE05ZnVlQURIV1EvKzhSUVlNVHU2ZTJGOG45SCs2ODhmS3RlWDFWS0lEUC90RlxyXG4gIFVzdWVYdWlLZEhjNnJZZC9UeG9rSXVFbkNmcVNram05bC9PWS9pYXpGRHpSVXJ0YUtpb3FiVGFjazVOcCt4aFUxRFNaNklBeWlBdE1cclxuICA1cnl6eWhUWlhLOWxaNld3UnpaWFpzZEJXSFh5RzNUUTJmN21JRmFkQVcxUDZTL2xSVTFTcVd4Y1ZuYTZQc2dPYVdwcWtPRjkybVJYXHJcbiAgT2dQTTlSNTgvTlJCQVFwU1FqUVdya1VaRjJzY1pRZ0J2WUFqYmIxR2dvZ0VJdUNoVzRTa1dyOVlnOElDUWp6Y2d1Um9DMEpvN2ppc1xyXG4gIGpsOGpIdWVEd0Y4UXR1K1llR0pEanhLK1ZaOUJrOTc3Z1AxUGlxNFY5U09xYThSRFE2eGhkbWtiN0x3SEZ4TW5IcHpQeXNtWG5kVWJcclxuICBaVmZORnB2RjF1L2FKYU1PUFVkYWQxVkp6b0J4cHJOZzBWaVdYcFBkOW13aEpkZlNOZ2doRmd0MUJnNUNKby8xTWNDbWVZOVkrK201XHJcbiAgUlZJMjZReUxXejM2cCtYbTNQNUo0L1RHblBCMVEvYjBEUTRFRGdhbE5pSWU5Z1UvNEx4ZjIzbXY2d2RpSU1RL3lLNDcybHZNWERQTVxyXG4gIGRObk1DcjNCdGxWdktFTCttUzMybzZ2bWFsL0R2b2RkSWVYVFAydGpDc0tMR0JKbGE0bUd2R2NVMDJZY1lRY0dFcndIRGk0ZDRuNVlcclxuICBtYjVlbG5Zd2tJQ0FraTQvN0FJOVBtdVdQa1k4dUdaZVgzTU9DVko4NS9ZelpZZ1NGQnBHNzhJMnExN3ZRaHN6cGsvUlo0QlYwOG9YXHJcbiAgZjJNY0YyVUJkQ29ENm1kSlpXV0ZORGUzY1h2R3NXZGtaRW0vS1JjWjRsMnAzTW83ZDM3S3kwZUVtWExvVWZEQmhUNE5VM1R1RlEvQlxyXG4gIGdDdlZVMlR6L0VmdFByaWNYVkYvTUtEZ1FBUnBadXdheCtrZ0N3OFhQdlIxTTk2d29xR0NIbmlsaGtqVEp0c3BvMHp2TTJ5U2hlWWFcclxuICBLQ2pXK1k4dWhoNFRuWmVOYy8xZTREeHN0MGdsQmkwN3F2UTdRS2xlNHZXaUsvSEx4bE9JbFZOU09vMzdhS3JkWU44TUhDM25XRmRrXHJcbiAgYTZ5VXNPQVVOQ2M3eFRhSkdxZVR5QUFva0VIcUxTMnRDVVIvMFVWbldSNUs5VU1QUGREaW9leStRQ0JDbEE4N0VkSm5sT1lqUmd5eFxyXG4gIGN5ZWU2R3RPcGs2ZGFOZUVTNm5adGwzTGZyenJRZ3J5ODJ6ZjgvSWhBK1VRdmRhZWdEVWhLUHRmZjJPZTFOWml1U3BtcFhuaUNkUGxcclxuICBEN2Mvc21jQ01salovTWEwZmhIeFVJZ0dMaEJlbkFmSmZEdVRTTWJ5WStXU3AyUG5ZMlhycTVhYnNodk9ZK0RBZ2JKcVMxdXYzQWNEXHJcbiAgRElUTnpEYXZIeWFzZXI0Yjk4RkdVWms2QUIyaE9sSnR6aTZYdEYycmRIYlJaRm5vV0ZwYW1xU3NiTEEwZE9iYXdEWkxJejFwaDE0alxyXG4gIDFEZS9TWW9nRUdlNVloTXJHeDFFVVZrTFRVUkYzTVU3eUY3cjFyNW5zdGlxSmJncUdhMEhlM0k0UVdFMnhjZmhkVUpkMmt2R21mR0JcclxuICB2RmtnYWE3cjlSd0VsQmxjZTFPOUlVTC8rSkw5cUY3K2h0N0w1c2dheGhYbUlFWWpIbHFXVmZTaGJHZitNTm4rem0yeVkyZUQ3UzNQXHJcbiAgaEs1UUtpV3RlS1FSV01yMFVTTEVWck4rbmVTMVdEV09tQWZpd1RYc1RVYm5NWFVlT1BFVVJZb1J3ZEU4L1RISGd3c2YvTHB4SE5qc1xyXG4gIDgzNVpYTWNNSHRFUGhHUG9vUmZhN0J1RTZuVnBPY1ZtM2lCVmlBTDdicGdyQ2gybGJQR0tIZ0lPb2xvSng0WTVENWg1WmxibEc3S2pcclxuICBianRGdExZaWx2eDhtWExsRTRZME9mdzVlOC9SRSszWXRNVHFoUVBPQnVUUFFrK2VmZnhjOWJMWHBFWUpHVndkQ3lnclBueksrZ2pTXHJcbiAgWkl5RXRza3o0cUxFaVBzcG0zeTJFUUNJQnViZnVBM0IvSG41c3orejIyVGRpT2xZdEI1YjJLS0R3OS9VU3orWVlBc1hNUUdtM2RwNVxyXG4gIGQrc0hYbVZ5YzBTeldCanUyTEhUREQ3UWxSakhwaSt6MzZqRDViV2ZIbUxqQlc2WGkvQ0h6N09xajE2VkQrNi9Va3JHSDJ0aXJjMUtcclxuICA5QWRQVmFLai9RaGJ2cElJOThHQkYxNklJdTB3dWVBWWRzUVh6VFZLWDlNYmVra0hua2RaUkVRY2VoSVIzMjdhLzZQSzJqWXIxT0c0XHJcbiAgU1VJME1IZkhzelFHSXhndDlDUWlTa1ExandrbUV6VEdNZHZqaG9XR3RtQlhDVXJMc29kbHpacTE4a3ZXZTF3WTN3UEdnY1YzKys4L1xyXG4gIHFndVhBQVJDRU9JL3Z2SE9oRGhxYi9EM3Z6OXVkUUtCSW82NGl2cUJxTERnRDVOYjdvWDAvOElpYTl5NEVmTExYLzFGVnF4Y0oxZGZcclxuICBpUUhMN29Iclhueko5MnpMMjdmZVRqcDh4TTE3UjZkKy83MkpzTVlkY3FtNWRRZHlCbU5XQ2VndFJXOG92REFERzFReHNJRVpvUGR5XHJcbiAgSHRQZjJPbVFHRlZVcmF6amZHbFZ6aUE3MjJXQVNmRVZIN2d2R2t5Mm9YbEtRSHlWTFVvMFhKZURqR0ZWMnhXSFoxZzhJQzVIbUNtU1xyXG4gIDMxNGhHNWZQazBaRnpDZ2ZtWFVQSHo1VSt1b3N2enFOZmFHcGttYmNDTXUwbWIwaGlrR1VZVzBraUlxMzZmRW9qTTRodmtMbXlxQzFcclxuICBjeEM3eXBYYVAreldVMlRMZ3FkMFZuNVdncHRKdGhQNm1TcWI1djdMa0VCdS82SEduaU1URG1LcittMXJaY2VHaFlhTXV0Y0xGbGJvXHJcbiAgT1NvWFArL0dCWnFtREVmZllYemtIdWVQY08xZlQ1RzFHNVJ6VUFLaWowUUdEdWd2QjF4d2gvS3NCNXMxVlQrZGpWb2RJS3JIL2llYVxyXG4gIHNNUE9ST2Z0V1lIQUZDSFpsTi9QbXA2RG1JbXJUcmxlbGovM0s3TUtZbE91emU4OWJHYXArNTN5YmVtcm5FaW9RNGk0a05rNHlBR2RcclxuICBWM3dtSHNxeDJycHE2U3RLMENGeXpOQ1BOQ1JjYysrUk1uZnVQSE5aejJBZlhEWklocHpudThpQjlQRURaZkhsczJYa2NWZWJmSjQ0XHJcbiAgK1NCdTEzUDQrZTRRNnU3WXVNQkVUZ1o2RVVTVjFHV1NRMWcwNUdCWi8vYTkybS92RTRWQWJrbm9ORkVZQUZIaVBaS0dhR1FveHdJQ1xyXG4gIDdEY2FmVTJ5RHp5blJiODdRTmF2MzJEM0M4YythZEpCc3JQL1NXYkJCYUJzSDN2U04yWHQ2L2NZZ29kckN3c3UvV2tRYUYvMEQvUGxcclxuICBuVmc3S1l3NjRhdVdqOWdOQ3k2MjQvVU82eEdWUjV6VlZ6a1A0cVpMMGZ6aUVWTmwvbDh2a2NrWDNXWDVpSW9TMTlJUXYyaXNjY3BSXHJcbiAgb29saEFPYnFuRWYzNGFJbGFrV2hwcmV2WDJBVExyd0Q4Qjc4SE0xNXU0VmxZVU9xcEJncm5qYjlpWVpNMkJCRFk1bVZ0ZlpoV2Jac1xyXG4gIG1mUXJ6SmFGNy8xanQydmZlclBBSWo1OStzR1NtWmtoTjk1MHAvemcrMWRvM3I2THNnTGg2QjcyZHU3dWV4NlZMMTN5U1huMnVkZmxcclxuICBsSlBqSXRUL080d2NjN0t0YlZtOTRybTlFcWN6enJwS2Z2Qzl5MlhtVVo5UDdLYUl5ZkdQZjNoMTd4eklIKzU2TXVIT0pDTVNZZGxIXHJcbiAgR24ydkVhcUkwbEhjUU0vRWs3c3A1ekg5VFdRbHoyMVk5cllwcmRKWk5xN1FtKzRqWHQrSkIrd25oQVRpa2VRK0lBQVdqeW41Q01sclxyXG4gIFRTMlF2dW5iWlZ0VmxlQkVrSTl2NTg3dDBpYy9YU29ycWlQRm9TTk5adGZNR3RPekNuVDJQdDg0RUFZemlDRWdiTUl1U0Z5dlRZakxcclxuICBCV3pUemNtZ0lsSkVQZVljRVlLblpVR0l2bzkxVCtMQmVTeXVNUG1sUDh4K21hbkJlYkNYTnR1WUZ1Z0gxRnU5N0lJQk5uUEVEcjlrXHJcbiAgdnlOdHBrY1pEajc2RVBkbm92MVNCTjYrOFEycDM3VkRFUzFmcU12VmM3SXpwYWs5MHhhZ0pldjROWEFpU0J3VHpSYWRLWElPd3NIdVxyXG4gIGhHTlB1azZmbVk2ZFFEeWljMWdiTWV1RmNCSm54ZjNtdVEvTGgvKzhSdlkvK3ljeTl0UnZtMGpGNnVnQmNZVUE4cDRoM3N4aUdRZm9cclxuICBCbmdIN0tHT29RT09LMXNiM0FwdDZIUVhTUm5ub20xc2YrOVBzcldpeXRhNDBHcEdacWFVVFBtTUlXb0lBSVFCeGEwWlRPaDdneHRFXHJcbiAgRjBKOWlDQnllSUEwczNTdVFmdThmN2RhWkNZLzFYUmtjRkNNRDF4b0REcm9OSnNsNHlNS2I4cURwNXdyN2MzMXNsNDVHdGVicE1pR1xyXG4gIGQvNWhZak1lYlZJTTVsWmJiRFhBekI0eFk1TnlaMlVIbjJuY1pQSHdhYmJSMHBMZlQ1S05TdkR4dW9zK0Q2UTJidHc0S1QzMTk4YTVcclxuICBLZWEwR1R2N2xNUDlybm54ZHpMazBFKzdFbDRKREM3TDRVeDRLRHdYa0NzNkVPNEZqd3ExcTVnY2lPbEkzdnZ6cDQycjhuZmo1ZUc4XHJcbiAgbVZqUWpvTnpJL2pRV3ZiMHp5SkN5VjN5WjFHOXhoZ2podXorQ1BKblRVOWV5WEM3VjdqazdweElWdEVBVTU1MzJwVEdONlpxM3FsalxyXG4gIHpVdjVOMkdXZ1ZZbENqMjJhek1pNG5IR3RjTjFvQnRwWDNpWHpyeFhTWDVXaWx4OTZkbHkxTEh1VGJrM2VQLzlqd3k1VmxYVnlvd1pcclxuICBrd3l4QTZOR3VZc25rSHhOelhhZGpXL2JadzZoTnk0a2lLdkFlU3dHdlZmTGtFYi9Rcmt4bzRkcDJia2EvL2hFV1FVRnVmTDRrNi9aXHJcbiAgWXNHOW1TU1BIalZVYXV0MktDRlQvRkR2eGhydDdSMHlZa1JaN3h3SUVCVHB6b0g0Q3dYQ3l6R3dhQ3pOMlVTeTkzS0ozOWpwZUFLM1xyXG4gIDdRRW03ajlCbG14bzFBRTJXbE1wTWU0ajFOZTgzWEFmQVhFNWdvd1FxLzdSd1lCdzAxUDA0Njk4VDlZc1gyS21qMnd3dEdOSGd3d3FcclxuICBHeWpaNDg4WExLK29Ed2NRZEJ2TWdrdjJPOXFRRG92M2t0eEdRTjRoVERObmdPZ2RjR1M0ZGRHelpxNGJ5bURpMkJvcEF5a2IraG42XHJcbiAgUm1qZVNaVWpZcEVhY25UeUlRaTIzN2dSeGVTOWVIMXZCOHNwT0M5RVRxU1pmWnFDVStOR1BPTFBRZU1RRDAyWnN2ekRXNmRMOWJidFxyXG4gIE5HV2MyWlFwazZUZnVmOUsxdEUvUHNnRkQxd3QweTVuYTlNT1cyVG41L25YNTJXYmFwSGxkU0FVV0M3MVYwSm01cGI2aDdOQ2lpQ09cclxuICBncHNZbzdOcEIyK0g1OHhIajR3ZXdvRjRpM2JaeHdHa00vL2VTMngyRGtBRUFySXkwQUJpa0YwNHlEaVhpdWR1a0sxYkt1d3M2SDdVXHJcbiAgeUJHeS96ZVgySDRlNDA3N25peDk2aWNXWW5hTWlBZXZ4dTB0OVVvY0hHbGh2V1BPT25jRElIeGN1RWRYTjREVENCOFd4QVpySlFnTVxyXG4gIGVqcjZTcG9ETTJZMmh0cSs2VVBUTVkweHl6VlFQN05waTlxaVJFUktXSVd0ZnZWMlczblBzZVRXZzJUMTZqWGFOeTJrRng4OWVyaU1cclxuICB2OXIzcHJlcXpNZ1ZGajM2YmNuTUxUWmlpRmhyL1p2M1NsN3BLQ04rQ1E3Uks5aXNIWjNhcXo4KzJIWlRERzE0aXgwNkNaamo3dU10XHJcbiAgMzhzSHhicmxSZVhoZkpmOCsvdXkvMWsvdGpMSjhxd1QwZkVTNVRHWjREeUxWQW5OOHdKV2lCcVBjeUtFY05XVzd1aVVvc0VUekdyT1xyXG4gIHo4T0p4RjNBYTNtOU45TEdnV2c3eEhGMXN2NzVIMG4xMXEzS1BWd2puem4zZVBOTnRTZTRVWkg3RDM3d0ZmUElXMUd4clF2Q0o1N2tcclxuICBHajQrTGdTbnBvY2RGbkd6RVFSdTUrT0U5S3lEekUzOXB2V3ZSRG03aDFNK2Nibms1bWJMWS85SjRtZFd0b05CZGd2NVdlbHl4SmpkXHJcbiAgbUpMWjF4TC9aRFFlVHdib1VhNDdKTS90WDhwMnJRNHBhWmxTMlpnYkVRL3BJcm95YzFMeUlpVTBiVGp4Z1B1d3BQMDRVdlVNUTFjZ1xyXG4gIHJTaVBFRjFGK3FCcDVuVVNheStJUjJaV2hpS2JyWktYc3NzUlZxUkFwUTJRR2piOWZQaEdQRUQ0RVhmVHRlMVVXM3ZBdWdlSUI1OE9cclxuICBzeC9Pb1ROaE5UZE9BOUhYNk5jYjFldEtQRHpOWlZOTm9ZcVZGZm1wK2x4MmJNVGtONVFMMTNYaVladjlSTVREVmxEajRqMU9QS3hzXHJcbiAgL0ZwNFVzWFAxelQ5MkJici9XZnBSWlBRSE9rL0tNZUJ5R3JETy9lYjB0dk1jOU1aSDVvUE42Si9pRWRvTjdUTjJnTDJ3NWh3N2k5dFxyXG4gIDVrNWJtRlN2VU1JQjhaajZaVzNMaUllWFIrYU5GUkxQbWxYNVRoeU9ORVFMd24vNzFsTmwvVnQvMDFueDEyVy8wNzZyeC9lTU1IRTlcclxuICBPRVptMTlYS0JiUzNOTW42dC84dWVEYTJ4OGpOS1BBdWlvdUtFdUlpaUFkQUhYUGtxQ1daaVVNOEVEOUJISng0b01NNHV1dWhSSUtaXHJcbiAgTTVNSkZ1S0ZmTHk4VnErWWJmZkRzZXpwbjJoN2JmcWMzN2V5WEl0MmFaUDNPbWpTR1NaaTRUNjVSNDZ0SHp5WnFELzRFRGRNbUhqdVxyXG4gIHpiYjFMdmVBb3JpK2ZoZjQwaUFySzgxbWg3aHY0Vm5ZbjRiRUozN3lGNVorK3c5bnltcy9POHoyRE9GNVFNald2dmtYZWVickEyMGhcclxuICBIdGVnVG83TzZFKzlaYk5VNnFRSEVSYldpSzVnVDdQbkh0YUxoUEptamFkeHJPVXNYLy9yZEJJRFI4bEN6OUFQTCsvclJEaklxMXYzXHJcbiAgdm8xVHp1SDlHV1Y1Mkh2ZnZxMm9EdW1FcWJwK3Qrd2JRaHdPbmZaM0tMZGgxNkY4N0p1RXl3bmNmdXVIZjVMcWlrcmxJSVpLY1U2cVxyXG4gIGlhaEEySHNDaUFkbEF2RWdqazVrMHFUeENjUlB5SXgrWDJGMmRNMDQ4V0E3V1FCdjJCQVBpQlRBZWNCRlpYdnU2MzhMT0VmY3NxVktcclxuICBsaTBMVzJIc0h0cmEydVhLcjN3bVNqbXNXNytsZHhFV2dDSzlwYWxaSC9Zb1dWOGJqVklGWGs4VUNUOFI4S0tqYUR3L1ZpN3hHenVkXHJcbiAgVEtSSVprdUZiS3RoclljTzFhd2lTU2tjWlhIT0Jjc3JURjZ6Q2lKckxKMmhCaVdhS2RSMDRGdi9tRkZwWnl4dXlNOEhrOFVUZWF3SFxyXG4gIFNOY2pRNm53UUttcTJDSlo2ZTJtVUtkb1RzdFdTU3M5MEJYbGpUdHM3UVQ3RDJRclM5M2UxdXpYc25hajlydHdJbWsyYThYYWhqUnVcclxuICBxL2tRRVYyQnpISG53R3pUcmE1YzFHV0RQMnFEV1JQWFFXa09Vc2RLWldkRU5QaUllQTRvYU1OOUpQcWdIdzZtaW5BMzV1SkNaNWRtXHJcbiAgb3FwbG5IaG91UVRCOHVmRDducWpqci9HWnV3Z3VmWU5zNVZkWlF0TExXTFB2a01HemJqYzZtSVd5cXl2MzhpSXc5QzJHdXMyU3NYQ1xyXG4gIFoyVDg2ZDhYVElzNTRVWUVLYkpRWjh3Z1ljUlZUVm9PQ3ltdXVlamhid2piMHU1LzFrMkdnQ25MVWJIb0JTVzh6eG5SUUVHT2RSUWNcclxuICB5enQzbkdXS2N2WWFMeGwvbk9aL1RpY1Q3TExuOXdGQ1JxRU4wc2Q5QlM1c2ZQZEZNWEZTWHQzN1VsMWRiZmNFRkJZV1NNNStwNWxvXHJcbiAgQ29NTDNnUHRERHpnRkN1UHVJZUpBak4yT0o3K3luR1N0cmE2SENPc1REaUhPdzJPUko0cHpJZmJ1K0Q5SUU1aEowRHFicGh6bjNLeVxyXG4gIFIrbDlyYlArc3lndk03ZXZpWnVZb0ZBMmlMcFE0QWN4bCt0MWpwVEZ0eDl1WEJWU1dvaElkbGEyakI0elNvWjk4aDdiTlhIQlA2OVJcclxuICBvbEJuWEJyMWNKdGlDeEoxQW9OWUVQRWlCNVpJMDYvNmo2M20zL0tCcjd1eGw2di9KZU9PbFcycjM3SkpDNlNYUFRzUXBRS2I1ei9tXHJcbiAgT3JHb0xCc3dzVkVZM0NaZWVNbERuTVc3WHpQYkRRUUMyUGhUWUd6eVBXUVg2WmpWT0dNM1I4ZThHYkZvQ0hqSktOUjY2UEt3eklxYVxyXG4gIGtJenNRbWxwcUpFVTVUQ3lDZ1lreWdNZVR6RXBRR25UUE5PRERSNWNJbGQ5NlV5WlBOVWRBaUlpQ2h6RjdnQUZkMEQyQUhYbVJQdWVcclxuICBFK2M4ZWhIT2s5NGJISExJUkZtMGFLVjV4V1dYUXVwczM3N1R3cEdSUlJieGNJVDB2WDkvVXZ1NWIxek92Z0FUNTM4ODhMVGc5di9rXHJcbiAgazJMbThiMEEzQWJyUGg1Ly9KV0VIZ1RZc3doTGtlblJ4eDRsNzZ3SE9mRXFZcThudk1FQW1rN21SREVMdXVmcWJ6Skx3UlBUaG5mSVxyXG4gIEs2KzVTNG9BQlNOUHRCREVZMTV2Tlk1cmduejl1TXpuUDlZa211dTZqMGgwRlIySnVDRk1rRHA1dllXWTdjNlRnZVVqWmVuckR4bnRcclxuICBRU2VTcFRQck1RY3B1Nyt0MVJBYVpVTjVDdzNaSjl0STVuR2syWWZKdnMvc1R3SEJveXlFQ0tJUzNMWUgwVld5RGZxTUl6bmZOeG9UXHJcbiAgVUxaV0RlczdOaXBDS1N3L1dIRFRIaTlQL2JyMTBheE5zeEFmc0NabXpleTc3UGxnWXBsd00ySjFpS1hvN1BBTzIrYVVOUStlci8xUVxyXG4gIElyTG92b3VsUlRreWdHZHg3SFhQeXFwNXo1dW95V1QrV2pTdlpJeko3elZxdS9kWlpuUjkxblhNdWVNY09lekt4eXlmWjlxcDcyRzVcclxuICB6bzRwZjlnMWJxbEVXVUw4U1NGcW9wK3NoUUJLZEhhODdPbWZDNFlRSmtKVUpPWmlLZ1d0aUNVWlhvdER1amRnUmd4aWIxOTByODQyXHJcbiAgMlV5cTNaRHQ5TU1PbFg0WE93Y1NCOFF6bUFOWEw1dnRoRmdSSUlRQWZRdnZEUDFJY0cwQ1YyS3J4NDBmOERVUWpDUFd3R0NwQjlFM1xyXG4gIFFtU2NCaEQ3ekRTNjlLbWI3RnoxOHRlaTBGMUxzTkF2SUdrQWYxQ1k0MVl1ZnNuMEh3Rlcvbm02TEY2d3dKK3R0cmYvaFAyazlLeC9cclxuICBtT2txRjFpcXo0NTlVRERhZ0VDeXR3ejVsRjJoNzJIWmM3ODBiZ2J1d2FhSGVnTENndTdLay9SWER3MlpaTUNoTWo0Z0dnaVhNSWFBXHJcbiAgVUVQTVNGdkQrbkRaMnBmTjJsRDhJeWFycjFocDNNYXFWMitYa1VkZm9jWDBhbEhiSWU0aUxaN2h3UnFmWjdvbEZnb3pXVXFLcFpJaFxyXG4gIEhETjE4WmZsN2s4Z0hxVjZHbFBkRWt1YmwyWnJ2ME9LTnowazc3NzdydVFwSGJ6K3F4Zkl0Vis3V1BEcmhJNERpSE1DdTROQVBDanpcclxuICBzNS9mSmQrNTRjdVd0MkxsZWxOMDc2MStkd2lpTVNEVWZldXREMlRHaklPTm9NSGxWRlJVNitTMnY3Qkh5UG5ubmF6bDlsMU10aS9RXHJcbiAgM053aTJmbFRaT0NBZnJKbDQydFI3dTZCTlNGc0NmM2l5MnlQNExCSERnVC81MnMzYkVnbzBnMEJlU1Q4UkJDUUFSRExqNVZML01aT1xyXG4gIEp4TXBrcDlTSjF1MitvSXU0SUQ5SjBoZG0zc0NUYy9CSDFkS1l0RWdlV2tadVNZK29VKzljeDhnWmZyVkZUbDNQNGR1ZzVsU1p2K3hcclxuICBrdDI0V2hvYUdrejIzOTdXSWZWMVc2V2tRTXYwajlhUlJFZUlkK1U2dXVhaCtPYmpUU0I3emE5aWNadCt6SldMWDdBUUpPOTE0LzFNXHJcbiAgTmNVaENJZ3RON0ZPd2VxS0dSa2VhMUZrZWptL0g2dW5kOFNzREJFQUlkd0V1aFYyMmNORGNRL2lvY2ZtRC80alEyZjR5bUxhNFJsM1xyXG4gIHRyRmZmTHEwcjM5VjZoc2FqWGp3TEJyWHZpcjdYM2lQNlNHOGpWVFo4UGJmVFp4UmdpaVAxcU4ydHl4NDBqWTVtbkRPenpSWHlZYm1cclxuICBwYWJuS0RINHFSR2dnejdySWczcnY1Wlk5Y29mZERLdzB2UWN5TDdKeG1YSzI3ZWRZVE5SeEhkY2c1azhKNW1SYjNqN1BqUGZIWEhrXHJcbiAgbHczQmc0Q0RTQWdGYmVXU2w2dzgzTXVnZzgrVURXL2NaZUlkekZ4QlhSUE8rNjNVMVZRYWdZRVQ0Tm13VHpiSWhqZ2N3czdOaTZ4dFxyXG4gIGlBSnU3elhia0dVQWlBbkVDWTRDTitlSUxQSHBoYkVFVm1Dc29yYnp5aG14bHpqWGhhdWlieEFiNTFxR0pUZ1Y1enIyMS9FeXlRZ3RcclxuICAxbGJzandGQld2clVUdzBacjllK2N2OTkwMnVrWXN0V3FkbUljaG1UMDJ4Yis5SFlsbW5yUzdBMkd2ZUo3OWhhRFVSL0tKcmRvSUJIXHJcbiAgbUdKRUVHNkVDUURiMGJJSFIvbWhuekh1WTVzU1A0ai95S011dFh2bUI3RWtJa1dlWG9lT0VaVFdjTmlJMGRnSURmOW05dUswTEdiZVxyXG4gIHpmb09xTnVta3ljNFdONXJSbWErK2FveWsvY0l3aGpBMUJ4QXQwVVduQ1Joa2hQaHJRQWVza2NOSEF0clNzS1pmRHpxS3FkbjV1NkZcclxuICB2dDhGNHk5OTZkMnlkdTFhU2V0b2tnZi9kcU1NS0Jzb2JDUHI3a0tTeW15QStPNGdjQU1nOTArZW81eHdTVi9qUEZCQW83UGdYb3FMXHJcbiAgQzZ5dFBiVVRnRjZ6YndnUWxPYXJWMit3dXB3am5EZHZzWVVUSjR5Mk9Gek8wOC9Na3JGamZCSHEveFZRMnVQbWZlblNOYlpZRVk4ZlxyXG4gIGV3TDZpZWp1N1lqN0F2Wk1RQ0tBZ0lRWG1BeWl1SUcreGtReWxoOHJsL2lOblU0bVVpU3JyVksyMWVqQWk2QzJPVS9TYy92cEtXMGJcclxuICBwS3g1aUt5UWl3UFl1Vk52ajl3SENIWTNoQ1NFSUlnK3RvTmVpbVNXNm95bmRvbXc2WkNlbGViV052TUVYRHBna0xTazR4N0NFWFljXHJcbiAgMlhjbkloQUhGS1VtNDlXdkc4S0dNcDVGY0NqOENTRUVjZTRqMUVWWml0Z0tGeUZiUG56Q3l1Q0pkT2ZHaFhiZitPRHk2OGJ1UWU4UFxyXG4gIG5RUWZOUjhjZTVZd0N3T1JRVHo0WU1NejRLQU9mcVlRUjlpSHErM2dtZ0xMTHF5blN2Yy9YdHFXUDJJTExXM1NwMWZBOTAwcVJKU25cclxuICBRbDgxaEpBWGxMb1l5ZnVUWXNpSDh5T1B2VkthRkxIcUdhbldXZTM3OTEwdUIxOTRweEVEN3pNRTdIRXpVUVpCZ3R6STUyQ1BEMmIyXHJcbiAgTEhTYitLbWJuWERRamlKVTFtTU1tL0Y1dXhZS2FSYTZjUTRrdmw2SkNnaWI5VEFtNXRKeWlKNUFRQnRlL0xrMDZqdmxYbERlOXovb1xyXG4gIFRFbkpMRENkQk00T1FkNjUvVERkVGpFRENjeHRCeDE0dWlKV1JaWkZaU1lHeXNobGxiTDNQWDdRUHdnWjk5R3FDRE10UFN1aFV3SVFcclxuICBVN21oZ0N2NTRTam8xOUluYjlSa2lybElEeUl5T0FYMnM2RS9sR1ZiWEpUbW1KRmpKUllJNWJ3N1Q1WE5LOTgzU3hpZ2JQQkFPZWliXHJcbiAgYnFXRzBRSG11R3dMeTFiR0VQcWgrdHh4dXdKaFNsVkM0MXNFaU9ta0dpcFhtMHVkMG5ISEtWRnd3dy9XN2J6Nms2bUNoVmF3dXFJdFxyXG4gIFBGNHZlL1puTW1UcWVZYmtXZnVDMkhMelBIMlBSa1NzcU9ZTk1jdEZSZzk3ajVqckhUM0phZFprMlU2RUVkQ1BiSjBVVWNiYzYrZ2tcclxuICBLSGpSNVZ4UElxTGxOZDNXck1SREMwQ3MyNVRBczFiRUt1ZzF3MlN5YVAwL1pOV3FWYkpoelJyNTdVOHVrejREZkRPbzh6NTFzaUgvXHJcbiAgY0VCSUJnOHVsVGZlbUw5SDVBOXhPT21rbWJid0QwTEM0a0pFV1NEV004ODgxczRmY2NRVTY5ZmVBT0x4MEVQUHlzU0pZMlRJNEFHbVxyXG4gIGg1ZzVjNHExUVgvaUlYMjY2KzVIak1oczJWeTF4ejcrdHpCMDZDRDUreitldEhVdmU3UEdZbEhoMXEzVkNYY3NBTmhnSHlGNktCYkVcclxuICBINURHZTN0ZVBjcDFoM0F1UlE0YTFDRExWNGI5elVWYVc5b2xXemtDTCtQbFhIVGxDd2g5b0NTQ1VFUWF6WGxhcU1NUTBsRFQ5a0l0XHJcbiAgSkR1ZWpzcEZhWTYrVTc5c0NzbjhQQmVsVkZYWFN0V1NGeVc5a3kwL0hkRTc4bmFrVE4xUUgzTlRQT3JpZkk0OFp0YUV2dkF2MWRaclxyXG4gIDJHcjVxRTVvSXh4NG1LMWErckxGY2N2T2ZoNXdJRU1VZVlROU9NSzE5RWNQNzB2aDRJazJxK1g1NE1wOTgveC9hM2xmTE5pVmVHaGNcclxuICAweXk0ZzJqZ3FzSVdJQ29SWkRZM2FKSWlWdjBydStBeDR6NUF1RmhUNHhWQTZsYllyTnBBbSt1dnlNWHVnWVJ5ZmUvZC9WbGhiVWU2XHJcbiAgSWdFSUFJdFBsN0hnYjhXYmN0cHQ3bzdjS21vZFhHV0E2RVljYzZXYkdldk1Ick5QRHNRaEtNYk5BNitXUi83UFRuOGdZcEFuU3UrK1xyXG4gIGV1M0JVejlwNXdPeUJlRGFCdXgvb3BXbGIreXBzZlNwRzZWTkVTMzNZN2ZQVDJPTklXeUlVUDl4SUc4TUltaHJsbFJGN1dFaFp5SVFcclxuICB6VytvM1dqSWpUcVl6OFlQa0Q1MUdwUzdvUDdPeW1YS1hmcnFYdElmS2FFWWU4b04xaVlIYldpVDFtK0lGWG5FMlZScTZaTTMyZlhHXHJcbiAgbmY0RGMyMlAydzhjUGxJR1JYdzQ2bmZWU3l0ZXFubWNlanVEQnp0QzRaNnhKanZ5VzYvTEFaLzZsZTJ2UDJ6bWw2dysxNXp4MVdjVVxyXG4gIHVRNHlvazRHZjVoTkR6bmtQSG4ydWtGSzFKK1FXajFITzZmOGFwUDVIc090dTQwNUxRdFJQL2pDTzh5SlpYQmVDRUE4VjczME8rTTJcclxuICBRMW5NdnRIVjZWUlBrNmtKWjR3NzFuOWdJcXZFMkxlK3NRVkNYNXQwQlE4SkhCQVRVN0NIZGkzMGV1RTY2TmJNSFVySTA3R0kyUzlwXHJcbiAgT0kvc3JCVDU1dGMvTHhkODdpeER5QUJJR1NBZGtEVGlvMzBCOUFaQnhCVGcybXMrYXlGSW1DVUlvZjI5UWRneUZrdXdGMTcwamMvaVxyXG4gIHlCbm8zWGVXcjlIN09PRDQ0OWcwMEYybTdBMjQ5djMvZkZweFFuSUN3Q2UxUnlnZnMzZVpHNi9TSVJtTGcrZnFiKytuWmRzMlY1d0hcclxuICB5T3dUS2MrMVBET1FaTFhRRXFFT0ZFVkN4bjJRMWdHRGN0dEtNSkRDRVpYdDdXQWdJeTZoWEJ5WjR6cGxSMzJUWktiREJJdFMzYTNTXHJcbiAgdHZSaHF4TUdNa2RBeUh3Z0hnL3RlSnd5aUJ4UUpCSVA1V3hMMStoOEtFKzdXSlNVVGY2a0p0bGs2U0NkY2Q5dit4b3dZeXViVEJ0UlxyXG4gIHUzcE55Z2MzSlZpdE1PdEZvWWppYytUUmx4c240bTBucjhPbVQ5elA4Q011c1hacTFyNW4xamVZQ3dmM0ZWWTJxMGh5Rk5Ia0Z2UXhcclxuICBRdERZMUNwVmIvOVJDc3NQY0xuM2FDY2UxaGNOV1F3STE4Ris1YmJ5V2ZOdGNhVE9pR2RjKzVTM3F3ZUlDd1V2UHFZZ0dsalJJWFo3XHJcbiAgODNlbjJBeDd2MDk4eitUeWxLVjl4Rjc0UGNLZEJvUURheXVRNjN0M2ZVYVI3dXZXWjRnRngvZ3pmbUFyamtIR0lHTDBHTlkvUGJBZ1xyXG4gIFlSa0I5QURSVjByQllLdHZmYkp5U254MFpnd25FQWZhb2dVQW1id1RLOXJCYmxhRTNlL2NkYmhDaDFzRzV2WVpxdVZtYWROKzdTSFRcclxuICBMakJDRTNRY2hJc2YrNjRjY2QwcnRpa1UxOFRFRmpHWVBYdjl3NzEvSUNhbEUwNHdZa0piSE8wckhsRU91Y251aGYxYjh2TnpwTHJvXHJcbiAgQkxQYzhqSlU0L2xaVk5hOWNZODhjVldCUHRmdm1zUEhrckV6cGFGcWpheDgrVFpybnpxOHAwLzh2bGJXdkhLYkxIdnVabnVIbUdhelxyXG4gIDBKUDdaZ01yZTk5Nk1QdWZlc2w5U2tUT05ZTGk0MERNc281bjZ0ZjIrOEJzbG5VaVhJTXRaaEd0MGdaY1NYY2l3dXAxL0dNRjZ5emFcclxuICBZQmRRSmcybTU3QThMMCtJZUxaNEtLYXVxWUtyZHlRU2pGWHo0S3ZGZHI1K282ejRhSWw4KzRvejVlWmZmRFd4V0RBUWphbFRKeGlpXHJcbiAgNXdoNUFJdnJkZ2VoelBlK2U1bUZFQkx5Rml4WUpyLzkzZDlseWhSdmMxK0J1c0VpS3hBSUNCUGVjamxIVzEwSmg1ZDk3V01rSUFEV1xyXG4gIFdPdlhiN0Z0YlBjR1pZTktCTlBmQUxzVllYMzMyNWVaR0lzRmhabUZMajgxc0JjZUExNW9GTlZFTE9pZXE3L0pMQVVTbnJkNVZmS2hcclxuICBkMTg0aUZpaXZtSkZRdmVCR01nVjBGMTFIN3Z3ZVJXWjlGSE9CMXVFMktOQmx3d2RBU056TlRjTlVUa1RsWkdmTTBwU2FwZEtmUU15XHJcbiAgVmoydGY3akx6dDY1VERJSDQ5SmEyK2dtdXFLdW0rcDZYdlBPYXZzWWNQZEFIQzRHdlVlbzR3ZjM3M1c5SHBzclBXSVdXaWhwbTdhdFxyXG4gIE5ma3hNK3R3UGg1aWJZV3lGNzlCckZ0bzBqVGlNaEJjcnUwdG5yeG5pQWN6UUJBRHNtakVWNGovV0p1UzBCOVp1eW15U2ptRWNZZWRcclxuICBMWnRYekUzc1FURm80Q0JKSDNLNGliamlaUmYvNTNzNjZ6L084bGhRaGdKMDhTUGZOckVKSWlzdFpPWFlOQXJ1QzdjZDFuOEZSQzFzXHJcbiAgRWdYaG9COHV5a28xUkZlOVlwYk4xaEc1ME1UUUdSZkp2SHUrWUJ3VGlsOWF3R0tKOFVHQkZjLy94a1JPQU5aVlpqMmxpTHU0WmExc1xyXG4gIFdEWmYycFVRdFN2V1RlMW9sUU0rOFhWcGFtNjFmVTNvQ2dnY3R5NHNhRVAvQWNJUElXMUZ0eXAxK215clBucko5QlBHYlNnbmg1N0NcclxuICB4Mk9xREQvOElxK25SSUYrRVdacGY2dVd6ZEoyMXNwQTVVNUJuUHVmZlpOeExZakhVS0xERmVBa2tESVFROFlsWWptSUc4OFRwVHJQXHJcbiAgb2svN0dsbTdjcW5zckY1dnMvMzI5azRweUN1UVFkTy9KQ09Pdk5Tc0JObDlrVWtMK2hvL2pwQlJ4My9OdlBmaXdCTWxPNzdEY0MzeVxyXG4gIHdYMlgyMWpBL3hqdmoyZk1EQU5QeHVoSjRFYXcza0pNaFlXV09WZlU1NEJWMXBCRHpwZDM3dnlrYmJFTFVjYTNGTVRlUENlTW1tN3ZcclxuICBCK0Q3Y2pIVFR1c2ZnQSt0dXJYdm1walB4bElFT1gzSzlQbk0wKzltaW83UExRbkx4L3lTVWZvY1hDSVFLNjZnWXc2WDhScURXeVJFXHJcbiAgUDlLMzVrWDVjT0VpR1RHMFZPNzQvWGQwWWhYVmpjSGJienZIRVJBellpRU9pTUhleEZoQmhQWFZhejhuMmRsWkpnYkRvb3A2UVNTMlxyXG4gIHJ3di9CbW85ZEJIVURmMjQ1ZGQvTmNLQmFDejQ0Q0kvV0d4eG54L25vc0tpb2dKNTZGL1B5L0JoWmVibmEwK0FHS3R2M3lLWk5kdUpcclxuICBtR0tZL3dLNnZEd2cvdnA3QnordnYxMEtKaE1IbC9pZ0NzQ0hHRVU4MElNUHJXc0RQYmtQWnRhaGhpUFk2SWp5NGdmbjhSQnFlME5yXHJcbiAgUEZIZXp1TW84UzBwbjNLbTlPblRSOU02Kyt6b05CTlFURUZUUC9wN29rNm9aeUdQVWtQa3NZVFp4ZXhMa2lKYjNuOWMrKzl4SnhwT1xyXG4gIEFMeXVwemUrKzFBa0h0SzAvdVlQMk0vRVlFT21mOTVXRW11aHFIeXlIaHdIOG5UTnNZOFVZZ1VTSEhiNEZ4SW11MTZlNTVraXExLzlcclxuICBnODBBK2RCQndJalZlSDdKTnYxZzlURWVkT3RXdmE0RWJMM1c5UGRSV1ZYVmxYaG8rUGJ0WjhtZ0EwK1ZZcjJlNWVzeCt4ZEh5TmhUXHJcbiAgYnpCNWZHaVRtWFpXOFNDTmVobFdhNE9RMEQ5QlBFQnluRU5SeXl5VzFlazI2NDdLZzBpWi9jTTVrUU15WmVaT3ZuTWJzeFFaSFdKSVxyXG4gIEhZdTVjV2Y4ME1wZ0lMRHl6WDlLSTBwZGU3WW95SlZJTlZaSTZUamxXczc4b2EySm9OR1Budnl4ZlBURWoyWHorLzh4aEUrYmdJdkRcclxuICAvQm5nZ2RqMUZjbkQxeUZoOG5xVXRZT1BMeFRUUzdVOStzTUs5RzJhM2wvN0JLRWVyeUhBS25qYmEwWXJCUTRGLzFKYkZ6NnI3M1doXHJcbiAgUHBPalplM3JkNWtDbTJmRCtGaiswU0lwS0IwaEdlbXBOaWJUMDFLbHNMQlF6MzFvWmRhOWhYc1d4RmpmajF5WitQUEx3QXVDUm5FalxyXG4gIDh1YXRwOXB6eG1SNHYwOTgxeFlXUXNURHM5N3YxRzhiOFVEMHlEZGxUMDNQc1ViRzNkQjRtcktUUHZjbkpTTG5LbEh2YThnZko1K0lcclxuICBzeEJSMGg3bCtJUFlJVWxnM1JDcjdmT1VVeHg1N05XMm8ySW9SMGliakdHdVF4b3ZDeENUak53aUcrOVcxc1pqUFBSNi9NRjlZSm1KXHJcbiAgaDkxQkEvdklYYi8vbHVRVzlWUU1nNUJCOHZFNFlZQjR2RHRRbHBYbkYzL2hiRU84Z1FzQlFsdk01RitiNVI2Szl3WW80TVAxZ25sc1xyXG4gIG5CdUpBL25vSUxERTJsTWYvMXNJMTd2bnIvKzJjRS9BL2JINlBvQi9HWHVCUHZ1MFJvWVgrZC9ERys4bVRjSW1UVGpRWEk0RFdERzVcclxuICAwMFNzc1BJOUw2dzYxMHNGVzNNQTUzdUlmK3lFUVhKUTJhQWozNktlSnNITW5aQWQ3a0taY0ZDMm9ucTdqSmgrdm0zdkdxQ3B1VVZXXHJcbiAgclZKdWFDMys4UFhSS1dJeDVLSUh5blB5K0RnOUw3U0ZidVJGR1R6NWsxR2Vsdy9uYmIyQ2hpZ3BFVjJWVC8rY3JSY0o1MEZTeWZhU1xyXG4gIDlkQjVGQTQrVUtwWHZpNjRWMWs3Kzg4bUF0Q3pXaVpXWHRNUWpxbGZ1cy9paUt4V3ZYS2JXYXdncDdZK1doMS9GcWEwMVhSbTJSVEpcclxuICB6R0NSSUlJQmJRTURoKzNSUWpGTlAvT05RVEplRVJYeDlwWkdhV3R0a3Jkdk8xMU8rc1VhczdZSzVSWS85aDNibjd4a0RCWk1ub2N2XHJcbiAgS3dqWjRWOTdYaEUwSnRMb0FTQWVzKzJ4WXAza0lpWlI1S3ZFUVpFSU5RUFNkc0xoU21pREVDb3NlK29tV2FxRUFBTEFEb3E3OVBtMlxyXG4gIEt4Rk8wMmVSa1pvbU9YbjVVck5waFJHTFFDaXdmQXB0NDQ0ZWF5bUl3RnUzbm1abGJHeEZnTVVleU4vMjJZNkJjeG51WEJGaUZBQWlcclxuICBDU2ZFRFFTaVFtamVnaFd4QjRMQ0JBQ3JKUmFlWWpJTVozTEtMUnY5M3ZRb0twOG9aZjF6WmQzN3o1cXJHZTU0MEtDQmtqWHg4eHBMXHJcbiAgTVJGZlcyT2RyY2NCV0d3TEp4SkVXK09VVU0vVTV3M1J3SWlqcGJIV1ZwRFRqdnVob3BoZmE3OVRia0NWb0htZDBxRDN5L3ZIK2creFxyXG4gIHBDRjNjclFjcHJPWS9VSkV0cTJlbzg5a0RhZU1pS3hXWWtWYllYejFqOFlhU3Zvc2ZmZWN3M2lGdlRyOE8vSnJFM2R1QTFQdCtVWjRcclxuICBpQU9KQllaUldVSTNTUEZyTUtGYTl2QmwrbHo2eXpWZk9rdFNzM3BIWElGZ0JNUWZnTHp1SzhCN2c4cktHbE0rUXp3QzhvM3JMdTc1XHJcbiAgeTJNOWtQK2VJSWl4VGp4aFJxSmZnVURjOW9mN3U2VC9mQmRlSVhycVN2NHZBRWV4MzlqaHNuRGhjdk8wdXpkWThPRXlXeGNDZ0dIMlxyXG4gIENtV0YvZ0xEaTB4QXQ2U0I1ZlYySWtDc3JXN0Y2a1BuZFVEQTFuTWFvdEcxSUhFbEt0bUYra3NiOWh0QmNuQjFPV0w1SWNUY2tIME1cclxuICBVSTU2QzU1dnNudWR4U0pPMlprNlFFcExTNlM0eUFrWUh4V1dMMnhBVTd6aG9VUWQyb1NGcmxqNHRBekUzdDd5VW5XVy9ZU3dkM2NwXHJcbiAgTHE3Sk02SVQrdUJ4a0JNei9rQWMwSHV3b2pxVTZkNXZ5ckhYaFNZTXNZTDB0aXVTZ2d2bzRlTXE2aDhFQkZOZzhsQ2VzNTgxL28yc1xyXG4gIGJMZ0gvWnQzeitkbHpDbmZzbkw5cGx4Z1NBdWxkZ1liaENoVVA4bjJwU0l2ZkdlMGZPSzNGWWtWMmhBdlBQS2VmcHZPVEdoVEQ5WjJcclxuICBvUEFGSWVJaGx6U0FYZ1BqQXBTOVhJZTl6STE0ckpobGZwcXNQd29RRGtSeGNCTG1lOG9JQjhnM1JqaTZnU25FOWZBdXVFWFZvRkwzXHJcbiAgazlTaWZXM3Y2TEExQ2lrREpwdmhBY2dlUXNFWUlBNFhNZjdNSHhseG9CMDRCSjRkOTJiZDBpTmJaOXE4TXpOSGpmTEN3ZmE3dE1kMVxyXG4gIEEyRmdFc1IrM0RXcjN6V2loZmtyMEgvY0VVWm9lTzBRbEVFSGZVTEdLVWVFVG1YYzZkL1Q5bEpNQWM5NkJ0YnpmUFRFamJKMS9yK0VcclxuICBQY3hUVTVTQTZQVnljL09VMi9xQkhWeWZaOFFKbmp2M2dwZ1NicVNLL2QycG9JRHVDVkVaWENCRWk3SE9wR3pGYzcrSWlMYVcwN0pqXHJcbiAgbElnZ1dzWE0yZDNPK1BQY3Rnb2k0cnNuMm5nYWRiZ1JFYzdqQW9XUWYzUmw1dUlrS2tjbVpzNmNSd2VERWdlT0RrNjRibzF2V21ibFxyXG4gIGFITUVlbGZxc0oxQ21YRWZuQXNHS01udndrUFhoeHdzTytiZXFWeEJydnpoNTFmSk42Ni9WR2JOUnNmUnU3NGdUanppeEFTT29MUzBcclxuICBYd0poOXdaWVRuRWU0aEdRT3dRanRJR1ZGL0RqRzMxanFMMUJ2QytCTUlUd3dBTmNuQi9TZU9vRnpqcnp1SDFDOXZzS1YzM2xNOFp4XHJcbiAgdnZrV1JneDdCamhLUkhZV3Q5ODlRSHBibTJ6ZW9VM3pQcnVBRFpVSWVwdzA4RnhldEVWNndKU1k2eElXRGE2b2NLK25RRWFPcndFSlxyXG4gIGRVRmtKaTdRTkJ2THVBc05RRm5kd2QyNUQzNWpvWjNyNWJDQTBBZXZseVV2VlFlckU0MnNTWmZLNk5HakpTODN5MWRuNi9uYTJsckJcclxuICBtMmZXOHI5UzJNUU9PTTREZkdCYkk1YjJ0aUVPUHRqdEd2WkxPYzlqbGJyVjBUVEtjODIxaFlpaExRdnRWZmtDdWxSTVJUVnNxTnRrXHJcbiAgNTlpWDJ0dEx0a2w1dUFuaW80NjlXb3BSTGhvb1FVR3hhV1c4RG4vMFlkcFhIakZsTGdnRG5jSkJwMytURXRJUktZZ3JLaXBrenUxblxyXG4gIHlXRlhQVzVpUG9COXNYRm5QdVBhcHhOdFFpelFZd3cvNGxKTGMwQTRPQ0FjK0hFQzJOVVBkeVBVQS9taCs4SnlpaHJrb2VNd3BLalFcclxuICBuWEFnZWtHOEZEVnZCNmJMNUkwNzQwZjJNWUN3RTNvc3pXaVREdGxlVjIzSUZTc3Uxc3hncG1xTy81Umd3RVdZUWw0Uk9YWElBekhoXHJcbiAgR2dZVDh1cWxyOW1CN3lvY1ErTHFIRzR4NUNPSzJsOEpFUFZEbjNaVktOYzhlTHdzZXZSYmN1aVZqK3F6YkxWMm1kM1RQd2dENVlselxyXG4gIGV6aVd4R2dDQWtRVHJBRVpjZFNsUnRqV3IyZXZFekczTzB4c3hwNzBkYTFES1RIakFvaXRLL29SKzgyeXRSMXd0U0I4NDBhZVVXNUVcclxuICB5NDg2NWtvTDJYMlFleWVPeUxGR2ljTUgvNGhtenBvSEoxSit5UGxtL3N1WXdKeVk3WllCRENjb3cvVjVGeENDV24wbVZrNnZ6NlFJXHJcbiAgTDc3RVF6azRGcmhlZDI1WVkza1FFWnN3WWEybHYzWS9Pb1loSWhDNE5iUHVNbTRiQjQ4WVNXQ3U3V1ZDV1Q5cVh2aTZyTmVKM2ZtZlxyXG4gIG1LN1hLVEtrN3I2akdBbTlBeHhFV3N5aUNLUkl2WXdNbnpEdENVRDZnWGdFZVBDaFo2V3BxZGsyZy9yZ2c2VktZTENnMnpzY3FlM2dcclxuICBWZ1VJSE0zWlovbWkwWENOa0IvU0J4MjBuenp6ckhQcEh3ZGM4SmxQV01nT2hIdURIeW14RFAzZHJSSWRRSW5lb2JPUTlQeWgwdDZwXHJcbiAgTDRyQmtBQmVZQlNONXljem8xejlqWjMyaE9ldFdKUjhBSmp1bXZKYzgva29iZk9YYU5VNUFCSm1CcytnUVhtZXJZUFJycVZIR0hRaFxyXG4gIDlMeGtHSTk3T2Q5Mk5USHpqeFRpbUo5aTZaUElpL0piaWlkS1VjdHFxZDZHRDN4RnFIbzA2a0RSTGt2ZllaTmtSL1ZHbldXdXNFVnJcclxuICBXc0VXY29GdytLQ1RDbktPbU51U0tJOFFGOXJJdll2TEo1bkNuQlhySmVPUGo1WHprSmtZSHhMdUtEUlRyN25jZkNzeFUwWlJhV1h0XHJcbiAgMmRKdWlqbGh4RHlTbVNoclBMaG5sMU5qdWtjNVNpY0pHTGI3SUFHc3ViRHg3M3ZRZWJMKzVkK1lHV3ltZmxTMU8zYkl1UEppU1Juc1xyXG4gIFNJVHRXenVhNjJYNnRjOVlmZHBrMHlPTUFBWk1PTkVXOVhGZmlDTlpUWTlld3hlMGVkL3djK2FMNkdhWjRuWE5hM2ZvalBnb2FXM2FcclxuICBhVXBodXNncWFCYTZvWlNHSTBHOGhONkNtVEhYdExGUVhHYUlINzBSNHEwS0plaEREam5YenJPSXIwRm5ha3hBNkdGQlFiNTk1SndiXHJcbiAgZGV5Vkp0NmlUM0E4S01NUlVhRTRwejBVNHZrbEkwMW5oQ3NkMHZHRFNRNUtjcXpTQms4NXgvTkxodHRNSE5meXZDOFV6Q3k0RzM3NFxyXG4gIEY1U1RPdG1za1lCNWY3bFlUcjU1alJFZStrSWFDTVNFL2tCRW1QV1QzdnI2N1ZKbmVqTFh4K1hsNWNtd0MvNXBkZGljakwxUEdHODhcclxuICBKNTRuYmFJN1pCTEJ2WER2aU5pSVVBYTkwOEFEVDlXSkFKd2lubk9QZE0rOSt4K3ZST1FLR1RMTjEreGdUcDZaMjhlSWdTMzJwQ0Z0XHJcbiAgQkZFVTNMb3I0UFc1Nm5mSzk4UGVIb09ubnF2dmFhTlo1YTFRUW1QdVViU1FWVlZnblFnYmh2VXhFMlYwUzlOczhXbllzc0d2Z1QrdFxyXG4gIHViYUxKK3QxR0V1MGlXUUNCYnNabGtTUThjSFA1YjA1YzJUVXlDRnk1UlhuUzBhbWk1MVJhSHU0cFZlbE0wZ1pVUlJXZW9odnNLS2lcclxuICB6dVRKKzF2SWdkSjZkeENJQjBoOTBhSVZTb3hTelNTWGZGWjVrNC83RDB4Nzl3YXRyVHJHYzdQdGV0UkhtYjE4K1ZwYjNOZGRtUjRXXHJcbiAgSGxaWDFjcXdZUitQTWowbkoxdCsvWnUvMmNyNnZZbmY2QU5teHl0WGJkZzdCd0kwdC9OR3crc0hZcU1oRHIzbGRZRmtnZWxEM0Mxd1xyXG4gIEFKQ09ReWlqYzVJZ3c5UVIxV2lPMnB6N3NBMmovSVEwS0pHSjEvSGZlQmcvbDJJRDNFWm9kQ0N1Y0RSS21pS2U3Mm1PQ05GUC9MS01cclxuICBIalZjY3JKWi9lNVFXMVVocTU3N3VZd1k0WXZRT0xZdWVOTEVJK2I0a1hyV2t2NVpPL0UyUFU1NXl2ZyswRjZPR1dvNEh3K1ppUkZDXHJcbiAgTURCN2JObFJhV2FlVG9qc0toWmFYSThEejljWklHa0ZpSWU1eUxCMFZFYi9RQXpZNitNNEVvWHQ2Sk91ay9sLys2SnhOUlFiTk1nWFxyXG4gIFg3VW9KNHEvb2FxcUtpWHNTdzN4ZExRMHl2U3ZRandvNGZ1Q1kxbURmc016VTB5TVJ4N0lMZVF4Rzg0dVpwTWlUV2tXQ0c3amV3OHFcclxuICBFUnlxNVk1V1FueTZ6YVFoQnJnM01mRVNTRkJuaThZcEtJSzB6Y1MwUGxaQW5NT1RMdm5NYzFoOE9mdm1Zd3c1WjJWbUpnWTU1UXZ6XHJcbiAgQzVTQUhtYm5RTkpGd3lZcnNYYlJWM3RybzRtZ09KWW8wb1lqNFVCUEJkZXl1eU4vMEdoWG51dXg1UEVmMjFxY0Z1MERBRmUwdnhLRlxyXG4gIC9scU8yVFFLZGU0SFRpVjZIQWJuL0VXSnRCSXd3TjZUY2owZ2FjN3ZOLzFNU1cydGtlYVdEcHpNNmoybHlxRmZSeXlGSmRzTDh0YnZcclxuICBmTXRUREFyV3ZQWW40MFk0ekErYUZ1STU4cUFodkJCb0UxVnBHbkVhSE9IWWs3OHBTLzc5M1lRZUVWUHFqLzd6UFZQY2t4NmdoR2JFXHJcbiAgekM4WkoxSWZmWWR3SW93eDQwUTE1RytNdHNNelhQbkNiK3djQlJGZllwaGdsY2lMOGxGNFkrSkx1Ym8xNzhsQTVlQWhHSDZlaVZDcVxyXG4gIGpYUGN5RkFlRnpPNDZHRVRLaUFvMVhNVy9FTG12emRYaVVlNVhQSEZNeVZIM3k4d1pzd3dRK0FjRU4zZGliTGdRc0pzT3NBcVJZeGVcclxuICBiOCt3VXBFdDVVRHNpTFZDSGRhT2hmdzRoN01uZ0ZCUUhnamlLaHdkQW9IN0NQa2hmZVNSSDY4eVBXeWp1eTl0c3VvZTJDc0hBaHd3XHJcbiAgSkYrcVcrSUtLUkJVRkdWZ0JMQ29weE8vc2RPZThJeUN6bXJaWE9rUDZMZ2pqcEtLRmwrWXhPeVBEV1FvaHlOREFEMUkvZ0RmTTV5WlxyXG4gIGZlQStVSjRYRE1ZUlhrREl5VEFnL2dSeWpmTGNETGhVWjRzakZLbk9NZmtwTGkwd0QyVUc2WHVJQkU1QjYwUmNDRWRhMmFHU1ViZElcclxuICBkdTNjSWVscGZoOE5UUzNTVUxWS2hoOXlqblJrRnBySWdzVmw3cFlqMlEvZnIxM2oyaDZtaWlBSitvcFlEdVVmL1VpVzczb3ZJWC9kXHJcbiAgNjNjYkI2SVoxZzRmR01yd0hFWEdYb2J5RUtXbjNDZVN4cG50c2JjMG5BQ3JzelhUNitzZm5BY2lIQkFKN2xNdzljWEhHSXZGckpqK1xyXG4gIDVSZjJrZlh2UCt0S1ZvV096allaY3VTVnN1R052OGlNYjdndWhnUGlBYklnanBNK1pyT2NnYU1ySFgrczViT2FIUEVXemdWeEtKbWVcclxuICBuV2Rtc2N5TWNhRXk2b1JydEJnbXY0K1pDV2VBWEozVk15N2lnSmt3TTJsRVFEd25WdkJ2VTZLQUthMmI0ZUxhWXExazFDNlJtdHBhXHJcbiAgdlhxS3BLZG55eUhmZUVINllpR21hUWhGeFlmUG1FTkhDQUh2alh6R0FYb0NWcjZqMjFxdFNKbVYwaURMUUZUaXg2YTVqMG16RW5QR1xyXG4gIEZ2ZUIvSitaK2ZDWkYrazdtbXBsMXIxNXIzSFY3QTBEUWVFYUh5bXhHVEx0MDJhcFJaOXhTa25lUVJmY3FzL2xGWm56Qjk4cEw2OXhcclxuICBwYnovMHYzS2liVXJRaExKek1xV3Rvdyt4cG5oQmZtSWI3NWluQXA5SHpMMWs2YXp3YjJJR3lQTWtuRm5mRjg1c2Z1TU1QT3NjTnV5XHJcbiAgL3UxLzJMdmhlYk1WTU5aTG1DZmJ5bjk5Y1hBaXJEQm5LMkxXeUdBUmhYTkdkRUp3SlZwTngvQlFXZkg4elJieXpubmZqSUZON3oyc1xyXG4gIHozS2krYkNEczJ4dHJMTTFNMXlIZWdEY0xuSGJnbGdqWVF2a3BLc1RDbmFhdVRGY0orTWZnc2pCMmlFNEVFcDg4T1J2cEYrZlBMbmpcclxuICAxMStYejEzOEtkbXdZYXMycDJOUVovTjMzL09ZdlBUUzJ6WjczNTNaSzhpWUdYWGdPRUQ4Y0NNaGozQjNBS2NDaERJZ1h1THNaQWl3XHJcbiAgMXdhTEMvZlZwRGZzRmNKQ1BUZ2oycUxOUUl4SWh5T2tBemZ5Y1VCWldZazg4T0F6SnNKamIvWTl3Wi92ZWtSS1MvdnVuUVBwYkd3MVxyXG4gIG1mKytRVFE2OWdaYTdMMkYwYXBtaFZmbVkydXZtYng0L2ZBcEFDSjJDRzE2bURjUUI0cUFJOEh1NXozczdSd3pIVjhMa1dackN6d1BcclxuICAxeGxZZm9HQW1mV3daaVAwaGNQYUNYRTloazg0VlByMTd5T3RiWjJpLzVLVmpvWFNObG43MGkxU3MrQmhHVFQ1YkdzM3RFSFloVERvXHJcbiAgT1pBMHlKbzh5dlFkalJzSWozdTlHUEhRdiswYkY5cE1FMWs4Ymt1UWE4TzVtQnVXbU9MYzZ1dGZsbjVjK0poQ2ZNUE1uUHdpVzNTVlxyXG4gIExFUElqSkk4ZkQyaHZNZXNPVFhObjQzOWFkaVFCZGZpSzlLQitsMU5NdWYzcDhuaDM4VHhKV1VrSWg1Skt5dmFZbkVYQklNWkw0WGdcclxuICBPdUFxRUJjeGkyUkdqcWlKMlNabFdIMU9YV1QzYk1JRllJa0VZdGZwcDZVQnVBM3kxcjM1TjJzUHpvR0pScW5tczhodDRVUGZzRFlvXHJcbiAgZzA4a2RDQThSUUJuZTB2KytsbXBXdXJuUWJvUUlRakpyRjhlWS9uRWJiS2k1VzF4b1NKRW5nTW13WWpMUVBRYzVPT3NFS3MyaUJ2ZVxyXG4gIGtYRWlpVWxyUm5hKzFhZTlKZjlSVGdZeGxRS1RodjNQY3YwSW5BcElrR2NBUVlGd3NGZitrZDl5em1LOGxvTXJnY0I4K093ZmJJMExcclxuICB0Z3lwK3U2blgzeUhqUC9FdDNYc3ZtbnRRa1J4MVI3aWlFQlJ3TE11QTA3RU9SQ3hCWXB3SHkySzBPa2Y4Y0NOSU1MQ1dJRTk1aW5NXHJcbiAgUFpWT09OSE0wTTJSb1FLTFJmUDErNFQ3TklHZzFwdCsxUk9tRjdNTGFKcS9Bejl6cTNrUElJOUpDdHd0RXhqT2s4ZnpoQXNramtzZFxyXG4gIEEvSkdIaXFyWDNHOW5iVmwzNFMrUFIzM2xPV0EwTEJGQVRyQUxZOTlTWWFXRDVBLy9PcGFPZkUwMXhuZzQ0b0RRdkxONnk1T2lHTkFcclxuICB1SHZpUW5CaTJCM2llNS92RG5DS0NGQXVjQWgrcmZjRVI0aEF5TjhiQkE1bTVzekp0djhJRU9vU0JrSVMwc0RIUlR5QVQ1eDZsS1RwXHJcbiAgeEhUcFByaDMvKzROWDVZVks5YnRtUU81NzlGNXNtTkhoUlRtNWtwRHVqOE1lNUgrSDBFVXM2QmJyZzJZQU1TanRBWXRkVWt6eUpUTVxyXG4gIFl1TUFLQStIQWRzZjNMZVRaeDQyZFNEaGxqbkh6SGU5TFQ0NDV4QTBiWU10TnVpaUk1NkhMb0RaT0drV3ZjR3k0eUNRZlR2STI3YnlcclxuICBkZlB3R2VySHVZOFFiOHdlTGtNeWRDYlUxQ0QxOWNqV3Riait0TFkyUzBGYW8rVEJRaGY0TlVLOUJQZWhCNklhVFpqcmNNdURHQ2dTXHJcbiAgeWNndWt1RCszY3Y2UFJFaUh5NmZkcjRSREJBSk8vRTFWSzJXc2ttdWMwRzNZaUVQVmtNUUZWNVRNVS9GMVRYS1IyYUo4VEtzTUVaUFxyXG4gIGdmOG1aTlRyMy95cjZTVFk0QWZBMG9LMUJNd1EwK29XNi8xaDRPQkU4L0JQZjE5eWhpTEN3S3JLaVFjTEdTRStiTzJLdUlFRmRsZ0FcclxuICBjVGxNVEZrb1YxUTJ3V2FqaU5NTStTdmhHS29jZzhudEZlbUR0QkR2d0hGNE4zVTg2S3lYNStCN2N4eHVJamRXNTZQYlFYa1BkN054XHJcbiAgemdQYUh1YStLRnIzc3pab1lNZ2huNUt0ci8xT2R0YlhHeExFakhmNDFGTmwrL1k2NHdyZ012QjB1MzM5ZkJ0M0dYbEZObU11S2ovQVxyXG4gIGlNVGdxZWZZdUdRUGJzUmNoY3J0TWw1QVhzeUtJUlo5UittRVFpY0FiSEEwN3ZRYm92UU1hZGIySVByOXg4NDBVMVVXNDZFdldmdkdcclxuICB2YkxsZ3lmTkVHTHNLZC9Rc29jWk1RRkdIbldaVFc0Z0prNEVqNWJteXNXeVpjSFQwcmlyVGxoUW45ZVBSWVZIeTVySHZpb1RMdnE3XHJcbiAgRVVIU0tNeDVmcXdETWlLcmVYZ1h4dGZXc0JrWGFabWp6Skdqclo4YU9ONjRFNTR2N3dIdUFJcytDQnA2SFh5TTRkZ1Jnc3RDV0hRaVxyXG4gIDdQTElZRWNQZ3FuNnBuY2VNSE50eEd6bDB6NWo0enF1NjJBTTRwV1ljY2NZd244V3V4cWlId0c4ekJCOUQ2L0tRQjJIY0I1WXF3MllcclxuICBlTEtkTTRqYVlnMEszeXRqbDhrVzNGNzJxbi9JbHMzcjVRODNYeTBubitGZXV3Rm01WEFPQU9FSEM1WW05dkxZRXhlQ3FJbnk1ZVVEXHJcbiAgYmFFZ1N2QWhRd1phM3Q0NGtUZ25FT0tFSFBpd21xS2N5cDdxQjZBTUJJS1E5UjVZZzNIL3BFTVlyaFBTSFBRMXVFWDV2OEp0dHo4Z1xyXG4gICtPWGFGejNJNDArK3NtY081TUxUM1A1OWZhWExjd1BRZVlka0xBNmUyL3M1WUVyL3BOTkVQbXhYbnFlWXNoVmkwVkpmYldzRmFBTVJcclxuICBEZEM5Tlp6L0dRWXpDRmNrakpDa0hVQXlENHNQRUMvMUdOaHRUYnZzZzhES3lCQTJaZm1vSXJOSGE0ZjhidkdOMmRPbHBLU0VIR25EXHJcbiAgUFVabXVuUXFjbHEzY2JNc20vMTN5V3VJZkhKWlBSNnhobEU2SGlkY3I3TjFTdUZ0MVlsSDEvUE10RkVvTnl0QkhYSGtaWmFQVG1Ia1xyXG4gIE1WZEVaYUwyOVErWDJaYW5mNFFjOVJYMEpXbzN5Z2NKSTZwRCthdzUrcUcvTGFPT3ZTWmFkK1BFZzdVZGNHTVU0T05xYnU0d280RU1cclxuICBwVlhiY0h1K2JZbUpveUQwQUw2NmFwVGpNTSsxaW1pY2VQajZCQlRKWVpkQ0ZMSUFTQS91QVFCWkFwaXpoanlBQllVZ0liaUY5clltXHJcbiAgSzRlL3JnMXYzMjhjQjJJaU5xc3lya0RiZzhzSnBzMXdFcFZ2M0M2Wk9tM25maUQwcmUxdDBtZkkvb1lrZzlWVTJhVFRaZEpGZjlRWlxyXG4gIC80K2tyV0c3Y1F0ei9uQ3VMSHZtWmtQc1M1LzZtU21IVWVKdW12dW9Fdk5uYlRPam5WdVgyK3g5OC96SEdjU1d2K2ExdXhSSlhtVDFcclxuICAyTytlK3dYWmpqLzdoekw4eUM4YTBRTnFWcnhsZlE4Y0NnQm5rcEZia0NBbWNDVkxOYjdzYnhjcXNYS0V5THNxNkROQVh2L1RGMlhBXHJcbiAgekN1TTBBVHJMVi83OHBxbFAzejRHOEpLZC9Kd3lJaHVockhFbmlQR2tXamFXM1BYSklnN3NmWWlDMDRFWTVEbHovd3NLaU8yZHVUOVxyXG4gICs3NmlZMGJUMmc1V2RIQWdjTEJPTkx3Yzc4cnFhQnJEQWtMeXdyaWJkdGxETnZhc3ZCNzg0WWNMWFFoN3F2T01HYy9zSDBKL0U5K09cclxuICAvakhtczRwS1RTK1R1ZnhlcWRtMlZlNjk4d2JKS2ZMeEZJY3drd2N3ZHczcDExK2Zwd2k2ZHk0RXhFMDVIQ29DN005QlhwajU3dzQ0XHJcbiAgOSthYjd4dFNEK1ZDblBwakkxMU00QnoyQm9HelFLZnkzbnVMRW5WRFNOdEF2TTA2N2V2SEJiaW01MXZabC81V1Y5ZnRtUVBKVG1tWFxyXG4gIGV4OThSbkoxRmkyeHZkRjUvdzZKaUErS0NEekdJTEdJUW9oNFhtRkhsV3lwZHNTVFhyeWY2enEwUHNRRTdvTUZZTXhZeVd2ZVhxR2NcclxuICBScW5OT3JDSThlc2d4MTJyK1FNVGd4b2s2WWpYWi9wSlpFd1kwc3JGVkM0M2VTMXhVOFJxeUNCblJsa3k3aGlmK2VHYUl5cFBtTFNrXHJcbiAgWXFhUEJkYzdVcUl6b2N5bURiSnIxMDRyWTZ5elBubG1iUm10dFpJOURQbXljeCtoTFN5UE5PS3p1YWh2bUlUeVRPQVcvQnBkNzhVc1xyXG4gIFZUVGt1ZEFQakFqQ2VnLyswTmQ0V3luRy9tT050Zm45ZjFzZmtZUHpjVEpyODdKK29PVE0xV2VKWjJDZXhTYnQxMEJGTklCL3VDbUNcclxuICBtNG9wbDl5ckdVb2sxNzBnTmJWS0dCVFM5RlpZdTFFMGFMUXNlK1Z1Ull6NEJWSkVWRmhpbkFHRUo2eGpBTG4zR1RaVisxUm1vaDRYXHJcbiAgWWJrK0E4NEQ0TnB3SzhqV2grcnNtUW1ETytyejFkMklpdUFXTkdtdzRhMS95TUdmL1lNaXh4dE5qOENCNG5iQWhPTU5rV09hV2pyK1xyXG4gIEdDVVN4YkxrL3N2TUdxYTVzVmsvQ2o0TGtRRTZFeDZtaUJSUktRczhsejV4azlSWHV3Z1ZCTWJ6UllkUlB1MDhheHZ1YmRpTXowcGhcclxuICAyWGdaZE9BcHBtTW9uL1lwQzhzT1BsMDV5WlBNOGdwOUFoTVNBQXMyWEhkc2ZQZGZ0a0IwcTNJUUxNQkRTWXhya2tNdXU4L0c4bnJsXHJcbiAgUm5qL0tKQTN6UG1uckozOUYrTkM5MWRpdHVUeEc2V2phcUdrTm16UkQ3VldVclg3MmJtWmN2Z2xkOGlFaXgrUWhoMjF6bTNvTXdLTVxyXG4gIGlCcnh4U1hKRjB4L0EyZUhkMkF6MjlaODdzZkdnUUljS09PSkNSdGoxdnJ6OW4zR3FjQjE4TGhRWUNOeVJLU1hscGx0cHJwNWZEdmFcclxuICBCbnZWc09nU0RvMkpDT3VxZUw5VVpMVTVsMkhTZ0I4dGZHWTExV3hVYm1XaldWSUJaaWlnUUcrd0VFUjh4ZGhseDB1NFFCWW0ydmNlXHJcbiAgZzEwNkdTcFllNy9NbmZ1ZUhIL01WRGxzeGhSRHBMM0JZLzkrU1lxSzhtWHo1a3B6dTRGRjA2bW5IS2t6NTk2NWtNQmxFQ0wrZXZXMVxyXG4gIGQwMTNFaEEyQ0pYenZVSFFWN0F1WS83OEpYTDQ0YjRkT054Q3NKNUNMTFV2MWxnOGozQ2RKNTU4VlE2Wk9qSEJkY1RibzB6SXh4SGlcclxuICBFVFAzeldSNGI4QStLUS8vNjNuekNmWUZ2ZGFlNExISFh0d3pBUmt5dk53VTZhMzZZWTRlTmx5MnMyN0ZFRXlBS0daQnQxd3dRQUtJXHJcbiAgZTNwU3YycVo4MkZTL3lIcEJaSVo3VERvTGhjd0o5MWc0aXZFQ21iMnFRaTB2YmxlY0hQTytWMmJsMGhCWkRIaXlEa2U2blUwbmd6OVxyXG4gIHFGM1BLbTBsWG9Nbm1paUlBWTk0Q1RreW9oU3VnNVZQa3lLMzNCTGxCdlNjdDBtWVptbmllRTFGVnR5ZVhTSkZBMFpMYWRaMi9jQzNcclxuICBTV3RydXltZk9DcTJiSkxNYmU5SzNwaVR2RzdVUDNNOW9uRlhRaXIzZ1Q1RC80WWVmckdsL1ZySmZ1dVAvaWNKQlAzdG80U21kdTE4XHJcbiAgN2I4T3NuZ2RiY2Q5Q2IwcnBSTk90bGsvU2t0emVNZWRSMldRU2JNQkZNUUR6b09ReFdsdU5VWkpYemVRcmUxRGJESHBYYS9JalRsOFxyXG4gIGU1dnYwOURTMGlFVnkyYkxNVDlhWklTaHM3M0ZGUEdZcXhyeDBOSWdGNUNuUmkzTnJEZFBFUkhpSWx5TkFLdGZ1YzA0TDh4Sm80TG1cclxuICBOQklsTDRqTWxOU0s1Qkg5N05xS04rQkZKdUxnZkw0aVEyYmN3MlplcE9ObGs2eDYrUTg2dy9aMUo1dm4vOGVRZXZXOGgyVG5MaGRmXHJcbiAgcFhhbVN2SGc4VW9OZDBwai9VNFQzYkh6SS9jK2ZPWVhaUERrTTZWMC8yTmtpQktIc0VnUWJvUkZteUQ1YXVVYTJKRVJjUkljV05WSFxyXG4gIHJ4cjNRUnJQeHh2bVBHZ0VDT0pUcW9oODVOR1h5cGdUcmpIUkYrMXhyUjJiY0dzdXN2aXhINWdQS3Q3bnBJdnVNQ0lGTjVJVmNTakVcclxuICBnZEhUejVHNVQrSE8zWHhCU2w1K3ZyVGtERE56NWdYM1gyVTZHY1NmY0RSTWZEaUc2YjBzVTI0Q0UyQzIzRVhzQm1IQm9BQ2RHQVFIXHJcbiAgUW9JdURVTURleTg2M3JrSStVWkU5SHZBRXpRR0JIQlE2VmtGU2tCeXRBeTdSajV2WEI1eDNOalAvdGwwV3l4TFdad3dMdm5QOTh4UFxyXG4gIGxvOU5zWFVraS8vOVBSbDEzTlg2SHBWclQwdTN0VU9EdFE3bkFiNUZGaDBpcGdJUWMwTDRlSzgyemlQSVhmeGJlZS9kZDJSd1dZbDhcclxuICAvL292eUxISEgyN0lkTFp5RnF5TGlBTjdaMEE4QUZ5dFQ1amdIaTRvMzV0SUtxUkJ5cC8vL0prSndnRkNYYng0cFptdGhyemVZT2ZPXHJcbiAgZXNuTHk1VWhRd1lrRUh5L3ZrV0M0MEhhUE9hWVE2T1Nld2JxaGZvbzAxbWJ3bU1pSGNKQU9FSzZvNzNEd284RDZPL050L3hGU2tyNlxyXG4gIHlKZS81T0xHM1FGK3NmWklRSUJnaVRWd1lMblVOb0dzTEttUWlFUlJUeWQrWTZjOTRSbDlVbXRrYzFXMXhWblZYVGdVQjIwcENmR1ZcclxuICA3VFFZaWJRQW5PbUIxTmpTMUhRZUdyZlFCcWoyQnc0RU5XbEloN3dvVHNqTUQ3Y0p6RW9oQkNDZ29QdkF6dzRXUCt5RndHdytOeUZLXHJcbiAgQ20wNTErRnhPQmlkQlJteVZjS2dIME5OUzc2VTVlNHlTeC85c3FXNXBjM3V0TG01U1RLcTNwSGNVU2Nab3NERmVucE9rUXllY202aVxyXG4gIGZlYytVaUx1QXlJUmlFYnkraDV5UDU2L1p0WWZ6YnR2NG42NW1wWEQ0cXBjWjNLSFNiWStSOXlMdTlXTDE5VWZZWTBHVmxmSXBGbXdcclxuICBCa2MwNU5BTHVoQVA5QjZJTlFZckltK3Byek45QnJzUTlrbXJVbTVyaCtCRm5MbDhmbUdSNU9ZWFNtZEdnZWxvOE44VnJMd1FXeFVwXHJcbiAgb1ViT1Q5cVFsRDVYRU43WVU3NWxPZ1JXcnlOU0JPQklBTHBacjNGaytJaHZJQkttRzlNMkNORlpZTm1FRlJ0bTM4eXdzVzRhZnNSRlxyXG4gIGRxMDFyLzNaWnJqY0xlZkdUemxLTnN4N1JscGFXMFg1UTBuVldiUk9mWlZnZlVMZnc1bUsrTTZ3MlRZRXMvS2pWMHdKWHJua0ZadHBcclxuICBJNDRDb2ZLT0NIbTNBeVllcjV6SU9LdkRBVmNDWjh3NUZwN3UwckVMTVVYMHQreVpYeWxTVkdUMStsLzF2dEpzQWpUbEMvcnVEajdOXHJcbiAgTE8rd1BLdGM4cklzZS9xWHRzOEduZDcvN0I4YUVXNVg3Z1d4MjZyL2ZFc0pZSU5rNnJrT2ZjWGwwejR0RTgvL25TTFZjaGwxL05WR1xyXG4gIE1DYWM4eE1MV1Q4Q29UQWlvdHpkcHJtUHlPWjVqNW91aHZ2aDRiS1hDa3AyZ0RLMkY0a1NDOTRQVmxPSUNjMTZUZDhCbkNMM2piY0JcclxuICBqQ1Rnc0JCdnNkQ1ViNEFObk9nMGVoRDJHdWszZHFiNXVpcWJkTGJyUTNCbkEyamZjV1hUc0cyREVvWmE2YTljQ1FSbmhZNUZGaFdHXHJcbiAgTW94SmlBaDVFSGNmcy9xNmloMXhacjU3Z3l4WXNFRDZGdWZKdFZkOFNqN3p1ZVRzZUhkY3lQc2ZmR1RyR3lBWUlGMFFNelA0M2EwTFxyXG4gIHdYejM3TE9WazFXZ0xNZ2J4NFo0b0FWQjd3bEovL0tYZHlmRVNvaWhRUERCYXkzOS8yOFFmQ0FRMmRtWkpqNGVOYXJjMmczdGg3NXdcclxuICBkTS8vdndMUGl4MFFzVVRibXg0RUs3TjlKaUJaQldYUzJPNDd4amtrSW9tWERYaE1mM3VVODd5MXk1Tk94am82T2hXaCthWkVlRXRGXHJcbiAgZE1HSGlDa2tlWmpIUWxSMjZVZFZXT2FPL3ppYWE3ZVllV0dTYUlTd08rTDFBK1RpM0l2bWF5Y2dIQXhZa0F6RWd6MG5RQWlKZW9yd1xyXG4gIFBSNlo4Mm82dElkQ2xRK0lmbTMrOEhuYnZDaHQ4RXhKMlRySFdGZ1dEcVduVXpaRnFxcTJTZitXSlpJeDdEanJmMTQvdlVhNm0vZXlcclxuICAzelZsaGluMzRXMzNjaTlHR0xtMjVpbFJSQndHOGpRbmtIb2ZpWE9VdCtmckJ3djhRRGJlYjgyenNpNjZnaU5CYnMzeDRZUFh5cGlUXHJcbiAgcjdkem9ReVdPNnkvZ1NORDBmcmFqeWVadVc3aGlDT2tZdDZEMHRUY2JnU2tYUkZMV21PRmZQamt6YmEzdWEvendCZlZUK2lKRWlWZlxyXG4gIEZBWnlLaDQrMVp6M0RUa1VOK3l6ZkNNaWZmYUlLbmdQY0JJUUI1QWFTQXZpQVVKY3h5SkFrQmtJWElGemNBR1k2a0k0Z3ZmY2RXOW9cclxuICBPWjFoSXo0Yk1QRWtJeklzMkZ2dzNKOXNGOHV3OFZKSDQwNDU2dHI3emFmWjJoZCtKVTA3NjNUbTNHN2VZZUUyaGgzK09TTkcvY2ZNXHJcbiAgMFBBTHhqMDRzZkFGZ3JnamdSUGlXblpnWHFyY2paY2JMbU5QK3BvTVVnSkJldWlNQzQzSXRUYzMyT0pFeEtYTG4vdU5jbjF6bE9oVVxyXG4gIHlJU3pmaWdqanJqWVBBOWcxZ3hzK2VBcFE5ajduLzBqS2Nwc2tCV3oveUdkclczR2ZXUmtaY3JNNzgyVGxjcHBGU2dSVy83TXpmYWNcclxuICAwUm1oQzJFcjRKZC9jSUFSYUlnZXJsRWdLSnZlKzVjOVcvYXFZWEptVGk2MXBpdmNQNThnSXBVZnZXakVBNHN0MjUxUndZaUkzai83XHJcbiAgNERNWjRWM1pPTkZKbFUxUWRES1MwM2VZYlI2R0NNNjJIRkJBSE14NERKdFJRWndXUFhLOWpia21uYmpSRGhQQzdPS0I5czBESmhIUVxyXG4gIEc4S25ISEU4LzhKOXdHMmx6cmxlbGkxZHFnZ3JUZjc4dSt0ME1wRXZsUlhiakRBY2ZQQTRRNTRmTFYwdFkwYkh2SVlyakI4MzBzb0FcclxuICBjWEhVdW5XYmVrVzI1bVZXMjZJT1JDQjR5UVZCOThhMWRBZk9CK1JQSE5GamJtNk94V2ZQbnJ2UGkvNTRyOVFCbWMrZi81RnRkaFc0XHJcbiAgTE5xUGk3SFdyTjFrbkVDNDdzY0I4K2N0bHZjWExKTmpvdnZZSFdDaXZNOEVKTDJnWERvVlVmbDZYaUFLTFFoNUlabE1lMDZVMWlCdVxyXG4gIGZaVldNRUl5Qzl4NkFBU0R6Z3hMakV4bGRabXRtcVVJbWRvZU9nQVFKYzd4OGxnbkF0TGtPbDFDeW5vWVIvcjQwTEZkQWZ1VmE1WVRcclxuICBCWWlJTzNicll4OFRId2hoVnI3Mkk2cmZXM3ZZNnJOVFcwUHRlcDNadWUwL0N4dnp4NTRvN1J2Zk1CRVcyNmVDdExLeU1tVFRwaTJTXHJcbiAgdjJPZTVJdysyVGlXMEdaWDdvTnJ4TzhCWkI1RVY1NkdZekpadnhJc3lvVTZtT3RpY1VVWkRwU1JtK1kvSW9NUE9VK2ZuYmRKUG4rWVxyXG4gIGhQSU1NRjFHOTRISXdVU0VuTlV5VDEzYlYyZkpkNXVPWThPN0R5aGhmVlBHbmZsakxUTkNFV0NPckgzdERtbHRhWVdXMmVyMDFvYnRcclxuICBjc2pWVHllSUIyc3EyRVlWQlRGdFFpemdIREFyTGRmK2tJNERjbnAybytOOVFqeTBXZFBqWUdxTnVJV05uakx5aWszUHNCNU9Rd2tEXHJcbiAgTTJDSUIwcm51WGRmYkVpU1JhWkJiSVJlQVJFUXlCSXJuN29Wc3lSZDM1MHlDY3FEZEVwbldwYXNlKzZuVXIvcGZSbDh4SmVWR3prNVxyXG4gIFFTaUE1Nzg1U3BIcGE5cjJGMDNCRFhIYXZuNkJJWDQ4SkVBNFdPT0M4Y0NPall1TVVBVmxlUHdJWWlobTdxT092ZHlKeXZUUGFEdnZcclxuICBHa2V3NnVYYlRhYVB6Z2RpUXYvaGdEYlArN2NTMEJ0bHgrSW5aSHRkbmFtUjhUaUdqNllXNVc1eHdSTDZ3VFBZcHRjaGhOT1llc2xmXHJcbiAgalRpakE2dm0rdnBPZWE2RTZLS1krQmd4MWpRQUZ4VG5SQURPTTRIZ2U4dUx4Z2FXWWVhZFZ6a0oxcExBNVRIcFloOFJtbUpkemNaM1xyXG4gIDdyZXlLTS9SYVdMcXkxVnlkTHlSWDM3SXA0M3JHSzdQSE9LQjhuemRHMysxU1lRVlZBaEVCT0E5c3lDVjczYkZXLytVckxRT3VmMldcclxuICByOHJ4cHh4amhPRytmenhwb2lhQW1mNzQ4ZEVlUXQwQXhCODRsRGh4UUpuZUc4SU5CQWZFR1NjYzc3eTcwTGFXM1IxUUppRDF3QkUwXHJcbiAgTkRSS1dabjdZbnZ1K1RkazZoU2RCTzhEeE51Nit4N2ZpVENJNkhnODVBZUMwZGpRWk52cjhuM3Z5MXFUZllIYXVoM3krQk92U21GaFxyXG4gIHZweHljc1JKN2dZWW4zdUZqb1pXS2MxcXNPMWQ5d1QrN3FNUjBCMDBlM3BwWFpTQTY0K3NyeFFRWDNHZW1acFpYMms4eUZ3NTRoWlhcclxuICBtU3dpMUR4TDZrOHkxRWdzcEF3SDl2c2tNZDhsemVDMUREMHdyMnpRandIbE9TdUVJU0xrV3h2MmFMcTJSeHg1OFpZUG56SnVZcEJ0XHJcbiAgRk1VcFg5RmVkdnB2ZEpaUkxrVkZTdXdVV2hUWjV1Wm15dEtseTZYbStXdVVlNWhybkFlb0RORVJTbERxZHU5N2IrSDJkZk9OblNmTlxyXG4gIE5lMGNmYktFdXhWWjlkTHZ6YjZlN1VVOVB6cG43cld0UzFLeDRDa3pHaUREeFF6ZVBzcm42VmMvYVpzK2tVYjJEZGlHVzFwbWh5TEtcclxuICBvcEtoUm85Z1FlQkNtdG82cEYrcHoxRFFoZUE5MVpXalRqeXdoa0tQTmVxWXI1Z2xFR0NFVXdHdWc5a3pFd1pFVm9oZWNDdHVlNm9vXHJcbiAgNFBzSlpKaVpVMndjQ1VnU0N5VmsrSmxLOUVIU0lGMXVpM01neHhVdi90NFdsbUtCTk9HY0d5MC9QU3RMV3BYTGFFZUVsWkVwZlVaTVxyXG4gIGtxTitORitPK2MwMmFYemhhL0xZeFdueXlFV3BNdnZueDhqcnZ6eFcyS1JwdjJPL0tPZjhkcW1jL3QxL3kxbS9XaUJIWFBJYk9leXpcclxuICBQNWZwbDk0bE02OTVXS1orK2thWmZQbzFNdjFUMTh1UlgvK1BISFhEcTNMdXZaMWREZ2hiNjZKN1pkRmRuOVQyVSt4WThtL3R2eEtTXHJcbiAgU1ovL2c4ejh4dE4ybjRnSW43bHVwQkt0VjQyelBPR21EMlRFTVpmSnBzMWJwVlZaanpZNFQzM20rVHJyQnRhLzlRL2psdXg1NkROSVxyXG4gIHpjcXg1OEw0aFJOWk8vdHVFMG55YkhrMjVQRjhTV0NwdG5uZUk5YU9qUTJGS3VVNDBKZTRBdHp6V0dnTEo0SW9rckVBY1VGOGhXZGNcclxuICBKaDhVNnpmbVNMUENJMEZUMDY5OTJseXEyTzZOU25ETTNEZFlZQUVhNUJhWDJmb1FmSDFCa09HR1VaYkh4eXFsZVpjc1drU2hYdm5xXHJcbiAgamRLM09OOFdDcDc0Q1YvckFYejJ3dE1NeVhJd1V5ZGtQVWR2d0RrMmFRcUFhR1ozczNXUWZ5QTRBSHR3QU9lZjV3NFNhV3Qzd0xsQVxyXG4gIFBDQlNVNmRPVEpRL2ROcWU5OW5vRHFGZTZPZTdTc0NBMEg3SUQvZjFjYnA0RDRzSVAvd3dyTVhiUGFSMHRpNEVGK3dXOG9vbkd3RUJcclxuICBDc2E1Zk5CZmN3UVc5WFRpTjNZNlFhTTBiNVFzbHdWcmxPMVg2SjlmS00wRGZERVJNbURjT01UWGZpQzJZbWFQMjR6Q2FOOEtzQmZFXHJcbiAgaEZYVHlaazZZWmpCUnlJbjh2VERJNFNBQko5WHRxaEprYWI3d1RwY3EwVnJOSmloZG5iNlB1dFIvZTY2RDNlWWVMckZkK3JNc1hEUVxyXG4gIGVDTjRzT25Kc243TjFqazN5dXJWcTJYSGpnYTcxNHlNRk1uTXpGUWtVQ2daSTA0MnhhLzN0WHYvL1hvOE04OG5EK1IrdjhtdlE1NXpcclxuICBaYW5HZldET3l3WS92bUJRRWI3ZXE1dk1lbDMrY0xkZGZ0am5qQ2lqc0o1eit6bm1FSkZ6WGtaczFqcDRpcnVjcDZHM2JqMVZEditxXHJcbiAgTC9TandKdS9QVmtPbmpSVjVqeHh1KzB2amxBb0l6MUZSZzBmTHZ0ZCtyd3NtMzJmRW8raFRvUzFRdjIyMVVhZ0VVV2hEQWN3b2NiNlxyXG4gIHlZaUxJamdBYzl3MWl2VFl2WTZCaUs1azNldC9NZUlEa1FFUkEzR2tTUS9SbFV6NXdwOTFwdnVtUG9jN2RlWTdReXFYdmlvenJ2RTlcclxuICBEUmIrbFBZNlplT0dqYmFHaGJXSXJFN09MeGttbFJ0WG1xaVJSWGtabWFsS05Iam1EbkNPN0grZWtwNXJybG9nWW8yN2t2c2Y3QTU0XHJcbiAgZjlsS3JKQmJBM0FNTzJMMWFIZHcyVkFkRnk2dXd0SUtCVGRLZXdEaUFnZXliZW1MOWdveU10T2tvZDYvTzBTaTVlWGxNdm1IYSszK1xyXG4gICt3eWRiSzc3ZVRib1RFRHM0ZGxnL3N1aVNBZ3d6dy9pQUJFSjd3Rmk4c1p2VDVHeHAzemIya1lFQitCV24vTkcySlZnWU5qU2dobTNcclxuICBQa09JQjk4SDcyM3BreitSbVY5LzNvaTB2VERPMjBRRUM3Z0hiUTkyMnU2clhPaHlkQ09JUzNVOFVwOHk3OXo1S1JsMS9MWDZEdGt2XHJcbiAgZmJyTXVmT1RjdWpsLzlKVCtyWmdFelVmRGhPRGhKenEyZnJlbXVUaVR4OG4xMzNMZHdHTXd4OXVmMEN1dXZJQ2k0TTg0NGkvT3dUa1xyXG4gIEdzcWc3MEMzc0R1NDQ4NEg1U3RYNEIyNkswQ2tkcWNiQ0gyZ0RBZyt4RU41VElTeHh0b1hpTjlQaUhlL1I1NHA0eTdrUC83RUszTG1cclxuICBHWGg5K0w5RGR0NWttd0IzdERyaDJoMGt2NXpkUUgzZGZFbk56YkNqQi9BbCs4OXVvT3M1aUVjZjdCRVZNalBENmxKQVEvMUhiTVhYXHJcbiAgdyt6RGR1L1R2OHo4eUdtaXhuZHRXbVFLZEVkOFpCRnFLb3FIME01NUFWTXFNNU1objhHTWVNWUpDcTNvVEpzWmtNYk56VFo1VnQvclxyXG4gIHh1TzJPanFLRjBadVFrQ1lXeUkvUDE3V0VYem1qQnRsZVBsUUtTN0l0UWVjbTVXdHlLQlpLaXFxcExRUmQ4bEtJUFNQZWowUEFnMmpcclxuICBBNE1BWk5OZHlrZm4xcngycHpUV2JqYnVnK3pSeDM4dEVnbDRPZjdZekluOUdScXFWOXVPZUN1ZXU4V2VnN1huL3pvRExyUDlTaXFYXHJcbiAgdm1KYnpzNjk1L05kaUlkKzA0WkUxbjRJVzRzYmZRZERLdFhWc3ExaXZSTFNZZG9YSmdkd0g2OFo4Z1ZwdFRVM1NOMWEvM2h6UzBjYVxyXG4gIEVvTGpBeUFlckZ0QUxNSzZEWnhRenIzcjgyYkpoU1VPU0JIQ0FZQXNQMkxHYlNtUlE3NzBGN00yUWp5R25EeDk2VDB5TkcyTnZQbXRcclxuICBVanRxYTJ0azU0NDZhVzFwVWVTdENGenI3RlIydjJMRGNzR1JzNUo4U1ZVdW1PSFkzTndtelkxdGhyQ2JtOXFsdnFaS09hTjEwbGhYXHJcbiAgS1IxTjJ5VkRMMHI1Y0lSMGJsNUc0c2pKVFplV3BpYXBVL1lmRVFENkw5cmphTkdqWGR2ZHZHYU5sZTNYcjQrc2ZlRm1KZVRuR1dmeVxyXG4gIDJ0Zjd5dG9YZnlvNzE3eGlyNDR2cEZucjRCT1c4dVJ0MkxqQjdoK1Q0b0wrZzZUeXJUdnQyUVRpVWJIb1JRdFJraC9GYW5ZRmlERFBcclxuICBsMVh0Z1JPQlNNejgyck95bVUya0FHMGNsejZzYTRGREFYaEhMVHZETnRPOHo5bGF6RGtSM3MwYnZ6bkozTUlIQ0p4SXVibmpGeE5mXHJcbiAgSWZLeWphbVV3SnNGWkRRbXg1endOZU9BOHdlTTAyL3ZiVG5zaWtkdGpOcWdpc3F3OEhGQTY0ZXladTA2T1hELzRYTElZWTdNdWdNNlxyXG4gIGlnQnhaTnNieEJFdnNLZnRXMmtqRUkvUVh0aXpmSGVjQ3hDUWZDQWVJUjdnNVZmbVJMRzlBL1hSb1FCaGJVZ0lmMzhiVWd4SjdPTWVcclxuICA4aGNzMkR2SHNLK0FtSXh4dUdhTm0xM3ZEc0wzdUUrUUZpSC8zb0JYYjc4ZTZRcXh2Tm9PVCt3c2Rydmwrb3JscGdjQjBmamlRZjJBXHJcbiAgMnNOZ1FYd1ZMV0xVYXVhMjNlSzA0UWpTd2ROK0FIckdQZ3gzem9iOG5qd1FYcEQ1TTdENVVKZ2RWZW5NTlF6d1VEZHhqU2dPMFRIUlxyXG4gIGp4S0pMUXVlMERNZ1Y4cmc0SkY5c2FQKzZIbnE1Qjd6U3hrN2Rxd3A1dkRjaTk2QWg3MWt5UkpwZnRuMzRnaHQ5eDd5cno5NjJDWmJcclxuICBJUThpcFpIVnluR3dNQXpscUowQXJMalhzVFkwWFBuQ3I4M0ozWmlUdm1ubjhuV21QL2JrNjYwczdiTjk2ZUhYUGl2VnE5NlVuUnMrXHJcbiAgMUdmZlp0eFZWTUE4dGNKMTRYUnY0clZ6WkV0bHRSVGtzNGNLQkFSNTZVNHBhbDFqNHJqK1k0OHg0akYwK3VkbDVMRSs2MklyVmZZcVxyXG4gIG9RS0w5NXp6NkV3UUQ0ak1tdGYrYU1nT2YweEhmdnRWV2YzcW5XWldhek5xUlg3VTQzcDlCdzZSNFFjZktXbWJYcFMzYnlpVjlTL2RcclxuICBMQ3Z2LzZ4aWc1ZGs4ZUtQWk83OEQ2VlMrMWRWVlMwMTIycVZZTmRJcStrK0ZPa3Jyc25KVEZHazNDbHRpc3c3dFVHYzFEZGlGTkNtXHJcbiAgczE4bEpxQWpuZmhMbGhJWTVqZDYyL1lSY1orMFlmTmpmWkhvQVNIc1RZMUtjUFJvYTJsWFFxVkVMSnNOcTV5Z1pPV2tXNWhOeHlOb1xyXG4gIDBuWWdLTnUxYngyTkRYWU9PelhTZ2RDa3RYVkl1aDVVZytpMVJubVoyckhsVDkwb0w5MHdWbGJkZTU0YytlT0ZrdE95MFY3M3dvZXVcclxuICBsd0VUVDdEbk5mN01INWpJangwWGZjOXdrY2N2eit0QlJJWk1POS9FWGdBZWJuMk5raWpIOGlQbi91QVNJNExTcVErTFJaT01LUk5uXHJcbiAgS2JmQ3drUFM2SE9DUzNoZU1zNDFhVCt2ZitRYmEvUk1xZnJvWlQrdnp3elg3KzRHZjdsTk1wQTZJTXFpcm8xM0xiZnpwYXZsZy9uelxyXG4gIEpETzFRdzZkdko4aDA3QUZiUnd1dit4OFE5THhJeURUN3NDNUFNUVBQSEJzb2s1M0NNZ2ZDTzFsMllUWC9WLzFWaWNBNTBKOTZoSnZcclxuICBiWFY4dGlmaTB4c0VBaG5xaGZDZ0ExM00rOUxMdmhsZnlBOTdoWHdjY05IbmZGMFllNlh2Q2Y0ckFxTGZoQUxEWWw4aFdYYm1vT1JxXHJcbiAgeWI2NStZbFRtSDhDVGJVYjlOY3prWnNEemJ1cTNQcEs4L25idWRrVnp3N3hVTStTcjBjSVBWKy9XSTJqcUxZVnNhbHAvNCs5dHdDc1xyXG4gIDR1ajYvMDlJUWhJOHVMdDcwVks4UWt1RitsTjNkMy9xTGRUZDNkM2RIV2loaFFKRmlydDdJQVNpaFBDZno1azk5KzY5M09COTN1ZjlcclxuICB2Zjh2YkhaMmQzWjI3KzdzT1hOMDFBYUNCd21qb3hxdDNFallIU2Zua2RZUG5SdlRqaE90bVorZGoySGxwQzgweGZ6eVNaOXBuYnBkXHJcbiAgai9NTUpLalBQejNIbFplbHRKWEttWm1TbnA2cVJLaFNwUXlkMUdqUzVDbVM4MDEwcmd4YjBGLzdWeExzY3g4YzExZzU2WE8zR2RzMlxyXG4gIHN3b0MwcHBnRUcvdVJuWjZ6M3BjRDJrcTlBUHZudVUzZzMyNFVQb052OHorOW41WjVaZ1Fhb2htZzY2VzFWTy9rMWFIM2VRTytlUE1cclxuICA0Y0VJRkFKU2tMTkMwNVlRaFovcUtETE9UUkM1dno4anJzTVJFL2UrSURybGEzcURORFlOVkNoY2l2Z0kwOHRqeHpEbUFWSHpoQ3BKXHJcbiAgYXJZN1FCYU5lczFKVXBmS2loR1BTYjBxVytXTDgxTmsvdmQzeVpnbkJqbUo0dzc1ZHRnQk1uM0M3N0ppNVZySjI1VHZwSXlOc25yTlxyXG4gIEJrZkFpL1hKOGNtaENTSGxDaGNyNjNZNnVpNUpibDlCMFZZcGNtc1lBZWxuNk01cE9QeTVOZENmN0ZyWm9xMmtxQnFLdUtFNlhRNlhcclxuICA1dnVmSlRXYWQ1Skc3WHRMN1RxMXBGN2RtdEtvZmgxcDNMQ2UxSFBieVNuZVVKK2E1TjUxU1lya084SmY0SmJOakJ4Y2MzNUdGWCt0XHJcbiAgRXBpUHV6NUxpYnZCMUlEcEpEblJobjNjZTRxcm1PWVdWNVJDOXdmbWtxSVB2RVFXekZzZ1gxeGNVMHFXL3lIRjA5K1dhcTM2UnBndFxyXG4gIDYycnVPV01Yb1Q4Z1Zlem5pTG94RVZMUHdFU0tpL0wwZlpDT0g4TTU3MERWVWc2Y3d6WnpzTERPbW1QT0Q3NC9HaE1COWJzZHA1SHFcclxuICBtbFBMZ1Q2S0srK2tOeTlXT3dnL0dMVWxBelorT3krSlhGbEVwSmNwVzA2V1QvU3ExTW52K2tTYW15YytLWE5tVHBPNjlXckt4Mi9kXHJcbiAgTFZkZWM4NTJDYllSYVJZOGtyWkhwS2xyaFAySko5OVdGOWtScFVTbUcrT0lFR2UzNWx4Y1hPMVlJbEFQVU1mT1RVMU4xV2xnclkyZFxyXG4gIGxVU2VlTUpMR25aZS9EcDhiN1ptLzk3QWZyMThickJISDJjbTA5S3hReHNJd0E0Q3FqVHBMNXMxdFhzQS84VXBmTW45amV5aUVHeTRcclxuICBWYmZNTlRMaXI4bTYyYlJXVFZsVHdlZGN5bDAxeHhIa1Z1ck5WTUdOZkpWSWFydEptdnVLRDVpeXQzM1UxZzdNMEZEWE90cDNQZEtWXHJcbiAgL1Rwc0EvRnI5UzFIWmVPMk1aamo5cWwxMk01YXJBbnhmRjEvcnAybjI2N01OZkM4cXROcGlQckpFMVRGY1JMVGtWYkQ3c0hxaGlQUFxyXG4gIFdhTmlxREQzZVRkQ251Wkc2N2xxTnloeUZBS0hoR2JOR2t1dDQ5NEo2dnJJN1NhYVJ0MXZzMTQ0NGxrM21yL1VsZTAzbGxIcGd6VGtcclxuICBLVTZ5UWcyUTdrYVE1RUxTSVROUFVNOWxVcWlITlZXM0x6L2l5dGU2NDdUQlUvYjFabjE3bnlNQU53clpXZ25raWpJUGR3L3VMMU9pXHJcbiAgVm5LU0gzbWZZQ1NheVhqdWF6SmwyblRKemZNem9tV2tsM1ZFbGVsVnoxU21BRWo3VFZRM05oZlZyVHNwQWpzT3pNVjA4cXpuZjgrVVxyXG4gIHE0N0dKcGZSVVR5Ni8yTFh4eklxVjVlTmExWm8xbU02YUlvanJzV0lFdzZNL3JFTGJDN1lyT29wUUhKa1RGR09qMGhLUmlWSkxpbVNcclxuICBqTlFTRFVoRGRjVjgwMVVxVnBCMmJWcEtyUk5lbCtRYTdTUnZ6Zy9MeHp4MVlsMTA3NjBPdTA3S09VbXY2ajZ4ZXUrdHhmbDRDTWlhXHJcbiAgaFc3dzR0WWxHeFpLY3ZWWWJ4cThCWEhqRGFONDNyZXl0VUlEbWZ2YThZNTRySGRNTGt0cVZxc3E1U3BXbE9VcnZCMlEzNXRjdGx4SlxyXG4gIFFlNm1NcW51OS9IYkFkSUlnTUhCU0dBb3ZBdCtmU3EvczF5cTF1RnRjd2JyT28wYlNVWm54K1Fjd2NjdUF1c2hpd09xUHdZdlBNTlJcclxuICBEdytTbzE4czlNL2ZNWGJlQzNFc3ZGTTg2VWdIejdOcmZzRGxlb3hKMjNUS1o0VW5FNmd5YVhER1YzZXFOeG94TlFBMUl2M0cyME5FXHJcbiAgUmo4MldNdFYzYUNMYzNIS2FEbllTYjd1WERRQms5NjgwUFhaVTkwUjJ0M3FwSkVDcVZwMm84ejQ3bUgzR3pmTHM0OWNMYitQUjdMM1xyXG4gIFJEeE1QTU1JRTFRaXdzbGpWUnJpaWFzL2I3eGJienR5dDNhUkhsQVZVVGJiQm9pL2p6RHNPblpmNFhYWVBySWpNTlV0azAwQk96ODNcclxuICBOMDhERmg5M3pPV0t5MC9kcHYxUFAvdEpqajdLYk5XN2o0a1RaMGlYSHY5U3FXYkV6MHljbHhqMHZaMkdONFFGb0VmSFl6djdqSG1BXHJcbiAgV1VzQ3NjaU54bjMrSlc5UEFGNGRSRjhNTlViWnRpUDdXY2VXalhDeXJKL1BTL1RCZFd4aisxQzNSRmZHT3dTdkgxdzNWWDNGK2NGNVxyXG4gIDRiTDdvLzlxZHpwQ3QxUEtscGVOWkFsMlpSaEtSUFVWcXF1UDFHM2JmcUtRMTlYOWw5U3IzMERLdXVFdTZnK1lpUHZwTW52dVFpa1lcclxuICBmcW1leGZsTitsMm9zL1RSenBLeDcwVGIxaFcxL0JYWXg0ZnM1NmNXcjN1MjQ4RTVUQk9yek1QdHcrN1JJc1E4ZkQzUlNZOWdIbXd6XHJcbiAgd1k5Q2o1Y0o5TkpKbXRNSy8vN1Jqd3hTVjlDbUF5NlVHb1B1ZFFSY3hWRUZSdlV0VzRvMVJnWWdYYXllL29NeUQxRGttQ2lFRE9hQlxyXG4gIGdiUm11NFBrNzN1YWJzTThZQktzazV3TWtMZHVwVzRuT2M1UXhpM0Z4YVNLd2RFQjV1cUpMOGtGTTZ0V2t2cjFxMHRLZXJvVU91YlJcclxuICBxR0Z0T2ZDOCs2VkR4dzV1Uko4aGE3TTNTcTlyZnBEajN5aVJnNTdPa2ZJSDNyMWsxSXVYeXNoN0JrcHVjVnJkL1I5Zkp3YzhrUzMxXHJcbiAgRDdsRnFuWTUwYjNUa1RMQ0hSdjc3Q202bnY3bEE3SmlwcE5lM1VXVDNQdUg4YVJYclN2cG1jR2MvRzdadUdxMlRQdDBtQzZjd3pKclxyXG4gIHlwK1N2UzVMMmx3L1EzcmZ2MUtPZm1XejlINXdsYVIzT0UzeThyWklrMEUzeStIM1Q1ZkRIbGxZNXJnM3RrcURCZzJWS1ZUTnJDSHRcclxuICAycmFVOXUxYVNmbEtGVlFpUVRKSlRuTURHbmM1cEJGK094SkxNa3pWN1lPSHJseTBTRllPZjBSbXZuS2NyQjErbDZUUGVVMlMweXZJXHJcbiAgMmpsNDFmbGJiWFA0VFZIbTdkNFJrZ2oyUnR6UnFjUDNYYmxCWjgza3k3R1M0czJ1SDZIS3dzV1hGckNQa05uWDl3dVlEUm1YZ1RxU1xyXG4gIFVJZUdIRnE3Z1FpMkVkS2g0TzVMdXBPc09kNzdqMmZaK2JUblZCWE1JSWhlVFpEbmlGZXVjb09STXNvOERqcDBvQnFmd3dackNDUnBcclxuICBSc0l3UXN5SS80MDN2OUF5eEpRbEh0UWxMc1BLbnVqaXZiU3RGR0xIeDQ3OU8wWWFZWC9seWhVVHRtL3c3ZnJ6N1Z6YmpqTER4SkpQXHJcbiAgR0RBUHU0NjE4OUREcittNmMrRFdheW5sN2ZqZmY4L1I5WjVpbjMwWXpEc205dXYyNzNPWEdFamxzaWFJeDhKM0dmODNpdEIycUlnM1xyXG4gIHltRUQwWG02VWVxYXVickcwNHJjVjFTenVCREF5RWc3blB0YnVIR1ZLd1lOc2RiRmx5T0VOb1FNOTVGekhMZFMxRmJZUHRZdmNnL0RcclxuICBVVzVHUmhoeWFibDhkVngzR1cxclk3NjlVSm1GK1RWWWIxb3ozMGxGczlUWVMrNG1nZ2h6bHMvdzlZTzZyRnhCdGpCeWN4dTQ3WktoXHJcbiAgdHRMQlQ4dSt2UWVvL1dDTEcxSnE0THVyUzNUdG1xKzhyLzZDWDUvblZGazYvZ1BOcGNUeHBnTXY4ZTBIMTBCMTFjeU5FUDAxL2JYc1xyXG4gIFdIaWJDUDdJZmkzWmNiOExIVGFaVVlraW52L3pFMnI0YkhYNHpWb1RtRzFsNXRkM3VkRmxpV01HaHdjTUlVbG1UeDZsREFUbkplZ0dcclxuICByQ1F2TDAvalRCaTVNa2YzMHJIdmFmbjd5OU5sNGl1bnlvU25ENVp2TGttVGFXK2ZKMzgrTmxBV0xscWlvMmRqSGpBR0pBeVl4ZVlDXHJcbiAgeHh4Y21kSDIxaTF1ZE9xWWJWclpER25XcUlGVXlDZ3ZhYWxsbldTU0lrYyt2VkphSDNHekxGNjZWaXBVclNkSFhmdXlkTHRydVl6L1xyXG4gIDRUMFpOMjZjZEx6d00yVWNOZHIwbDNtZjNMQWV3bDYwTmIxQi81dUhDMHVOdHYwRGhyRy9qTGg3b0t5WjRWVTFBOXl4bmhlL3JldDJcclxuICB4OXp1R09nUjJvWXRGV3UzVUdacDI3VTdETko2TEp4ajUvRW9ZU3BmWGxaWDE0REVpc2UvdmtXanptZjk5cDVNK2ZRZWxZeTdERjBnXHJcbiAgTUpKSzNjK1hhZE5uUzBuTGsrU2dwelpLNDhZTjNTaTRSTGFVYkpXeWptbFVxVkpKeXJwM2k0cU1aOFNRanE4U0tTVS9KMGV5MXF5VlxyXG4gIFZVdVd5cmcveHNxczk2K1ZXWi9jTEF2ZlBVMlpkNldHblZSQ2dZbXc1djAwNlgrZWtHc080M3ZydzI3UVlGTlRaOEZFaU1YUjZZUWRcclxuICAyQTlESVppVmIwNjl0Wmc4TE9oWDJRdi9sT1VUSFJGM3gxQmZzYnU0SUVlVExtSVkxK2tEdEQrNnhhMlpIMlZMTVhuSzNMa2picGRxXHJcbiAgMVNyTEUzZGZwTXpERUNiVWxPZlBSOVVkQzdMSEFvaHpQTUdOUi9mdTdTUEhVRkdDN3QwVHgyZFFqeUMrc05SQis2UXJLYTE5UUQzUVxyXG4gIHFsV1R5TG1jeHpsMnJEVFZXV213ZG14dGVPVFIxM1VkdWNkK3NjZjNCTVNlNkx2SjlubndFbUdYR0VpcVJPY3MzeFYwcmJwV3FrQU5cclxuICBIRW9jUWZoanBaOG9LaVhEcjNVT0VEMmNwRVpjMWt6Z1E4ZjJTSkpLOVRvR1ZTQ0Z2cTBJWVZYNGNwU1pPQ2xrbnArcTFTYTd5V3pjXHJcbiAgUTNXL0hMT1oxTHkrM3ArajU4YVZTZE5CUmxPOFZEQkExKzF5dEtvSUNIWkRXaUlkdU5ZUC90bTV5Ly82UkpnWEE0Tnl3MTZlUVNTMVxyXG4gIE9WM2FIM21idEd6ZFVzcWltM0NFRVQzc3RMOW55ZDh2SFMxTmVwMm9iZUFSVnFVUmFrUGZuaTM4d3c1RGVmNElmTjY5VjRzZTE2UFVcclxuICBFMW40NjRzNkRTdGxwaFJWMVFFYmV0eEhwQlBVR0ZTWDRzSmNuWVhPdzlzOUlBNHdEMGFhR05vMTRGRnJvNDlmNTBaeTVTWFY5UzZJXHJcbiAgTzlpVWxTMHJYdTZwYnFCekhtc3Z6U3B2a3JHUEhxZ0RCbk9UM2VLa0NEcGtVWDZ4RWtVNEVBYm9MYTdNUG1NZS9KenFWU3RLYWxxR1xyXG4gIHRHblZVaG8wN3l3SDN2U1QxRHpxT2FuWjcwcXBmOEMvNWJEbkMyVDBreWZJNk5ldjF6aU1BZmZNa2RuekZzdEhwNWVSbW0wR1JCakhcclxuICBwQmRPM29pMFVhbnQ0RXdJdXpJTnh5aGdHQ1B1OWhOZEdkRTNobUNBY2U0SmFBdEdjc1JUeTNVTkUvbDU2TDRSWnRMT01aSE9KejhzXHJcbiAgaTBlK0xEOWV6OFJpMDVXeHdFaG1mbkdQelA3ZzZ1eHVkeXpTN1phSDNhWVNTbzhieDh2Z1ovT2ticjA2K3J5UVJDcldxQzFiWFgvYVxyXG4gIDR2b1NueGtTQ1UrY3UyZTlmUEVTK2ZIYVJqTHBLZGQzZjdyUzdVRnBKT3JXSHJ4U1pTallSNWlhbDNlb2RrajNJb3lKNUs2ZHI0eWtcclxuICBnZXZMcE83blJJN1JGN3p0emtubG5ZOTAzKzFVYlk5ejk3dnlXNVZDWUNhc1d4NTZnNjY1SnBjbEM4TEtxZC9JOG0rdWxkbXpaa3EvXHJcbiAgUGwza3QzRStYMWdZRUY0SXNCRmZZeElHVXA4RGpsc2RwSVRTWU1SMjMzMjlrNEZKSmZHZ0hpb3gyZ3d6cHVyVk03Y2g1R0ZRbjdreVxyXG4gIHlwZlBpTndQNTRYUEdaQkFiYlk5MkQzRXIrUHZZMi9HZzNSbzcrZGUycDUzMXk0eEVFMHhvb1hJbjFJUUhBdFdqRTZ6TjlObFJlcFVcclxuICA5d25qUEtHRWlFVlR0dVBSb1NuRzNYbGxOSkRRd1cza1lEejNHOEVhaE1xdVRwaHhFQjJNNUdIZUhSandVR0Z4Q2xOaEVuR09GTEoyXHJcbiAgSm1uYkEzc0RCNjBkTGJNWlZWOVZxdFBhTVJFZVpKTEdTeWp6VUZkalg5MHZrWUw3MEU1MWpPTTAzNTViTmpncEpBdHZtL1RHVW52UVxyXG4gIFBWS3pwbWVPdWJsRmtwNmVJdXRXTDVWcHJ4MG5UUVpjSkhXN0hhdjVvamlQMXF4Ti9wTVdoTDJOK3B5clJ4YnIzT0RCYndpdXo2aFBcclxuICBLN093MHJYZjV0L01yKzdVbE54em5QU0J6V1B1Ti9jNjZRTUc0dHNoaFR5QWVZeDY1Q0EzTXIzWmpmUnYxWDJvT1lndXIxV3JsbzU2XHJcbiAgOFE2Q0Y0SkpZOGJMZkRlU25UTjFwdncxY2FMcTlCa3dRT2hnSkl5WVlSQnVseEkrR0VxS3E0TXFwbnJWS2xLbFlxWlVxbFJSOWgvUVxyXG4gIFQyclhyaWVORHJ0VE5qYy9RYnI4ZTV6TS92TTdXVGR2ckNQS0E2Uit6eE0wK0E4Yy8zcUpWS3paWEViY2l3UXhRaGtIUkhqaER3K3RcclxuICBobkhVNjNkQlJaVTJIREdIY2Z4Ni84RjYzb0NiUjBTWVJtbFF1OVplQkV6a2dHRmpJc3drTEpVTXVuK0dadStkK2lGU29NZ3hyeFpLXHJcbiAgY1dybEtoK2Q3aGo2Ui8vT2F1UE9JWGJrKyt0YmFzeElyM3VXUzlNbVRhUldqYnJTK1pSbnBjKzVMMHFsS3RXa3J0dlh0MzlmcVZ5alxyXG4gIHV0UnRXRi9TM2ZQazlmQkxlRjh6Sms2U1daOFBsYkVQREpDaUtTL0p5cisvVTZjRzFMb1kxVEdvbzI0a2NTV1I0dlFiM0xBSm9NVnVcclxuICA0dE9jMEVlOFhwdytybXBvZDVHQ0RhczBrU0x6blJpNHJucXR1WFpRWmMzNjhrNjNKK2lMYmwvTzFFOWwrZklWVXFkV2RibjZraFBrXHJcbiAgd1AyRC9GZ0JJSlFReVREaGpCLzlzdzl2UndNT0ZyMzM4emJXZUR6NDBLdGFuOVR1TzRKZEU5ZzFUdys4azhMSEVvRXBkY25NYTdEZlxyXG4gIEFQenYyRGtHRW54YXBjTGEzTkg5N0E0c3BtUkM2SGZFWTljWVNNbTJFb2ovZ2U3dmRuN3BPQ2VTRzhoUUNZajUwS0JCaHdxMXZiN05cclxuICBqMnhBa25ydHNHWi9Xa1VDQiswYXJPbDhGSDBuREE3NHRkdldkTzJ1ckluMTNEWWpJTXZQdzZqSjEzY2RtclFnV3VZMGF5ZmE1dWI4XHJcbiAgalQ1SzNwVmhIcWphVkgyMVlKeDZoNUcyZyt2eEwzSmVzUENQYVVPUllNZ2x0SEc1OTlUQ0psSlN2bzQwUE81RmFkeTRqa29pQlc3MFxyXG4gIHpYQXhkK01tV2ZJMm83Z1o2cUpMbTc2OXFJcU52K3dqd0EzcHc0OFUyUW1JKzNoWUd1N25KUjZWUGc2NTNwWDlhNllwMUFnYVJPWTJcclxuICBPQTBYVERXYzB6WVZITWpQQmNPQTBlRGs0T0VaRDRTRE9TWFNCejZvZTBzS3ZSV2JuZ0Zqd09tSVphdGpGZ1NnNG9KS3RsQmNaeGwrXHJcbiAgSUl5a3BUdkdVckpWeXFVbVM4M3FkV1hBTlY5SzlYNVhTRW0xZG5MZ0V4c2txOUVwVXVYUXgxVS9EelBBczRqK1FobjhjR05iOVRnYVxyXG4gIDRDUVBpUEJYVnpXUU9wME9WWWFRTS9QN0pSODZLYVI4dys0MWpYSE0vZUVwbFRoQXYrdC9VQ2IwUHcyWVNEd2pRU0xwY1B6ZE1zdHRcclxuICB6M1NMU1NNclo0K3JCdFBZOStUYlo3TTkvYk9oeWtRNjNUcFBEZWN6djMvU2lkZk5aZUREcTJSajJVYXlPdk1BNmYvZ0dza3IxMXdhXHJcbiAgRGI1ZDlyMWhoTlJxMkVCVmhzcjAzZnRCT2xrd2U2Nk1mM1N3ZkhXMkd5Q3QvRkt5WnYrbUM2aGN2NzBPbmxCejRRYk9nQW03Q2YyR1xyXG4gIDlPcytnNitQVWFyU3NJc2JtRTFoVTNOYndYeDB3OVh0NWFRUVA3ZUlhSllETWpHVHlaaGpXUjhkSTV2eUN5UzF6RmE1NGVwVEpNOUpcclxuICBveERDZUFaaDJ4ekRDTTFjNFBFNDUyeThDNzNPL3NRVEJxdXFLaEY2QlBzWG14MTJCN0JyMjBnL2JLUTM0cDBJeEprWVVlZWVLY2VyXHJcbiAgZ25hRzRDZXlnOFN2NDl1eC9ZYXNWWDdxOEYwRmM1bUFIMy95dHRaRTJDVUdrbHdRTzdGVTZYQ2R4eEFxWWdobHBBRjgxS2tvVWZaMVxyXG4gIGtyd25oMXVYRUl1Z3lSUDlmb3g4SGxFaTV3K0dGcmZmRHBFeWhDSlI0cWliSUpXNG4zcURING5rbk1Uaktxdmt3MGw2WXRCMnFNd2NcclxuICAwVXkyUTVrTXFuWDNjUjNlM1M5WlpIUGNCNVdtK2w5L2pyOHZycFNrTTc4eHBXdVZCcDNVT1FCLy9BYjdPcUlZVVFPNTM1cFJVeG9kXHJcbiAgODRLMGJ0bENSL0hzQllzV0xaYXNINjdWbE5lMDVkdGs1ZTBmek84QnlwYXJJcFBldmxpYUQ3cmExOURyaTh6OS9xR0k2bytFanhFRVxyXG4gIDl3Y0RRVjJGMU5FaWtENmFPd21EWXdEYmlFL0o3cGpOVjNkSjQ3NUlPclN2dTl6Mk9lcUF3QUpNK2lCRWlEY0tnUXBqQys2dGpqQndcclxuICByR0tOZXBKUm9aSWtwWlNYZ3k5L1d4b2Q5WkIwRzdaQWxzMzB2Nm4vRGNPVldTRGhvR0pVNWhFUTE4Nm5QYW5sa1U3U2dIRkFiRWM5XHJcbiAgaWlPRGt6cmVMSEVTMUhVeTU4TnJjNlo5KzB3RHRrM2lnSEV3dzZDWE5nWUVmZXkvQjRrWVNXdjMyMnJ2TTBRK2R0SUhqN2YvVFQ0d1xyXG4gIDhKVi9KYlVzWDdSeUtVeUUzODJ6NEJrUlJUN3RFNEl1UjZvNmoyTTh4d0h1ZVpLa2xPMG1KNzhwVFk4Y0tvZmQ5YnUrSXo1OEZoVEdcclxuICBNUHdKbzMrWCtaL2ZLbk0vdTFYR09PbUVkN0J4K1RSVlp3RXlIcURLQXN6QmowZml6Syt3amVCUWNyZ0dmcUwyWkRJb0hEdzBOa1Q3XHJcbiAgRFVHNE5XU3JXL05ia1B6SkNwMzc1WWt5Yjk0OGFWQ25tdXpicmEzMDJMZExoUEFOUFBCc1hSc2czdmZjKzZJU1NzcGtLbzZIcWFHWVxyXG4gIHg4UFNmaVNDRWZWV0xXTzk1a3FETVk1NFp2SGpUejZ3c0RRUTZRNzRUZFlHOWl0akp0ekR6dHBCV3JmMmJ2SFdUdnphbnR1bzBRUXBcclxuICBpekNUb1dIeXhPbFNyVmFJRHV3Q09uUm9xZStNUkpXbFlaY1lTRTZ1RzFIaVFMOWRCQzgzZGlXcHhadWxRbHFLNnZ6WlJ3UXhuY3VrXHJcbiAgRUVDNmMvb0d3WVVlYnNQOXg0M1VsemtUc0hZZDBxK0MzY0UrOTQ5OFVHVDhaRTl5V25rMUVMTy9ZcEFTcFdici9UVVpuYzRDU0MwYVxyXG4gIENOb0lNeEVpcE5YcnlwVkpGTWordWwyT2RTT3N2Mk5zSHh4UDRsRUc1MktnWjg0UFBGckl0c3B2dFhaWitiVmpsT1ZxU2JWajNuRk1cclxuICB0WTZVZDRRMUw0L1U2WTQ0ckZ3bE9SUGZsUFVmL3l2U3BrYWJ1MGZ2OWRha1puOVVPcC82ckNzRzEzVjNvRUdEQjEvckNJWWY0VFhxXHJcbiAgNHo1RWxUNzhmWkp1MjBzZmJwY0RPdStXS24xUTNiZmhqemxHNHhnTGJ4cHBBK0RpU1JrOXVIcFUxV2pxUnB1QlN0TUJScUl0cEpaUlxyXG4gIE45TmtnaS9jcGJGdlZLMWNTUnJVclMzN0hIbU4xQjk0bFJ6MlpMYk1ualZkNHoxRzNqZFEyMk9CNk5FdStiTEN6TVBLU2hRZGdVVGxcclxuICBnc29xdFZ3bFpReUZTLzljOU9GcFphUksreU1xOWJyNmN5bklYaG1ST0tKcUt2MWg3bkV3RHYvdlF6d2p5V3k4ajBvZk0vamRidUVaXHJcbiAgOUxqb0hYbjkzRHIxRjR4OFJZNjRZL2hzR0tJeEVTYlJtdjNOUThwRU9wNzhpQ3dkOTVFK0x5UTFHQWdMOVdhUCswRU9mR0MrN0h2OVxyXG4gIENPbllvNnRLaFVWeG4zU3llMVRUWGo1R1ZuMXhnZHBHa0VMcytlbkF3UldUVXpMY3MwejFXUjdjRHV4MnFEdlZ6ZGR0a3dIQ2JFamRcclxuICB6bjFUWmdjTUJTbWtTYlV0R2xCYnFVS2FQUGZZTmZMY2MwUGw3WGUvamhERTRUKzlFak9xaHVEMjNxK3pFc3FLRmN0SENIQWkwQVpaXHJcbiAgc2JjSDJnbm5xVElieXZhOHNhd3VESURaQ3N1bStzREMwbURuY1Q5V2Z2YTU5eU8va1gxVzNoR2VmOTVuRGJBSnFVeGRSeHZBMnVuVFxyXG4gIDI2dnQycmJ4RTNGTi8zdVd1OC9vTjdvN3dONnp2V0JDZjBjN2lkU2tJc0hKMGpyVHpzSFgzWnppZytuOFEzQ01vN3hQNDR3S2hob0VcclxuICBvZmtScyt1TXdUd1M3TjhZVE1MRWhyYmt5a2JyL0IrL2FHMTN3SS9RZy8xdW0weThQcURKRWV5aVBEK2kwZ2FBcitPdlJObnY0eCtxXHJcbiAgSjhxa0xWa3g2WFBIYkpyTGlyOCtkZmU1VnBtQ3FxUTRnZk5wTDlRT3M4NWhtOER1Z2ZwcStjVFBBcnVDUHg1ZWtKQ2FudldsZEx2b1xyXG4gIEV6ZHlxQzFidG15VnZQd2lKKzV1bEtsVHA4cnFkOGc0U2wyUjVnZGRvV1VZZ1NaQ2pQd09oMGdSQm5hQSsrdDJCTWV0R3ZOUEkzM01cclxuICBVZW5qWmlkOTNLTnJaVUlPSk0vRDdyRnMvSWRPQ3R5c1pZVnJnRzJZUjVzaHQ4bVVlNXJKdEZmUGxLMzV4VHFhMWZmcW1BWk1CTlhWXHJcbiAgMXFJU1NVdEtsa3FWSzB1ekpvMmtTcjhySmFucElWS2w5eFhLbEFoeUl3T3RKM0JEbGJnUkoxSzVZV2ROU2xrYTg4RGVBZVArOEl3eVxyXG4gIEtrMzB2T2d0bWYvVm5XditlUDM2UmlaMVRQdUVhVjd2aVRBT3BOblF3OWt4cUxxcnkxNEVUS1RSZnQ2Rm1MYXhqeEJiaEVxclVhK1RcclxuICBsS2xNZVBrY0dmUHVzSmE5VDc0OWhvbGtOdW5tbnRWUWpjOGdZU01lalR5MzNsZVFPY0U5ZDU2M3E3Zm85emVrWU1NS2FYVFJlR25tXHJcbiAgcEpLalg5MHE3YnAya1NxMWE2czB3anZOeVZvbkMyZk5rcitlUFZ4bXZIYWNMSDJocHpKNTljUkNBcDA5UWxXZnBGOEgyTlJxQmlwaFxyXG4gIEpIMitZZlc2MG9HVkp6VHIzZUJuM1p6ZlpPcWZZNlFvYjZNOGZmOWxjdUFoQTlSYmlma25iQ1ROdlZyWllNU1NpWnRBL0hHRDFUT0NcclxuICBud2lXR05IYWVQNEZUNkJMa3dobzArcENySm1EbkgxaHhsSWErdmIxR1Rlb0QyRVAzOS9PMmtIc0hOcmlQQ1FEdTI3NCtsYVA5U3N2XHJcbiAgK2FTWmJkcjdoTFc3aTZaTmZFb1RKdFpLaEoxaUlHUGNpQUI5OXFJZ040dUJGNjEvZlNFaCtqYklrMnJwbmd1V3owaVRNU3VxeE5vL1xyXG4gIDZ2aTV6NHVaUkNab2lBeWxIbzdScUN1dkwwY0pKdXZRd242S0RreU5DVUZuL21rTTU2aVpjTGxscmdpOHZXbzQ2WVBLK1ZrTHRKNmRcclxuICBIeTZ6VkhkU0JQNzlsSm5BaWR4Y0ZldTExM3VubmtrZ2xIVUp6aVB4SWJQVVZYRVNDUHVyT0tMWXFQZlpLZzM0NnNad2ZNd0w3VEpEXHJcbiAgWWxLNW10TGhqRmNsdld4WmJaRmdvYzN1UzU0MWQ1NHNmbjJ3RzYzalBlT2xxM1h6LzlBSnNzTFNCLzgwWllsYmNwWk4wVVNMekxZWVxyXG4gIE9lN1dxWUdFUjRlWTVaZ0hCTUQvYnVEVzdqODJGRkp0TXdHV1NoL0JjVWFZcWZQZWw3RzMxcFZGQ3hicVBnTktJU0tsWVNUa09LdnZcclxuICBDRkcxNmpXbHo4UHJwUGEvWHBYV1I5NG1IWTYvenpHbVQ1V0EwU0xFRElJRTh5Q3JMaW5kTnl5ZXBNY3RGVHBxcWpEellQOFhsOWJVXHJcbiAgL1JEYStaL2V1S0d3cUtRR3pBSWdkZUNCdGMvcFRsb0xvRG5PRW9HYlNMVHNEaEsxdzdLYnFGQzd1VEpBbUNIU1NKdWpidFVNdlQvZFxyXG4gIGhnT0Z5UEdPaVN3YS9aYU1mbWRZeS82bjNiNDR6RVI0cGd0L2ZkV3QrMnN5Uko0djg5V3p2MzczNHlMUG5UVDY1TmF5NlBXQytrT2tcclxuICA5OTBycE5zMVAwbVhmWHRHQ0VQaHBrMnlZYzFhbVRNbnNJVzUvZ0FUSWVVSk1TR29yVFEyeE4wWmZYbldWM2ZxUHZ2OXZ2dVVrWDNKXHJcbiAgMWp2ekY4bWQrcTd1NzlTK21Sc3dSZzNmUTIrN1dOT1NBNGgxb3RFNXgzdjA2S0JFaytscDhYUktCTTR2amNHQTFxMzlDSjFyYk5xVVxyXG4gIEY3blc5anlqcU9PSmZwUUJnTzFkaDdvTW1LbHJxaXN3ZHV3VVhZTXdBeWdOZGw0aUZHL3hkaU1qOExRMythOXBUanBNa3JZZGZLeklcclxuICBucUJpUlo4RmV1NWNIL3dhajUxaUlCMjYrYkQyblVQb3kzRkZQTEFLQ3d2VkMyZGRicjRleGZXUGcyci9DS0F1dlhxcTY0aEJza0syXHJcbiAgdmYzRGx6MG9RQkI5MFhmUVlKLzd4NlEvWk1sTlRlZUgrd3BNVHFQdHVFMVQ3MVJ2UzdSbTBBNEh0S3diV3FZTjFpc21mYUV1dklCSlxyXG4gIGdTRDYyRCswdnZ0SEE1eW5aYmMwM1BjMFlWSWhSdE13ait3bGt5Vm5pZVh4OFhVOEhCT3EyMDRXakh4ZVowd2tSbVhlK0MrbFdmTldcclxuICBVcU54TzQwNFRVOHJLOFdGbTJYV3JEa3kraTYzNysrM2RaN3paZ2Rjb1hwa2E0ZDd3TE9NOHR6dkg5U1ltcGxmREpXcXpmSEZ0K3VSXHJcbiAgUXVRQVdUdDNsREpTZE5SUjI0ZVA5MERpcU4vdEJNZDhuZzVsNWhXWjhXQmJxYm4yVzVrelk1YXNYdW50VVVnY1p1OUE4aWlUWEVZNlxyXG4gIGR1NGdqUWJmSkIyR0xaYU1MbWNMODEwZ1dUQy9CUmx6NjNVL1JoYi8vcmJVN1hxMG5wZTNab0VTc05XdUR0UDBHdlBBbXdvbUFmRU1cclxuICBNdy9VVmdOdUdpNXRIZk9ZK1B4SitRV1NVUm52SkxOMW1OUlJYSkNyRGhEK3Q0WGdmK28ydS84eDdPSDFZSktBNTBEZzRvRjNqSmZ2XHJcbiAgcm11cFV0V2hEODNSNXpUeXpXRU5CNXgyKzhvd0U4RitFV1lvRTkrNnpBMGVLbWw5dGdHTWhkUW1QRi9BZXlDTGI1a3lLVkwvL0RFcVxyXG4gIG1UUnI2d1pOVmFzcWtjaGJ2MTYrUGpkSnhqODBRSlovZHE0c2VMYXJhaEZnMENyMXU5OVl0L05SeWp5WTE5Mll5K3h2SDlEMmkvNTZcclxuICBVbktYakplVml4Zko1NTg4S2tOdnYxVHV1dWNGUFFZZ2d0T20rN2d3UXp4eEpjRWhxZHNoMmhqSlRmVVVENGg5SWdhVUNCTW0rT20xXHJcbiAgL2JXMnl1clZsa1F5RnR3ZnNVL1VNNExPdXJUTXZNRHVQOHdRbVI2WHVVR3NqWjN0SE9HMndtdDdCa1NPZ3ptejVxdmIvT0tscTNSN1xyXG4gIFQyRnFzWG56dDQyL0FUdkZRTUxvVm1QSHFhM3RtYkRLemMyVmdvSVNTV0p5Z3dBV2ZCUzJmK0JWUkgwTWQ3Z0wyMk90Vkw5ajBCNS9cclxuICBJTlpCTWRqV2ZicnAvcnFGRWJycVhnUGl4OFEzbE8xZnpUYjdTNzRqWEp3WGFVeFh2Z3d6S0NuWnJFd00xMTNtL01DQURyUER4WkhnXHJcbiAgTzJwcS9hQmRmWXh1dGNHTi9GbVlONXBKZW5Tblc2Q3pXby82ZHA1YjFqdkpvMm4vaTZUSmdJdWxLZ2tISFdxZjlMNjBPK3NkcVZVdFxyXG4gIDB6SGVJaW1iNmwvUkpzZDgvM0lqMHBWZlhhVDJrQllIWDZQdEFQNU9lZThxTGVOYno1d1ArMTcyaFIzV2EvMDhyTE5qV0czVWxYTGlcclxuICBHK2RycExEZWk5NlhyMGRoeVpnM1ZGVmx0ZytaKzVsc3lDdVVxVk9ueFRBTUpGS1FsSklzelZzMjAxUW1qQkJKNWtkN1ZGM3lCNU1NXHJcbiAgZWVJRWdZTllvWjVoMGlUUXFPK1o3cmM4cmVWT0p6K3Mwa1k4OHpqNHZ1bWF1dHlZUjdQTy9XZi9kdjhncWQ1eFNFYmJvMi9Ua1RnVFxyXG4gIFFKa1VBbExTeXl2QlZBUS9NZm9iLzRld20vY0JFMm5TN3l5WjhxNVBnSG5JUTdQbHQvc1BVb21hNThIekd2SG1zTm93QzlsU2tNY3pcclxuICA0MWxXYjlsSC9uanFlR1VpekNuUFBPek5EN3hFc2h6alVIc0l6SU9BUXNkUW1oMTRxVDdyZlU1ejc4SmR3NkxWVXpxY0t4dlgrZmttXHJcbiAgc0dZRXIxK1dPcWtZQS9pTWx3NlQ1WitlclFNMDVnL2hYTlRGZjc5L2xaU3Iyc2hKS3YxVTliazFQMHRHdm5xTGJDMG9VS045aDY2ZFxyXG4gIGxBQ2VjZnFRR05YSW5EbCtsTXNqZ3NEZU5zejNqWGdZTWU3VnExTkNnM21VT0h2RVpOQUlnWHY0YlpUcld5R2lIRFpBaHdFQjd4MFFcclxuICBVMk1pUnRSTGc5VTU5NXhqSS9mMDBjYy95QzAzKzlUMC92ekU5MVlhN0xmYnVuNDk4dmlKckZ1L1FTWk5tQ3JqLzVvaDdUdTEwVG5oXHJcbiAgOXdac2JwQ1JwVVNrN3pRRHVmR0c4M1M5Y1dNMEtlSzIyUGJyUUFLQlRwVlBUNUdlN2IyNmlneWN3TnMvM0VGWHdTWjhDbnNPNFE3b1xyXG4gIFcvUmtPdnJIRml2Nk1ubXZqRUJ6SU5tTmp2QytVcmg5cEF4bmYzclYrcjRlSjd1MWJ6MTZIZ1oyTTU2VG80dTVNaWd6eHpSMVVGOVJcclxuICBVeEdjeXA4eVpWQ1hKRW50OW9NamswVmxOdHJIQndYYTlSUlc5a3hFaTA3azFNbWJ1Si9rTkdsMytzdlNvVTFMRGJqakphbXhzNmhZXHJcbiAgNWs0YUxrbUxQcE9TbFlHdHg5V2Y4NzFQMFk0dlA1SHhMUSs5MFczN3FVczVUclI1NTFPZTFveXJwR3NuOFdLcncvRzA0c0lpMy8yN1xyXG4gIGtiUTZGRnVJT01sbG1EUUxjbThWalg5Y1JyOTB2bXhhczBJS0hGUEZRRzZBbVRSdTFGaWxtQzJ0VDVHdVR1cElQK2tYZGZFRVNBd1FcclxuICBxWmFIWEtQRUJaVUtFd25OL09xKzRLcGVqVldwZm50SlpZSW94ekI0Vm9Cek9ZYkJuRG5JVWQzQVZGcnUwMy8yMTNjYzNMTDFrSnVsXHJcbiAgUWErVFZNV3phZFc4eUVpZE9BUUZQNFNMMklYKzIyRDN0cFAzVjY1NlErbDQwZ05PcXZBNWpuQlBIdldRVHhNREU4SHVNZStuWjZUL1xyXG4gIHJYK1VtL0g1WFZ0NWR1Mk92Vk05em5pdWVHYmxMSit1ejdURjRHdjFzdWE4d01iOG41N1M4c0xmWHBFTlRtS3VpZUhjdlFQNjdlRVBcclxuICB6WkxHclZwSmhjeE1QYS9Fdlhmc0pJVWJjbVROc3VXeWVNNWNXZnp4V1RMbjdWT2tlUGtZMTg1QWxUejhESS91VzZuZlFhWTg2Yi9CXHJcbiAgeno1K1JGS1NrM1d1OFdyVnFzZytuZHZJbzQ4eDBQSjQ2SUZyWWxROWVGdUZZeWtNUnBoWHJjcVNSbzNxQkh0anNabkoreDJvWitrL1xyXG4gIDRnRVJocGhmZHVrcDJxWVI1ZEx3d1lmZlJlNk5kdTArUENOSURPcVkrb2Q2U0N3bU5Yakd0WE9kb0xScllEOENTeFl1a3kzdU41OTBcclxuICBrczlObGxiV1I5bnZLVHlkOUpKVEl1dzBBeUg3S3ZoclZseEQyLzM5U2JKaHd3YlZqWmNrSlVkbVZmUDVyNklTQ0dvaEEwWnEzeWJNXHJcbiAgeEtjeVVlZ1BDVjNNRlNOTXdDMzhRMjFrd0UwNFBiT2U5MnQzOVh5QTFQNWF4cEFIWXBnSXhhQU12QnJOclowVXdsd1pHQjNyZFRzK1xyXG4gIHhuaXU1d1gvMkFkandYVVh3em1xcTBXL3Y2YkJXTjdsMWRmeTYyZ0pNSzhIYnJ2ZVk4cUJ0bXQwa0JxbmZTTk51aHlvYnI2TVU0cTNcclxuICBiSlZObS9KMVVxSkYzNUREaWphYzFOTHBjS25WOFZDcFVMTzV1d2VmR3lmNEdYcDg5cmYzYXBsVUk5ZzkvR3lQd0t1dUd2YzdUMzMxXHJcbiAgOGJUaU92anFaNzI2bi96NjFzMnlmdjE2MlpKU29wbGxNWkFqZlRScDFFeGFETGxORnF4Y0UwbWVxTUZqN2hoelkrZXVuaTg5TDNwSFxyXG4gIDk4LysvaEdwN3BqSG90Rk1tOXBYSmMwbUF5N3dJK05LTlhVRTNXTFE1VnAzL2FLSnlpaVFObFQ5MHFhL0VOTkJlZCtUYnAvOTAxUG5cclxuICB0b1J4bUxFY0dQTUE2VlhjYU14KytQOFdjTHM3ZWN2OWIveEpKcjlEVGpQUFJIN0YwTzZBVFdUaUc1ZTRaemxTam4xdGN4SU1CUWJRXHJcbiAgWXRBVmtyMTRrcGE3bmZ1S2tERVhGM2ZRUEVpM3I2b3M5M3dCRGlkRnVldDEvZzZjVFdENkN5WjhKOGx0VHBIOUgxb25iZmZaUjZyWFxyXG4gIHF5c2xhVGk1T0lFbm1lU2hJaXNYTHBLc2xTdGx6dnZueWFvM2ZHQW0xMEdOdGY3bjIyVEZ3Z1Z5MmRWbnl5RkREcExYWDcxYlhuM3RcclxuICBVMW1YbFMzdDRxYUk3ZGl4bFh6NitjOFJ3b3hkNUtaYkhnK094Z0xpVzgrTnZtZk85RUhJOFRqd2dGNjZwaDVUeTVaR2dJbk5DSHMxXHJcbiAgbFphamltTzFuSFJDTzVUdEhsbHZEM2VFM0hhWkZwYzE5ODBhWnJLcmh2VHdkVm5YcmwxZFhuMzVJNmxRc1p4MDdSbWxmK1hMcHdlbFxyXG4gIFBZUGx4RnEzUG5FNms1MW1JQWYwOTZORGcrL3o4VDAvdEIwVUM1ellTdDZuekVybFpOeWFhanBYTlFmVmtHN3pvY05JdEg2U3BLWlhcclxuICBkbi9kaHZ0ZkZOZ3RZcWdoUkZ1M1EwdXduN21yMlNDUTBKZ1NpZUIwR2s2M2YrMnNYOXhmN0I4SGFYMFF3NFIwbDd1SGNwazZQU3ZCXHJcbiAgZ3h0WGtEeVJ0QlFIeXJJSkg4VVl6LzE5K2lVdmE2RmpISWpUanBFNUpvTDlvM0dmczZSUjMzTjBWRVpWcTBzWmYvbk1KdDExSWQ4VlxyXG4gIDhHb3NiVlhYMUYyYnZVblRwek0xZ082SHdqdXNXNXNseTE1M3Y4UHRMY3JObHNyMTJzdVMzOTlRbmZNYzFUdjc4MW5qSVFQeFJwMkhcclxuICA3WU81UFJUdXNCbEFDUndrWlVtMzg5NldOYS8wZEtPbXVacHRsd1NHUENQcktKMDdPbW1xNHlrNlZ6blNCZW9PVUxmTEVEWEt0blFqXHJcbiAgM0FvMW04clhWekw5cmg3U2tXL2ozcWNyc1FMbzgvRXFXamJCRzlYWFRQOUY5eHZ6WU0zeXgxUC8wdU13aWJIdkRtdEpkb0hHL2M3Y1xyXG4gIGhubVVsTGpScGw0cnVPQXV3aitsdmJQc05uYXlnVTRuUHlUalgyWXFBSkYram9tTWZ0VFBDejdnUnVKQ3ZMcWhmMUNHMFdhNmZqanRcclxuICA0MXVWR2FBYW52ZlQwL3BNU1JVMDc4Y252Q3JMdlIra2M4cmNBbTdubEpsWHZaTHJ5MjJHM0txdXZJVU5qcFJtcDd3anpaczFrMHl5XHJcbiAgTDVkTmt4STMwa1c5UmYrWU4yT21USnc0VWJMR1BTOXpQcjVCeGoxeWtDeWFPMXZLWjFhV2huVzhnZnhrTjBJbTZXSFQwR3lBRUVMRFxyXG4gIHJUZGZxTnNRZm9pa3hUYUU4YzIzdjBha0JUK0tqd1ZTakxWSlBaWkU5WllzWGFteEdkUmx3aXJXL2ZwNVQ2ZDRsSlNVNlAwWTRRWmhcclxuICBZbDRhd3NkSWtSNCt4OXBKZEwzdFlYVm9ldDd4WThqNGtDTE5tdnU0RnRwRlpSZDJVOTVUWVB2QlN5NFJkcHFCOU9qbkV5RHVFREVmXHJcbiAgQVZsVWk3V0RsYy93SEpFSjk2bGo3cnUrdkZiTHVQTDZPYlZCa3BTdDVPZnA4RTBHQkR2WU1paU5EUFpWcU5GVTUvMWd1MUxkOXNLOFxyXG4gIEgwRFR1YnVLR0pHWm1TOHNlWGhZMlYzQnJkSXIxOUxNczB5c2hHZUpEMFlVcWRmOWVGazI3Z05xK2ZwdThhUTFTWU9yS2pmbzZFWmVcclxuICBmNm9Fc25UOGh6cTNCY1poRDkrK0IvWHI2U2pOTDMrcTJtaWRXMXU3dmxhU2RELy9YV2x6K1JpcFZLV3FaR1NVMVJFZktjeXpzN05sXHJcbiAgd1lJRk12Yk9sckxpOHlCcXZVeXlJK0RYYTg0aGY3N0lxcW5mYWc0d2NoQ1JVbUtPK3VNRFV0My9LWDJ1L2xIYWFKcVNKSTFhM3pMbVxyXG4gIGJwazJkYnFzWHJ0T0owY2l6UWdlVnVEQS9mZVh1cGU3VHVrYW52Ynh6UkhwSXd5dUNVRnFjOVJ0YnUzbkpRZnNNNkJXU1Vvcjc0amhcclxuICBvMXBlTytzM1pSalRJR1NPYUVIZ3NJRVU1YXhSSmpIL3M1czN3VGN4bm04amVlalBSc0hIbFhjTzFBd3ZleE43M1BaT25OVHRuQmZrXHJcbiAgMS9zSGFibjMxWitySkFLemFIdjBVTTB5SEM3alpGQ3R4WDc2blB0ZTk1ME9jaWhYYnpOQU9wendnREo5MUZmS1NOeGd3RS80NWZxWFxyXG4gIGt3YVJRcGlZYXZaM0QybVpZemhGYkczMkwrbDU1WEJwMXNhTmVBdUxwRXg2bWhTNSsxWmlrcDh2RzFldjlrR2xiaUhwL01FSDdTZFpcclxuICBHeXpMaEljRjJzVVQ5OEdIOUpHaGpnRVlnK2plclYxa1FpYkR1SEUrMzlhTUdmTWo5Y0t3TmsxMUJGRk5aT3crOVpRamxNaFM5OTc3XHJcbiAgWHRSOWQ5ejViQXpSTjVnM0ZaSHVISWRKL1RLY0dKanRNd0JyaTJzd2pUS3c4NlBYMmZGTHA2NWRaL3AwQnVFaW4zenlnd1pRemx1d1xyXG4gIFhJK1BHZU16bnU4b2crNnVncHhld2JoMUcrdzBBOWt4WWg4Q1cvdld6bllTU0pHbTJZYURoK3NnTHZ0dGdnbDkvQWR6ZnZncTVIUGFcclxuICBKT21WYXJPaDIzNi9BVUxQUG44K1MwSE9LcDBySFdZQjFpOFlTeTJ0Zzg5NmJoQjFEaEVGWVNhaXhhQ014TEVKcnl1M1NabllEOHJMXHJcbiAgSjM3aVZrbU9pWnpncTNLS2dicXJac3FTUDk1VTkxcEFUcUJHZmM2UnFrMjZ1dU4ydnhUSnV2dUNKbWhFK3ZEWER1WnV4elZYejNhdlxyXG4gIHhSMGdTR3ZWMU84MDdxUHI5Wk9rM1dtdjZzc2tsaE43eUthTnViSisvUWEzM2lpTG45OVBtZzlrTGhGYTBBdnBHb00rREFvSmhDU0pcclxuICBMYzN6eXYzSDVSa1ZINnFycGM5MWtUV2pINWVaTTJkSzBkWmlLWk5TUnFkVlRYZmlJeE1vOWJwaHBHU2M4cU5QWitIUWN2QjFFZWxEXHJcbiAgWjd0emhNaVl4WXpQUGVQQXpSakdRY3dIV1AzMzk4b2N3SmJDWEtsUzMwbHpEdG81M2YxQTJBNjZhNUtxWWlnVGdWMDQ5NmQxaFNWbFxyXG4gIEs4QTgyQStVZWZpZkZ5QlNLQlZXZmNjMTl5NTI2N283Y1FMTXdKaHBtMk9HYXNBaFRCanc3RlN5YzhTZVoxYTc0MkROTXdkejduTG1cclxuICBjeXBaSTVGTWVNWG5VNE5KVEh6OVluV25odm5BVU1pcXkzdEY4c2gwa3JFTkZtQWl6UWRkSmV1elZrbXJpMytYYnFmZUx5MTdIQzcxXHJcbiAgR3pTUUpNZElDaDJoTFhCOXp3Z0w4a216Wm42cUJnT3FLVU9VaUhwQUVQK2FPQ05DTUtsclU3Y2FqRUcwQ1FMbTRnazQ1MUxuN1hlK1xyXG4gIGltRk9wUUhtY3RPTjUrbDVsTGVueGlMU0hlSi8zcm5IU2JMN3JleGoyUjY0djRzdVBDRlNqL09Ob2ZsN0w0MDhKOFpXeDRpZWUra3pcclxuICB5WFRTVTl1T3JTTk1GS2NiZ05ZQXpOL0JkTFE3aTY1Qnl2aEUwd3J2TWdPcFZiRmNVTm9Sa3RSOTEvM1h5RmJ6aE5EY1RRNmtLemVZXHJcbiAgNFR5NUxHMjd5dTYvcGh0UitHMy9KMHFJby9BTWdBU0tsTDFMSWQ1WXpBM3VqMnNLQnJlUHpUTEpaYlhNL2dnVDBiSmJ1VFVlVjNZY1xyXG4gICswZGQzRmxkbVprSGMxWk1qeHhqOGZkQ3Uwa2FlVTdXWGFRUERTUWMvYXBzV0RKUmRkQytQdkRuTmVsL2dTUHFFOXdIUFZ5bEF6TDdcclxuICBCb2Zzai92cjE3VTZERmJtdDJuMVBNZGtKa2l2eTc2UTVxMmNaRlRCdndlZWFsN3VKcGs1ZTQ3OE5yU056SG5TTXpBRDBwUjNKSERQXHJcbiAgd1RHUmFNcjJKUG51dWdaU3ZtWlR5Vno3clV5YlBsUDFuRVdiU3h5ejMrcmVXUm1wVzZlbU5HbmFWQnFmK3E2bW9QQjM1R0VFcGNHK1xyXG4gIEordmF3Q2dXNldQaml0bXV6cTE2RGt5azdqNUh5SURiZnBkNVA1TkYyS3VyQ2pkNll5SU13V3dkVlJwMmpLaXhhbFNReFY4T0cxU1ZcclxuICBVVFNZKzlNejB1NVl6enp5MTNsai9ZN2dmK2wvQjNiNVhyWnpBb2tlaVhtWitlVjlTdlNwQm9Nd296cHptb2RWV1V3VHpienBNSTY4XHJcbiAgckNVeTZlMnIxTGdPL3Y3d1JrMVFpYTBxTENrdUcvK0pNaUVZek1KZlgxWXBoR1h1RDQrcUpNSkYxK1hrUzNHVkR0TDkxa1ZTbzBaTlxyXG4gIHFWSzVzcVNucDR1VFN5TEU1ZUg3bnBjVnkxZEZDRDJFRk1JZUp2emg4c0FCN250d3NIM2JZd0tUcHlUT0ZNczFJS3dRYW1ZQVJMSUlcclxuICBYeU1NSXRlWk5iQzA0d2FPMHg3dDFxMWJNOElRMkwrOWM2bUh0QVNzamRqNk85OHJKbzcvVzdKeUNxUkhwNll5TUM3eHBNRWtrQjFOXHJcbiAgUjd1ek1ObzlNMEZLazExbUlMamxSckNEMzQzWWgvMER2VXZad0N2QTVqMlBNYUFIN1d3cHlvczBtWWI2aWczZEVSQjRPeGdjVUNJYlxyXG4gIEhLL1d6RDFNVnliSlc3NzdRT3lFL0xVTHRld0pNbm0xbUpDRzgvUkVqNkF1cTJ4SDlHRXllRjl0V2gxMUdNRCtvWFhzM09BY1cyQWNcclxuICA3TU9JVG53SGdZT1ZHM1p4QkxHTDFxQ092d2QzRGNjOEdOV1JVZ1VWVm5ZZ2ZXaGIycHl2QnppblFjK1RaZVhrTDVRcEpsZHZMODB2XHJcbiAgR0M1MTZ0VFJhcnhBUmh3YXdaNmJKOGtWM1A0VnYrdDVwSERSS0h5SExac0xaTTYzOTJ1TC9DY3hJcTY2VTUvc0xaTW4veTM1aFp1bFxyXG4gIGZIcXFwSlZQZGUvTk1jK0tGYVY4dHd1bHFQa0pVbHk0a1ZNaTBnZk1ZOEhJRjNXRVdxRjJDNW45N1lOZStuQ1ZaZ1JxSzJKOUlFWW1cclxuICBsVlJwN0dlMVJDVUlabi8zcU9yallSNm9xNENxc1lMUk0wYnpYOThjMXZEQXU3d0trQ2xjZTEzdTUrMkdlV1JVcmFkbHZXZ0NzRGZ4XHJcbiAga2Y5NTdQSzlsVklaeHNDOE0rdm0vU210M1hPYzhjbFFyWXM5NUk4bmozTU14a3NUNDU4K05xZkwyYy9Mc2o4L1VDYlQvcmk3ZENaQ1xyXG4gIHlqQ0lDcldhSzVPWTh1NDFFU21FUytJZHgzWlJmclk2YUJCQUNKQkNUTlZGcWhQZDd6cGpoYzVuUzVNaEQwcW5UcDBrczJwVjEwQlpcclxuICBWV09CVjEvK1JCNTY0QVhKMjVBZDdJa3lCcE1vREZkZGNab1MyQnVkVk1CK0cyR0hnZm9KWEg3WnFVcWc0d2s0MjViU0hjK3YwdVlMXHJcbiAgSjZxYnlISTdmOVVxQmpXbFN3VFUyMW5HWVRCRHVpSGNCdFB3aGo3MzdlSmRKMUdCNDQ0YUlGMjZkOVJ5R09IbnVUZlJMNGltWDUvQVxyXG4gIGtMNGJES1E0Nk0veHY5cHQyNjVnalFHZEtVYUxrMU1sS2FOYXhIMlhDa3dtUXozUFNEaVhrK3gya21ScktCdXZCeVZid2tWZlFKL1BcclxuICBXcVdab0VxNWFvMWQyYmRCVkM3bHpDWTlnaGZtei9OU0NFVy9EY0V2S1NueWtrZ3dUU2NNd2VmNDBTcDZwaS82RFdJLzJMZjQ5OWNkXHJcbiAgQTVxc0MxbHJtUk5FRDlDMkxyNU01UG1Da2M5cThLRGY1NGhpOW5LM1lvUE11MjVrdDJDc01neHlYMjNPQzZMMDlSNzlLYzB2L2wyYVxyXG4gIE5tMmlOaEcwZ3p3NXV2MkN2MytUcWU5ZUtzWExmdGRvYzZZUzVkN0hQSFdVejRPbDhEUEtaUzUrVytjVVo3cFgrSHgrZ1JOUm5RU1NcclxuICBXYW1hdERycm80aVVBY1Bqb2szM3YwUTl2bEJkTlJsd1hpVFhVZTMyQjJ2Z0hnekRiQi9WbXZmUysxUW00aGlDQWNNc2pNTG5RdlA3XHJcbiAgVUw5ME91bWhpT3FLNDMrOE82d2x2NmRLbzg2cXF1bjc3Mjk5WllmdE1RLzJiTHYzdnhPN2RLK2xWSVFCTC83ZGU3eDFQZjlWK2ZQNVxyXG4gIE0zWE9FOEIrSkpLRll6K3BoRHEyN2JGM1JnenFCTXJpQVljVVF0YnF2eis0d1VtSlExUUtnYkZzZGRkREJjazdtUHZENHhHbXd2dm5cclxuICBmSUI2aTNLMVp2dHBtUXBJTjNYTy9FMzYzN2RTMnJYektrcEFQLzN1aHpIU2ViOHo1WWV2Zm82b3NlS0pLMkQ3bGRjK1ZkVVZ4SkR0XHJcbiAgTUtGbTI5UTFSc1RqMndDZmYvRkw1RHlPSjZxVG5sNVdmdmp4ZHozV3MyZEhxVldydXBaTHk0dkZnaTNEcnNteUkxeHp6Wm02NWh5SVxyXG4gIHZKM0Q5bkhIRGtxWVhUaU1jWDlNbE1lZmZsK2FOYTB2KzNUcm9PZUhmN090NHhuSDNtSWtlR0tCdkFRNXhuYVpnV3pOU0pWOXFzZW1cclxuICBORW5jdTVPVWdlQTlsT0pHSXJsSnBERHhxY2Q5QkRybitJVy9pRWtWNjVDM3hiZWxCRWJodGdQQ3FkQk50djFpUkp3MDZVUjBVNWZaXHJcbiAgQi9PekZ1dis5Q29RRzhjNG12YVF2RFdJWUhZdUsxODJKa0xFT2VXS3RkdW80WnpSTXJFZkpEaE1yNHc5eHM0TnpuRUwvMUJmc1kvWVxyXG4gIER6THVWblFqT3V3ZkdzMGQxUGRJVXRVVmMzNFFQR2o3QVBmdnEvcjZKS1BidEhLT01wR2M1ZE9reGFDckhWSGVMM0tjWlozVWtjWk5cclxuICBtMHFsaXVWMXBPZGJ3aWQ4dnZ6NTdIR1N0bkcyenZPQm5RTW1vckVmZXI0YnJmeTd1b3dmUDk1Skx5V2FKUUJXVUsxcXBsU3BXazE2XHJcbiAgM0xGVTFzMzlQU0p4dEEwWVNVcGFlU2M1ZFkyTVJFbkdTR3M0RHpBRkxvRmpKbkhFTXc1RmtBa1hLWVBiNERobEdFYkx3VmZIcUs1VVxyXG4gIGorK0k0NnEvZjlRZmx0bWtxeFNzRDR2azltczkySXJkODc4SE8zM3ZwVlRxZk5wanltU1psNzFpemFiS2lBbXNIUHZjS1hvY2cvcWtcclxuICBWODRxYUxEdkNUcFFnVUd3THpkclVVUUt3YlViWm9BdGE4Wm5RNlhGd1ZmcmZySXphN3lJQTU1YTlBR0FDa3ZWV0E0a0YwVzFGYjFCXHJcbiAgLzMwMHVYaWN0RHppVm1uV3JvTlVxdW1aL3FMWjgrVElZNjZVcjc4ZHJRVGVpS0ZOeldwQS9XTEVGcU01aHZVdzFxeFpwN1lFbTFxWlxyXG4gIDZPNHdPQTlWMGErL1RWQzdDdGVnZmp4b20zb1BQUGlLcGhpaERuVkxrMEk0Tm1yVVg5bytkUk8xR1kveDQzMjBPK0JhZ0hhUWZtSWpcclxuICA0YmZGeFBGVFpQelVCYkx2UHMybHg3N2JCZ2ZhZWFXZHZ6ZFF1WklQdjBnVXRMbExEQ1EzMjZzVFJ2NjIvWnUxYm9RTkJNSzJkVXVoXHJcbiAgNUc4dHB5S3hva3owc2tXYmZLNzZ2Tlh6aE95ZWRySkdvSWUvR05jaG80ekQ0TXE2bWFUZVd4alJRVGo2Zk4yODBlNURJWGNURWVaSVxyXG4gIEZOU3d0clNvZi9qSGZ3eU1Wa2FDcU5YdUVGays4V090aXFzczdlcENoV0JoM21mMkxYSVN5T29aUDZtOVl0R29WMlRKMkhlMUJuK01cclxuICA0VlJ0MHMxSkg4L0pnaEhQaENMdTlZcTZ0aFZCa1p2ejFybjdINk9KRXllK1NmUnFVQytvMXV1eXo2WGFvWTlLaDZOdWtqcTFhMHB5XHJcbiAgYXJJVUZtL1YzRlJaR3piSmlsV3JKWGZCYjFLMGFwTE0rZHJQUDg3SkM1N3VLaG51bzlya0pBN1VYb0NNdVMxYnRwVHV0eTl5ak9NT1xyXG4gIHFkcWl0NDRzbFhtNDZ5RjF6UDNwQ1YxRExDQTBUQ2ZMR3JzSElDT3NlVjV4aXpDQkZKMWExNG0vODhlNWVuY3BnK0NnZlo3VUlRNEJcclxuICBSbEsyWEdWVlhmMUdlbzViL0lqMjF3Y09qbmhjcFdkdUd6VEdkVmoyQ3F5eDNWbjJBbmFxcVZJcWxVbEpsYld6ZjNmUDhqWlpPdDVKXHJcbiAgdmc0d2lYRXZuS1hQZk5Xc1A5SnpabjYzcE5zNUw4dVU5NjVWWmtFcUdTYXhJbnN2bVFLUUlyRGY5YnRodU9iUGdtRTBPK0F5Ti9qb1xyXG4gIG80d0dSa0oyQnNwaE5WWm00eTZTVXJaY1JKVzFOb2l6c3B0ZFZaUXA5ZXZYazJhdDIrbEFCVHo1eU1zeWFjcHN4MGhHeWV1dmY2cURcclxuICBvREFSUkVKaEJBMkJKbTJKQlFiR3c2TERNOUo5UHdzREpuVHJMUmRxSEFoSU5DSTNCdGF6QnhtL1BZR3ZvUGJGeEcrQytvRDdvaTRMXHJcbiAgRE1yMko0SWRneUhhYit6YXRaMDgrZFRib2ZOaXJ6ZnVqNy9rMFNmZmRXT3VFcm5vdkdPazUzNWRZNjVoNnFwRXNIcXNFMDBCdktzZ1xyXG4gIHZ4MVlsTUNtc3NzU3lNN0JQNHljbkJ3YmREb2t5WlpDVDZ4STZtY29HeGpRU2FCb2o5RHlWdm5GaUdzWWJwOFNaRjlXQTNwUTVsKzVcclxuICBtczFVQ21HN2NxT3U3amlKRXdrT0pJQ1I4NmdjdE1FMmNHVU5IdFN5WTJCMTJxcmhQRy85RXFuZjdWOGF5YXVuK2hwK3pSKzNFUGZCXHJcbiAgMHNpSjV6VTF4b1I1TTg3MUJ1YndOUnhNQWlIMmcwaGZQS1NxWWtRUDZ2aGY2eGIzbnpUMjJJS1lncGJnUGwvRkg1L3ovWU9Pa1AvcVxyXG4gIHBKSStzbngxam1NSTVkMUhXdDkxNW5UM3doMWpjdFd3ZlkxNGVMRE0rLzQrcVZPdnJoUXYvbGxXZjM2ZUxGdTJWRlk3NXFMcUwxZW5cclxuICBSdldxMHJGalI2bHh6bWlOVkVlTkFZaHNYemJCRXlQQUpGL1lQUXg2T3c3bzRHRWErZXVYNmI2dzlMSDhyeTkwalgwTDRLcExIWWlhXHJcbiAgMlRzQWpHVElNMW1TVXlpcXVxclJ1cStPcWdmZGwyaHVCMzlsdS81dWd3YkN5NTVnTDdhMVU2ZkhWV296NUNZMWtvUDYzWTVSS1FUR1xyXG4gIHUzQ1VqOExHTGpMeGsvc2JvSXBDbldWU0NJNE1aQUJBbmJWbzlKdlMrdkFiVmMySWRFR201SXExbTh2S3Y3OVhhUVNtdzNucTB1dWtcclxuICBUYUNxSzRlYTdZaEpvcysyMStNNXk2WnBIOVRFaWc1NWRRNld1c2U5SnMxZFAyN2QyUk80Sk5kQkgzcjBkZmwxekRSNTdxVlA1S3ByXHJcbiAgeU43cmdmMFVJZ25Sdit2dTUrWHVPM3l3YVJnUWJ3Z3loSEptTUM5NkdBc1dMSTFJQ05TaFRWTjl4V08vL2FJeEdoRDMwaVFRRFBKZ1xyXG4gIDBFSDdhVjBXbTd3S3lhUTBVSS9mWXNRZHljTVlHc2ZDREdIa3o2UGxqSXZ2bDQwYjgyS0NBd0YxUzRPMURhemVraVhZZlBjTUpMQ2tcclxuICB1L0U4NDdIN0RHUW5lamxUdU5wcllDWTZvcEE1Y1hPdVY0RXhGN2UzV1lRYlM1S2lIRkpTZUZLcWlCRGhZRS8wZ1Arcmxub3krbnE5XHJcbiAgZXJrcTlYMkFuQ3VYZGN6S2QySW5LYXlZNFpwSzBFYXdEME0xdGc4TEh2UUlET1M2STFpb24rUm5DY1N2M3MvR1J2dlRkUjkyRkE4N1xyXG4gIEIzREUvVXRPMWF5elJKNnphUHpIQXZleXRXcjBkWkEwa1ZRdWhSdFhxUnFMek1LY2I2alpkcEQ3aVB2cmRMMnREcjFlMmw0NVVkcGVcclxuICBQVVc2SG4rWGVzSEFQSGptM05lNmRkbXlhc1Z5R2ZQOHFUTHpqODhreTIzRE9GSlNrdFVWTVNPanZGUTVmWVNtbmNmT0FTQUNYSzJlXHJcbiAgSTBZQWV3Z0xFZ2RNQklheGFOVHJLajMwdWVackdYbmYvcEpldWE0ZUl6MEpESUZSYmMwT0IydVpmRlVxZlRqWXIyQi9tSkhVckZSbVxyXG4gIDhaVDNycGMyZUZvRnFGeS9uYXlaK25Pd0JmelowU2V4aStCRVcvNUo3T0YxZHVxMHVFcDRaY0U0WUJMVE1hZzd0SE5NWXVLYmwrcytcclxuICBtRURaalhPWEUreXBVOWtxTTVraGY3MTZnYjZyY2s2S2h5RjRac0VjTGYybElHZTFsSy9lU0xjQlVnbUdjNzRqK29pcHNUREtaN2x0XHJcbiAgMUxhNDZDOGo3WThEVWttdERvZHFYeVV4YVhVMzRHbDB3U2c1NE9MblJSUC91Qkhta21WcjVMMzN2NU9GaTFmTGI4UDk3SGVrTGg4ZFxyXG4gIHVPK2Vlc3JoT285UW1IaENMTi8vNERzdHMvKzBVMzFNUnhqVWdja1lZeUNVd0dJbHd1QTQ5aGJpSzh6d0hpYkdZV0NRQjdpMFVzZnFcclxuICAwYjdGZVNSQytGWEYzeWNnRS9EdnYvNHA5ejd3aWh4NjdHVnkrcW1IeVpHSEpQYXlDc01ZajYwVHRiMm40Tm1YaGwxbUlOZGNlb2F1XHJcbiAgMDFQQ0hObzlIbnRDd2JwS1dyRVVoR3d1QlNVcGJqVHQ0enA4NUhtU0ZHNVk2YXFISDYwdit3QkNFRDdtRVpVYWdqUGRObnBaeXVUZFxyXG4gIHljUDI0WUFFNGlXVHBNaTB0TW1CT29WOWJMTm9rYklyVkhIU3lxcS92OVZOMHBsekJWS0RKS1drU0dVaTBMVXFlNlBuSzl3S0F6cUpcclxuICA0N0tYVEZMMVZmYmlpZjZvKzZQM3JJc2IxN2dQWnV2V1lwVkFtamxpVGViYmF1VEFpclNGSy9KWU5aNlhyVUQwYnBMYVB2eHNocnFwXHJcbiAgZjJaOE1WUWxoSEpWR3p1cDRYN0gvSmlIMmtsYzNjK1hWcTFhYVRwNEovMjZlL0x2aVhLK1k5ajUrZm11UXlRRkFZbGJuTGhlVWJyZVxyXG4gIDVrZHZST0RQSC82MEl3eCtWR25TQm1vclJwNHJKbi9sZUZ5eU1oSFFZTDlUbkhUMGhCNkQySkFxZy90THIxaGRpWkFsUmpTUVhvYmJcclxuICBONVZWKytDWU1aSzVzNlkxVEU3ejdzbElINmE2cXRHZWVTWThPRjhmd2E1aXQwLzAyTFI2dnN6Kzd2RWRMdFRiQnJ0NTdaMDZMVlFCXHJcbiAgaHJEc3I4KzEzUGFZb2NwTXNDUE4vZkZKdjg4eGt4K2ZQSzh1U1NoSk44TnhCZ2dycHZoNTBYbG51QUREVEV6YVlGOGx4OFJ4ZXZIdlxyXG4gIDJYdHBVWVk1bUJxcmpQdTJyRXlpVHo5eGwvKyttTWRmandjREhnWjNLUjNPa0VPZTlhcWxyWGticFVLbFNySit3eVk1NjZKNzVOODNcclxuICBQcWFqY0FzZ1hMUm91ZmJWK0xnR2N5dGxtbG1ia1RBTWlDa1NpQkZWaUwzbGpnckRqbU5YNmRDaGhXN3ZpQkNIR1FkTGFVa1lEV0ZxXHJcbiAgQ2VJWjFQZy9KOGx0OTc0aWQ5M3psSm9LYnJqbWRPblVKZXFFWUxDc3V4WURZMUpNdkhvdWE1MVBlcnNwVUZIdktiai9OWEhUZVlEZFxyXG4gIGxrRHFsN1BHRW5WeEp3MlVKRWxhamNhU2xCWnc3Tngxa1NqMFNNSkVlbGNDZUFJZFFPdlFFZDA2dm5wd1BsNGtNVzI1TW5NMSsvb3dcclxuICBEdGU1WEZubmNYYkhJdTNyT2I2VEF4STZNaU1lVWtqRk9tMGphZHVKYWw4NjdvT2dmZ0IvcXJydE1ua082cXNxRFJ5UmQvdVk5blhiXHJcbiAgQklwRWhYOHZtZTVqSXZhRE9VcVcvUG11MU85eGdqdmk2OWg5WVVCSDZpamE1Rk1XWk0zN0l4b2pReTIzYW5mTVBhNGVrc2tpamRHb1xyXG4gIDNkbFA5azhiRzJvY0xGV3JWdFhSRktNODNvQ1puUW9LTjd1UGNhdWtwS1pJOVdyVnBkWitQak1vaURDT0lkNkdZWUdDbFIzellyVEpcclxuICB5REk4SmV5c0wrK1d5ZTljcGNUR0pvWlN5Y050azlLZUVUSGJwRGFCR2N6NitnRjNnLzVHOEx4cTFPOXNaU1FWYTdlVTZ1VmxQdnA0XHJcbiAgWXhxSkVIbHZ1d0wveUhZTHhqU21mbktUL0h4WGQ1bjA1cFU3WEVZOU5xaDBacktiOTdMRFUwSVY2blU1TWlLRkxQbkR6NzJCSys0U1xyXG4gIG5xMWowaXBkVkpERlc0dUxOTEVsa2g4eElqQUVhOGFZQjlLRlNSNCtFREdxeG1LNkJNcEF2YkVjY3dEV2gwaU5ZK3F0TE1jd3BuOXlcclxuICBpMm9Dc09ldG5jMSsvekN3aVF4K0prOGExcXNyZFd2WGxoVXIxOHFERDcwcTUxeDhqMk1nV3lScmxaOCtBR0RUQ01PSUpxb1ZpTGhKXHJcbiAgTEFhSU5CS0lsYWxqazBlRkVTYm1aaUFIMi9QRUNvTlorMGkwT0dseTRwZ1V3TFhENTlrMkV0ZTlENzRxQzVldmsvdUdYaEN4TTVjR1xyXG4gIDg0aEtTL05oRWZhYkp3UkpKL0dvQk5XQy9GNlRKeWRPUWJLcjRHMU5DeUxndzlobEJ0Sy9sOWYzL1RWbSt4eTZjU1hIK1hJV2FreEJcclxuICBxL3ExWlhPZVl6anVMdFNkTm9CTkx3cGhTS3RvY1I5T01nbFVXTUgvRUxTQy9qTmlUcG41RDB6RlE5SkVteHVEZVM4QUJFeFR1RWNZXHJcbiAgZ0tzWktyUG9uQit1cUtuYlY4elVNcElMT1lNb1E5RDF1aXp1WEN1anZpb3BkcExIMGttdTdGOG13WU9rZ3RDNkNsKzNWdnREWk9ISVxyXG4gIDU0UEVpVDc3YnE3R3FYQTRXbmZjOHllcThieHE4MTZhRm52WnVQZDlTMEVWUm5ITVFjM0VVdXdxNHRrNldCTVpUdnJxY1BaN1VyOXVcclxuICBYZDFtZCtCeHE1SUgyeldxVjVjdG1lM1VkaE9CT3dEejRNUFBiTll6NHNhTHpjcEdsMGdsNnFIajZsQSs5clV0YXZOWU1QSWxKVWEwXHJcbiAgRGRQWVVyQkpDUXlqMmRVemZNRGFsdUpDbFVKZ0dveG95bFZyb0hXWmFXOXRualMxZHhLV1Bneit5QzZBRTNiNUpBOWpITC9jMVVPWlxyXG4gIHd2U1A3NVhDckdqK29lMGhaOUc4Q0RPWjhOcFplNDJSN0d4MUdBZnFRa0RpU1pnSmlSZkoxa3NqTUlRWjQwWTJiSDd3bFU3YTlpcWdcclxuICBpblZhcWVUUnhra29NQnNZaEdjV1hoS1ovTmJsT3YxelJJM2xqcEVhUjVrTWFpeTNBUFhNY21YNk40TWxnM250MlJ6cXpKR3U0SDVhXHJcbiAgOUhYdFh5VE5MeDByamYvMW9tUldxU0oxNjlXVFpTdXk1STgvLzVaekw3MVhQdmpvQjBsMlRPNkZZSmE5TUZEZGVLTzM2TFMzOFRBYlxyXG4gIENHc0l0akdVTU9LSnU1MnpyZHdRQmVld2dMVnVaQTR6R3pnZ2xyR0VFVy92U0U4cEkvYzkrSnA4OE1WdmN0U2hmZVRKUjYrWGJqMWpcclxuICA4dzBtZ2wyelNxQnFzOTlzMGVKcGdjSGJWRnJ4YVdEMk5uYVpnUnh3MkFGeTdiOTlDb1JFc0k2ZVZMUlI4cEtTbFlHa01aMnRUaTJLXHJcbiAgMTFXVWdWaFdXSXptNlpYOHpJT2NYN1p5cllBWThzY3QxcWdoc3UyUGFmNHNLS1Fyd3p5VWdWQmV1MEFsSHpaSTRoaGxBTUc1a2JKYlxyXG4gIHVRdmlnZVUzM0lQUHkxR21zWEVGYm5iZU5kaU9CYWQ0dUkwcURiMGJMMHZCZWlhaWlrS3Z5WCsza0xxOVNmOExWWDFWdFVsM056SWJcclxuICBGVkpmQlpYY2Y5S3RjMjJZeU1hVjA2WGpTWmFSMU5mTG12dDd4SFVZS0pNTGpyRk0rL2dHeWQ2d1NWS1prTXJ0Z1UyVDF3cGcrNmhZXHJcbiAgc1p5ME92OEhWU21nV2dCNFhqRmRMWXdCWFRicFV3QXBMY0lFQXZWVmFvYnJ2RnUzS3VPQWlGUnd4SVdBUXREc3dFdVVxVEpKRk1CcFxyXG4gIG9GejFSc28wQUtOZ0cva2ErcDU2KzN3a0V0UXRpZUIvcGYrN1E5aGoyQTFBNkdkOSsyaUVjUlJrSlo1Y2FHZXhhdkt2MnM1ZmI1Ni9cclxuICBWeGpKZHF1R0RpTDVaUythcE16RWJDRUFab0pOWkJyTW9sdC92UmxWYzdsOTJlNmRlZWtpVm8yVjVkNXY5dEsvWmVtZjcydDd2RytZXHJcbiAgRE1sQ3JWOVV4YjNjZ1VGR0JTZE5WcXpiVGxXd0c1ZVRzeXBKcFJPQ1Zwc1B1azd0b0dFYTBQTHdXNldjay9wdHp2UUtuVTZYcmpkT1xyXG4gIGwzWWRPMG5OT3ZWa2ZmWW1lZWFGaitTa2Mxei9iTk5jUnZ4Z0hsNGVNQVJtRlN3TkhHL2J0cG11a1JLTUFJY0I4MkEvYXhhSVBldEVcclxuICBLaHRBM1VxVkttZ2RDUFhVSU5WNW9rQTdnN0dpU1JQK2xwbXpGc290OTd3a2ZidTNsdU9PR2lodDJ2bHZaMmZBTmJjSDVqY0JuVHI1XHJcbiAgak9meHFxM2RSV1ptTUw5T0hIWkxoY1UwaXFYRDkyUmNlRW1KQWZJTGNpVWxuUnR3eDJKY2VJa0xTZElvYVE5L2JqUUhsb0g5amhRclxyXG4gIGdmVmxYZHgvUnY5c2VkMDVPN1pFUExCWTFMRHVnR2RXc012KytLWW91MEw1NmswbFY2VVFVcGkwMWNoYm1BOGZ3OFpsam9rRTE0NHlcclxuICBJWDgvbFJzd0FraFM5UlZCYjNVNkg2SHFLK0lsL0RuQk5VTG5vYjVpcVZqZmZXZ1kwUFdJVmxSNDV1R05pY2xwRlNUTE1SSi92cDR1XHJcbiAgOVh1Y3BJWjljbGtCNXY4QVdzUDlhVHJnSXZmUjlsTURPY2tRT2NlUVZqWlplbDM4Z2VZZGc4RXlYUzlvM084Y1pTSUdHelVpZlpndFxyXG4gIGhEV1pXYm1HcVNjZ01sV2I5M2FFeURFWHh3VFFsUk1YQXFGQ3V0aGNzRkdaQnRPcDJtMlViQzdVZldZOFg1c3ZUYWM2cVFNZ2ZiUTZcclxuICAxS2NzQjZGYjN6RjJxWElzSU80UStzbHZYYjNIakNNZUsvLzZXUm5KakMvdTNKYUpnRjI0NysxV0RRNUM2Q2U5NVNjWUsxUFdKekZ0XHJcbiAgZDR4akhJNlpFR1FJazhqS2xhWXdBczhzK3F1WEhNekJDSjB5RS9lT3FkdjE3SmZVNFVVbGp0bS9Pa2JSWDVLU1V6UXpOZjNFcHdmeVxyXG4gIDU2VlhxU3MxSGNOQWtxMVl6N3ZHQXRSVzJhN1BtN2VXdXRwemt2cy80L1BiZ3h4dHJwN2JUMyt0ZTlwMzB2MzZLV3JMcSt5a2txVkxcclxuICBWOG5QdjR5VlU4NjlRMjRmK3F6Y2U4L0xrdVpJQ2NRY1YxNGpyUEdUUjNIOG1XZmYwelhwMkcxZlBEaWYvWGFNTmRsekU0RzZUSVJGXHJcbiAgSFFoMCs3aTA5SWt3L2UrWmNzdlFwK1g2MjUrUXBzMGJ5a04zWEN6RmJvQWRaZ2lsNWVBS3cySks3RHh6WTdidGJ0MjgzWVE4V2NBa1xyXG4gIGtUMEZxVnNTWWJjWWlLRjNrK0JsQlowbmpBa3o1OGpXb2hLZHVZNjBHUGlYSzNqQldoKzFsYjhwbnhmTE40STNod2ZiYnJHMmJSM0FcclxuICBFMFhVWGRTSENlSGg1VXJ1T2t5cENWQ1JGQmZnbVlXYXkwZThSd2kxTmhBbDI3bHI1MGZtS1FITVZhSEdkMWZQc3ZwRzRDK3VZQUllXHJcbiAgRDNSRXZzM0NIQi9iNGhHdEMyQWMwWDNCT3RRZUkzOGtEdzRSaDBGQmowYXJ5T1IzTG5WL0hTTnlkVkZuemY3bTNrZ1RmSURrdnNLZ1xyXG4gIFBYWDZWSjJReXNDY0hwbVZxMGh1Y1laKzBPWndBQmIrOXJJU0F6NStybFZjNkdlS0l4M0tidzhjcUFRRjZRTWlDRm9kZG9QYk4wQStcclxuICB2eWhUS3RScXFveUFVU3RNdzI2MVNwT3VFZGZ0cGVNK0V1SmVZQnExMmpJdmZXQThkMUpIV0dVMTNaV1pVVEJycGlNa3VnZUVmbnhwXHJcbiAgMklrcWlRQkJSenI0ZVZoWEpmVC9KQllNZjAwbXZIN09mNFNKV01CZnA1TWZrYldCVFFSbUFIaHZKbm1zWVNaQmgzcmRqbFZtd2o0V1xyXG4gIHNHTFNWN0p4MVZ3cFdMZlVEUUNPOTdOSGJ2WDlDWTBDdGt4U29BQ1lpOWxCQ0VDMUFZYUhkM1NoenpIYkpaS3ZnUUJYMHUzTStZNDBcclxuICBPd3grVURIeEk5emkvcWZYN2lSOWg4NldPdlZxUzkxNkRXVHQyZzF5eDkwdnlNMjNQeVduT21ZeWNkd1VHVDE2b2hKenZJVVNaYUlkXHJcbiAgZkVqZkNJRmxiZk4vaE1INUhBdlhLMjNPZGVvYVljYkZGWVRQRFdQMHlERnk2N0JuNU5Qdi9uQmo1MlM1ODVhTFpORCtQYVZUVjM4ZVxyXG4gIGJVVWRBR0taWHlJWWd3Q2NhNEdVQm91SHNTbG85NVlFVXFXS1Y1bkZZNDhZeUxkZi94Q1VFaU01M2RzNEtsVWtDcDFVSXVLbnM5VU9cclxuICBFaldtVzJkUERFZEFRd1RXZzIyL0wzODllYThjY1ZRaW55VGxxamIwYnNMdUhBSVRrWHlvYVZIdy9JbHBUOHRKa3J0Nm5odXRwNnY5XHJcbiAgWTJNd1YzdkZXcTFVK2tDaThXVGNMYlFibE0xOU4zdnBaQzJUUjJ2RDRvbnVudkFXOGJXQWxld3Y2aXV5OWlJRm1CU2g5eEc2TDAwUFxyXG4gIE1mTVhLVnN1MDBlZ2MzWndyMlFjdHF6REdDVmJIbnFUUCs0V25VRExZZnl6ZnNhNkZJd2VBVExTeTBxbHl2N2p3YURacEwrZlY4SUFcclxuICBBZUREaDVIVTZlUm5OcVA5MXN3SDRRZ0VycnN3aXZtL1BCZlllRVQydStJemxUd0FVZ2dnb0JPR2cvb0t5WERCcjYvcTNiVTU4bWFaXHJcbiAgKytOVFVxMVZYeVZnQU9NNTUyblUrZFNmSTJxczZxMTlEaThOL3R3ZS9NL2VMVURJNS8zMHJFb0hoZG5SSEUzL0pGWk5HaUdqSHora1xyXG4gIGRDYXlrNzlsdTlYY3dRNG4zcS9QdUZLOU5wcHpEQmpqVUduRU1ZdlczZnJQcjlhc3ArNHJXTDlNTXR5QWkvY0dlTjlNbTl0a3dMbTZcclxuICBEK2JUNVl6bklyWXcxSm5zSTRpVWI5c2tab0RUUlhKS21tWmNYcVB6elpDTExWOHdzTGMrd3I5Zk03WURwQkg2ZTRWYUxXVFRtamt4XHJcbiAgZ1lqUWhyay9QaVpkblRUUzZKZ25wRUtsQ2xLaGZBVWx4Z3NXTEpjN0huaE5ubi9wRS9uK3E1K2xyS09sRlN2RzBwSStmYnBvc2tTSVxyXG4gIExXQzlVdk5keFFMaWIzV2lqQ0R4VThaZ2JZUTVVWFEyaHZFYmJubFN5bGZwSW5jKy9LYm1BYnpuMXZQa2p0c3VsTHpDYUgvbU9tUWVcclxuICB0amlTblg3NWNRai90cVhML0t5Y3pacEc1MXZaR3pEMzVYanNFUVB4Q1Azb29KaVdISXhTQ3Z6RHlpc3NDQ1NBcUEwRXJ3NEQ0ckdlXHJcbiAgNndoa3hJQU9ZcDZuVnRCL3RwOXlobU1ZbERLcU5oS0NFZjBCZ2d1RHdLS0E2SHJhSEp5b29CMi96ZC95dFpwN0tTWlN4Yzh3V0xGZVxyXG4gIGUwa3VHM1JLVHZFbEQ3ZFJMck4rWkdQVEtpZDFhU240US91NmVQc0hlYmhJNGE0cXJBVi9xcHJNVjlVekZLaXZXQmo1bHltYklTdi9cclxuICAvdHJ0OWNldEZuTitySE9TQjhUZGtpVXFYSVZVeDZCUlh4bVNTSVVjb0ZpMlNOdC96OWFKdkdhNWthRFpmSEE5WmxUSVI0MDl5blRiXHJcbiAgQlJ1aVFVZ1FER3dlZ0xuVnpVZ0tvV25VN3l4MUN6VzdSdUdHVmJxLzlXSC8xdWgwdk1sc2JBVWpSMzJGalVUVlZ4alBnMk5yWjQvYVxyXG4gIHhuaGV4a2t0cFNMNjAzWUx5Ly82VW1aOS9WQ3c5Wi9EaG9WelNtY2lZQTkvRnlCK0Jsc1RLTXp6ekJIR3NYYk82SWcwZ2hyTEI3RjZcclxuICBGOS95MWNrZGgyUTRWR1o4ZnBmVTczRzhNZzhDQzJFd2Z6eDFiTUJNdktvTGh0UzQ3OW1TNXI1dGpmRnk1OUpQR0VTVmJDbDBnNGNvXHJcbiAgTWEvV3d2ZEpzak1BK3BzZnlMa0JrWk5DYUEvM2R6d1VRZkJwcXZzNjMwMld1Mit0Mi8wczZkNnpoelJ2MlVLcVZNMlVEVGw1OHU1N1xyXG4gIDM4aTlqNzB2eDV4d3ZkeDJ4N015SnBRcEE2K3E4SHplRU8yeXFkNGVHQWJFMTVpSUVlVFNKQUlNMXVUTkFwekR3c1JPWjV4enU1eDBcclxuICB5dlV5N043WDVjbW5YcFdycmp4WDdyamhITG4xeG5QVlFFNjdabDhCYkhjSnZLcjJGbXlPOUwyTnhFOWlOeG5Jb0FIN1NOT1dzVG4rXHJcbiAgbzNCTVlFc1pxZVFZRm15a1RMbFVuVlNLemdWTXZXVGJGRWphWnNDQXJzZGNEd29UMWdqQ3Uxd1pHd0Vnd1I1eEpURVZYQnRNSUFWc1xyXG4gIEhoRGZNNDJoQUZkd0d6YUZiV281SDN0aDFZbi8yRklFZzdQNzhZdlpQL0tjdEpGV29hWWFGWEZIeGY1UkJmdUhOYUR3NTNqR1FiNHVcclxuICBOcE5pODMzcFgxS3ZqRkh2S2tmNTllUFJqeXpVVk5hODBhcTIwdktjVVJIMWxWWEpYN2RJdnJ1cW9oUG55N2lQZUt1VWhGUlk1ZElyXHJcbiAgeU9wcFA2aHRCK1pqcWdRQ3ZBQ2VjaGpremY2eFlNVHp1Z1lRQzFSVUlIdnhaTjBtR3JuT1BrZklJaWRoTEI3OVp1UWU2R3d3aUpsZlxyXG4gIFArRHE5WXVvdzJaOFlaTlplZlZWb3o2bnF2cksycldvOVEwTHQ1MkZiaHVFbnNudUFPSTk5V052Ty9xZkFFeGt5Z2ZYN0JFVDJXNFZcclxuICBkM0JMa2JjdHRobHlzMG9abVUyNitkeGlEakFPOXFWa1ZOSlU3VENWR1ovZnFmc0FJMzlqRnJ4TDBoRDF2UGg5M2FadDNqLzU0WExYXHJcbiAgekk5SXJRQUp4YVFVb0lNUlY1KytYYi9uU1c1d3RLL1dEVXNnZlAzemZuNVNXdXRVQXdiLzY2cnFUSm8rejFXMUZyMTFnRk51eU52U1xyXG4gIC9JS2ZwVUdEQmtHUW0ydTdmaTBaT0xDSGpCMHpSVlZiTjl6OGhOeHkyOVB5eTRnSlVxdGFaV25Zc0k1T0pRdU1nTWZER0FmNi9pZ1RcclxuICAyUmFjVDk0c01QeUgzOXkxbnBJVHo3aGRmdnJ4ZDBsMTBzYURkMStpN3JoM0RiMVlldXhuUWNVZUppSEVnK3ZsNWZ1NG1PMGhmTzk3XHJcbiAgeTc2eE04Q2VtZ2k3eFVBR0hqeFFqamdpR3R5VkNHV1NvMXgrYzlscUVRbkU0Z0IwOGlnSHVvazNmSG55VEJTNjd6b0JvSTY2eHkzaFxyXG4gIGNsQUxNVmtQdVpFcTg1WlQ5dTY3dnIzeTFYM3NSNFVhemR3cWVwNEhKMW9wS2JEVGJCV3krT2JZM09kYUozUk9zQXVZL1lPWkZCbkZcclxuICBFNEdPYW9jOFFoN1I4MGpmWGliRkd6UkphWTlxU2tIYldzM1hWZWJoeXFpdGNBZXVxbllRd1BHa3lFaE1rZUI1a0N3UGtFTUhoQVhQXHJcbiAgNUpxZHBXYTdRZWlGcEZ5TkpsNW43VTR6NlVOemxmbG1GRVlJU0cwZlJzVzZyVlVhWWVJbzhpQTFPZUFpS2UvYW0vUERFK29CeEVMT1xyXG4gIEwvTzhBNDM3bk9IdWFiT1hVb0pyTkc3U2JENjlBYlVWZllCcGNUbUVOQWkyYkU2Y2RpSjhqN3NEaVBiWUY0Nlg0aUJIMHY4VWx2N3hcclxuICBtY3orN3JGL2pJbTBPM2FvTUM4THpBRURPcllsczRNUVY0UnRyMW5IM3NzWEIvRWl6SCtEQklFMDB1SVFiNFEzMnlKcTExVlRmRVprXHJcbiAgMm9DNVJBZEFpY2VubTl4Z2hOUW0zQ1Y5akFFS1V5MkVtUWVvNmlRUVhOeTkralhKU1lVMjBPQ3JUSEtEemt5VnRPbjd1VTdLQjF2bVxyXG4gIGZ5SEZXMHRrYzFHUk5ITE00Y1pyVHBFM1g3dGJici94YkRueGhFUGt5YWRma3lKMzdLRkhYNUFISDM5WFB2LzRlMW5taURlRU91cW1cclxuICBHMFZHUnJxc1dwMGw2ZWxwVXFPRy96WWgxdkdNaEJ4VjUxMTRwN3p5eGxjeWVNajVjdmkvcm5DZlU0a2NkL3dnZWVUZVMrV05WKytVXHJcbiAgZmJwSG5RZkM0RjJGSllTSmsyYkdNQVNMN2RnYk1LK3BwbnRKbGRXMGlVK0d1V0pGMkw2N213d2tqRjROb2graEo5bXVRNlFWS1VHd1xyXG4gIHhndnpHSUg2WTJtVnZOMURjMkFGaE5rVGRnOGZyUjdkTnNUVGNQdVR2MjZKZW1LQjlDb2syd3NxV3FWZ003WUJ5dTV1Z3pxcXluRmxcclxuICBBZzFKblk0YjhLYmwweVFIRjE2M1AzS21POEgvUnIra2tOTXJPRTZlS0FpK0psYlVQUjVXSHhzTFlqNWJlRGJ4TVVYc0grd05UaUU0XHJcbiAgc0JvcUxIVEticCszZFVTUGU3VlYyUDRSaktMMWVKSmVBK25EUG1sTUlEVmE5cEJCaitTcEs2Vit2RzdmNHQvZkRHcDRaRGJxR2pHQ1xyXG4gIDJxZ1J2VFZNb3VtQTg5MG9jMFNFTWRacVAwajYzL0NMamtaUmIyUlVxdWxHb2d1VVFRQUkxam9uYWVHcHc0aVdXeU5UTEZJSFNmZXdcclxuICBPMkI4UlgyRkJBS21mM3FIdEQ3c09pMnJtN0JESkhOQUdQbzdkeDhRNjluZlBpeFpNN1lmc1BXZnd0enZuMVJWV3FuWWlkOWJXaFhlXHJcbiAgdzRhbGZ2clh6RWJlb3loc0Ixa3c4aFhKYUhGd1hTYjdvZzBraW8ydW53THNVcnpmZFhNRDI0YXJnSTJpSUh1RnY1Nzc0ejIzZkx3SVxyXG4gICs3QUR3bGdBZmFsaXZiYlJnYU9EU2tSNnNoKzBBTDc5bWkzN2F4b2RIVWFXU1JZbVB2TUhmUjh2eWwydktsMGNXeHJzZTRydXo1MzZcclxuICB2cXhkdTFZYU5hb3JCd3pvSWhkZjZ1Y1E2ZEM1cmR4MWg1Y0FIcmp2S3ZucS9jZWtkdTJxOHViN1A4ckJoNThubjN3MlhINzhaYXlNXHJcbiAgSHVGeldoa3dodU9sVlZCUUtKTW56MUxDL3V6VGI4dXJiMzZ0RWdiMkRKWUJnOCtWVFJzM2FkM1AzMzFFcjNQWUliMWs4RUU5cFhiOVxyXG4gIHV0dVZYRnFHb3VDcHQwL24xakgxazRPNHVCMkJXVWpCdnZ2NkdDNlRSUDRNcHZvRkhUdDZoNkFHRGVJOVduY1A1bEViNzZxODJ3d0VcclxuICBkMUN3ZW5VMFV0UlE3RWEvR3paSFI1L3B5WjZ3UklNSVhRK3d5RGFIU0dDUjIxK1lZM3AzVnlmb2JKRzFRYmY5VGd4L3BxdFBTYThjXHJcbiAgVENEbHBKQ3FQbTZEeUhLZnh0MGp6S3dpRFFmdEtiRVBkdUcrNnpld2hiZ1JSZVE4Vzd2ZldaQWp5U2w0VURqcHBXeUdFdS9LbWtXWVxyXG4gIDZyVEZvb2ZkYUcyOTJqOUlLNDl4a3AxazNQVU1Kb0Nyai8wakhPMU56QWV3V296cTE3bVJHQjhXSXpJK3JEQ3lwbit0NmRtQnBUSHBcclxuICBmT3F6NmdGanlJb2JBY0pVaURJM3p4ay9DNk5JdG1NQzJGTWdKSTM3bmlYTkIxM3BpY3I4UDdVdUkxVXpuQ04xTUEweHhsbmREcVFYXHJcbiAgMUI5Rk9wK0pSNnZEcjlQOFN0WGJCaW9QUitRQTdhU2tsWFBQS1RwVDVUOEJpUFhjSDdZZGdmNVBZdWxmNzVRdWhld2hWa3pHaGlheVxyXG4gIGFaV1BWVUJkaU9TUVhxVzJEaERvV01zbWZLcE1oV001anVIQWVFeXRXRkpTckdVWXc4d3Y3cElsWTkrVDlNRHVSLyt0Vkw5OWhHbEFcclxuICA2QTFrTVZqditrbmsyM1BYWWVCRTRLcEt2SzQvYXI0NkIzb3JucGc2NTg3V0xXNC9ra2kwejVzS0MrL0dQTDV2ZDJUTm1qVlNzWHlxXHJcbiAgWEh6T0VYTDY2VWRGQ0hGOE5QckFnL3ZKUVFmMGxOTk9Pa2lPSGpKSVhuemxYVGZ5LzF2T3VPRHVDRk5nU2EvWVdaNTc4V01aZE5oNVxyXG4gIDh2WjczOGxKcDk0Z2R6MzR1b3dhTmNFeHRoSzU5Skl6NVpLTHpwQ3ZQbmhNWG52bFRubmczc3Zsb0VNSEJsZlpPY3hLa1BEUlVLc1dcclxuICB6a1dKSmJsNFRKbmlvOHNaS0FJejZEZHRXbCthTjkvV3RLQW1oRDFFUVpDRU1wWis3b2tFRWpTMEtYL2JJSjdrTWx1bHZEdk02TGVjXHJcbiAgZXlnclZvZTlIdng1Rm9YdTIvSDd0a1ZBMUNQSDNUcW12bDk3d3M4ODZsR2JncnJlNnVFa25SekhJMUxRK3JweXkrYmNiQ2ZxKytoelxyXG4gIEQxZHcvMzBnbE4rTUFkdHVJWTBKWWovQVhrRktFOXF0RXN5KzV4RjdNc2J6bktEZHNPMkgzMUJTWE9Ta21MODBOaVNqU24xVnoxVnFcclxuICBFQktIWGR2MjBURkhDQjlXdVBXbzk0b2ZNZGlvSWJsbVJ6MlBqeFliQnhIdXJZZmNGcmsxVmhsVlBWRkFQMTNaRVFWUXpZMEU4YnpDXHJcbiAgZG9PRVFlZEJ4YkZ5eXJjUjk5eHFMZnRJc1NQNlJrUmdKQkNqL0EwcjFGZ09Vc3ZGdWszQ0xLeWVFU3Fib2pabWtCR1BCTHQyQlJCcFxyXG4gIFAvWHhmeGZXVHZ2ekg1TkNiRERTOHRCcnBYQmpsajczMmQ4K290SG42K2FOMVdQTkRyaEVHUVZNUDYyQ2o1VlFMeXYzbnNKT0RFd2lcclxuICBoaXFTR1F3QkF5RVlqanBYdUJ2UStYZ0NvUDVrc01RQXpzZDVKYWwzMXJ5Zkh0Y0JTL1dXL3IwREdBY0JyZGEzRmZwOUJrdnc0eGcwXHJcbiAgSVlYa2YzTzZaR2RuTzRZd1FIcnVGenNaVTZKb2RJSUlMN3ZpVExudy9PUGwyeTlla0FmdnVrcFdyUEw5elJnRHpLVkIvVnB5ekZHSFxyXG4gIGFQNG9VdjBjYy9TQjhzSVQxOG45ZDErdXl3UDNYaUVEQi9YYnE2b213NnBWdXg1N2hQdHlHTldyVlluWWVjS1lQMy9QNTBZM3hoR3NcclxuICBJdGh0Qm1KdVhYTm1McFFlOWIyUjFGQzhOVmtLZzlFditrRkRPQUxWUUJ4SFd1Vm9rRXBaQ3lLMEc0M2NjTXhZM1pmZG4vVEtkZHhIXHJcbiAgRWczWEw5Z1l0YUVvMFhOcjVoclJYeDZjRk5PUzJ4K1pwOFR0SjQyN0hTWUhWdFErRTV6bjZ1czZ0SGhqTjZtczIva2NXSkZqQml1N1xyXG4gIHRmdlBxQXdqNWxaR0hQcEcvSEZVUkRBUk5zdFZhK2hHNUJYY0I0cWJZTFNPanlQQjRPMDlhK3p1K0p1M1pwNlVDYnl1eUFCQWFiK0xcclxuICAzdEJ0M0haWlVDc2tKWmQxRENEMm5lRlNiU25YZzBzcENHSkVjdHFjNzZVSU5hYTdCUThiQ0F4cUtrYWlDbmVlcWtnYzhkR014aUVRXHJcbiAgLzVHUzdoMGVrR0lZNVpKeUE0SUdHdlgya3grWmluTUx6eUdNMEQzdExpRFNzNzk5Tk5qNjc4TDZoV08zTDRYczV1OW5aa2c5MS9VelxyXG4gIGlIMzFWbjM4Z1JCSXZUNzd1MGUwWEw2V2o0cm0zV0FITk9tRGQ4Wk1tNmlwN0ZhU3k2WkgrZ01nenh2UXRFWHV1ekVibS9VUDgrNGpcclxuICA5eFllayt2Y1lBcEVpRlBRY3RoN0M5alJEY3VtYXRxaUJmUG15VnB5WkxscmhBM2pGbFFYajRVTGw4V2tXbS9Yb2JXcW5saU1NYno3XHJcbiAgOWdOeTJPQStjdUY1eDhvRjV4d2p0OXh3amthSko2ZHRtNlRSa09zWURaSVBIbGxjZjMxMnJIb25FY0kyRDFOQkdiREQvQk5ZdVhKYlxyXG4gIHVydXJTSFVNRlpBU1A0emRaaUNIRGVvbERRTUR6ZnIxc1NIL1ZaSTN1ZzdpR1VkZVFZblVyQlpybktWc1J2UUk2RVJXeDVYRDFTT0lcclxuICBhY052WUt3blJUcG5vRUt5S1BiSTlMbXVYdm5BWFRiU2dLNzQ0N2NqbXpId3h6ZXU4RW5LRk52VWNidDhOZjFqUnZJby9BbjJsN25QXHJcbiAgV1RNcTgxUHdBbmZVVjNDTXRIWkU3NDhOQkM4dnRZRUV4d0dKRXhtSkFReUwrTVBiOGFoUkU1V0FIM21XcXh6VlFSdG1mM05mSklnUVxyXG4gIEpvdlVRZlpnREt2MmtVTXcxanZtUWRRNERNSGlQbUJZT2gyeEE4UmxyU00wYTJkN3J6QkdzS2lzSUFETURXSXdkVmE5cmo3cUhWUXZcclxuICBKL05SZWNGSWtFUU1lV3U4aWlMWkFrOUI2UGZ2Q2N4Rzg5K0lSYis5dTMwcEJPemdPU1E2WEtsdWExVXQ0UTNIdTBMeU4wTzZNbnYzXHJcbiAgN091MTdyRStLU2xaMzhXcXFUOEVnWWNETklZa2pPSkFGUWxEeVpvN1JtMk9TRGlld1RpSkplZzdPTW9nWmNRR0U3ckJvU1ArU003a1xyXG4gIGFpTjZuVnh3ZHRmWUVFMVRnRDNPd1BkRktoWDJGYnRCVE5ueTFhVXdQMThhTmFnbGd3ZDJqVkhaeEFmVkdjam1DeURlbHE3ZEpwa3FcclxuICBEVkdpVy9wRHQ2andOV3ZXS3lPeDZPL1NFRzRKSXplcDVjTU1KVC9mT3l6c2JjUkg1KzhPckkzNDFPNjd6VUM2OU93aUo1NXdzSlluXHJcbiAgL0RrMTV1bXNMU3duUlFFREFka2JjM1VkaWFlSVlOdVhreExreDlybVdHU1RndCtJZnk2cVFsSWtTWnJyYU1hR29xTjBRMURXRmFsTFxyXG4gIFFoK0s2N0hNZ1E3S3BKYU5PU3NLdjVjRWl2RkFGV2JuK0RWL0U3ZFNMV0pFZDNEWHhRMFpyeGVNNkp4aVhsN3haNXRPbUFOUkx5MlJcclxuICB1ZC9jb3V2aW9pMCtBNjliVWhvendWVzBoVEpPWXFCZFBNZEFWTlhuUjRqbWpra0tHRnd1T1JZZVpjTDRpQ3FIYUxBZ1FWUnQybDBaXHJcbiAgenByWnZ5bXpRUFhHM0JJR0NOT21sYk0xSVovcHlUR2daem5HdzZXUlpHcDNQRVQzVjJyZzFXZkZnWXBzYjRIUi9kTHhid1ZiLys4aVxyXG4gICtxWTlVRGR0V0V6QXErczM4Nk1HMnpDcXREMDBzMXlnd2tTRnhmZkNPMUVKSkpBKzJDYWJ0cWtjR2F3eFlQRU15VEdjb0g4QTRrQlFcclxuICBZYUVHWXlIekw4QStpSW9TZDNlUDZOMW1COUpJSWxTdTM4SDFtM1VxMlRCNDJwU3pVWTQ1ZW4rMWI0QVNSd2dnNEdZSEljMUlJbkI4XHJcbiAgdzRhTk9ua1VVOWttQWxKQWFaSk1hZGpaV2YvQzhTamJ5NXUxdDdDOStVbDJGVFlSbDlsZERMdk5RRUNoSTFURkNaaGIyWkpOTWNROVxyXG4gIExjMlB6QzE1SXJDWkNIMUFvWkgzSkRXMFJjRmVqdm0xWDZLcklwMjVNRW1qemFOd0I0UGpwQ2Z4c0gycy9VRy84bVcxZnlqWTlsZERcclxuICB6WVE2Q2ZkZzNhOG4yT0kra3RBa1UzaGZBVlJRYWlDbnJpNVdKVW5WUUpXQ3pMZk11ZTdWUlJ3TUlkaEViWlRFQXd3ZjFuS1NOTnp2XHJcbiAgVExkS1V1bWplamlJMElFMDdlRVh6SVJSTVhCdElOSFUyZWZJUU5YbVBqNDE2TnQ3Y0FpdWFSNVhPckowaS8xR3k1bTBjb3JQNU1yelxyXG4gIFdlY0kwNmJWYzZWR3k3NDZkd1NxUExMdUltR1k5SkVmSkptRW1NRlF3RG8zaWpWVWF4NWlwZzZjcndnL2d6MEFvL3QxczdlZFRPaS9cclxuICBDVXZHdjdGalkvb3VQZy9pb3d3bHVMeUhBRE1vME1CZERPbWY2Wm9aQ2dFU0N3R2pZWmc2SzQvcEV4eXFPTUp1OTRPekIwekViazhIXHJcbiAgSTI2YkpTL0xHNCtwd3dERlN5Ylk4NklTaWgva2VYdElScFY2WHIwVitlYmN0K3phd1BWOTBRdjdTNFVLYVhMby9sSGJSeG10NThFOFxyXG4gIEdUWm5oc0ZtTnpRd2VWUnA2TnExYll3azA3Nzlqdk5jN1N6NjlZdTExL3pUeU0zZHZwUzFLN0MyVEpWbDJDTUdBaXhUUm5LU0Q5VkxcclxuICBLYk5WaWlYMklqWXBlNndOSkZZbUFEN3hZV2l2RlJQc0Ftb3ZjUEQ1cnZqdjA3bkhJc2wxdkNwQk9ZeWdwY2hLRzRoQWt5ODZxQkV5XHJcbiAgdG1wTVBTV3NicnRnd3lyWDMxMGhkQ3k4c1g3Qk9NbFpPbGt5bmRSQnFoUS92NGVIUFFsc0V6Ny9GUnZoaGlqN2JWd3Q4UkRER0V6a1xyXG4gIHV4M1RvKzRyeEFPTFJBQ1EzM0R3eitJLzN0QTRGejVlN2hPdks0QlJIMWhhbWV5RkUzVE5oNCtMdEVrZkJFb0NUMFFHcUFHV2ExWnZcclxuICAyVnRqUG95b29ONUNwdzdXTDVpZ0tpMHF3blNRVnRDdG13cXNlaXZQQUMzOXVCblNBZk5OK0IvMWZ3ZTRGdTlRalFWMjhGemlENXM2XHJcbiAgc1dKRDc1QVJsaFp5bG5saWF3bE4rYWFRR2xJRFk3bzFWakZnSnJ4SFhOTHhtckl4SWt5RjZaVk5OV1pTck03LzQyQTU1ckI3cUtkVlxyXG4gIEdERTNTOWJzK1Jwd1dMSk5ERkNTRlAxK3A4eWVPMFV1UHZkSUdUQW9kdkJrU0RTeEU3TWI3aXl3bFppYkxOSkl0V3FKYU1mL0RtUmtcclxuICBKSENEMzAyWTdTTStKOVllTVpBaEIvZVVsa0ZFZXRQeTZ6M3pLSEV2T3FsY1RBRGJobXovUXZ6VXMxcUtkSnh3LzFHM3doMUJUK0FQXHJcbiAgYllUUDl1VzhMSzlEeDg3QUFyekIyUkhaU0hWZmlKN3RTMHp2cVlocE53eTNQM1NvaW1iaTliczBpTkdCV2YwU3c1OUltZzlGNUJyUlxyXG4gIEJ0VUlHV3FmM0Z3eDkrS0txcjV5bzNQeWJSWGtyQXcxRS8xOU1IV002RGE1RE1EOVVkdHp3STNXVHJPUEhaUTRrWmRaSFVHU0l3K2tcclxuICB5WWM0aEdIblZYT013NUpHRm0vMjZpWWpJQ0hoTS94elBOeU9Tb0dYbDd0SnZ3NUFERTZDTS9ZS3RwYnN1U3ZqLzFac1hPbUQ3OEtEXHJcbiAgbHVLQ1dHbWtiSGsvMlJ1NXkzaC9OdTAwS0hMZkQxSzZmejhlVE1zTThONkRxZUFnZ1VORkdIZ3BocEdhWGttV2pudlBsY2pDRUxhYlxyXG4gIFJ0OTVmdll5bWZOOWJIb1pPN3BtclIrQU5tM3B2K3RkUWV2V08zK091Y25XckJsa3pmaGZpdFFFS1Z0MkY2a3B5Zm9leUk0Y3hoNHhcclxuICBrUDBHOUphamp4Nms1WlhMbHNxV3JXNWttMVNpYXB4UUNpYjF4R0l6SlEzdTVVZkw0VWgxajlBSjRYSjR0eUoyaDI0RmxETkcrdkFIXHJcbiAgNHFxemtXaWYreENxbVRIT2IwZXFhSFcyYkgrMGpGZEtQRHpUOHNjOWZBb1RBek1JUmhDdTVqWnNRcXBLZFprY3htMnJtaXdLKzZpTlxyXG4gIDBmbVUyRkdZTndzb0xna0NPWU45R3J3WUdObEp0eDZCTzh5SUUwWlJ4akY0eTVxc05naDNET0pBb0dVOGMxangxeGZCUENTTVlrT09cclxuICBCZzZtVDhjZE9jeE1xamFMVlZOWjU3T0k5UXAxbzltUVk1L05ubVByMXIybkQvNnZ3RzQ4bjAzTFRWWHJubjFLcXNiZHFCRzhUZjlBXHJcbiAgVllzTk1wWkFBQ1I0WE01eHBMQjhjZVllbkI1TVAwMi8xL2NZdnE5UW1TSjlpNG5mUU9rRHJjUlk5OTAxc25MbFFybmpwZ3RrM2Jvb1xyXG4gIEk5dFpWS29VYjMvZEZ2RUVsNkRDL3hkUW1uUEJybURCd3FoMklJdzlZaUJnYzdIdlNNdVdMSk9xWlF1VmlaU2taZXJFUllZdFdzZVJcclxuICAzaERUc09sdGpjQnRDMGkxVm9ndTRib1UxZEFTM2hjcUIvc2plOEtIREZiZnJTd1lrUkdRQVkrUm1CTkQ3VWRpT055dXFPdXVxQzNBXHJcbiAgdzIvYlgxMXY4MXZkZG1pWER6QU1ubzA3Z01FeGZJWVJiRVdDcHN4VGdtZHZxa1ZENVVBRmhkc3pxT2lZbEZWQlhSV1A5U0dmZnFLUFxyXG4gIEZhRTJ6YTAzREZPTm1IcE1rMlNHZ05zbm9Ca1dVeTJhRjFmaGhtMkRVdmNhektieWZ3UnhyMS9CakpEUkE3NFFpY2VLWWZXeDREM2FcclxuICB0N3ROZGdDK0E5ZFVPRGxxb21zRDFHUFlOMkt4YlcwWVRmeW5zamJMU3gvRWZjUWJjbmNHTzJPMHR0bjdhdFR3a3NmdXhHYjhONkoyXHJcbiAgN1cwOU1YY1ZHd05IcUhqc01RTUJtNE8rVjZFNFN5cW5vWU5uNmxLL0QxaG5zRkZMR09GVUJ6R0k2MERoVFY5MmpDcVVheW1tUmt6dlxyXG4gIFF4bGpjSVE4Y2loYVIvVzVnWXVuSjR3Y1l5NzFrRnR1dUVrSG90UGpkamt3Z1pVbnJQN1l0alVNTWNlM1lTeHhpRG5NUnVuMVVWMHBcclxuICBTcW1TVWNWUGMwdU1TUVR1WlZrNm1BaWhEYi9BRUhERkJKb2VQd1EvcDR1SGpVb0JzUWVsZ2VqOU1PTGIzSnZRbUp2LzQvQ3Bmanh3XHJcbiAgYVRaUHQwMHI1N3JYN3Q5N1BOTUhTQ3ZrUDhPTExoNHdEcVJYamJtS1Uwbkd3UFZISmhmejJiTVpaSVQ2WHh6SVJlZmgrM3IrOGttU1xyXG4gIGxwb3M5OTErbWU2MUtXeDNCYVhON1JFUEVpa3lnK0UvZ2ZBOEpIbjVOb25lN2lNK2RYMXBhTlpzei9OaGxTc1hvb1VoN0RFRE9iQnZcclxuICBwOGdONXVWdFVna2tvOHhtdDlaZGl2UWdjdE9JYXhSUmdodURSTVF2MFQ2SVhTbUVFa1Rvc3E3REZWMDUyRVEyS0JObUZLRjZ4R1VZXHJcbiAgd21lRHBQZ2h2b05uUXFIOUZPT3FCYktJbG1JUTJUUnBSVGNDc0JIc0tHMS9IRXFoL3hFVmxha3NGTzVCUVNRTWlWdjBNQ0pQOGtTRlxyXG4gIDNaWnJqMmhtRUNiV1ljKzcrSVpOc3JGUnNFWERiL2NHL245RXNZdlBLWklKMndIMWxRRWp1eG5SVFFvT2c1aU4vS3pGa3BIcEJ4OEVcclxuICB1ZkwrdWJ4UExlS1pqT3NBV2phZy9vd0YvY0wzRFR6MEVvRmdWNU9Td2ZyM2o1Q0NnZ0xKV3I5Rzl1bmVVVWo1MGFCKzZmbWR6SlUzXHJcbiAgREthOERhdDNMUlY3SWl4ZnZqb1NOd0lzMW1OdllQMjZLSzBybDVFdTY5WnZrSG56b2k3QVkvK01WVm52Q1B2RXBZS2ZQbU8rTEZrU1xyXG4gIG5ZSmhiMkp4S2UzdU1RTTU0TkFETk9RZnpKbmpSakt1ZjFSTnlZLzA3UXJRcTRDYW1XdG14RVhUUWVmd0NGNnUxbkxsSFg0WFZ0OE1cclxuICBvM1RjeUVrN09qdnV1TnVNMm1OaWowWFNPT2oxUWt2TWRoUXE1dXR1NnZoOWtZTHU5OFV3WW45dGdnb0o5OFVpOG5HNGxhVXZLWTJCXHJcbiAgMkl5UDYrYjlIbW5hcEM5RlNEVVhSWGpEbDAwU01jQW9tT01kbUxHMVNvT09PbCs2Z1hsQkVzR2lvMGt0L2svQnNjaWc5SDhIOXRZeVxyXG4gIEFzbkRQT3pNbmhXR2ZVc3dkVEx2eHJ4K2g4M3UzUm1qNTkweno3MEJSa0VxZGxPRkZoZHVqQVM3QW14c2dDRGZLSU1pUTIrZ09uVVhcclxuICAwK3U1Zmt3NkV4eGhiTUswV2JObXViNjhSYVdQM0x6OGhGNVd4SFdFRVE3T0F4TW1USlArL2JxcGFncHZJakx1Ymc5RXJodTI1d3ByXHJcbiAgbmtrMm8yQ0hEaGJmc25Pb21sbFpsaTZORXViT25YMWFwSjJGdVMrYml6SzJvZmlZbE5KVVQ3c0ttSENpZWRIMzJsZGxOby82eWF0VlxyXG4gIEFra0pyT2liSEgrSWlWNTB1NGx1M2dhK2Vpd1M3UXZ2VkdJWHJ1VEw0YjhnUXFSalZ3NitaT2xLUU9TWUt5UWFqUUhxUkZVMmJFV2xcclxuICBCcDFYcEZSb3JkQTZEcVhzTnFURTVaU0toU09SUVlkU0x5eTNMdTlFL2EzcloydXpwajdjdE5ablcvWHc5WkVjYk00T1E1VkdQcGdLXHJcbiAgOVFTTEdkN3RGak15bzdwczVrd3h3em13VVduWkNyRmVMQnVXeE03ZUZqdGVkZmVJR3MwdXNMZGhqUEgvTmV6RTh5THZGYkMwTVFiZVxyXG4gIEUrbjQ4YkF5TisxR2ZjOXcwZ21aQkpaSCtnemVWWHdoR3dNamZHckE2R01Za2J1UDNHQVNOOVJhU0tURWdvUWROc2didDM3QldPMVBcclxuICA4UWlQZHdodWhWbXRlTzFBVFpoWXRteXFYSExGNlZMZUVlcS8vL1llVW1ITW5yMUltVVk4NDRqSG1qWHIxS1VYS1dWSGRYZDBITkFXXHJcbiAgaTBXMU0vUGg5czdqTnlhU2tNQ2N1WXNsemYzT25ZRmRJMzQra0Y2OW9sNXZkcDIvL29wMWNObGRiTjVjbk5DV3NsZStxc01QNmhsSlxyXG4gIEtVQmFFL0x3NDlGalNJbDdNSDYwczIzUGorNkpPeGJaak4xUFZEV0lHZ0lkZ2lweExRUUlINHpXU01Yb0d6NGhLUHU0bERnRXh6YXRcclxuICBpUkppVFFzU0VPL285THpXSUdzckI0aHNodmRIeTFsSUIyNjd4ZUIvK3gzQUhXYUtYYURaZ1IySUtRa2pYdm9vM0x4WnRwYjFobXJjXHJcbiAgZnkxZGV6Z2JMOUh2eWFrWnd2U3pCSkg1K1VZZ0VwWDFkK1ZsK1JHTk1RT2E1azRyMVc2cFUvMkNEY3VtYVJ5TUdkRnhtellWUlpnd1xyXG4gIGdJcTFXMmhVTXdpN2lvSm9RT2ZlUjR6Szd2OFFTRlVTbTl3eml0dzFDNVVaRkdTdmpNUlVMUnIxaHRwS1VGZnhYWEUrc1Q2VkczVFFcclxuICB2cEpyZzRQeVZUVzllNWlKV0x3SkhsbVcxWURjV1NhWkZHUXZkNUpGSDJFZWRvNnpHSWdQc1MrQWU5bjA4ZEZPRWxpb1NRLzM3ZEZ4XHJcbiAgdThGL2E5ZjZmclE5eG1CNXBzSTVzZUlCb3dyRHR4WGZnMk1SemcwMTF6R0JSSE95N3d4YUtQME0wNE9kaDJYakxXM1NwNzJGUkxtNlxyXG4gIDlzb1ZlKy9mVzQ0OTFydno1dVRrU0dHaGt6QkN6MzFyeWZZZmpEOGFYNGR0MnhjcVIxYnVYd3hSc0xyQWxTT2I0ZjJKUVdaWjh5SXhcclxuICBGMXF3YlZCaUxHelVGc203VlFxSVF0OEdjYmNWdSttM1RPVUEyR1AyaTFSODloMXMyMEFrT29BOVU4TDdyV0NSVnl2NUZOcS9hVG5zXHJcbiAgUW1sT0RLZ1pDUEF6ZFJZZk93eEVaNXh6eDBnN1lpQ1lrT0EvNXZpd1BGYlZXL1JXZDFDSUVzL05qS1EyNnJWUko1S0xkUTFOc2VIQVxyXG4gIHZOeWdTakJuQmNoZkgzaCs3U1dFTXgvL3R5S2xRbm1wMitXSVlHdnZRRk9RQlBPclpBUjJLMmFTQkx4WDNobnZnM2VLbXpmdnJXS2RcclxuICBsdnArMWJra2NIOUdiYlYyM2hqSlg3ZFUrd1VNaFhjWkRrcGtVQUhDVElXNWRRenBWUnhUY29NKzNNL0Q4VWZXMzdrUEdBa3FyRldyXHJcbiAgVmtsdTdocjUrc1BIOVJnd0ZVcVlTZGhJdTdTUlBhaGVQVk9sQTFCYWVnL09MeXJhckcyenNNMnNnMjNhSkhBY0NOSjZKTUwyOGs2RlxyXG4gIDd4RjFHcHFab3NEemEyOWg1blpTeHU4cFdvZm1NekhzdGEvS0h0dktOV3RsMllvVmJ2UWIyQ2Njc2pmNHpMR0dHSWxoQjRpMUVjUWhcclxuICBLV2huTzFVNDVnK0hLd1ZsWGZGbmF4Q0pUVGxjTHc1eGg0aVBpSy9OM09kUlJJOVdhZFJOZGZ6azE5b1cwWHBaT2lNaHFUMzJjeU94XHJcbiAgYlQwMStLaVJKakpkZTNiV2xwWGpKUHZYdTdXTWkyTjZXcXFxRURGbUUvVk9SUmdJdGlkR2h5VWhiemcrYUVzN0FhcTNET3dSNlpXMFxyXG4gIGJNVEFFaEdTa0EraXBJd2g3c2N2L1BWVmpaQzNVU3JFeWFMTWdaVmhPdFhLeS95YVFVcVR6Q1pkM1RHZnl0dXk4R1prUmcycGV3TVFcclxuICA1cktWL3prYnk5NUE4d012a0FvMWR6MUlibWV3YXVwUDByRFhpWUZFRWMyZkJuSVgvYW1LOG15bUVvWUF1dmRhdTlOZ2RjZGVPK3MzXHJcbiAgV1R2bmQzMlg5SjNWMDM1U2p5dURkUUg2eVlZZ0hnaFZWWTJBUVNDbG11U2J2Y1FuNUxSNS9NTk1oRExTRURhUTlkTytsbm56ZlBEalxyXG4gIGdJUDZTcDgrWFpTbzQ0bzdKcGhLTmhHbzgrQkRyd1piVVh6MDhRKzZEak9lMGdDUk4wSlBITWlNR2R1bWxpRUpZaGkweXozdUNFZ0tcclxuICBreWI3TE5WNGV1RVFFRHMvZStuTXh4Qm1RaVo1R0ZvNUF0K2tpVmNsL3haSVdyYmVFeXdORE9oMTZ2eERLaXlBYTdaMXBweU5tMkllXHJcbiAgUlVySXd3ZEVreDdHSW80ZWVZUjJKandlZ0dQYlpsc056bkFyc3pOdkQ2cW1DZGR6NWFqZk93ZGlGMndrNXJwb3VhWDhzVzBCMDhRK1xyXG4gIFlpa2FxamIxaVFvVFFRM1N3VVJTOGJBRWkrc1hqWmV0MmZOazg1U2xadkhlQUFERXBVbEVRVlNYWlBYdysyWEduMTlLYXRreW1zcWtcclxuICBzSGl6RkR0Q2dJMGhtNWtOSGNpT211YWtEU1FLN0JzNk0yRUFQbDRrQkpoSWRIS3VDbXB3Wno0UVJwbU1VRUdsQmgwMXNSMHc2UU1nXHJcbiAgRGZrZ1N2K3pURDBGb3pFMUNNekhtRVpXcmpRMUd3aHpQQ2pjaVJzV2VWVkZlSEtpdlFFSWM0UDlqZysyL2p1Ulh0R0NXWGNScGZRalxyXG4gIFFEWUJzTTVKa0x3am1MaDZIWWJPMmJCMmVYbExNMlBPRVFRRjRtbUYraXNuc0YwMTZuTzY5Z1ZUUVlZbERlMGpiZ0drMndIMHFmQWNcclxuICBJV1R6RFRNTkw2VW1hVjlrRUlNRXRQNjdxeVF2TDlkOXI0VVI2WU9wSXlDY0VPcnZ2ZzhTaVlZUW1aSHZ6NzhUWnRtRjBIS3VFZDk0XHJcbiAgMjRFaEVZTXBqVzZFR1EySXoxS2JDTkRFenAyaXdiSjRmQmwyaHJtVkJqc1hHNFhaVVpoaEVleU5oSXJGd1lSVUZlS2kwTUZlWXlDSFxyXG4gIEQrb2xUWnBGUDRBWVhocjNGc0txcDIwejlPNE9mUHNGR2dUb3k2VDZNTDJ1RVR3UGZ6ejgxMWFXQ2o3WVZIai9lQzhIaGZkWHJ1OE5cclxuICBWc3l3Wm9obmpGYWZOVG1uTE84VVlJNkUrTGdZemNMcllNWjduUXNrZkZHM2taeFdRY3BWcWk1clByOUFGbjF6dS96KzFnMHk5YThmXHJcbiAgWmRQSzZVNDY4ZTB4aUtRNzQzbTAza2swV3haOHJ4Skk0YWExT2hxa1NXWStCSFpOYzduTVlMYTU0Sm9ROW5oWHpKd2xVM1F1RTFOSlxyXG4gIG9jOG1ZV0sxRnIxaTVuR28xKzFvWFp2VVVhdkRRZHVNcnp6UklrZFdmNVZlZ0UzUXhUellleHNWcS91UDZ2OFN5R2NHVmszN1JkZDRcclxuICBXZFh1Y0xBc0d2MjJ6aWdKeU9lR2hFRkdBVk5MTWhpcjMvMDRIUWpZb0lLVTY1b0xMUmhNc0o3KzJWRHRDN2FFUWQreHBLa0dHSVZKXHJcbiAgSktSb3A2dlo3SVNabGRKbDVhcmxrcHBhUnI1Ni8xR1ZQaURTcG5zUEUrd3d6QzBYTlZWOEh6T0V6NDBmdVJ1b1EzeEdPUC9WM2t5QVxyXG4gIG1LaXRXTVlSODdFbkJQTzZHMHphU0FSakpLWDkxbDNCMU9uZTN2dVAyVUJBdHo0OUluYVFlQlFXZVVJZXpzVmppSlVhZHZ3QVBWeTlcclxuICBVcXBhYkFITUE0SUpZckwxSmpqUEdFMDhJT0NSWU1XNDg2S0pFNU1pMGtlbGV1MzFvNGl0SEh0aWRCNTB4MVFXdWs0ZE9zd2NJSkZrXHJcbiAgaWc3a3BjcWFhN1lIZjcyVTJXL0s5T2NPa2JWclZzdnFOVm15S2VSbW1KS2VMRW1idDBTOHNZcmQ2QU9IQnV3WmZQeUFaSXFNK05ZRlxyXG4gIGtnbWpVajdxbkdWVDFRNWlvMHFJQVl5WDdmQklzN29qR2hoWm1TQ0t3RERIQllNaklsUGV1MDZtZndwQmlZNHl3YlJQUEtFeWlRVmlcclxuICBSUmtDbERYSDMwZHVNRlBneHBYYmV0bnNMYURHeXFoVmVnekIveVNhSDN6WlhyZC9rTytxNVNGWGFibFd1LzExUGYrWDV4MnozemN5XHJcbiAgeFMzdndUenFzdWFRTGJkZmhPa1RLMkxxcWhsZjNLTnJrejRBZllUNk03KzhKekxRWUUxLzRSajlLajVna0lHTDc0UFJkdWl0clErL1xyXG4gIFZhYS9lWWJrYk53b1RJbzI4T0FvTXpMN0JXalJJdW8rRENEQUdlbHBFVUk4Y0FjRXM3U1J2dTBuUGlNcks3dlVlbUhNbnJOSW1RNHVcclxuICByb0J6dG5jZU5JTnN3V0ZtRmk3bjVTZjIrZ3dEUTcyaFljTTZrZlBEN1FDYjkyVFI0ajIzSmE1MGtwSktUd25jalBjYUF3SHFQdXBwXHJcbiAgbHlld0FUYm1iSklxcVlVeGtkMlJtSkJ0MUU3YlFiVEpBSDY4NFJNb2VtaTByZFpMaWtSZGI1dDNLeFlRMGJTS29laHBUV0VDQVM4OVxyXG4gIDRBZ3dFK0d1Z0FsMC9Eem9TQ1RqblBTQzBUajhvNUxVQXd2N0IwdG00KzRSMjh4M1YyWEtkMWRXa2Frelprblcybld5TWJkUVhhZkRcclxuICBaek1QU0lsN3BjeVBZRDZ5ZE83NVh3OVR0UVcyRTlLM3R4cHlXMXp3cEdkK2JRSjFsVEZOUEczcWRUczJVR05GUDJqVWNVeFhpK2VXXHJcbiAgcWk0Q2hsQ3YyekhTb05mSnVnM1l4L3RGMHJCOUJvZ1Vrc2Vxdjc4UDluaUVVNDduWnljT1h0cGRvTVpxTmVpR1lPdS9DOFRMN0czN1xyXG4gIHg2eHZIcExVY243d1pHemVnZ2tYLy82T3RCaDBtVElFdktrQVV3L3pyc0o5eWdZRE9FbFF0K1doMStuYUdFYTdvNGM1NmViSHlDRERcclxuICBNdzlMMlI2VjBHMmJmaGJOT09DdnhEd3lNdTk5TjdwZUlqV3JWNUdyTGpsVjl3UFVUYWFDQXZYcVJtY3ZCZmMvOExJZWc0QW1JdUMyXHJcbiAgSDhTdnd6QUNIRzRqVVQxZysxc0d6SXc0azUwRk5oVUdkbUhZdGN0bHhHWm1TQVM3ZGp6RGlBZnpub0JHanNuc0taYXQ4QTVHellJSlxyXG4gIEJNUFlxd3drT2FXTUZGdFBEWGtqNUJXNEVjUVdZaitDcnVsV2lhYTNqVUc0RjhjZ2VvQ0lXTGFqcVE5MkFYSHRGMjZNaW9aaGhOTnlcclxuICBsQWFiT3lONzBRUmRFdDE2bWRUWXpvRm5WanhqUTUyMEpYK2pNcEdzdHdiSkQvK3VKNlB1MjArK3Z6b2FUMEhiNm16bDNselpqQlNWXHJcbiAgT2d6MzMzTzFuSG5tTVpJYVBIcnFscmg2V1ZsWmt2L2psYW95cTlYaEVOMGZWdXNaQWJIUm83bnlibGc4V1phTi8xZy9mbjhza0NBY1xyXG4gIE03R3lvV0RqYWxmM0Uxbnl4enZCSHM4a2FyV1BWVjJoc21wM3pGQTlWcjI4ekRlcEJJTTl4Nm83cGxLVTY1MHVMTjVnYjRKUmZ0WFdcclxuICB1OGI0LzJrMEdYaldYcGMrd3BqK3lURDN6Rzkza3VBd0orbGNydnVZNEF1YjM5cHAzK2NqQ2ZJZVNNTVBvN2YzTmM5Sksyd3JRNEF4XHJcbiAgdUhwSUpTME91VnFaeUhRbmhkSVAyaDRWbFRxYkREaGYxNkJ1bDZObHlSamZINUJ1c2Q4eEJVRzlyc2RFYkNFbHE4WksxcXpoTW4vK1xyXG4gIEFnMnNPMmhBTnpsa2NPeGdBNklaWmdSaEVGd1lKcWJ4aEpVZ1B6dVhOVXY4WE9JQWczYlRPQUlaMzVhQi9kZ1lFdDFQYWZnMWFPdXZcclxuICBpVE1pMDRIYitlYUoxYi8vanRWbFZ0Y2tDN1BuVEp6a1hlQnRlOFpNYi95ZmtpQnVabGN4ZlpxWFZoT2xSTm1yREdUd2dkRjRrRERnXHJcbiAgSlhrbGFYRzJDQkJMYXNPcFEzWUhxZVdqVWFvMkZ3RmdDazJQOFBWQzVZaUxaMUpFK2lEWUVZTml4TUFiRDNjNjA4QWFqSW53OFlVVFxyXG4gIEVScVlWUTJnd3NwMGtnanJjSlplUTBwR1JSbjM3REV5WWRLa01BK09vRUh0Mm82d3BraGFScW84OCtnTjh2a256OGpmZjM0azB5ZDhcclxuICBLdGRjNHdoUjNScnkxanNQeXBiZ0o2VTRobzVoTVhmVFJzZHNLbnBtNEJZa0lBTWZkV0V3c1JBd2wrYWlQS1pDSFNBVmFyZVVyTGwvXHJcbiAgYU9CWnpZQjVxQVRoamxrS2IvVG43WTRaSnYxdkdxN0VpT040akpua3NYYTI5K1NCaUNGNVVHZHRyalNGWWVBVlZxdjlnYUZBUS8vRFxyXG4gIHcrazI5aFlZNVRmc2ZrYXc5VCtQdENwVnBNMlFXL2E2OUJIRzZxay9CU1ZSK3dmUDN1d1kyU3ZuWnlDSjhMNHNQWTFOSjR6dHcwOXZcclxuICAyOTlKZ3l0azBsdFh1RUhDcCtvV3pQbktlQnhqWUhaQ2l6WmZNT0lGM1llR0FVY0ltLytqUnV1QkVXbGt4aGZEM0dER1M3bnpQanhQXHJcbiAgMzNiMWFsWGs2a3RQbExQT1BqNkdNRU1RalpBbkl1Z0hEUFFxWWV3Z3BSRjh3K2JBR0d4RzRUQ1lscFlvYmdJVmFjZTNGVXVmd3NCZ1xyXG4gIEg3NWU5SnpFTU1MZVpaODJVaVZ1NnR0WVQ2enR3K291V09EbjN6RWJ4ejZCZXNtMmpSbnVUdWJpZUJCRVdOcVQyS3NNcEZ0dmJ3ZUpcclxuICBUeE9WVXJhcytFbFd0NldJS1RFekVEckNIWk1nY2Rld09SU1BRVENiTWFTd0wzcEN1TTZ1RWVUQmZVTm95NVJOMzI1eVAvdUpNQkd6XHJcbiAgZ1dBd0xNMUZHUU02NmMxVmhaV1VwT3N3Umc1dElpTnZieVRqbnp0V1Vzc21TM0pxc21NU1RzSnc1YkxwcWJwc0x2aGJ6anIzYVBudVxyXG4gIHl4ZmttOCtmbDZiTm02cXhqUGtSR2pYelRQTFR6MytXNmpXcXlienBYK2s5d29TUzNMSjY5V3JaTk1aN3RiUVpjcHNhTXRjR1UrUGlcclxuICBmVlcveDc4aWFrZWJFTXBHbmd1R3Y2QU1OWGVOZjQ0V01NWmtVUkFLQ0pKRzVydUxVUVpiM1BPMzVIMVZHblpVVlJhU1I3Z1BVSmQ5XHJcbiAgV2JOR0tWTlordWZIdW4vOXZPMFRnajBGby8zR0EwNFB0djVuMGVhSW9mOEk4NEJSSTNVQW1ET1kvc2xRdFgvQUxFenFBRWdpczc5K1xyXG4gIFFCcjFPVU9tZjNhWHE3T2ZxaWlCVGdqbTBIRGZrNlR6cVk4N1J1THpSS2thaTNaY0g4RjVSTjNBWGZkaG02Vm1tNEZhejFTZmEyWU9cclxuICBqOFJEbWZTeDV2VitzblRwY2swQW1yVnVuVnh6M2ZueXpudmY2TEhTRUc4VUpoSWNoak5xdEIvQXhVc0YzYnY3dVdjZzdobnA2ZHNjXHJcbiAgTnpScVZGZFdyMWtYUTNCM0pCRXd1aWVlbzdRMnd3alh5YzdPaVRBYjlwT0taWHZNSnd5clo4OGhQMGc1YitsWjdEcDcwNGorNDAvZVxyXG4gIFRwa0llNVdCQU1nRHNRaW15UUlaYWFsU0lUV3hPMWx5bk9mU0RsVmJjZEFvOEZMZ284SzNHMGtTd05VSnBCRG1RNGNZbHE4Wm5jcHlcclxuICBBOTVRQ1lBK2wvcElIeWtaVmFTSWtic2JUZXZFVUFtdWlnMEV5WU41eFRjdkhTVlQzamhIZnJxeG9WdWlvbUVaOSt3c295NlI1V04rXHJcbiAgZTA5eXMvL1NCZEFoNkNRODV5NWRDSHFNeGVPUGVCMy91eC85S0JkZmRFS0VYT2R0eXRONEhBSWxWUUp4OXh6MkFwdnhtUnNWT2daQVxyXG4gIDJnc0lnQUZQbkxhT21FQndVRWVCVGNFRVJVcGtTa3FVeU5UdGZJU09WS2Q5T2xRTjZYVzZIcVV6RlVLa3NoZFA4UkpMSUhrQTZtNWFcclxuICBzMERhZHVzL0g4SVdSdFdXK3ptbUVnMWMzTnVBWUxjOThuYXAyMzF3c09kL0J2K0U0VHdlTUpLMmpwR2d4bXFyRE53ekVwaEw5b3h2XHJcbiAgMWpjNzRDTGRsOW1zcDlvLzZMKzhLMUFoY010R1ZXVmdpZ0ZBbjhBRHIxaW5admFNQXNrVXJ5OENVdWQ4LzJqVVVCNThDbmpwVlE5eVxyXG4gIFhGV3JWZCtOb2hkSS9xWmNQZnpPeTNmTGh4OTlMeSs4OUpFZU54eDRnUGNTckYrL3R2d3habklNSVlhWVB2VHdhN3FtWHZpWVlmaUlcclxuICBxT2RqL2ZxMXRHNmlldk9jOUZFelNPUE9jVWJ3STBjbWppcm5PRWJxamgxYWFub1UydXphdFYxd05ESHNtcXhuelY0b1cwS0pKNG15XHJcbiAgRDAvK3RqMVlPMHVDSEZvNEVJRDR1VXZDMTl0VDVPWVhTT1BHOFduNFBmWTZBeGx5U0M5cEVPZGVocDRTTlVXcUk3S0dTUHJ3UFVBOFxyXG4gIGlRNFRST0lkQVBOemhKbEJJcVJYOXNaMlhIOVJZV2tFdGpzUEJyRTk0TGxFL2V6RmYwV3lDdVAzbmtpRmhkcUtlWjUvdnFXRlRIemxcclxuICBaUG43dTZkalVtY1hGZmpuZ1FjS2pLTmc0eVQ1L3FzWDVmTXZ2UHVsZ1FuLzZiQXdFdkxjbUs3VE1QU09aN1RUM0hEOXVVNGFQRmc2XHJcbiAgd21TQ3QweUdnTDhmNlNuVmE5V1RUQ2MxYlFtdXo4ZVBBUjFzWERFcm9zNWkvL29GNDcydTJ4RVY4NWlEbVVCc1lBWXdEOTRERElGdFxyXG4gIFUyMndiYUN1emNTWVZxbUdJMUJlOGxqNDIrdXF4akltMSs1WWJDTWpkVHJiOUNDMzF1YjhhSnI0dlFtWVNPZVRuNUlhN2ZjTjl2eG5cclxuICAwWHpRSmRMeWtDdi9NZFZWN1k2SDZEcDdZVlMxaXZvcWU5RmtIU1NBT2FNK1VsOXBtQXdxU042WnZRdTg3QnIxT1UyTjU3eGY0a0U0XHJcbiAgenJzMTIwZi9HMzZXaFNOZmlxaXZrRmFKT3lFbERqRWRqZnQ3ZXdnREpnTmVoVE8vR0NyejNqOVAxbWV2bG5MbE0rVDBrdzl6REtXbVxyXG4gIEhIL2N3Wks3SVZxWGZtNlIxU1FkL1A2SGJRY1ZOamNJZGZjLzhHd3RoNEg2aGUrQlpWUWdwY1NEYy9GYzdOV3JzOVpqT3o0cFlUendcclxuICBTQW9UWnd6cDhhcXBNR2lUQmJScTJWalRqdGcyNnEyMHNva0NqTGVGWGRPeStKcHE3TytwY3lMdG1WRi9VbUFYMlJzb3pSaS8xeGxJXHJcbiAgOXo0OVpNaVFBN1FNT1lmUDRoV1V2eVZWZGFXRzR2elk2SFJEUEZQWU1hekx1M1BMSkV2NTZsNlBhMEZ0T3dPOFQ0RE4yT2VOOHpzSFxyXG4gIG1FZVZobDZGVmFWUlY2bXMwc2UyR0g1N2E1bjYxaG1xa2tJOXhUcXNubUpCeW5qKzZXSEtQT2dNZEpaNEVaVFp4Y0o2NFRhdG04cTBcclxuICB3TWdGaHQ1MnNhN3RPSlBnUC9Mb3pWcmVVcmhaMXF4Y0t0TmZPVkc5c01KMkVDU1FhczE3cWNkVldxVmFZcE04a1piRW1BS0FjRENTXHJcbiAgaExtc21PelZEU2F4d0V4cXR4K2tvOU9jNVROMUpPdlZKZjBsclhJdFpRNlY2clYxQkd0b2pEVEN5Smd5KzZaOTdFZkpsZ1llZmJ0TlxyXG4gIHlicTNBZkh1ZnM3YlVxM05qcU9JOXlaYUhYYXR0Qng4OVQvR1BHQUkxWnIzVkRmZXFzMDlnelQxMWJJSm4wbURYaWZwKzBFZGhTUkNcclxuICBnQ2VTQ013RlpzOVNzVllMWlNLb3YxQlAvWHJmQWNvNGVPOE45enRGMjZRdk5EL284a2dXQS9vQlRBVFFqeGFPZkVITHEvNysxa2tyXHJcbiAgcmgrMDZpK3BLV1drZk1FQ1dUQnJyTlNwVlV1YU42MG5aNXg1ak5iNzdQT2ZZeUxKNmVmbm5uMU1oR2pHZnd1a051bm1SdjUyL1BaYlxyXG4gIHZUUVZCcW9jdm9WaGJtQjF5c21IeTUvanRwMmZocGtJbVFma3NjZmZqSHczNjdOelhMdmJmc3NjWjdIOFcxeWJCZVA0dE9uUjd6QWVcclxuICAwRFVqOW5hT3dXc1ZkbXhBVHdSN0poM2F0NGkwYjI3RmE3UDJQQmgzeFlvMWV1L3h6OTZ3MXhrSXdNdkEwVWhIN0lMbXQ1WklXa2x1XHJcbiAgWk00QllBRkdFS3VDa0FHWGViNTNGcDUxNElYbDlmKzBaVWlyR0d2OHhsQzhQZVNzbU81R1p0SDgraVo5b0w0cTJwaDRwanpjZUtQTVxyXG4gIG8wdkVBOHVyc0Z4bnU3T2pqTHlqbll3WTFsYU4zb3lXYk1SVW8zSTFaUlNtbmpJVjFSbW5IeG5weEt4eCtiTnRnd1U2TVdLaTB6Um9cclxuICBFT3Q4d01kaUhUUXRyYXhjZE5HSjh1Y2ZiK3QyOGVZU1dUeGprc2pVVjNUYkFCR1k5ZFc5c21qMEd6SWRkVlpnNURTQ0FPSEFpSTUwXHJcbiAgcHFvcFJ6ekl5VVhRbzBrZkpGQkVTaUZ0TzB3WjJ3ZHBTZ3d3RGlRUFl4eWN0M1RjcDZyR3NsZ1JzR2JtYjA0cXJLa0dYRUFDeG44S1xyXG4gIEVQR2U1My9vUnN1bkJYditXYlE0NUFwcGR1QkYveGp6Q0FNMzNqWkRiZ3pVV0xIcXE5Vi92THErOWVGZTNWbXVSbU5sR3NzZGN6R0dcclxuICB2OUY5TDBnc01CSDZRSjNPaDBuZHJqNDRkUEh2Yjd0M1NJeEhSZDBPSjhIME5wRCsyb2ZhSE9tbFdzMTA0SmJsbjU0dkU1NDVRcFl2XHJcbiAgWDZMTTQvWG5iNU54RTZMWllvbm1QdWpBYUJ5VXFhenV2ZTlGNmRadFd4WFJCeDk1RjNDK2p6QkJOb1QzM3g0TXJLNjc5aXhkaDRFTlxyXG4gIDRwMTN2NWFlUWZRMjV4eDFwQjhFSjhLNDhkUGtsVmMvRGJZOERoM2NkeHNYNHpENnVUYkRSRGg4YjZ4TFU1ZUZFYVlEMWxhNERkdTNcclxuICBhclczM1NieU50dFZUSm8wUStsc2FRUDdmNGFCcEdCVFNISkVxRVJqRlZpS3RxWkUwaVFBdFJja1FGb1FEYjZ6eUEvbUdFZHNOdFVMXHJcbiAgNnF2Q09LSy9mY25HczZLTnkvMWM0d1pVVk13SlVqYU9HUm5DWGxpLzNkdERwcjV6b1V4NTYzd1plZGMrTXVhaDZJZ0M2UUtRWmdUalxyXG4gIE40eGp5ZEtmNVpmaFkyTTZCYkJ0NnhnSDdMOXZwR3dnMEFuODhjY2tPWGhRYi9sdFZEVC9sdFdOYjdkRDE0N3k2ODh2YXJuWS9kdzVcclxuICBzK2JLaWhHUDZyYitmTWZrVVdNWk00NHlqcWpra1ZvK015S2RxVXFydUVnNm5uQ2ZNZ1J2QnpuYzFlOG52ejl4ck16LzVRV1ZBc2wwXHJcbiAgN0tVTDN3NVNCakExMXUrUEh4dFJZN0d2eHdXdnlkU1BidE02NGNSMHBCZi9wd0F4eHhXMTQ4bjNTMHE1SGZ2aTd3NHFOMmtsblU5N1xyXG4gIFRGb2NmUGsveWp6Q3huT0RaOXplamRjWXljUlBIOGhzZmNRTnVtL3B1SStWYWRqVDFqYWNGRW1NRG12NkFGTGw4Z21mYWorZ1hLLzdcclxuICBzYkppNHBjYVROcDA0QVc2M3h2Vis4dThuNThPV3ZKWS9QdWJPa0JaTldlTUJyYldxRjVOWG56aWV1azlvSmM4ZU44MU9naWkzNzcrXHJcbiAgeHVjeGMzdHN5TmtrVHozOWp1em5Ca3BNN0JRL0NyN3JEdStTVEVaY0JrMkpZSU1wdmdmSzhkOEZZQjhNaG5yUjd5Y3hRZS9VcVpWY1xyXG4gIGU4Mlp5bXc0ejlvakQ1V2R1ejJFcjA4NUhGbStJNFRQdGQ4RWJNMWdFYlJyNjFYMnBVa051NEpwVTcxVU5URHdkb3ZIUDhKQWpqbWlcclxuICB2eHFzZ3VuU25lVEJESVZscEF6dVFEdEE0UzVJSUNDanFpZDRXd28zUlVaRUViakw1YTd4RHlBdE5NdFphYkJyWXhpM3I0bTVNdExqXHJcbiAgWEhtVDhsZkwrS2NQbE9rZlhDNHpQN2xDcHIxM2lXT1kvaGlTQmdzdzFSUkF3c0NtWVMrZUJUMm81YXd4V0NlMGpzODYvdU9nWTJEa1xyXG4gIHd3T0Z6S0R4T1dyc2c4UUhucnJXd1hyMjIxY0dIOXBQSEgvWG41ZVRzMUhtUEJRWTRwUEtxQm9MQW1ENXI0QWxWNFE0bUQ0ZG9OTENcclxuICBqUmZBUENpYkpBSmdHRlVhZFpJRkkxK1dsWTRRY1l4ellCSURiaDZ1Uk0yWUNlZnNlOEtOcTJaOFBOUXhIWE81ZHRkMng0MXgyR3g0XHJcbiAgL3hRZzZxMFArN2NNdW51cU5PenpyMkR2bmlPOVdqWHBjTkk5MHZ2eWI2U2xrejcrRTVJSE1FWVNaaG9tZmN6NzVNWU56Tk5CbmpjY1xyXG4gIEhsb092a2FON0x3empqY2RjSzVLSGpDS09UODhLU1B2ZGNSLzZvKzZyZTI0WThzYzAyRTdIS3ZUdU44NXNucjZMenFZb3c4QllvcFNcclxuICBWd3lYcFIrZUpZdm5UbGV2dmJkZkhpb0REeDRnZDdoK2ZkME5EeXZ4cG8vR1M5S0h1TUVScWhuNk1ra0k3ZHNBOWcyaDBpMXhBMVZqXHJcbiAgQUdHUWVvUCsvL3dMSCtneGswTGl3VEZyTDhwa0V0T3FiNzhiRlJ5UHdzNHREWGJNVkV6QTd2V3R0Ny9TOWM2b3NPeWMrUFpzUFQ2d1xyXG4gIGZaaDZiVzlncFpObWVCTFFta1Q0UnhoSWg2NmQ1SzFYN3BCbVRlc3JzV0p1cWZTczhaSldKbXJrOWlvcy81TENNUWdSSkg1L0R2RUhcclxuICBnbTFId2NQenE1c05wSHdOejQwTE54QjRFem8zTkxvRlNCK29ucFI1T09TdTljYnB6Y3QrbDhtdm55VmpuemhFeGp4K2tJeDU3QUFaXHJcbiAgLzlxcEVhTTNLaW1ZQkhZTkZxU01FcmV3amxkUDRhbGhMOTg2QS83azhhQkQwTm5wekxmZGVsSENqcy9IOXR0dlh2SlltbUFVdzNWd1xyXG4gIFllUUR1dk91NTRLOUlyVnJWSkY2OVdycU80SG56Vis0VUdiYzIwS3ExWXNHRThKRUFITjhxRnR5K0xHNUpWeEhwWXNRODRDWnRJdmtcclxuICBXSm9pVGZxZm82b1FBNHpJN0IvR1RLWTZ3cGJSZkZBdHV3ekc5REZQbjZKU3JDVlhCRG5MWWlYRWZ3SVErUGJIM3F2U1FxZFRIbElHXHJcbiAgc0R1bzJhbVBkRHIxRWRuL2xqK2x6ZUUzL2tjWWg1ZnFTcGMrMmh4MXErNmI5ZXQ3bGV0MVAwWm1mL3VvOWdHT2swRVo5UldZUCtJbFxyXG4gIEhUVEJSSWpkSW1jVzg4UHc4ckdYZ0lneGZjWnczVVppWGZqcnk4S1VBUXcrVUdHQjFkTi9rbVhMbDZzYmVlTkdkZVNCT3krUkFRZjVcclxuICAySkRocm8rdVh6TTY4azBjNWdZM0JoczBrVCtLNDloSHdpQ29MWHZEUm8zcDRGdUtIMlNCbjM4Wm8rc0x6ditYdHNGaTMxMFk0WFB0XHJcbiAgVzhOWkpSRk9PdkhRb09SUnFWTHBjN3ZIZzI4eDdEbkp2ZXk3bmVsMVM0TXhETm9McjJHMndJSUh3d3hyZHpGNlZPTEFhTU0vd2tCQVxyXG4gIHo3NjlWQnhGZlVYa1B2TWFWeStmN0QyUDNMN3daRTFoNzZsdHBJaWRoVEtFcmU1RFdDQjVRZjZlM05Da1R6dEN4YnB0SkcvZEVpbWZcclxuICBNMGttdlhHMnpQandhcG41NlUweWY5eVhFZW1pU21iVmlFUmgwZ1dNZ2dXMWxIbE81UWZsZU9qVW11NWxzOWhIazZoRDA0azV6dnFiXHJcbiAgYjMrVmUrNzFxaWNENTV4dzByV1JjK3ZYaTQyV3g1RE9zV2VlZlUvWFlaZkJVMDQ3U3E1ekluanR1alVsMWYydWd2eENtVGR2dnN4NFxyXG4gIHZLOVVyTmRXQ2NHQ2tTL3AybjU0UkozbGlBWU1nQVhnZlFQRENETVBZeVpMeHI2dmhuREtZT1dVNzNXRWE4WjQ5ak1pTm1hQ1ViZW5cclxuICBrMExHdlhDTzdqUEpvM2JuUXlPMmtNZzg3UDh3SVBaSUM2ME92VVlaQU15RXBmbmdzeVd0V2pRclFCZ1Y2dFdYdHNmZUZLbmI3Y3pYXHJcbiAgcGRYZ3EvNWpFc2VzYng2SlRGMkxDdENZaG8rOThkSUg5cEQ1VHZyQUk1TGpLeWQvSTIwQ1psOGhtUHZHSkpjNm5RN1ZUQVJJR1N3clxyXG4gIHAzeXJES05Oc0szcUt2Y3VUZEx3dGcrL1hhbGVPM1dUQnRsam45VmNWcFVybFpQOSszV1JkVG5SZkU4amZoMHZrNTFrc1dMbFd2blZcclxuICBEWVpTblRRUkJ2MmZDWnJvdzBZa0RYZ2hIVGxrZjFWZjJiY1NEMVJmd0w2MVJBaWZXN0ZpK1VqZDBhTkxuOENLKzdGdkx5ZG5VOHgyXHJcbiAgSXRqYzVkUjU1TkhYdDJGMmI3L3pkVkRhUG15cTNmaG5ZYkI3T1Bvb2I3OHByZDZ1NEsrSk15T3V3b253anpFUXNFL0g1aHBVQ0JuS1xyXG4gIFdwL3JSdTI1c2lYd0d3L1BmeDBOdnR1Ni9leThOa1NOZ2Q4WnpvZFZUajJ4WWl1WEQ5SjF4Q090YUtWVW1QbU1GRTE1VGZML2VsNm1cclxuICBmdnUwYkNud0xybm9GTTFUQ3VGcFU5WTZLY21MZFQrR1ljQXM2QlIwUHZTMlZvNEhMNWhqTE5icEV0V3pmYXhSVDIxT01Pbk14UmVlXHJcbiAgb01kcEk5RklZK0FCWjhuRkY1MjR6VEhxdi9mcEx6TDRrRDVTeXpFUm5sSVo5MmZSL0lXeS9vZWgwckJWVncwVVpHNkkrYjg4cStjb1xyXG4gIGNZRDRCMUtITVFIMDJvblVXQk5ldTBpajEvM3NnMGdhSTJUbWwvZnBNUWlQVDYzaFhYWUJCT3V2VnkrU2pCYURhdVd0OXBJZlVzandcclxuICB1M3d3V2dYSDNFRnkyWFEzS0lpKzUvOEVqSm13ZERuMVpUbmdsbkVSSmhGZStsMDdVdG9mYzNlazduK0tjUmlJWFdJaXFCbnUyWnFkXHJcbiAgS2tiNk9QSVdaZWpUZjNtOWNwTUI1K2p4VmROKzF1TzhENFlZbEFIYnpIbSszeFdmYUIwWWh6R1M2Wi9kRWRrMklKRWFrRHdzRUhYU1xyXG4gIG5ZMWx6Wm8xVXJkT0RYbnQyWnVsLzhCZUVXSk4zejNoZUMrWm5uakNZTzJuOUUzREhVNXFOa0w3dzQrSnB6YmdPT29ySk5YNDc0anRcclxuICBsaTA5VTdSdkxkeStnWDEyTHZPSDc3dXZqNVpQcEZLNjYrN250YTdWdHphNWo2KytqajZEZUR6MjJCc1JhUWdubVhQUE9kWXhEYSs2XHJcbiAgMnBTYnQ4MEFzRFNjY2NaUnVyWnZPcnkyZStKNUVET0QvVERSNzkxVmJIYWovNE1PaXAwL0pveC9sSUVVSi9uUk9nTlpOYVp2TkVOb1xyXG4gIG1MakhFbm8vNXQwUjNEbkJhV2IwMVh4WXNVMHBTRkpYZGt1MkZDNzFSckV5QlZsU1pzS2pNdjJOYzJYbUIrZkxwRTl2a1Q4bmpwZmxcclxuICBxMWZJMmczclpOMkdiQlZtV0RENEZSVnNVWStSbjc5L1R2S0wvdFlsWGpWRkI3SVBZOGdSQTdWYzJzdmpHQXN2M0JnSndVanhzTTdKXHJcbiAgWW0ySFlaMEhmU2RSdFBheEFjNWhkTWNNYTR4Q1dLeURnU3V2T0UzT3UrQkVaU0t0V2pmUmR3UG16NXZ0bU1aemtqdnVKYW5TT0NyQ1xyXG4gIFI5UlZJVUtoYWl6SEVMVHNHRUZZallYS2loaUhOYk4rQzZTTUFkTHYzOS9yTVJ3cHVCeFNCdlgvZVBJRUpWd3dtZXlGazJTZlk2OWZcclxuICBNdEl4RHJPUHdHVHd5Rm94eWJzTTQ5MjFKZEdjK3Y4aGhCbEtlUGxQTTR3d3BuMXlSNFQ0d3dpYURqeDNHK21qL2ZGM3l1d1AvNTIxXHJcbiAgMVgxaHhsUWlUQ0NRTkUzNnNHOFFGVlk0WDV0S2hlN0Q0RHhjdUUwU1JVSzFwVjdYbzJYSmU2ZkwyRnZyeXVJbFN5VzFiS3E4OTlvZFxyXG4gIDdyMVhpc2trUy84OTd0aEJVcUdDdDk4OWNOL1Z1amJjZHN1RjJtL3B5emlMaEwrQmxVNWlBZXpMV3JkQlIvalVDNFB0MmJNWDZqcWVcclxuICA4SWVCaEU4ZFc3d2hPakVWdXVYbUM0S1NaMUJtQU9jK0RqL005OWRFdU0wZHQveFhCT1R4SEV3Nk9PeFF6a3RBdU9JUXZ2ZldyWDFmXHJcbiAgc3paZ1NFWVBURjM5NUZQZTYzSlBNTVZKaHp3SlM1T1NDTWxEYjd2WTk3Si9BQVRqdEd2VFZINGY5WmQyN0p5Y1hLbGZOVmtLMCtwSVxyXG4gIFNsb0Y5OXkycVBTQnh4U1QwRENTSUQ0Qnp5YzZOZHNzaWN1Tzk3bUZjdjY2eFZKdXkxb3BtMUZSNTJDdVdHYWpWRWd1a05tL3ZTWWJcclxuICA1djhpS3gyeDI3aHltcXo5NjB0Wk0vMFhSN0I5QjB6QzF6aEFjWDZ4STB6dUx0Mjd4Tk0yTlRsRmpkeEZoWk9sUWthcVRKcTJJUExDXHJcbiAgd2xpMGFMbU9ET3dGWjJkdmxGbXpGdWorUk5HYkgzejRYY1RJeFhFOFR3NE42WDRCKzJtUFkxd1RJK0RYYm9RVHZyNTFjWmdQTG9kc1xyXG4gIGg2L0grYzJiTmRCOUhNTmdhU09Zano3NlFXclhxaWJ0TzdTVUNST215LzREdTB2MnhqeFo3ejdHN09WenBjU05PZ3FXalpjTjgzNlhcclxuICBpazE2U2ZucWpXWFJxTmZWamJkR200R3FCMGRuRG1OZ1AyWHFrRDVtOWQvZlM5UDlMMVJtTWUwVFQ0eUloRWF0Z29xd3plSE04NTRrXHJcbiAgaTBhL0pZMzduaUZUM3YxM1FQeVNOSGxmNjJQdnFyeDQ1QXNGR1RXYnA3US85bmI1OC9tenBFbS9NeDBoSzZ1cXpyUUtWVjA1VnRYeFxyXG4gIGZ4blRQa2F0ZEl0K0QxNnl1MTFUNVAvMStxWFM3L3J2bENrZ01iYnJQbUR4dC9jZVZRY3ZNSmpDdU9kT0Q1d1p2SzJDODNobkxMeXZcclxuICBSYisvTFpQZXVseTZuL2VxbmovRE1aUDFDLzlTNWpIeTNvSDZQbEJYbWEzRHE3S1NaTlBYRjBoK1hxNnNYTDFhS2xZb0w4Y2Z1YjljXHJcbiAgZHRYWjJwZUI5V0dDL3RxMmFhYnhGMisrOWFWR1o5c3hCa09RMUROZGY3V0JVYmp2dzNTWW1SQnZ4TUdIOUpYNzduOHA1ampndkRLT1xyXG4gIGFHZXZ6NUhUVHh1aTMwSDQrekNRSGg1UEw5UnNCQ3JtQmpFVWllb1MxRXZLRUJnTjN6ZHBUeExWU3dUcTIvZHM1eEtqaFEyRjM5SStcclxuICBzRitVaGpmY3VWd1h0Ry9uN2JwMmJkcUF5SE52UmdmUWhDUktmcmdyZU1uUm5WL2NRUFFNOS93NmQ0NkdPSVR4ajBvZ2NOckJCL1ZRXHJcbiAgNW1FOGRzNmNhT1EwOFFJZ0hMOVJPVzJ6Sk9YTWwyU2QyZHNoeEp4VHBNanQzeXhscFVEU1NqWklTdEU2MlRML0s5azg3MnZKV1RoR1xyXG4gIHNpYStJMG5ycCt2Y3pmUCsrRWpkaURGMmsrYThUR0Z4WktSZHBseXFMbUdVTFo4cXllbkpRbmJiSDc1L1JmYnQxVVh5OGliSzIyOThcclxuICBKa2NmZTRoY2RPRUpRYzFZOEZJaDFqYUNJVUlWaWNCZWRqeitkZndoa1hxczZWQUVNTVdERVFVakd6NEVFbFNHSjdrQkdQbElaMEFiXHJcbiAgVExGcEl4Q0QyVUVZZmJFZTdqcUNvVytmTGxxZi9iZ2sxbXRRVjA0N2RZZ0dYVEhEWW00ZXpDVGIvZjQ4V2ZxT1R6eW9LaXkzMlB3UVxyXG4gIE1BK0Flb3QwSjZpd2x2MzF1YXExOE1KUlk3b2JBZmU0NkMxTndGZTd3eUE5QjRtQ2tTdk13S1NRRVhjUERBZ1k5cFdSc3M5NWI2UmJcclxuICBRQ0hSMEJCSnZMUG0vL0NVN3Z2L0VZc3lTY25LUEZJRE4vbWZoKzBuUjcvb1hiMU5qVFhpaldFTlNlMUQrZGQ3RG5DTXdEOWZtMUhUXHJcbiAgcEE4cjErNXdTS1NPSWJOcEQxVmY4YzROTmdYQWxEdWJ5dXhYajVPRkN4ZklraVhMSEJHckswY2UxbGY2OU8raDlaakMxYVFJQ09oOVxyXG4gIDkvaDVTdWlESFRxMGlKRXd2blNESmZvdmZmU21HODhMOWtaeHpubTNxZG9MOE8yRnp3M2p0Rk45bWhqcVBQQmdiTndUWUQvTHBaZWNcclxuICByUGVCc1oxMWRIZ1dDMnd1QUViQzc2RXU5eGlXL3VQQndBMmdxcnI1SmgrWjc2OGg4dDc3MytyYWZzdjJjUFRSUHA4Wjl3dnNtcmFPXHJcbiAganpxM1hGaDdnb0lnNmVTWlovcjRuM2lnV3Y5SEdRam8zbWRmK2VYN1p5T3ZwRUtGREZrOTZTTlpQZkVEV1Q5bnVLeWM4SzZzbS9XVFxyXG4gIFpQMzlucXlkOHE0c21QQ3BySnp6bTZ5YytMYXNudkNxcEMzOVd0S1hmQ1ZKOHorWHZCbHVtZktlYkp6eWdhd2E5NDRzK1BVRldUaHpcclxuICBpcXh5by9BMVdldGszZnExYmlTOVFmSTNGMG11VzlTdXZzWHhJTWZCQ29xWklaeVB6WW41ZVpzankvaVJiMFhVVWRnenpOWDI3ZGZ1XHJcbiAga3FVTGw4b3BweDhsVHp6NWRzSzVrZU5oSFpJUmdKWGpZYWxKeUtWangvc25tS25NWnYrQ3dSQUwwaS9PalE3M3hRYjFhMnNlSGRQYlxyXG4gIGhtR2RkSjk5V3V0MXVJYk5FV0RIQUhFa2ZBUU42OVdRRzI4OFgyclhyaVlwanFoZ25OeTZwVVIxMk1zZjd4SlJZekhudVNGMzlRSmxcclxuICBBT1JISXBNdWpBVE0vZWxwcWRQUmZ4U0x4N3duUzl4bzFxdTNmR1E2aEFxbmhiQXRoUDBEYmg0aEkrODdXQ3JXYmk1MVczWFBtdTRZXHJcbiAgUjlNQlorc3hQTERhT0lsazVxZDNhYnNnYSs3WW9QUi9FekRXZHU2WkdGb011alJnQko3d2YzbDVRM1hoemN5UTJhaXhoank3V285dlxyXG4gIEtTN1VkNEM5aEVGV21IRlllZTVQVDBVU0twcnh2RTZud1c2d1YxTmFIM0ZUVlAzbFVQVFRWWktUdlY3V3I4K1d0UFN5a3VvR1orZWRcclxuICBlWlJNbmJsUXpuTEVod0hPOUdCV08vRGE2NThKVTYxQytHZk9uQzhUL29vR0U0SWpBblVRTklNbzhjc3U5Wkh2aHBkZnZNUDM2YUFmXHJcbiAgeHhQd3UrOTVRZHUyT2l4WFhCNmRZOFRBZnI0anpuLzBzVGUwUHRKK3YzN2J1cXhpSHdHY0F5UGg5MUNmNzdNMEJnWlFYd0ZVVlFUMlxyXG4gIGNRNmduV3V1UGpPeXZTTjgrYVZYRitKc0FFemlzcldCYnptODNoUDg5RU5pMjVOaDVjcXNmNTZCZ0Y0RCs4akJnWnBtMDZaOFNVOUpcclxuICBsZ3JwNlpJUkJMNFFONEVua3lFa2RNamlsU3RsMFlvVnNtTE5Tc25hc0ZiV2JjcVJMTWNrMW1WdjBybEgzT0JMbVFJb1VEWFVGc25QXHJcbiAgZFp6UjdhUmRKSXZVdEdSZEh6eTRyenp4MU8weWNjSUhFWHRHbTA1UnQ3cHdRclBaODVmS3ZFVXJ0SFBaQ0tVMHhCL2puTkplWU9kT1xyXG4gIHJmVTRZck1CVDQ1NC9QdTYyTHcrSFR0RzUxSTJjSTJ3Z2YzbFZ6NEpTaDZJekhSYzZqR2lpeCtsMEhsaEZHREJrbFZ5eXkwWHlrZHZcclxuICAzU2QxNnRWVVl4eGdpcytaczJiSmpHSE5KUGVyeTNRZnN4THlqaXlSSmJFeUxRNjZUQ3JYYjZkbDdDRlZtL1ZRd2svVWVqTjNETWtDXHJcbiAgQ2Nha0VHYU9wQTJUUWl3dWhLbHhJWXl0am4rZzJycnAzeGNVYkZndEEyOFpMcjhNOC9Fb3JZKytSWmFPL1ZETHBPdFl2eUJ4ZnFQL1xyXG4gIDE3SDRqL2NpekFNSkRyVVRER0REMG1uS0JDZzNIWENPRERqOTlzV3ZucGJaMG1KQlpuMzlvRElWMHV2YmQyYU1nNTVBTmw1akhPSHZcclxuICAwRURLa3pJcGZuUzdjTlRyTXY3VytySnMyVEkzZ010VzFkSzdyOTZwZzdGTitadmxzTUg5dEs4VHF4VEdzRHVmVmZzYy9lK3JyMytOXHJcbiAgMkFkQS9MZFRyV1p2cVZvMW1yR2I0eXdHdnIxNEFzNUkzd2d6YXhhWVdEeFFmZUVHelBsWFhYbTZ0b1VVb3FyeU9KQjNqdXRhdTlSbFxyXG4gICtmR24zMlB1Sng1SUlKYkRpM2JKbDJWdCtQTzJ2VllpbUZ0eC9FRFNZRFRJbnNVeGdjU3lKeGczWVpyVXF4TTdKWEVZdk5kLzFBYkNcclxuICBvekU5SGJyT0M4NCtRcjc3Y1l3YnFUamk3MTVjZ1NQMjZZRXFDZUpQL0lUR1VEaHBZWE9STDZjRWRncFVVVnNjeDdBbHpaMlg3QmdSXHJcbiAgeTVZdDJFSlNKTlh4bzlTeUtVSkN3bjY5ZThnYnp3K1ZmNTF3dUp4MnloQjU0Yms3Tk5YQTBjY2NKTlZySlg0b0pHeXpGOEY5STJvUFxyXG4gIEdOQkRqWEVtVmRqdkNlUHhKOTZTNzc4ZnBUWUd6bUhOeUNCUjNTcFZLdXB6cVZXem1sNkxPaEI2Uk03NFFDbzYyRUx1d2RWRGNubmZcclxuICBpYnpoRVFmdDBJYmRGLzdmNGVPZmZ2YXpZNjVKZW94Nlo1MXppK3FWQWVmeW9mTDdNQnhPblRaWERZSDFHdFdUTHUyYnl3OC9qZEhwXHJcbiAgY25uNlJadUxKVy9UUnJXTnBHUk5sM3BOMjBtbGpzZW9OTUpTcysxQVhaTm5pWlF4MkVPWVo3dFM0RDJGN256Qkw4OUxXMGZ3Rm94NFxyXG4gIFdXTTcyaDg3Vk5iTkh5OS9mM2l6REx4NXVJeDc0V3pIZEhwS2grUHZVb0pJbTlYYUhwZ3k1ckdqaXBzUHVyd01PWjJtdkhlak5PaDVcclxuICBuTTRMejV3bGFSV3E2V3lTZUkxUi9yK0NPZDgvcWN3QmpINzRLTFYxQUo3YklmZFBVd1k5N29VejVWLzNEbDg1NG8xaDlYQ0Q3bi9qXHJcbiAgajhvb1NLdmY0NEpYWmVISVY1UkJ3RGhnN3RTQkNlSE45Y3V3WHRMM1d1KzBFUEc0aXVNbXVXOE9sRG0vdlMwclZxelViKzR5TjhpcVxyXG4gIFhiT0tYSEhOdWRwdmlVRTY3OXpqdEQ5ZWNORXdlY2xKRFlCamVBbkJGUGhPdnZ4NmhOeDVoeCtZQUk0UC8vbFZYWE1jTi9Od242YmNcclxuICB1Vk1yTlNSVEIya0RHMGNZdU1yeXJkdjNSVDZuUG4yMkpieDkrblNSeno3L1JRa2gzeURmQk45dm91L1d2bXVPY1YyamJjelNGNzYvXHJcbiAgZUhBUHk1YXUwcnFvdHJHUHNnOXczcElsSzNUL2ptRDNGTGFqc0kvMXhFbE9PbmZQdytnQTZ4NDlkajIrSkF4c1FuZmYrNkpjZmRVWlxyXG4gIHBmNCt0REwvRVFuRTBLMTNUN255a2hNMFUreXdZWmRJL2JvMXBBUWJoVnNJYklOWDZBMjV6c3FhZlNWdXBGTGtKQXBVVVNtT0dFTFFcclxuICB0a2JEUmhRcHFWdmx5Y2R1bEV2T08xRkhQeHFQOGUwTDByMTNOMDA5RUI3QmJBLzJZbmtCZEJLd2JObHEzYysrMGtDSE5wSFpRTmttXHJcbiAgZllrSEk1SHd0VGkzTkZkRlJrYlVTWlJaa3paT1BmMEdaUVNNYkhqUjRYdlkzekdIT3dNYlNIZy9zT3NER09TU0pTc2pJNysrQit6blxyXG4gIHhQU0IwcVJ4WFVuUGNGelp2WWQ4eCt4WHJsNHI4eFl1a3BHdjN5U1Q3bXdqeXorSTVoVmk4cUhNUnZ2bzZMVzRjSk9VTFplcGFpK2tcclxuICBrTXpHWGFUbnBlOHBBU001WDZPK3AydTVhdFB1RVlrRWcrNXZEL29nTFZRd3crOUNXdWt2OVh1ZG1qTCs1UXUwWEtsdTY0ZzlaTU9pXHJcbiAgeVVyNDBpcFdVM2ZoVFlINzcvL3JtUDB0NlZBOHdaM3g2VjNTKytyUHRQekJxVWx5K0JPK3Y0MjRlNEFjZE9jRW1UNWhWRzFVVjMzL1xyXG4gIC9hMCtiOG84VzU0aC9LRFZvZGRHcEkreUZYMFFMa3pkTVd3dGw0WmxUKzRqbzM4Zks2dFdyWkhtam9BZWV2QitycCtreXh0dlBoVFVcclxuICBjS1BYY1ZQMUcyTGhXelRVZEFPbk4xKy9WOVd2NE42N3I5UzF3WWlWNWI0NjFFa3hZZENQR2JBUkg4SjNjMHRnVndnRG9rZlNSUHVHXHJcbiAgVGUwVGhxbXM4RWprVzZBdC8wM0FHcllGeCt6M1dGM0s4ZDlWR0RZTElibXA3bkJTRnpBSnhNNGo4L2FPWUhZVXdMV0JmYitzbWNrUlxyXG4gIExBamlSTUlTM083aWs0OS9ERXFsNDUzM3Z2NW5HUWcvTHY0QlgzbmQrWExnUWZ2SkRUZGVLTU51T1YrZWUvWjJlZmlCYTZSL3Y2NXlcclxuICAwL1hueTUxREw1YUx6ajlXN3IvN01ybnQ1Z3QwbXRabm43NUZYbm5wVG5uNXhidmsrV2VIeWN0T3N2aHIxRHNSMndVTW8wM3J4aklrXHJcbiAgU0lBV2ZyRjB0ZzRkV3VxMlBmVHRnWHFNVE94RjJXUXZuTnN1OEg2SVIvaGxodTBSaXhldjJPYjNBK1lvd0F2RFFCMEwvb21INVlPeVxyXG4gIER5dStQVndKa1NvKy8veG45Y1lJZHg3dXg2TFUyWThhNjZPUGY5QnRBKzB4bTl2WFh6NGpsMTF4VDdCWHBFYXQ2bktYR3huZWYvOTFcclxuICBqaG1rcXlNRTN4WjNrNSt6VmhZdm5PTkdka3RrM3F2SHlZTDN6cGZNTFV1bGVOVmtOMks5dzBraFBuM00zSitlVWVJRXhqeDFZbVFVXHJcbiAgdTJMaVY1SmN0cHd5QldEcUsxUmN3ekdvTzBtRjhxaUhqOVJ5MlRJbDJkaERUR1V6NTRlbnBiNlRSQWlJV3pmUHAvOUdONzkrNFo0blxyXG4gIGovdHZCb1MvNVdCUGNIa2VlRitCWCs3c0w5M1BmMDNLVmEwbjMxM2ZUcGxFd3paZFprOSs5enBWVjZFaUpBN0h5a1lpeWNhYlhybVdcclxuICBNdUpxUWRaZVVENklJOEh6S216cnlIOWpmNWs1cktsTW5meTNUdEZRbzFvVjZkRzlyYnoyK2dQYnBPUUJmRVAySFJudXV1ZDVYVE0xXHJcbiAgcXhGa1E3aE0vTk9BQTg2S1RBZ0ZPRTQvNWx1dzd5TFJOMDA5bkVOc1FIWDl2NzIwRmdZRE03S0VjNXo2dHQ1ZVNoSDdQZGhKcUVzNVxyXG4gIDBmVU54aHBxdTIrSmpCS0FBVzM0bkoxSllXSjJsTysrOXhQQWNlM3cydEFra0ZMd1ROdFRXRHI3Yzg3Mm1aSkJlQ1pISkpSeDQ2ZitcclxuICBzeW9zWUtJV3kzaDNRVlJadGk5blU3NGNlZFJCMHFOblo4MHg4K1NUdDBydlB0MmxmSVh5Y3RJcFE2UmYveDdTYzk5OXBFdlg5dEtwXHJcbiAgYzJ2cDBMR1ZkTjZualZ2YVN2V2EwYlFsWU5FaXozMXBsNDdER3BCN253aFRYUDY0TmgzRmppVUNkVjU2K1dOMWk3TnBJYW5QeXlwZlxyXG4gIExxUFVjMm1YMzlXc21mLzRLSU5FSFl6N3d5dUVjK2pFazZmTTBrNFczellmT2tuYTJHL1BET1ptZGd0QXA4RjFtR040ZGhITkcyNEhcclxuICAyMUpoUWFIdTQxNzI2WGFjM0hyemhYcU1aL1B4Sno4cUU5TEpkTnk5Y0UzcXNxN2duaHN6cmlVbmJaVjI3VnU0ZDlGSk5tM2NLS3V6XHJcbiAgTnNnV04zTGF1bVdydnNPTnkvNld3bVVUcEdqNUJLblo3MHBwc084SnNucTZZMmgxV2p0cG9iRXlsUGJIM2FHRUNwZGZtTXJXTGNVNlxyXG4gIEh3aGwxRjh6djN4QUJ0ejRnNHg3QWFrbVNYcGMrS3FNZWZwa0xYYzQrZUgwbVIvZW1KZFJxMFZxazM1bnlOenZuOVJZa0hwZGgwaldcclxuICAzREZTbUxOR2craUl4TjZ3WktyR2pmeS9oaFdUdnBXbSs1K3I1ZW1mM0NFdERydEdrcFBMS3NPdDFYYWd4cUlncWNFSWVwOXkrK3pQXHJcbiAgYngzWUVtbVA1enZTMVNFZXF0dDVMOG1vaHc2WDlNeDZ1bi91RDA5cFpvakc3cGwrZlhrOVpURFlyNWI5OVlWS2hzVDZWSFR2Y08xTFxyXG4gIEEyWGxqdy9Kd2dVTGRINzlOUGQ5RmhadmxtOCtmbFN5YzR1a2JadW1hdHN6MEsrUFBlWWdsVGI0Ym16d1E5azhyTDcrNWxjWjZrYmxcclxuICBxS3NNQXc4OFd3bnRZdGZYY2E5bGtHWG5Bc3IyYlpORDZoUW5mVi90R0VFWVJsVHB2L1IzNmliNjVra0RaTWV0elNUM0QrK3hlS0IyXHJcbiAgZXZxWmR3WDNlN3l2U0NIUE9WeUx0c1AzR0FhL0F4VTAxMEhEd0tSVmxTcVZsL0xsTS9SN2Z2Mk5MMG85Tnd3a0VOcmdPL1gzNmI5UlxyXG4gIDdDRm9NNHcybUhvTCtyVXo3VzRQTjl6d3NDeGR2a1llZVFpM2V3K1lSdG5BdTR0WkZlOS80T1YvWG9XRmY3Y2hOOWVuTVNENEIvQlFcclxuICBlQUhnb2d1aWJyTGgvVHVMRVNOOWgrQThPNWMxNmhtd3ZValJNRDc1OUNmOUlQRE9zTGFZOVl3WHNyMzdZbVRFaUlQanBCNmhMa3RwXHJcbiAgb0QwV3ZGUVl5U1FTT3puZnZGYzR6dmFvVWJGR1kvYlpKRkpqeDA2UmV2WDhyR3NHUmhDa3lVYWtaLytqRDE4ZkVhM3IxS2toaTVlc1xyXG4gIDFQdmd3K0FhZGgrMHgyaHA3SjkveTdubi9rc2FONnFuQk9IMWw0Wkp3d2FlUU9QRWdFcXhvSEN6TEZxNnhrbGNpMlg2ODBmSzZPdHFcclxuICBTa2FKZjhkNFdrSElJRllrNzRNd3pmemlQc2xlTkVtYURqeFBWazc1UWFVTkRPSmVsVFZDSlJMS0EyOGhsc1NuZis5Nyt4L2xSdHpsXHJcbiAgMVYwOUwzNVRzLzB1L08wTnFkL2pXTm1jbXkwYkZ2dWNZcFVidEpjQ3gxRCtYd0cvRjhtalRtZnYxVGIyeVJNZG9iOU5KOTJDZWZBOFxyXG4gIFlRYW9vcGhDR09ZeCt1MWhMZGZNL0RXeUh6VmkzK3UvMDNmQnRMSThkMU5kUVFBbzk3N21hMWsxOVNjTkhrUU55WFdMcDc0cDYxNGJcclxuICBMS1ArSEM4TEZpMlVySUtOY29rajJJY2YxbGR1dnVFQytXblVaTzI3WVRVTVJKVjlpZUlhWUJoRFEzTjJoTXYwYTdabnp2UTJBb2doXHJcbiAgN2NUREdBUkJmVys5ZnErV3c4QjExNGduL1oxVThMUVhqMStDVE5nc0VFWUlmR25TQUlHTDNBdUJqMXpmN29GOWllN1JRQXAzdzZDRFxyXG4gIDluUGZUZTBZYjdUYmI5dDIvcEpFTUFtRWxDL0F2bEVMR3JUZlovZGkwczZlZ0pUMXJSMFREOE04UXdHcFpGYXUrZzk0WVdIQU1waU9cclxuICBqb25yZDRScG9RZTlNeGpRM3h2SnNIZllBeTBvTE5JeW5jUTYxWTVRcDNiMXlQbXNlVm5kdTBVbnJiRjFQSGg1ZG8zZVFVcHFycHViXHJcbiAgNndPVDRrRTdMTlFCcGQwZmhCM1ljZXM4OGVDRllnZ25SVUs0RHA0eCtRVUYwcU43ZTcwZVdaSnZEejRBY0xyNzRNaDBDaGdaaHZYRlxyXG4gIGs5MStQcTd3ZEozZGVuV1RMejU4Vk00LzkxZzUvYlREcFY2RE9wcDFHUnBTVkxSVjFxM1BrZXoxNjJUdVYzZkx2TmRQbEZZTk1wVUJcclxuICBWRzdRUVVnZkRqSERqWlI1TVJZTWY5RkpFSDlFVkZtNCtWSkdCUU96cU5HbW53eTRaWVRhUTJqalgyOXYxZjE1V1V2Vk0ydjE5T0V5XHJcbiAgODZzSHBXNjNJMVdkdFhDRTkvVlByMVJETnE3WWNSLzdid2VNQTVqcWp1MmVsNzJuWmRLOGhKbUhNb2xUaHlyemdPa2UvK1lXM1kvZFxyXG4gIG84c1pUMnU1Y2tPdlhrVnFVd25EUGRNMjduemF3RHZMNWs3UG52NnRGSXg3VmxhdFdpVi9UWjZpT2RNcVpsYVNIejU1VWhvMXFTOE5cclxuICBHemVJRUt0VnE5WktiZmZOeElNQm16RVRjSmNyTTNLKzhRWWYxd0hMQ1JOZlVuMndUYndWMzBTZ29ZcUFmY1EwaFpIb1d5UW8wYjR0XHJcbiAgUnVWMnZYaHdMWWdrWUJJckpQbEVzU0xBdmxPbTNPVThGbjZiMlRVU3dRWnB6Rmx1REdlVkk3Z0cyaHgyUitubkc0dytBR2dUTUVjWVxyXG4gIHV3OWdhM1VHY0ZMSm5nQnREU3JyRStJU1I0YTlSWTNHL09NTUpNeTFUSzBUaHQySXZTUkRvdlFlMjRkL2FFZ1FnTFpRQ3dIYTNsbFlcclxuICBYYzRueGlMc3dzcytSTm50Z2JxTStBM01ZeEQrWGZFSUoxcmJYajA3bm9qUlFQanhJRVBzNS9qR0lKcldVRGJWaTUyY1h6a3VleWp0XHJcbiAgSW80QzNnVXBKS3d6Y296Mnd0ZmxXTWV1SGVYa0V3K1RzODQ0UnE2LzluVFhrUytVT25WcmFHOUtUMCtSelk2YnJGbTMzbzJZVnNud1xyXG4gIDEyK1JHUzhkSnhtNWM1U0lRYmdxMUdxdVpieCtBR1dJR0VBTlE3bjVnWmZJQjZja1JSZ0tUQVFjOTNxUmZIVjVBOGxkczBpOWliWVVcclxuICA1aWxoeld6Y1dlcnZlNEtzbXV3OWtsQnBFZENJaFBPL0RlVDdtdjNkRThvNCtQMFFlbjZqTVpKUHo4dVVOa051aWpBUHBJMGo3eHcrXHJcbiAgZTFUQVBJWTh2VXJQZ1htZ2xtcDY0RVg2ZFdRdm5xem5FTE1EczhZZTh0RnBTVHB0Y0o5cnZwSlY0eitVQmsxYnk0Um5UNVJwb3o1VlxyXG4gIGdySEZ2ZFBNek1yeThUdjNTKy85ZTJ2YURFQS9nSUM5LzRGLzNzRDJzWTVQN1dIU0J4SUJrako5TmhHczc4WG5mN3R0Mk5NcWRkQStcclxuICAzMkNpYndVR0UzYVR4YnNwVVQyU2pBTHNKUFJ4UnV4OE8vR3U4NEQ3SVdNMjlaaHlsN25IYVJOWDRlMk45RTM2T09UZ1BuclBnRFpZXHJcbiAgN0o1MlZnSUJuR1BuaG4rWHRXMDIxTVk3NGRHMUl6d2ZoQmlRUlNRTW03S1hRYkVOTlA5eEJtS3pmQUhjOTBDWUNCSW9aQWlQbk5IOVxyXG4gIDd3b1FQM0hIczN3MXRHV0VrVTVnRDUvMWprQTl6cWNUV3dSNFhsNis3ck0wQW9uQWVTellLUUQxYlltSGRRQU0zd2JxVFpuaXBZRkVcclxuICA0SGk0QXhyWWg2NlZuRUdVS3diNWhRenNNelVYRWduUC80c3ZmUnB1RU04azRtSFhSVDBHa0VyWVpuL3J0cTNjYURGSmJybmhiRG5sXHJcbiAgbENGU3QyNGRkY05XRHpvM2l0eTBjWlBrYk1pVzMxKytRdkxHUHk5TDNqbGQxdjl3cTFTdTIwYm1PNGtCaG9JS3k1aElSbVlkZFVmdFxyXG4gIGN1WlR1cCtSTm9RVEpnSkRJUVlCU2VUckt4dEw0ZHlmMW9WSDV5bnA1YVZXcDBOVXZRWFNLbGFYMmgwSC9hOVNhYzM5NlRtZHFLdmxcclxuICBJZDRUS2l5Rm9GYmlHZlMrNmpPcDNlRWdHZnZzYVpJemYzVGhnSnQrbGovZThjd0RGV0IrOWdvaGRRek1nMmVLWXdNRGVsUlRwSXV4XHJcbiAgWjg0VXR2MXUrRm5tZlgyWGpMdTl1YXo1NHlVWitlUnBzaWtueHhGS2R3L05Hc2pOMTUwcnh4eDlnUFRvRzUxUUNLSkZJQ3pmMWVXWFxyXG4gIGJSdWd0Ly9Bbm5yTWlCdmw4eS80VjBUcXdHa2pESTRiSUlRRERqdzdjcTVoNUMrditiWHJjOWdpRW4xVGZQdDg4eHlqemx0dmUya2tcclxuICBIZ3hPa1hpNEx1MkZyeDhQN2dNSEFlcXhXQ29UMUhac2x3YnNGdVpaYWVlRzYrK005QUhzbkVTL0Y5aTk0N0lQU3F1M0sxZ1dETjR0XHJcbiAgK2gzZ0VHUll1blJWWkJLN2Y5eUlUZ1JuclZyZVIzK2pHOUVnVnJMZ2xvcm9TOEFhMjRDSFpVUU1NY3IyN3l4R2ovNUxmeWpuMFE1clxyXG4gIFBBZklhVVhaakUxY1ozdHRJd1lpSm5icTVLTzRPWThwTDJtVHpsUGErWnhuY1J1QVVSLzFXclJvdkUyTVI2TDdvRDZlRnFVUmNtdVBcclxuICA2NUJpR1hXVTRmUFBmNG44WnRxMXVnYk9RVXduZ0F0Lzl2TXVIS3IyRjJCdHNsK05lMjkrb1hsNjhGN2pHRzJ4djFyVnl2cjdSdjgrXHJcbiAgVWEvRmZrWWlwNTV5dUpSTlMzY01mTE1NNk5OSmxpeHpJK0NzRFY0Mzdpb1ZPWVpTV0ZRczJlNzliOXEwVVJQc3JaM3lsYVFrbDVIVVxyXG4gIFRRdGsvZko1VXJQam9iTHdWNTkzaVh4YkdOaVJNT1o4LzdncytlTjlOYXJUbUtZOU9kWVJScmQ4ZTB2dmpPVENyQTJ0ajcwem5SSDNcclxuICBxRWVPMUpUbFRLTzdkT3hIc21ySzl4cVlTQXFQLzNac1dqVlBsazM0UXBydGY2NjZKdk43RnY3NnVqSU9IQkZnSkF0L2ZVME9mM3lCXHJcbiAgeHRsZy82amR1TzJHVHVlOFhoN21hOHlEcEk3ZlhkZEtHdmMvUzVuSEJDZlJwV1JVMURMMVNGRy95RDNiM0JYVEpMMThKWm54N2hWU1xyXG4gIHVPaDNqU0pmdlhpT3hsNVZ6cXlrUlBPS1MwK1NUdnUwazBzdVBVVUpGUU9VWDM0WnErOGV4dy9tM3Fac2hOajZuNDJRMlFZWXg4ZU5cclxuICBlUzltWHhnTVp0TFR5dW94Q0dIM3dFZ2RCdGV3OWxFcEo4b1FTL3YwWWRLZUwxK3hSazQ4SVZZRlk2QWRiQkZkblBTL2VYT3huZ05CXHJcbiAgVDNSdmdHdm41UmZLY2NjTjBtMnVRNTZwOFBjVkQraUU1YUtpSHQrUE1UTzJTN3RXUE93Yys1NVZSZGV2bTh5WU9WOWFOUGNhQjJEclxyXG4gICtPOStkM0Rza1plb0NtdlkwRXY5RGdjR0RBWlU1UysrL0xHVy8zRUp4RnhvZ1QwTVlHazF3bGdUSkJrRVJxaDNCWWtNNlJqRDdibzhcclxuICBkTEFqTHMzTHNPQWV6cVUrKzZ3ZFc4ZURPdllpQWZXd0h6UnBrdmlGaHU4RFJtcVNTenhza256YXM5OWxMbjJHOFAxUnJsNDlNK2I1XHJcbiAgZmZMUlk3cTJheDdnUm9uaDQrWExsOU50anYveTB5c3laMDQwWlFsZ1AyMEMycWN1MTBPaXdidUVjbnA2V2VuU3ZiT2NjODd4OHV6VFxyXG4gIHQ4dlpaeDNqUnB1ZDVmcnJ6bkxTaXcvZUxIYk1aTlhxTlpLYnYxSG0vL21KVFBqbVJTbXo3SGVaOThxSmtwbnAyMmNFRGlCNGcrNmVcclxuICBLT3NXVEpBUmNaSUlCUGFJWjFaSWZwRlVKc3NzeDQ1NWFZTjhmbUZOSmJhNCtiWTQ5Q29uamJ3b0N3S0pCSkM2NDc4SlRMbzE0OHY3XHJcbiAgcFVLdFp0S2svNW02YjlSRFE1UVFtSFJsYWUyOTNjZEpJYWNtU2QyVzNiT2FIM052NVREelNLdFlRNzY2b3FGTzRxV1NoenVXbmxuWFxyXG4gIHp6Q0lDaXhnSWlYVDNwSU40MStUY1UrZklObkw1OGlLMVZuSy9GTlNrcld2RHIzNVhKVVcxcXozYzEwWUxMc3pCTlVNeTJGWTMrSzRcclxuICBIYnZUbFk4UGpNL3g5UUg3SDMzOHpZZzZDRHRCb25yQStpdDlOUjYwWS9mSzRBK0RkeUpZRzZqWXVuWHpka0dRU0oxa2Ria2ZiRE12XHJcbiAgdlBoaHpIVktnOFZ0VU5mYTRKenc5czdNZ2Y1NGdoeDVGalNKcXk3dEFWT3IwL2FPN20xbndOZDMvZlhuNnZzMkdMMUd5eFBPM2ZlUFxyXG4gIE14QVFKcFQyQVBFS0F2eGcyMGRIMnhOY2ZKR2ZpaFJYWEd2WEhqSmxvalZCbU1nbmdyMEV1eThqem14dnp6Wmo1K0YrU0tBVDlTR3dcclxuICBlRHNsUXZnK2NNME4yMDdDb0EyN2wvQ3pESU5ydi9qU1IxcW1EZ3hwWkNpQklucHMxRmoyY1hKdHRnM29nMzhlUGxhT09IeUFYbXVpXHJcbiAga3hEZmZjOUhJOU0yOFMzRWtIQisrRHo4NmJHeDhKeEpDdmZ0ZDc5SngvWXRIUE00V2s0OStYQVovZXViVGxwS2wyc3ZPMWxPT25Hd1xyXG4gIHBLU1drYlQwVk0wbWtMUzEyRkgwTFRKejZwK3lObnVOakh2N0d2bnI1Yk9sSkd1bWxHeFlKQ1g1NjJYcVc1YzV4cEFqZWV1V3hxaXpcclxuICBzSWxBRkR1Y2VLOXNMbE8rR2luZ2ExU1F4VWMrNStmQ24vaUdqNWRvdXY5NVVxL244WkVZRVVzZUNIQUZYakRTcTBiK2t5RDlDdmVPXHJcbiAgU3FwS3c0N1M1b2pyZGY4TXQyLzZwM2RKbjJ1LzBPbDhxUU96OUJLWEkvNXVteUJCbUFXcFhwQkNZQjcvZWd0eWovM29mSjMzQTNmZFxyXG4gIFB4NDdWcGtBNmlwbUdHelE3VWdaOStCQTJUam1HWmsxWjY2c1dMbEczYnVMQW43S3FuTFZTdkxwK3cvSnBWZWNKVDk4OThJMktYYkNcclxuICBmY2Z5VS9IZXplTXFFZUVuYlVuWHdNNlhDR1liZWJBVUF6WjQrQkgvanV6N2lnZjN3TFh0R3dIMjNZZUJGTUMzUWY0dDFFdW9peFBWXHJcbiAgTTlnM2I5L1YrZWNkcjljeDlWZHBzTythdWx6UDZySnR2MkZuNGordXVPSTBYWE1Qbk1mM2w4aitjZUFCUG9hSGtJQTlCYzRPSUwxc1xyXG4gIGFzUmxGNWdFZ2lmdG4rT2lzNmorUnhoSUdHU2xCTmdVREdTVkJmYkNES1VSeTlKZ0xuSW1hY0JJN0dYU2xyVnZMM0Y3UVBYRk9lSDZcclxuICByREhBSWNxWEJvSU44UVFqV0hCSDl4Ly9lMEdZcVlSaDk4S29uam9rUWJSZ0tnT1QxVkFIcVE4bUZuOGN3eVVUVGRrMWNSQUlYeit6XHJcbiAgU3FWSTByaXJYT2Y5UGZRN1RjVkE3aDk4OSsxK0RCd2p0WUhkUDhmNGZYdzg3TnVuV3lkcDFhS3gvRFg2YmVuVHE1dlVyMWRINTFyaFxyXG4gIEhrazlVNUM3V2JhNDdZS3NSVEwyOVN0bDRSOXZ5dHlmbnBRNVB6K2pvK1pESDVtajdYNStVUzBscG5oblFUeDFaTzIyV3g3K2Izbm1cclxuICB5S1NHTXovdzBzZytwejhtbjV4YldZK1hMWjhwbVkzM2tmbkRYNUxsZjMwbG0vTzhiUXkzWWtiOUpHVXMyVklzUzUxRTlFOWh6Y3pmXHJcbiAgWko2VGhCYjgrcnBrVksybjkyemVad1FGam5ya2FFMFcyZmJvVzVTeGZIMlY5NzdEM2tNOW1PZWF2Ny9MZzFrd01kUVhsM3FwbHUxRlxyXG4gIHY3K3JqS1ZXaDROMDNvL3BIdytWU280eHdUd1d2bm1hNUk5L1VjYmV1NStzbURaQ2xxeHdETmE2aFJOejJyWnBMQU1IOXBDSEhyeFdcclxuICBtald1TDFrNStmck9zRTFDb0NqekxubUg5azZSNnNQWkhhWk9uUk9wQzR5d3NRMWpxbGlwUW1SZkdGWWZhZXZmL3o1SHQrUHJzWStrXHJcbiAgZ3pzQzlleDdRejBldHEwYUlMNzhEZ3ovZk1Pb3k1aDBiWHYyQ05wc0diaXprbGtDdWtWeTAwUy94NEFCM1d5TTFHT3gzOHA2WjZRUFxyXG4gIEVJNUFCelpsYmV2VzNqNXNOaGJMNnN1Z2RVK3haTVVhN1I0d0w2TWZOdjhLUURNUnBpdi9FUVlTZnBsNEpRRWpOQUFYVklPNTFnRUxcclxuICA1TnRaZUlJOFB1SnB4QTluSDRCWUFyTkZoSWxmSXBCamgzdU1KL0xzNjlYTFI2Y25RbGpORS82TnBTR2V5Y1JmejBCYjFIM2wxVSswXHJcbiAgRHAwbzNsMlBFUVB6UkUrYk5sZnJvQklMdDhVKzgzNmh2SDU5empiU2hCbmJBUk5PV2NkbkgzN29KbTIwQ1hsb2NBeGJ5QitoaEhXOFxyXG4gIGM2N054OE45RTNuTXM0RkEzWFBYRlhMemRXZktGWmVkSXVlY2VZeG1TMDUya29tbTB5K2JyQVNsZUhPSnBMb3ltUDNsSGZMWm1jbFNcclxuICByV2lCVkVndTFGRTVnTGppdmpyOHpnRWFKM0c4Mnk1SkxsOE5wb0UwZ2tvTFVKOTlUTFJVdDh2aDdnTW8wZEUrRWUyQUdKUXl5U2xTXHJcbiAgdjhjeGtyMzRiMWt5OWtOVmRTMXl6RzUzQVJOWS9NZjd5ckFvMTJqZFY1cnRmNzRRQ0duUjMwemZTeXdMT2NMNlhQMnAxb05Sa01yK1xyXG4gIHNFZm5LWk5aT3U1VHZmK0crNTBzQTI3L294eXBUSDYrdmFlMlJRNHhtT3ZzYng1V3FjelVWdmtUWDVQTmsxNlR5VThOa2FWTGxtaDZcclxuICBkVWFPbTdlSXBnODY2cWdETk9Qc3NVY2ZKSWNkM0ZkKy91RmwyWmlUSy9mZWMxWGszWWRoNzQ4MTd6NDhYemo3ZU1lODYwVWhReXN3XHJcbiAgNlFJaXpUdzQ4WWlQQzRrSHlRN0R3TFpoMGtnWVhKLzc1aHZoL3NnYmx5Z05QS0NlRVhVV0FtVVRxYThJa2dQV051Mis4ZVlYVXE1Y1xyXG4gIGh1NHZEYWpzd01TSk15TGZEcy9td0FONmFabjJlR1k3QTR2L3NQckdLSjU3L2dOZEUxc0NhQk9RbG1WUDhicVR0bUFLNU1jeitoSjJcclxuICAwNTd2bUNqeEg0Wi8zSWdPd29aeWJzbU1Tdkg3QUNOY0k3eE1Cck9yQmlFNC93bi9Pa1JmR3B5Uzh5bTNhZU5IZE0rLzhLRVMxdkFFXHJcbiAgTFluQVBYR2NjM21CM0JPL28wbVQrakg3U29QOXh2RHZUQVQ3N2FnTC9HeG8zdUFkM3paMXJDNEwzaUFFUS9GeU1YZ2JTTGlJUHBsN1xyXG4gIEhEaXc1elp0Y1QvM3VnK1RYRVFZeFNIcStYa0ZrWHZFMEk1TkF5ODRwSkVac3haRW90dHhkU1FDbUE2YmtaR216NXJyMEQ2R1BWSjBcclxuICA4MXlPUFhhUUdsbHhmK1FZOTQxNmJ2cU1lV3F3WkFUWXRsMUxPZXl3L2pKMzdoSzUzakd1VGU0ZSt1N1hSVnExYkNJSHVZOXQrclI1XHJcbiAgYXJoTUtpYXBKcVB1TXJJdWU0TWIwVzZSbERMSk1uZjRLN0ptNUJNNjdXclc3eS9JNzY5YzRhNkN1c2NuQi96MjlvRnVpSndrQTg2NFxyXG4gIGZYR1RJNFpXWmg4R2VQYlY2WFNJMUdnN1FLbzE2NkdqLzNJMW1zaThuNTVSSWc5eEo2c3dIdy9xSlVEbVdnemNUTVJFZk1tcWFiL0lcclxuICA2dWwrN3BJMWJwMnpZcGFVcTlwQU0rU1djVkxObHFJQ3lXelVTWU1hY1NmR0NBNm9QK24xeTJYWnVFK2N0REJJbWgxd3ZsUng5V0FjXHJcbiAgVEp5RmF5M3FLaWJTWXQrRTUwNHVXRHR2UXNyaGp5MlFxazI2NnYzalJZVUtDMGJFOXNMZlhwT2U1NzBrbWVuRm10SWtkK0ZZeWN2ZFxyXG4gIEpLdlhyRkdYVThhS1BQK3ExU3JMK1djY0psZGZmWlpqQUYzZGUra2gvZnAwbFNiTkdrckRoblYwOVBwYTRHaGhmWXgzaXdNSXdYbExcclxuICBsNnpVZlF6cUdNbERIRG1PdllIK2twYVdwbzR2MXRjNHpxeVlGbW1PK2lYY0QrMzRvWWYwbFp0dU9sKzNqUkFhK2c0OEkzSSsxenI2XHJcbiAgdUN0ajhtb1orTTY1Yi9wNjM3NWRJODRoWWVEZUh4NzA3QWg5ZW50N0pOZmxkM1B2TEQvOS9JY2Fzc08vSlF5aktSem51Zk85c1k5blxyXG4gIEhHNXJSN0RvYzJEMXcydHJpK2ZHTnV1REQvWVpxL2NFdHptbURpUEMvVGljOFFMYXgvczkvOEpobXR2TDhCK1JRSXdRQTlLS2dQQytcclxuICAwckF6ZGVLQlJ4RGdYRHZmT0RqbFhwRTVqN2YvRXUxY2NtSFpDK09CV252Mk1yY0g2dG0xUzRQZEIrNjh0TDA5Mkc4QzFDVWRRM3p3XHJcbiAgMDYyM1hLZ0pGc01JdDh2NU4xN3ZVMkpReGkzNXFtc2YwRzNBUHFLQ3pZaU9sRUw2Q1FDRHMyZEI4a1htbkNZNlBkdyt4eWRNbUtiTVxyXG4gIENSVWlIWnMyZVE0UUNMYnhmZ0drbjRmWi9UNXVtbnowd1dPUzZ4akdHYWNmSlljNG92TDVCdy9xQjdnMXBZeE84Z1dRU2pZWGJaRWtcclxuICB4eTlUbmNTeU9tdTlmSE5EZTFtelpwR2t1VHFvdEQ0K3ZZd3MrUDV1U1MvdnBMRS9ucE9uajB4cWlFdHIvOU52bjQvRUFqNDZNME1sXHJcbiAga3ZVTEorbm9uK1NNYlk2OFNlYi8vTHdid2Q4aGM3NTVWS1ovZXFmV0JkVmI3aWN0QmwyaWFqRFVTY3hSMHVyUXE2VE5rQnRVNWRSc1xyXG4gIC8vTTBmVXJUZ2Vjbzh5bGYzYWV6Z1dHb1hZUGwwN3VVbVBlKzlndnBkY1dIeWpqSXF2dlJHZWtxY2VDMmpKRWNqTHhqdjN6MnRUN3VcclxuICAzblNrak9tZjM2T0c4NjNGQlhMb0JRL0k2by9PMWUyMXMzNlZ4bzBheTh3M3o1VlJMMTBwUllVRnNpbG5vK1JzeWxPcHpqMDZuWld5XHJcbiAgcjVNMlNJNDU1TGpESlMyam5ONEg3K1RiSU0wNEVpc3cxU1RIZUtlVXcvRVlaSkNBUUlkQkhWUTZEUHlNQVRCd2dMaHQzZnkzdm0veVxyXG4gIDBTWDZYcEErcmtzUWV3RTR6NlFUeWlDUnRNSXhHeWx6ZlZ5SUU0SGdaZnNXN1RkWnU2V0I0M1lPNEprZ1NjUXp1akF3Tmx1N1BFY1dcclxuICAyNmF0blhYZjVUeGc1OGF2NXdaYUcySlR3UGJ1YVdkeFQ5QTJOcXQ0ZXl4TWV2YnNSZXJDSDhaL1JBSUJqRmJ4LzhhZ3pJdWdnOW5vXHJcbiAgbUxMdG95dXdObnoreFhEWk44NXZmSHV3em9zUE9ITm9tQVRBWXE2cVhJc1hSS1Ixb2loYUEvWDNkeDhINStKOXdJZEdKK0NlN1NNTFxyXG4gIDMyczg3TGRZSGE1SExweEUrbGs2Qmk2eTVOMHg5OGhFN2RzK2ZoZjE0enNPSHhNZkM5NWZHemZtcVM5M3ZCVEVOcW9xUm0zOERsUjlcclxuICA0ZWRPR1pVRm5RaTlLOGIwZkVmY3UzZHJyM1Y0QnRoTEdBeE1tejVYOTltQ21HL0JURlV5SzBsVEo3RmhkTHZrNHBNaTk4NzU5aDZZXHJcbiAgdFpMc3Fmeit4eDY1UWY1OXd5TWFOVitTbEN3dnZYaW5TaDlOWFhzVksxYVNzODQ0VXFaTW1TMGJjL0owUDZPZjRwS3RqaUE0YWxtOFxyXG4gIFZkSmNuM2NESlNrS0xNTkZqdUNpQm9PUWozMW5hR2JPbUJla1hlY2VPUzE3SDV0Vzk4QnJsR0dZVk9JZW5LWkZJYmdPMTEvV1JMempcclxuICA4a3B3WXY2R1ZiSncrRXV5YWMxQ1dUSHhhMWszNTNkWjR5U1JOYk5HT1FsbHRNejU3akhadUd5bUJ2WGxMSjhwSllXNWtsR3RvZFRyXHJcbiAgZnBSS08wVFY0MTIyWWVsVWxUWncwVzNRNndUcDdxUUhwdXhsd3F6eHo1NmN2M3JtcU5TMng5MlZpaFN5YWNsa0dYTlBMMWswNFJ0bFxyXG4gIGtCVnFOWkw1WTc2UUpVdVhTb3JqRHV6THpzNTJ2emRQQ2dweFNQRFAvS29yVG5XL3U2eGNldW1wVWkyem9oeDRVRzlOMnc5NDlrZ05cclxuICBSb2g0RDdqWjg4N0hPOGJ2YlFMUFJONG4remFURWR2MUJ3c09oRWplOThETDh1b3JkMnMvcGI1OXg2Qis0d1BsMDQ4ZjF6THYrSWFiXHJcbiAgSDVOWFg0NU9CR2JYdHI3TGRudy94dlUzTEgyZzdyTHRNRGpHdFEzWUtCSjlYOVJEeXNkNzhUYzNRR0pLNTJsT3lnMmZhOEFSaEVIVVxyXG4gIGxWZWNyc2VSNUY1NTlWUE43N1U5b0w0YTVFYnVYTXZ1aSt0WjhDWGJTT2w4RXp1Q1BVdjdMdVBYTmdqRDdzdTJ2WU05d1RNdmZLQXVcclxuICB1azgvZVlzNjdnQ2VHWE1yclZtelhrYU4va3ZlZnVmckdHUDlmNHlCaE9NYmpIR0VYMzRpWmdKK2NPY1pOOTRaK1BPOUhZU3lMWGhjXHJcbiAgV01KQ3U5YjJtQWV3bHdVd0drSWNPYytZaHpHVDBzQzVxMWV2VXc4R0RIYkVxWXorZlZMQ2MreGFxSlJZRStPQk0wRExGbDc5WWVEZVxyXG4gIHFRdjQrSWtLeFNCbzl3azR6aXh2YVdtcHV0L09zVHFzWVZKTXI4dUhNdVNJQVhMUkpYZEdVaVJ3L0MwbnBsdDl4TmsveGs2V2d3NzBcclxuICBlbHdJQ0hNdVkxam5IbWlmU0hnWU5zOEdFUjgxQjR3S1JzT2tWand2amxHWFZOMzhMdTZKeEhMTWwwQTdmQVIwWHVKTWtNaVdMMStqXHJcbiAgNnBPS2xTcXFpb3hVT0VOdlBFZW16ZlR6c3pScVhGZE9QMldJR25IejNFZnVlSXEyQ1dNaEJxWElNUmFrbHJRTTVvcEpscHlORzJYbVxyXG4gIHVGL1M1am1DUE8rYnU2VjY4VEpwaURGLzJRUlpPZjVqK2VQVnEyWHBqNC9JaGo5ZmxlUXFqYVZpY3FGVWE5bEhhblErWE5WUnRUc2RcclxuICBJbFdiZHBPYWppRlViOTAzd2hoUWZaRkEwbS8zbHlybFU2Ujg0MzNWUlRkMzdTSmxHT1BjUXFKSHpvVTV3RFJRYmEwZitmQzYzeDQ0XHJcbiAgTkdQRm4rL0pwcXdGcWNVYmw4cVMwYS9MM3g4TmxVVmpQcERpNGtKSmQvZlBDREI3K1NJcHlNOVR4cEdhbWl3RmVadWxydXZUYmRvMFxyXG4gIGQ4L2hjRWxPU1pIWG5ydEZHalpwS0xlNjBmb0hIMzB2UngxMW9FcURnUDRLb1U1RXdKbnptdEU3N3drMUZVNGdQT1BaVGhKbG9JTHpcclxuICBodFZsR3pkWjNpOUwxV3BWWk5DZzNwSGo1djFIUDdkdlBOem5iUi90NHhMSzRDeDhISGZaYmwzYTZqNjcxL2cyQU1maUdROTU2T0xyXHJcbiAgQWRMTG81TE5kQXdXaHNEOWp4dzV3ZFhkMWh2cUhVY2tZUjZBYTZEQ05lYkJ2ZHQzRVEralUxeWZmc2l6TWR1SG5iY3p6Q09zdnFJTlxyXG4gIHpyTnJjdi9ZWjdnR2JWS1BKTFVubjNTWUh0OFRuSGppTmRMRGZac25uM3lZT2tyZzFvMTZuUEx5NWF2bGd3Ky9sd2tUWTJlUFRISmlcclxuICBacFNkL0lNZ2o0eUpXeGpDYkRwSGUxQmtoYldYZE9ubGQ4dFRUOXlzNVhDZG5jV3dPNTV6SGV2Q2hPZENNQmtGN0d5YnFHTXNGNVMxXHJcbiAgeDlxWVIybnRXRW9WbXhtTWN3eUp6dUU0bmNUaVQwQ2krd2RJR0hoWmNROHdKd2g2L0lkRXgrZitZRWg0aHNWL2JPSDdnVmhEbkduWFxyXG4gIDZuQWM3emlidDJHNDIrYWpDQjgzb05yREhzTzl3NFFZRmVIdXpQM2gyc3RFVjJUN3hjaHZEZ2oyL0d3TitLMTJuK2pNYTdoNzV6amJcclxuICBwTUFncjlHbm4vMGtCdzNzTGc4LzdnM2NwS3UvK3BJVDVlZVJFK1dXb1U4cVkrdlhwNHZzdDI4bmZRYzRhREI5REV6Rm1BdmJ5U2xKXHJcbiAgc3RsSkxXVlR5NmpoUG96eTZSV2xUTVU2a3JONmdlVG5lYTlCWnM5azBxKzBzbW42TzFLU1V4RmFKQ2s1U1Vka01ITHlIcFVrcFVydVxyXG4gIHhtd3BsNUh1cElKQ3g3aVk3Q3hKUjNHR3pNcFZuZFMzV3BsY3Ntc3ZOV1dMMWlHSXI3Q3dSSmtGS2pxWUhtVzgxY2grREdpbFJzMnFcclxuICAwcXA1STBseEgvZnhSdzJRdGgzYWJQTThrVEJ4bU9Bc3U3STlYMEFkMjdZeXNHMWdiVEVySlhFSDl0NUF1RTY0WDFYSzdDblhPSW1TXHJcbiAgZmRRbklhZWx3QUI0QVpva3djUlAxL3o3SVZWMWhYSHI3VS9LbmNQOG5DZmNEOUpIZkIxZ2ZjVVF2eDBHVGpFMkovbXVBRlV0amplMFxyXG4gIFRiWnJteGU5TkNDOWhOT3AyejJ4cHZkQmwzWUUzSXh0d2l3N043dzJ3SGhSS3pOZ3MvbmZkeGVrcUwvWURTTFBjZElTNll6SUdvSTBcclxuICBoOU1BMTRIcHR1MXdwQVpvaHNIMzlCK0JwZ3NQUURwa1FLYzFRbFE5U0JrQ3d2T1BoK3ZzTEd4VVlaMDlmSDdQbmgyMHpiQWI4ZlpBXHJcbiAgcEtyQjdzVStyTzNkRzZNK0cva0I2aG9TVGE4SndzekRrS2g5QWk3cDFLZWNmTGltbmFkVHhlY080djd3YUNPbGd5SGNGdmRqSGxpTFxyXG4gIEZ2c29jMzRYYWpiQWNaZ0greWdQRE83ZjJnai9IcGdIMThPd3ovRndBc2lac3haRTNyMjVIWEl1ZFZjN0prTWRlMC9NbFcwZkNzekRcclxuICBrbTlDZEdBZTdFZUZCZk1nTG9XNnZmZmJSejc4Ykxoa3JjK1c3S3cvVkUvK3F4c2szUGZRcTNMQXdCNXk1OUJMWk9ndDUwdGZ4MVJnXHJcbiAgSEwxNmQ1SDY5V3BLRWlvdjEvdVJVcGdDbVNVdldLL1BXaWRyRjA2VElzYzhjRTlnMmV3K29rSTMrcy9PM3FCSkJwY3ZKZHA1dVdTNVxyXG4gIHVxdFdycEoxNjllNUR5MVBOaGRza0dUWGJrRkJnU1BlVzUwRTRWMlZtWEd6MEMyMHY4SXhqeFRIV01vNEpsRmNWT2draVdLOWRvRmpcclxuICBGQ21Pc1pWakdtYkhQRGduM3gwclY3NmNuT1lrakhQT1BGcHRja01HOTNIN01qVGdjL1c2MkZnTjFNVG94eG1NOGY3SjV3WjQ1ancvXHJcbiAgd0RNblN0cWtRWHVYSEQvczBINjZiVHB3M28wUlJIdFA5czdvUDJHQ2xwVGFRWExXajQyOFE0NkhtUWY3T05maUw3bzZLU09SWFlNUlxyXG4gIFB6VEE3cmMwMjBmNDJqdkNyakFQK3JCZE81eEJZbnZNdytxalFpZHJCY0R0RjlkNndMMVdyeDZsQjlzRGFXU0EvVDdURE5nMkVnY3dcclxuICBMeldidTJOUHNIcmxXaDFzWEhuNWFTcDE2TDdWUHVZTkpzVzNHM2JuTmZ6SEdBaWRNa3g4ckd4dXUrRjljTUF3MEZudUNpeEloOEFmXHJcbiAgUUdlSGd3TFRqOW9IWXRjc0RmRkVuYmI0Q094KzdhT0tCOGVCdFk4SWlLc3JtVy9EazA0Wnd2VnRLUTJrWmlFTk8vTURBT29pdW9kQlxyXG4gIGU0eUs3VDd4VEl1SEdVMlBDaWJpWXNSNjVkWDNhUmx3THNjNW56Sy8rNVhYUGcyT1JvK3pIMkMvTVhBTUlJSURPOTgrTkNiNVFWSXhcclxuICBKckkrTzBkSGUwWVlVSlBZdVVPT0dCaDVIdVE3WWtRTlk2Y3VINWVKME5ZMm8xV0l6ck12ZlN3M0RYMGFNVUZHREg5ZDkrKy9mMDlaXHJcbiAgdkd5MVJ0dnU2NWpKVGRlZnJTNmZMQmRkOEM4bDBNMWFObEptZ3lXRlphdTdJTmNnSmN0bUo3MDZRVUdLbFRtVXFGb2t2M0N6Mmw2MlxyXG4gIGxDUnBwRDNIRVJnd1pHOXg0NDlDeHhpUVVod3IwYmFjaktIN3RtQzdDVUJhRnhnSGdaWXdEaGhLd3daMTFIWTBkc1NyYXFjNCt1Z0RcclxuICBuR1NUSWFlZWRwUXdwNHM5Szk2QkVSZFMzS0JPeEhiRit6ZDNWbnMyMW5keHVTWlROdXBGd1BQbEdOSFpBQ21kYld1WDQyUEdUdEZ0XHJcbiAgem1mTmNRUHQ4MTdzT2lCOEhIQ2ZlRUNpem8yLzd6RHdsc0x0bDBTajBJZEVkZUpoejJKdmdQc3lHQVBlVWRzUTB2WHJOMmc5SEZDNFxyXG4gIEh6dzJ3K291M3VXT2dQb0tTUWZnOFFWd1h3YThBOXJsSFdHYnNIdmFHNy83SGlmbDhmNXFPdWtXclFVdzJvZG1nc21qRWdVcS9zZHNcclxuICBJSUFSajNXcW4zNGVJMTNjQ0NUc3RvdnV1Mk9RZjRtSFpROS94SWcvSXdScFo0R0VZY0ZPUEpqbXpSdkd0SWxLalk5c1IrNjhHSXBSXHJcbiAgZStHR3g0ZUpiWVg2dEdYRU05eEp3dUQzUWdpNVBpcW4wOTFvWkVjT0FaelR2WHNIMlpDelVSbUZYU01NcmdkeDVUNHdkcUV1d29aZ1xyXG4gICtjVU1uRWVIcStZNkJBUVg5UkcvSlh5L2pGNXdjT0I4MnFTTFFNZzdkV3lseHpHMGt4WWZPd1hYWS9USVIyWGVPUHcyQTIyOC9Pb25cclxuICBrZHhqTE1hNEtlZmxGYWcwd3VSaEdPUzV2NDgrK2tIalM4NDk1emkxYy9CY1daaWdpUFlvTXdVeTg3blRCbEhQaDdwUk1vYjlDeDNCXHJcbiAgUngxS2g3L3Uyck8xTGw1by9RYWVvVk9oZnZqK0kzcC9xRUNJaUtiTXh3YWpSS0pDYlhUblBTL3FBQVdwdUZyVkt2TEdhL2Rxek5EeFxyXG4gIFIvYVhXWE9YeXVvVnExUUhqRFNCeW9rMjlETnlCY2kvc1FDU1I5cEJqbE1rU08vaWkwNlEvWjBreEhPRVlXRHp5VjdQQkdCMTVUZ25cclxuICBKVng5NVpseTNIRUhTNnZXVFdYNXNyV09xR2RKLzc3ZDVMV1g3NUpISDdsZXhvMzdXNmJPWEtqZWd4TW1USmVYWDd4RCt3ajlrZWRCXHJcbiAgbWFod3ZQSG9heXo4UnZhejVwa0E2dkk4V1ZPWHljUk9QY1dyUGF3T2dGRXhBcVcvOEgwQ2ptTmM1WHZpZDlGUGNPczgraWl2bmpXbVxyXG4gIHdYT2xmWTYzYmR0Y2Rla0c2ckNOVGNENjVVa25IaHBKVm1wZ1B3WmI3aDFYY2p6NWFETU02c1FUVGU0eC9qdEpCS0xLa1h4S2c3Vk5cclxuICBXeERPcjc4WnVWUHQ4bTFZNW5IcXMzQlAzRHR0bGpaWlZUem9IK2E5aU4ySk5lK05LWGhQZE0vTDdnVXRoclc5TS9lM1BaQ0E4aDdYXHJcbiAgSjVBK1VUbWpIU0NOQ2FvMDZOK2lSU3ZrdXVzZlZoVnRQUDVqRWdnZ3lNMWdvK2Z3ajU4L1B6cUgrQStPc1JpMlIrQkxBem4rRFdHQ1xyXG4gIER4aVoxUTNTaSt4TTI2UXVBSlpOR0pzRFUyMXk3NXdmRG9RTWc0N0lZdGZnSHBCRTZKUjBpRVNnVFZSQVBYdDAxUE1zN2lRUmFNZGNcclxuICBNS2xEQUZVOFlEQms1MFdQYlJIMDRmYk1PSXJvRFNBQ0JDc2F1QWVNNVR3N3p1UCtDb3VLSWlteHc4K1A0d2Z1djY4OCsvejdhZ2dGXHJcbiAgNGQvTzZBWXdZUmMyTDhEeklTaVNEOEcyclUrd2oyMUdZRWhMUEg5bVcwT2xSUjBtSDRLZzRlVmlkYkhIdlBUOE1PMzhOZXY0K2JSTlxyXG4gIElubmlxYmRWemRLaytjSDZlNmpQTVJZR0J1empPTXVaRjl3cDdkeDlIWGI0QVhMZGRlYzV4blNKdlB2MlEvTE9Xdzg1eHZTWWZQVGVcclxuICA0L0tlS3c4WlBFRGF0R2dxZ3cvcEx3L2RmNTFjNHhoQzE4NXRYUCtxS2VYTGxaYzc3bnhlbDFkZisxelZoSysrZUtkZWI4R2M3elhWXHJcbiAgeTBzdmZ5aDMzdldNdlBEQ0IxTExQWjhSUDcwU2tRd0hIM2FoL3M3Um95ZHFpaG5LWjV4MWs5NDN4M20yU05SUHV0L0ZNUmFrTlJnRVxyXG4gIGRYZ20yTCtvQzc3NTlsZmRSNGJzOEhzcERPVThRakpuSHpFL2dQbzRaUFJ3Z3hyYS8zdnFIQjJKaG9OOFljNGNBMGlVZ3dhZnY4MVVcclxuICB0T0NnQS9mVHRyRjlBTnpBRFhhUERBWWdZZ1pyZDN1d2Q3OHo0UHNyRGZwc2dnRWVaUVk2MXE3OWh1M0JwQlVEdjRuZjY5L1h6a1dKXHJcbiAgbXdSbzM2WFpqUW55QmJRSC9yLzI3Z1IrdTJyY0gvOE9vVXdWSVVNZHdqRkVuUnlFaW1iTk1wUlVwRkFVb1lIbVNVbEpTSm81b3BSS1xyXG4gIGc2VGhhVENkaW81S1NjaXNIdzFLR1VvcS8vMWU5L2R6UCt2WjNkUDNlUjROL0QvMzYzN3R2ZGRlODE1clhXdGQxN1d1bGZxYUcvak1cclxuICBwNzVZcnJUc1lxckpDdFJremQ0UHF3L24vQXpDZlNaRUI0V3ZHMjczdm5hcmhXMVF2NXNFOFk5dloxYXVBV2lNM1BEc28zSFNUWGNRXHJcbiAgNnZmZHhqcHB2dmpUWVhKQ0lnd0t4eCtrZ1RBY1Z4OW9WU05wV3hYNDJObW4wdlhMalRDVGZBTWJ3aXFvOXVPOTlPck9pbjlkMTMvcVxyXG4gIEwvNndGdXA4SmQ5Qi9OWHY4VklKNUFKeHNNRUYzdC9WTmxvcnBPUkRXTzZ1ZGZyMm5pZ0Rnc1RFZkxkeit6NElpTUhJUCsvcndjQ3FcclxuICBKRUJjNnJ4QzZzU3VXM0Y5dXgzRTVhOEdYdjNmcTNPaVBST1drMHZkZGZjOUxVSFp0cmgzNDFXMzE3VURtYlpaNUFCdHZsSlc3NnllXHJcbiAgcURMbkd5UXZ0T2F3ZGxJL3FXTWJBRGR0Vjdmc3krWGdNR1ZVM2tIMWwzcndyZ3Vyd1F6Z3FiZWtKNTV1djN6OUc5OVgySWdJSEppSVxyXG4gIEVDVFhmVVFZWllTNzI1V0xrL1RxT0FEUlJsakh3ZW1nYVROQnlqb09vL3gxMytVNWRUQXEvbndmZm5BYVRJNlpFd3BNOGhEeWNjQytcclxuICB5dTd6ZkxlZ1RnUDdpdUxMM01MODgvMVhjMGZianErNi9KVG1xVTk3VWhsSHRHTmp6dzAzL0tINVdMdktQNkN0OTBHNFQxY2c2U1RkXHJcbiAgKzZqOTFXNXBjSUhLbXc1NmNWM2FQd1VzQTRUNHMvcEluRWx6R0JMdWMvOXpTcjh6Z2NFdXUxc3Q2UWNoUmhYRllRK01Ld3hyVUhtdlxyXG4gIG9manJMRmhJWmdTRElHNmIvWFJLalQzaGExQUhKc3owenNDcjNIV1pFOFkxOXdoT2pzd0VlVEdncGZ5SWgrZEF1TzQzcXRQeEh2R3dcclxuICBQRTdqRjBjNnFQY1BhMmUvMG5FZUJMeGgvZmVYRmRoWHo3aXd1RWM0LzY0dE4yaiszKzl1S0t1UlFSMmNtOTN1NGVVRzNQMnhackx5XHJcbiAgUUR6SXBxUnBFSHZLMDFjb2Z1UmRXUTg5Wk5jeTJQMzlqc3Y3WWZLLzgvYkw3dlY4eDErKzMxejBuZU9LK1hJUWp3RTBLNXVVN2NqRFxyXG4gIDlpZ0M1d3lrS1FjUXVxc1BmU0R1OG9KNEtPZk50OXhhK2t5K2hUMFcwdGwrTytmSjkrTHlMdVdRZnVvbjF6cTl3STd5THZId3ZiNS9cclxuICAyWS9LZlUwSWdKK3ZuSHBlOC8xMmhlSTdlN2JSclBzdFFpRDlzVGVwaFhjUlFUbStmOTAydTVoZDRqRWQxTnFJc1B6eXd3MGZTbCs1XHJcbiAgY28vTkZ3M01ZQkxpVVNOeHV0YlB5UlBXSytUOW5PTDJsbmlzdHNvcm1vZTNFenhhbmJnV3A1N1c0MlpRWmpqeXFKN3A5bnRqbnZ1V1xyXG4gIGdJQUdIY1Iyamc0VDVMMEtxeHRTT3N0MElDNERvVUU4OFhHakl1Y29UanRvSVExZ0ZJU2p3NTE0L0EzcVpzTllXdlZnV3lPTmovOE1cclxuICBlT0xRME9yeWRlRWR2Njc0blloVkYzVysxVTlZT2QxNHQ5eGlnNzY3TUlNNkhEZXlnNFRkWWJ2Tnlrb3RSM09DZ2FEK1B0SmNjV3BBXHJcbiAgQkhIa1BYanZPZG9pd3BDSjRLKzc5NmZvVU9mTnZjRVl5S2pzSHpKQWNjYzJrNGI3cmtsdmd6UFVaZVBQbjJtRzJ2MnhqM2xVL3gyY1xyXG4gIGQrN1JKYzNMdm5kaXMwV2JId1RiQ2lWRUpmK0hQV0xKTW9nTysvTkRqZFgxNmYreGNnbXYvTmhNV0ZNaE5PclJURi82M1crRm9HQXhcclxuICBlV2VnU0IycUd6TkQ3Z3N0K0xnK2k0aXF0VGlVeitaWlNGOXh0ZW9OSVJJSHYxaFpOUkFKcDFpR2JWTG55WVREZS90QnNNZkVBV2JMXHJcbiAgaUpqeUpEM0llNUNtdXJSM3diMi9zbENnNklKcU5GdFAySFVoc2pXRWhhNjJJYU9pazBENHVnM1U2TDdMNmlIdUsweHR3aHlFREtBSlxyXG4gIEgwMUNvSG8rSFdUMTBVVmtWVUZZZ0hNRGRwOGpSNjk0eFgvMU5WTnBqNUZQV2VsUTN4K3VzVHJQZmN2Q2dzM2ZzVnNSQkVJK1VBWVBcclxuICBxTy9yRDRzWFo2Q2Vqb0ZGS3hBYVdZNjZwTDBqUG8xZC9LenRFbzZLc3o0c1pSaVNMMWY4WVpvV2VkWXBFdThvOEl2bEVvRStJRENaXHJcbiAgVWRSSWVvSEI4d1h0REh4VUdva3pxUDE2cHlNVDBFVnVJdCtwWCtESFVuWDdkcGFId09sSTh6MzZ4YzN0ZjU1NVRqby9sM3ozeXY1SlxyXG4gIGsxWWhWRVpqck5MNzFFZmdHWkpXOHBuODVUbjVZZnFDWUsvV3U2ZkFRQVpTZnk5YVh3U3R2aXMyNWZVRzVaYVEwK0lURDNldzV5aEdcclxuICArSklINzRTdE5jY0NiYVUyNVdBVG1rNlVjZ3hEeXF4OXFPY2dkUUkvdmZiWHpiUGI3ODl2NmtrOThHTjM5N1lmZUdzUk5IOWd1LzJiXHJcbiAgZGFjR2JBUCtvK2Fmcng5SDBxRkpSY0VnOVZmRDNodnRERXNwYVdSdkRYVHJ2bjd1cGdQY1VuZUloNEVGOGJlYXQxZUEzT09XbTJiS1xyXG4gIExidnhpSC8zUFE5cDl0eDlxK0lXckwzdVZzMTI3ZmVoTHB1K2ZmWTUzN2tYWWNpM0pEZ21FM011aHRYcHBCQSsrZThpM3dHN3hvUXdcclxuICBHQlVHQ0pwcmsrZUI5cnZOZXplZXl2TmtlejlNRWdkcFp3YkppODNNeXA3eGEwNFI5dFY1NXh4VjJPRGF2YjduVzVEcEhIbjBTWVZGXHJcbiAgT2d6M3FSWVdMUEM0M2c1eE1HeTY5OWZnWE0yeU1rRGtQY3cvL3lQTEhvQThUd0phRDRqSWM5dUJ3c0F0UGcxWldtbXNabGVUSU9tZVxyXG4gIGQvNGxSVnNvZWJhS1dxcGQ1WWpYU21vUU1RQWZBNXNMKzBRNG9IR1JZMks3b01uaVQ1dkc2b09XME5YdGNwTDJVaGZpbzVXalF3a0RcclxuICBHUkFDK1RXbzNQeUhub1ZhTEMybnVzWDBDN2crdFIzNGRDamFPSWdJb2ZobW0rOVNORUhpUitNRmFkQXVZcUNTK1JMdi9OV0FPT3A0XHJcbiAgYVFlUjFSQlNldmFkbVllNGMwb21rZ0ZLV1RiWVlQWFNvUkVFYkpYRm43TjY4OEh0TjJzZTA4N3VDZlQ1c1RKaXRERURDeUpoZjh5YlxyXG4gIE5uaE5jOFAxZnlpbU1NUWhUak5CZVhMUHZ6cjY0eC8vVklnZVA3NkxreXdSS0xNdUxDMXA1UC8xZGhYRVBSQW1aYzMvcG5hQ1k1WitcclxuICB3b2xuRjdZcGhRWm5mMHVYQmROYmIrMkZYMm5GbDVYMnFPNjgyN2ZORzZVRnErRlh2bUtwWXQrTSt4YnZYTDhZbjdTbmdPQlgvU0dtXHJcbiAgV0V6YWhEVE5USzBTSHpMVjVsTG5lN1ZFZFAwM3JsYTBHcFdabTNLRUNIbE8rNEswRld3L3BrdEFHWU44R3hEUDV1L2N2ZG15SlI3T1xyXG4gIDEvSHVXOS81ZnZQaHZkNVQ0ZzJlOGV6WGxOV1VlS1R6L20zM0x5dWhtTWdJVE1TMExlZlZCTTlhdkdkTHJJWVNxZ1BmRFJqcnJQTTRcclxuICBDdU1JUWZKOXpCZSsydTlmV0hFclQxbGVHSVo2a2xIajdMYTlLUE0yNzkyazFOY2srZnpzWjN0V3RtUDBVVGo1a25maEV3K09DbWduXHJcbiAgZFgzUExuWnBpZm95N1dUUTZZM0dEK01YTld2N2hCem5RUDV4WjdVWERwdTVwODVyN2ZXUCs1NkFLSFFxcDc3WEtWUVE0akhvUFl4VFxyXG4gIHVSMEU4VzcwNWpVTDZ5UXpmek8zK3ZRLzJrbjFocUZSaUEwYVMxV2FObFJLNVU4bkh5WFlNa2dRVUZHUkJlWFFlZEtSVThiQU0zZWRcclxuICB5eXJGODEvL2N2dFF2M3ROcWFrR2crSmR2Q1dhVkhhWmRER1EyNGRoRmxYN2NaODZKK1ExUy85Rkc0ODZTa2Z3amxvdDRnSGN6enpyXHJcbiAgVzBYWVRIdk1lM25CNG9oZExHN1Jtbkx2T3lNZUJxQlRUanUvMmJBZEdPWFhjL3o0ZjZHZGNSbUlERHdHSUdsNXIxNUNQRUlZYUpCZ1xyXG4gIDF5SHExSkNwVmVLcG15SHZ0R052STVteUdZUjJhQWtTRlhJRE5PS0JvSkt0aU4vZlpFQiszTmZFQTdCbGF2bUszZS9pZ0tkTlRRaXVcclxuICArZkV2V3dLM1N1SDVNNStlZlAvOXJydExYYnBYQjRUZXNGZzdBUWhSc2FyVGJsZGQrUlhGQ3NLVDJsbXg4dG90bkxMbit5SWUvQ3RQXHJcbiAgTm9DWjRIUUhmYzhVQWxpWlZaYzJocW5mOUNmMVp4Vm44NWk4Qm9UOU9UeUt5WmlYdmZMTnpRWG5IdDFzdE5GYUpYMjc0YlVoZVFxd1xyXG4gIDg2Z2hlNS92YUtVWFcxcVFOdVlLeXJ2ZTY3ZHBQalNBdlNWdjRzKzNTUjBNQXpNc2FadGdzRlVuZzJCY01KT1h4bmJiOW1SSVVGdTRcclxuICBIZ1ZscndrSmJnY0RvZFRRalJHVG1GaXZoZWRSa3NoNHFINVNickF4V0h2Tyt6a0I5dFVGYlI5OTNYcXJsRDBmdmUvMHl5S2pjdTc1XHJcbiAgY2NkL3JhaU8xL3MvWnQ3N0NvKzQ3d2tJMUlYUHZld29RTzNXdllmNG1SU0pOOHM5OFdGUkFGWU9UUjZEdXpUWW1Ja1o1Mkh3UVhVTVxyXG4gIE5wNXlMb0xHdDhicXk1VlpkVHBHRitLMzZ2RXU3OFVEdzRpaTkvVS9jTjlOUS95MUh4Z1ViL1psWUdkbDBLT205NExuenhUMGlRdUJcclxuICBjTVU2dEdmQTdLLytSalJ2NGdlY3oweFlud1lmZjJlZDg1MytqSkpibDBEd2YvQW5keXptR0tTUitId243d3lDVmk3T1FFQ2dYdkx5XHJcbiAgRFF0UjRpLy9UeDl5WE5rb3VlNjZLNVp2WVFrdUhPSWh2YWMrdFhld0dObUVxM2NHaUp4ekwxMThlZWxKbDh3c2RTbVA2dEZteTZSblxyXG4gIE5aajgreU95ZWVldmZHUUhCaTV4eXg4aUFNeWgzSGpUSDh2a1laRjJ3QTdSU0wxNFpqblhha0JjN0JFWjdMMEw0WkRIeGRzNmpiMHFcclxuICA1ZG4zSTBlVWV5dWgxZHUyS0t6eThDOXVPNktwYzlOOHc4YXlFZFcrSkNCNzhKM0psYXltQThRak5wYXNPcC95OUJXYnUrNjR2TTg2XHJcbiAgc2dxdzJrSzhBdldmZWttWjVEZkVMSGo5K3U4djhpYjU1TmQxd1FVZTA3ZFNFU2hEbDFpSWovOUJZTElFRDc5K1A0eDRVS1ZmYnRrWFxyXG4gIGwzdnBESXR6Rk5qeWVzWExsNXA2bWxYZ25nMkJrMEFkcUR2MWxDdU5ycTVaRkJwNmVUK25XTFZkcFZQOTJiNGxuTGdOTksvWXo3TWlcclxuICBaMEdDcXIzMlc4UDM3QUVoZWZUOVEwQmtRb1hWOTQ5NzNLUDc3SlQ2dlZsbEJqZHVQblRlVFlKdW1EcHV4Q1B2L085dVo0ZDVOd3dhXHJcbiAgTHo4Wm5IMU1EVStuRWhjTWk0TmZmdVJCeHhhSFJrSzExM00zbk9mNGM2MHhLSTNhcjZ2MDZ2SkM0cXpORWlBZ1hYOW1jQ2Uwc3lIbVxyXG4gIDNzRTdNOTJZVlFCK3VLWGo4Zk9JUno2aU5EeHVudWR0QjBBRGlYdUQyL09mdDNoL1lPSEdIeGFkaG9wdlRNR0J1M3BLSjNsU3UyTGlcclxuICA3OHd6djFsV0liKzk3b2JteFVzL3I3Q21zS3BlOXBJWEZ1SkJUWm1Nd1F4UTJiSDFQbkhRaDBwWXMyZjdMSkl2eEVSY2tBRXFBMVBaXHJcbiAgWFg3N0hlVmVQUm9rVFRhc3FFNXJWMHZ5MXYxYmdmcVdxWHV6ZkN3ajVVSThMbTdidHJyMHptNTM1VmQzNnBDYnRHTDJaS0dGRmlqdVxyXG4gIDZvbU1JWVREZmd6RVFYclNvdFdtTEFpTWdWZlpjNXlCOG5zbkRpcTJNVXVCUlFraEh1S3ltUlRCVzZCZEVXR2ZtT1VLbDVVSFVDQzRcclxuICA1KzlYbGtrU2lCOHJqbXB4d0EzVWY3N3RJT0lCOXQwZ1dzcDFYZnM5ZmF0QnhDUHRXRnllMHpZODErQ0h1OEhQTy83RzRaeDJjc012XHJcbiAgWXY2NktUdDgwNEUwbWRnQjdhdVduMHdIeVNzWkRJMHQ3Y2FrSnhzVEtlaGtrNjM4bWdCa1Q5WHNRbHhIdDk5Rys2SWtzTnBxcnl6ZlxyXG4gIHdaNDN5a0xZV0l4SzFncE9WcnU5SjYzWGhQeGg5dzhCU1NOd3piMkI0ek9ISFY4Mkc5WHZWYWFCd1QzTURoc0xEOW9BYjZBeVEwamNcclxuICBvSUhyb056RVc3OGJCRGFWeEdYeklLcXRLcE9mREI2MGhnYWRnKzdqcDNFbmpld0xHVlltL25UbWhFc2FnL0xwT2VXSWhVNytCL25iXHJcbiAgK3IzN0ZwNTducUgyNityMFNGZnh1ZUtyUC9KUkwyNTJuMUs1NUZhekNyQUZkVVlycldPUFBhT2ZaM1drRElnSEdGUWRWRlUwYnFiOFxyXG4gIHVKSVpZTEZaSlRsTWl0d0lQMW1aL0ExRS9DNi8zSXVMOEZJWVJNQTdoSVNKN2hBUHFDMnFVa2NVWGhtMWgyZTI4V0E5aGEzMnpHZS9cclxuICBwc1FsbitRVUc3WjFKeTJybnd5bzRiOUw5NWIyM2dCdTFtNGpwUGlWU3hocE1OdlBPakcvNHRjUkR6M3NoRDVoMEtiZjhJWlZ5eW9XXHJcbiAgVy9QbW0yOHIrd2RZUEUyYkVwYk03VTl0UHFWeDV0ZS9WZDVaUFlUMVl1QTFlR25Ea2EvbE82YmRZSlZGa3liZkV2aEZ4QlovNXFKRlxyXG4gIEZzZ0FKRGtaUXBWQlg3NGYrdkFYTlRmKy9sdGxkaHBOTUNiNDY0MkFxWE15dlRQT3VMRGtNM0tRR3NtZjFSQklsN24zdDFVVGswRGZcclxuICBwT3A5VzB2UWIyd0pZTXJqMzRYVnROVVRBa3RaSVBLMllaRGZsTEc3RzM1U0tJdVRCMWtKOEcwSDVXczZpTG92NGhISXB6WU5pWDlPXHJcbiAgaVFjWVJ4M294U294R1ljeVhIN0ZOZTJLWjlseXRiS2E1ZUNvbG5nZ2FEM2JnQ1lSQ01oRCtscG85emtPYnBmMWdlVVNJQmFCeGdJYVxyXG4gICsvNmRYZVhUaFUyRGx1RFpTMEhiQURTQWZKU2tOdzdacVV2SUZCZ0l1Y21icTMwTHcyQWpsRWJCWDhLQSsyR1F4N3hQR2lHRXcrQUlcclxuICAwN3pYeUx1Z2FkVXRNMVB6TlhRd2ZzVGpUeHZwL0hPUExqenVRSDdzVGdhRHFQT2pyUnJWVHdZVmZtanNpTXRmZVdnWWdlZmFIOW1GXHJcbiAgYjI0MlJtQ1lUcDVySUV6Q2VVZWRGSlpZOHJYbDJSOXZtWkE1ejJidDBzTmE4dnplOTJ4Y3d0aFhRVGhOdGlGdkJQY21HeHRzdUYyelxyXG4gIHlhWTc5Zk5jdHhYYVlNQ3FnWDBEM2pIdjhvbFBmYkc4UCtua2MvdmZHYWdrODZOc1dlbXdRNlZPc2U5b21TbS9mRUhDT2hCS2ZBWjFcclxuICBZSGJGTEp1L0tETWtUTlE3K1lma043dUx4US9peGJiQ1hqVEFHNlJqVE5PTU5QSHhoM2hZZVdENS9lSVgxNVY4a1dYa1lEaElHYVVYXHJcbiAgRGJNenp2eEdVVjJ1d1YveUVGYVBRZjdDRHBFQmZwbWxRYUJwK1FsWGI4N3JnbVlTUDlvZytMYXhkakVkaE1VN0R1cEJQWkdQNVg1MlxyXG4gIEVJc01HWnV3WDBHY1VCdWpoTGpQS2ZiWis5QXkrR3V6TnFGUzhrQWdUQkNzUGlLckRYckVnd3ExcVFIR1YyK3N2dDhJU0N4T2dzRU9cclxuICAwdUNodm5kOGFxQ1JwTUZPQngvZC8zUDlzSmx4NkREY3pGNWlkTTd6cEVnK2RPVEVMYzVSamNsR0tPLzVUeGlvNzd2Z252ZTVIM2FBXHJcbiAgdm5jT2FYTEZtM2ZOMGJNMXVIZGhSV0xBclNHdk02Wk11U1FNSTNjMUVhSE5wTnhZRW1iaFM3emcyY1dTTDFWV0JCT3N5T3A2WVpmTFxyXG4gIGMvS1ZxelJpaFZjYkNQSFRjZUluSGRiZmZUcVY1NnV1T0xYY2crVTJZZ0g4SFB6cFkvdmg0c2FpTWUwK20vR2lPbW9Rc3BTM3lsbG9cclxuICB3Y2MyTDMzcEM4dHBmQ0V3Zy83eVRXQWVHWUlCbCtscmJMdEF1bFJRYVZ5cHIzekxPaisxR3ovKzRzL2tLdkk3L3ZqaDE3MC8xcHM2XHJcbiAgcjgySTJKME8vQUVUTXd4NkVtcS9waTJ2Y01ETVM4b0IzRmRlN1IzTkJWTkVnSUxJc2NmMVZwVTUzZ0FRd0xBeGhVMzRSN2NEZis2RFxyXG4gIHc0N29uZVhOdmQ0TU4waHprYUFZNnlabEE0UjZITVN0WG9RNTZ1aVpoajlyc0JsWG41OFJBaXN2azJwbEF2LzVkb0dWejZRd3dja1JcclxuICBGb1R2UUFXNEJyWXVtRkROTFh5NFRkZlVZOU5OMTJ2KzFCSU9pZ0FPaGpQSm9WR1pNMU5xL0tWZHdmYTBzZlFxckRYdkgzbi9zTEFBXHJcbiAgTDFhalJObWlDZVR2dzNmdlg3akVjNXFycDA2K2c5bGhZLzNqSHVlalA2VS8rL1B4WGNWcGlXOWxFYmRjaHlINXNCU1hqN0FNL0lVelxyXG4gIGdCdXNoc1VoZmwxR09CQ0hzdHB3aGgrZCtBUFAzaWV0aElPa1hVTkg0MjZsSmI0blBIN0J2bFpSN1ZmKzFFZnRoakRKVysxbUJlY3NcclxuICBaQTBNMndidkc4eGlvMW1UdUFqY1k2NEVvY2JTcXVQakwvZktoT0J3TTFCaTYrREZlOC9OWUlzVlpDZTBqc3BkM1NXc1AzZCt1WHQyXHJcbiAgNzRwOTR0NmZzTi9wZVhtZitwZTI4MXE0RVZaVG9TU0hzNC9EYXNYbUt1V2p6a2syUUJsQUhyQXVheG1TZXFabW5uelRyTHFyN1d6cVxyXG4gIEMvdUZhdXg4N1h1c01OL1E3SnMvMzBPZHlRdDNWL1dRK21MbWhNYmdHOSs0V2wrVjF6dnNLdStWSjIyQndKc2hVa1JFT3pLcFFkQVlcclxuICBNT1FYbUJoQk9GTEhOWGJZZnZPK0c2Si8yZVUvS3FxNThnWHFqRUEzaWlQQnhtLzVZRm5GSkt3OEtVTjNZQldlbk9GclgvdEd5VWZLXHJcbiAgckI1cXBFenFuaC85a3JJQWYxMi9vQTJheGVmYmdyVGs1NjF2N2NsNXVxQnRSckdCZjM1cFVrSWR4eWdJRXlMbG43SnkzMkQ5MWN0M1xyXG4gIFJnREhRVmgxa1BpNjE4Q3oxV3JYZlhheHdpcWJselhFc3haN2F2T01aejZ0VEpBUURySzZYLzdxdW5iQ2VXRTVaNmVHQ1V5UGZlV3JcclxuICBJQ0RXSGcrOS93aUlEK3lJUktxbDdsV21hd1o0eVAzQ0N5L1lsNDhFYWJDVEludENYSVZOQXc2U2Z0Nk5pejhmM3hVdjNZQWlqT2VZXHJcbiAgM2hnR1plSTNuVjluZFE2NHdkNU1mUkJQTm5GTE0rRUN6M1YrRTdlL0pUYmlnVWdhMkx0KzVZV2xUVVFDSWNkREppUDRmVHQ3cnYwNVxyXG4gIHNHYXhaNjdTSEhYa1hpVU9Gb090M09RcDM4dTFTNUFNZHB0c3VtT3orRE5tTlczTkxBd3RIck54OXBISUJyQXlkVDZXa3NWbCtXNEZcclxuICBZdUNVenJiYkgxQUlsTHIxREs3KzNKSVA2ZGh0cmp5RTY5bUpUeE5wdzQxMktJTG1ESEpXRzU4NTlFdkZyOFBEeEJIRGhZVGU0c0pXXHJcbiAgSUo5UjdxK2QrYzNtL1BNdktYbktuL2FaOEtsekJFZzRmM0dJUzdtc1JrNmNrbkY0eCsvMU45eGNCS1RLbVFHVnUzcGtPNHcvMm1McVxyXG4gIDBUdlB5c3VQZEhQb0ZvRjM2cjRNdkMzeFNQdm0zenNydTZ4KytBdnFmcUNlckw2Y0dFbmJ6ZXIva005OHFXZ25kb21IVldndDQ1RE9cclxuICBJT0lCM2xIQU1GZ3B4eUZ0bmErNnlzeitITWluT2sxWnlYaEc5VWZFdXdpWXE0bFB3ZzVEUFJETEYvL1RHWnlGOGVjLzRlUHVPLy8zXHJcbiAgZ0wxYVhkU3F1NGtqVjVNQTdUeUl1OVdlODIvbUZGYU1UMTU0b1dhTmRuTGtxR09ta0l3Umozamt3OHNtemdzdi9ONHNxcnRrWTR5eFxyXG4gIDlvaEdWaUE5cmRiN2pZVUZ0ZlZLRFEveU1hQytYM1AxM2l3Qk5QanUrUmVUUUJyQ21zMjUrakJVL3VwMzNPb09OUXp4aTAzQnhFUGtcclxuICBLdHcxTFBGcWxNTWdiQkN6Mk1JNm95SFdmd2NCaTRtL09vLzFmUkMzWE1PelR6M1hZUGI4akhabVNBaExrOFRnQzNVZTRhOS91clJmXHJcbiAgSm8xT09jMVU2bkttRTJxazBoYkhoL2Q4VDNtdTJWNXZhNWZQM21PUHhkU01zTFYxWVlnN3JOTU83TzZUWHR5Qlc1MFBRbDZvV1FJR1xyXG4gIDNUZStZZFd5NFRCNDk5Wjc5enV0cS9Sb1lERUxJajc1c0lKd1hvbTZ3eXZtci81YktXQnZwVzZUbDRTSEo3UURmWDFvR25mK3NRcGlcclxuICA1Ym4yYnpDRWxOK0tJdSt0U3NCbVR6QXdleWN2akRzSzR3L2NzYXhnbjcyM0tWZitwSzFNOFFjZjJ1bWc0bTRuZjFSZktSbFlzZFQrXHJcbiAgSU1SRGZ2Sm5RYnYrSm9FODBQU0pQODhIZkhTN3FiY3o0UjMybTI4WFdhSCtNQTVZWUNuVEpEQkJReFNsVjJPUzhQS1VNZzY2eDhhZFxyXG4gIERoS3Vqc3NFSnRhdWEvZllPcHNUN05QR3AyMHQ4dFFuRnV2b0p0UmtmcTl0SjFxVVp1eWg2aG9OUmNSbkl1d3JyTDYvM1g4ckVLaG5cclxuICBGcm4zOTJGSDNRTkJZdTRueGJMdERJcVFpSlpVNHNUdkUrODY2NnhRMkdrMzMzeHJXUVhVYVEyRDk5Z1VaaDIwTUZveVh0eUVQZTMwXHJcbiAgQzhxSGw4OUJQRjcrREdoZzFzV0haMnc5eS9kQjZYdU91bkRDZ2gzTGlPSWcvenBnM2FpVGJ0ZXY5R25WaURzd2FOVDVVSGRtSXdTa1xyXG4gIFZQM0VZK1pMalpUUVdTY0cvcTBzbVUwbm9BUHZ6SDZmOVo5cnpLSnE2WnB2bjg0aVRiTlFxeWNzQ243eXAzRkVkZFE5NFhNSVdmTE5cclxuICBIYktKSzgrSkU4dEtuU3p6c2lXYk4yKzhReGtFbFFNTEN1UUR5MHZuV24zSzZCK1dwTCs0RmgyeTRSUUxURmpDYnZzQ01vczJLQ2tmXHJcbiAgRGFwbys5bEJUOGhPRUsxT3NidEFHSEdFQUxqblgvdWduR0NWd28wR29PdHFiZjY4VzJDQngvVER4Y0lDdG83VnpwMS8vM3VadFhwZlxyXG4gIHR4bDVvZmtJQ09hcXIzbEhjMnk3MHJFQk1KQjNOckpxVlYzNVVUOGhIbUJsWlNMdzBZOThvRHdIM25mYm1qem1lM2RCalJsQjFRNnBcclxuICBPaU5jK3VjZ3Z4UUd0THZNeXZtUkhpNUR2bmtYSmhQaXhFSnpma3pDOE85YXE2Z1BBMy9xeS9rMUNSdDM2dDQ1Z1hBVVJxMCtBdVpyXHJcbiAgUEdNNWR0V2I1d1Nyckx4WldVTzhmNXUzbE0yRHhxYmZYMzlUV2UxLzlXc1hsdFZIYldIYVN0YmtFNWVndC9xd1dkcDdKbHorY3Y4U1xyXG4gIGtIeEExL3IrYzIzbmp3RXpIU1FWVzkvWC9pZEZUd1h4c01JYlRWaFgwSm1zYXRaZi96WEZyVHQ0RGdNL1RFYXcxMjhacU1HYjRhdzZcclxuICBKYUMwSWF6ZTlWNUQzRHFZenB6T0hUYVQ5QWNoK2MwQWczVVNtVU8zc3dZNlpPSkhnTEJrdW43ZEc4QmRFM2ZTcXYxUzA3UzM0NWgyXHJcbiAgOEtZeHBVNFJack1YczhZSUp6Vk9BN3ZCQnBUUlRJWUtycmpZOUVrWms3WjlETEdFNmpzakhpQWYvdHhxWFh2cGN4TVdoTFB5OHcyeVxyXG4gIEVTcURGWC8rQmxzRHF4Vmo5bnFrYmtCK3JTajIyL2Y5ZlhjckI0UCt1Tmt3T1FsMVcxb3M0clZDc0tKaTVkVGdpRDNnZkFmRUNDRXlcclxuICBPT0FyeTUrNkVNYTlzbVpTQVFnTDRzRllKazBrN29Vd3RaMy9oaHR2bVVYT2tiRFVnVzJPWkhVZ0lGQ25JbHEzclhQYlFmaDVTNnhUXHJcbiAgQ1AxQkIzNnd0Q1dDZU9aUVdBZm9FZzhyeVM4ZmYyQXh3Nk4rVExyK3QyMy8rKzd6dmlsZlBmQkx3d2ViazZZVkt4RDV6dHBDRFc3S1xyXG4gIFRyWWt6dnhwVWFWY1hWRENFR2JHakl1S2VZMnd1amJZNERYOVRjTTE1SWVKSExDQjA0b1F4QUhlNTM0WXJOSnBFOW8wSzgvYUcrQVlcclxuICBXRkgvdmUyTGc5VDN1NUNXYjVBNGNCV0VEK3E0NXlieHNQUDh2SGExenlUTzczOTNRL3RORml2RWczcTlnK0JNaEsrNnVzY0JDT3lkXHJcbiAgdXZXMnYwdzltV1NwWmZJZExLMzdlUVVDREhYbHd4MzNwVE5MbzZOelRLWmdhWjhCQU9wN3FBbktwT2pGOFpUU1FNVWxEZzNhZm96TVxyXG4gIGRqSVRyTk1hQm40TU9EUTdhRXFJMTRCTklHdzJ4VjZSQmpNc0x1N2VHM2orK01jL2wvS25BNFVnMWVBLzcvMXB4TGdHM1hUdzBjM2tcclxuICBhV1R4RnpWQklFeXNPNXU2NU1lS2hmQWJOSFFEdVE1S2pnTFNZTlBzZkR1aFcwTEI3QUUzcGtIVVp6MlRjMCs0NjVBanF6VjFTMFBKXHJcbiAgUUkzOWhmMEgwclk2eURmV2lXekdzMUZML1lDcjJYZk15UVJNZzBobjNmWGUwNjQ2M2xMQ01sL0Q2S080REV3c0FodG9FQmpmR3lGS1xyXG4gIDJ5SFhlTlNqNTJzZVBuWGNNWGZoMUFXMVdXWnV5SVFzOVZuQ3hSL0djMWVXdEJVei9WTk9PYTlza1BNTXRBdWxkWE5ibnhRQ3FHb2lcclxuICBHRmlFSVJoSlM5bTZSSU83ZXRjR1BGTW15SHR6UWJ2and4TVhua3pKVG5QdFpwOFBiMU9JdFBTVlE1NlpXYW1KQjRPTjVFMVdIZndoXHJcbiAgYVBDT0xmY281dFZydi9ZRmVLK2VuVFlJNGozaXFCUExaczBheWtIMkZOYWtOaVovL0V1bmhuNU85cVJjM29NdzZaZGRKQjUvOVNOY1xyXG4gIGhPeWVCeEVQOEU2NzRBOVI5MXlEK3pqVSsxNXFJbVExRHBNUWovMzJPN0xaZWVlZWNVVmxrYTV2YkNJV3hEMUl2dWNVckJ4YlJ6eXVcclxuICBKZjZydldiWkl0YzY0T1AvVTdRdjJiM1NwbnV5anBrZ3orc3BqS2hwL2NPVjZSWXF2WGZmL3dSRWRuUndBNTI5QXhFbU11TEZKb3NQXHJcbiAgclVKZDYvdUU3VGFFY2VnSjAyZXVNTkpJYVdXNE44RDgxMUxQNjZkVHB6Y00vSmk1aVZQRHhsYXg3RXNhTUN3Tzd3MlV6MzcyZjVTR1xyXG4gIDVIbmhoUmNxRzcrV2F2TXhDT0x5VDBlcVlVZS9XV0VOZFN2ZUNOTE5ZaEU3TTd4MHhNQzlnU2kyZ0x4SEJBMGdkU1BtandEWGJGdTlcclxuICA4Y2VhNk1vckxWTTBvTnAyTmVXenAwT09iWFZUTzF0T3ZBalAyaTN4NE5kM1ROemkxV0VjbjBsempudnFFS0lVd0t5Sm1TQXdSOEVzXHJcbiAgaGJEOGFrZDMzUDYzL2lDc0E3aG5iOG9tdkQrMjMwZCtmOXhPR2h6VlM4c3BnbS9wdVFJLzJvTTZNMWpFbUtlWnYyditrSFA3YlRDMFxyXG4gIFVzbGdFajlXb2VKVzk1N2wweURKT0dST3RFeCt0WnZrQS9GZ3BORitFTFB1UC8rNWQ4NTl6R1FrSG41WjgzM3JKdXVVRFlwWWZkeThcclxuICBXNkNOSTMwcFlTZzIzSFAzUFlXVmt6cTJxcEdINDc2NGY5OHYrQjdxZ0Qvd2puLzdTRDc5cVoyTFcwQ0J4S3JGZS9rRUV4QWJCL05jXHJcbiAgZzVWazhYcjN0Q2xiY1dtVGRSNEM3MEFialdGT2FZMWlYVUYyV1BPdlR2aWRaR0RldS9VektOOGhIdFBGSlpkY1dkaHowczRxb3lZZVxyXG4gIHRYdWdmT1B5T1E1WXpEZzdobjd0d3hISzMyNVhqbFRWc2Q1TURoaHJyV0ZQencrdi9sbDdGK0c1elovNnIzdXJrb2ZldjBKMDhIRm9cclxuICBBWUdsczlrRXJOZk9yZ0o4Mk9Ed3FhTlNRVmlWTzMwWXNtWUt6WHkwOTc2blo3YkJraHZ5YmhJWW1PdThHT1R5YkpZL0twL2VHUlM4XHJcbiAgOS9mczRDU0RWTndHSWU3ODF6RElEUUovTE1TNkl0akJvSExXOW5kQVdnWUY5VlFERzBoakoxQTF1RVVBYmxNZnR6cnZ0THdNc3ZZV1xyXG4gIGdIQ2xFN2N6WGRjY3R3dmVZU0c1SnMyNlU1blpVcmRsOTZoKzc0K1htL01UekJpVjc3Ly91OGNHY0UrYnpOVk0zZUR0T0ZjRVNUeXBcclxuICA3OXlySzNHeWpKdDcxMEgvcEUvdWdwMFo5OFNwWFJPTXVpZXZDc2l2NU1lSmg0bS9CditwRytYSmUrNHB1L0QwOUtNUmhaMEkzTVVaXHJcbiAgay9pd3g1NkhGRFlVeFlhdDM3MWg2UW5pNHRkMzRML0crejZ3WC85ZFlMTEY3U01kdGhYYll3VEE0cXZMYnBObXQxekF2M2lwSFN1TFxyXG4gIERibnhOOGkvVlg3UnVtcmZZVi9PK3UxN3U3VzdpSjlvbjlXZ0lteGxPQXFHeWtFd0lab3V5RDYyN1J5SU5RN3kzLzBtczRNbzVwamtcclxuICBYZFQySFVKelpYajNsbThxY2lUbStXdFlTZE4rblFtVFVxc1RCSVFRWGMwOEFGWWdRQ0FXdGtkV0ZabFp1T280dWNlUHpnd0ZkRXdyXHJcbiAgaHVrZ0tyM3JyNzlhbVJGTGt3ekUzZzB5RUVSRXA2czdRdEliQkVRQzVJdC8xOHlVc0ppRWgyRnhjSS8vaE1WakpreDNQeWhjd3ZnalxyXG4gIE5sQ25QU2dNWDNrUEtWczlPQVIxbnVRRjYydUZsZ2gwVnlMZzI2My9wbTM3UkYvWW1PeW80N2YvZ1lhUGVNMEM4NjNCQVBycWx1Z1lcclxuICB6T3Y0M1p0OWt5RWdiSjVUbituRW5wTU9JU21JOXl0VE5ybXNnTERsbUlyNDRoZS9XanBrRGlZeXNDQkltZjFEN3YzRlcrYzM5VWYxXHJcbiAgbXNDUmxoTEZpMTlQdWRPUXdySnl6LzRVN1Ntc3RKLzk3TmQ5eTd0V0lWODYvc3htbDUyM0xKTU42Zm1HMkV4Sk0rbjVSc3FRdkNVL1xyXG4gIE5Lc2N0dVdkOGlCS3dvanJLVTk5WWhrY2F4WVE4L2R2M1h5WElwOWp4RERnajFVSVptcWtWY01rZ01uMm80L2F1L1FKWWNtTnFENTNcclxuICBCelg1Nmg0VERWWUp3MlFTTm5teTV2dm90bjFsRlp0Nkh3U3paSFdLTlVpTlBHM2hWNy82WFJ1bVovVzVpL2dScDN0ZzBCSmIwdGlCXHJcbiAgRFRnTU5rNVNFaUY4WjFJbjRRM3FvdzZaR29iVXpUQ2lNTWhkbUtRN0oyRHF4K3JqVisyS2U4MDFsaThjQ0cwUG01MkNoNDJ5Tlp4UVxyXG4gIHlBckFqMy95Ni9aSlB5TTgxeUxGMHRQb2hQdDlCUUlIZjNLblVsRlFONzU2eHBCNzcydDN3cWY0bng3K1VRWVdIeTFwNHRVRHRnVjBcclxuICBaeXlqSUh6aWNjMWYvSkIzdytCOWZVV1UrTWQraW5tR0x1SVhDOHlxb281L1VGcmROUGhKQnh2bTM4Qk9PRXdyU2IxbzRFNVc3UG8vXHJcbiAgK2NSUGxKbHQ4S0lYUGFjL2NLUU9ncVN2Zm5QdllLUmRkOTZpT2ZIa2M1clZWbjluL3dBb0lBdEQzQk9QUEF6cWdJU2NrTHp4STM3aFxyXG4gIERZRFpSNVQzVjdVcnBoMCtkR0R4azA3SzVIbmk1cS9iQnJNYUpndDVmbHN2aE9Ga2RqWU1lczhVaUpXV2Uzc2V3T0ZiNHJRUEF6RVdcclxuICBMK1VIMm9ETXdFaWJqVFh1L3ZLVHZBTTNaZmRYeDlnS2RpaG54Y0ZkZW1HVEtXZkNHaVJXWDNQTFp1ZmREMjcyYk9Pa0NoMElZMlpLXHJcbiAgalR2K1FYcUlCemFrMVVOMjg3OW5tMzFMMnQyNjV6K21kY1RqQ2xiU28zWjJ5eXRMQU1MRXBNY2cyS1dkT1BrbDdLMmZIUm8zRFBFSFxyXG4gIGFUL3FIcnJsNkVMZWhNbHVjTWNmQk4yVEVjZWgxcnlhRk5JZWw4ZEpFTlZkWklEMWdRTSt1bTBoR2pRcVRYaXdTTHV3RjZ4bm9raW9cclxuICByRDVjcy9yb2tZNEh4QXFFUUROOFNjaDlQVU1kZGc5MTJFa2hmTDJ4ME93bmpUOVhzNkw2dVU2emkxNTgzeXZhSmprWEpIR0kyeDlHXHJcbiAgeFZIN00xdW1NZlduUC8yMUw1d2ZGSlliQllCSFBPSVJaWlplTDYwSGhVayt3WUFUbGgzWTQ1RFZWRUJyeW1CT3pvRFZKazdDYnRwTVxyXG4gIE50ZlY4VnVKWk9hTXIvcjBSUmNwYnA4NitOaG13NDIyTC9yOUNDTDRYdjRHS2hCR1hURXJZYk9pRFhqeEMvR3ZVOG4vdkMxeDBzaDFcclxuICBzTHh6RUJRZXZGazRQK0kwczVkWDd4T1BQTXNuVnRQRkYvK2dyRnJNTnJranhnWXpuY3B6UFRPbXhST3pGem9Yd2s3bVFhQXFyL0ZMXHJcbiAgMXNLL2U0TTA0a0ltYytPTnR4UUJPbUdsZkZCRFJWeTBMLzZUTjVELzFLVzRULzdLakRLWVd6R0U1ZWtkT1E1TkhlR3NFQk1lZHRybFxyXG4gIGt5M2hQYTZVYjdPcGZUZnloT2Z1ZEVEZlJwNXJxRi8xRjQ2QXRMQUY3UkZCVUdpUjFVaGJFbS82Q1poMERMTk9Hei94TCt4M3YzZmxcclxuICB2ZklTSUU1V2tBWitNcUVvaEl4YWVZaFhYZmhuZk9EbU9wM3hRaGpmMlZraFdKRFBlKzR6bWpYWGZGV2ZxRTBuSHVVTlVVQ015RHFEXHJcbiAgUWNSaU92R1BBdFZkZU1FU3orNmZKSXBkU0JaRGNZbE0wTW8vTUNtNjdiYS9WTHZSaldjMFBhMCtUS0NNTVZyZi9YQ2cxRERJVGhwL1xyXG4gIDd2MVY0cUI3blR6V1hldXcwNEZCWTVOTjFtbE9PWFZHMlFrdWZoQ1hCdXFheGtiWVZCdVFHd1Joc0NkY3I3amltbGs2VkRwdjRoMEVcclxuICA3a25id0VlVGl6b3NyWmRSWWJsYmlrYURxOGFnTUo2cGN4SXVzeGliTk1VeEtIN0VJL0lOUUdnSUViRVc4Ykd6OXdEU1FRMUMyRmppXHJcbiAgTllDeE5VVVRxdHNwREZUY3JyN201ODNENTMxWUdVUThHeVIwS3V4TlJDN250QWpyYnpCQnlFSlEvR25EdFJYWExMbmtjMHU2dE1SY1xyXG4gIGt5YS9TZHZWUU9wcXBhUU5HZXlWbnl4Ty90Mjdla2RtWXVOZFp0VE1QbmlQZUFUa0dkSGtTbHlQYkdkNXQ3ZkVRMmVNYVh4N0JieVRcclxuICB0bXNnbnlFYXZqLyt2UGNJUGVMaDNtQktBUUhiOXRUVHppL0VROXVxNDFGT0dtbTc3clJGcVRmdjBoYmx5MHFJYVpjNkRDRG0zRkpIXHJcbiAgaWRkQlZvUDhnL3JGZXNPcXdnNHUzNnJONzZpK0loN2h2bmpzR2NVSW9qSVBtMmxiSVRsVXpEZVJuMHhhL0JkZDlNbWxuZ2JCKzN6dlxyXG4gIGpBOW0zTlRRMHg2R29SYWM4K2VVUW51T0dHZzB3UkN2L0k0VDNBZUQ5bjBnUm5YWWJwNlN4cHlDNnU2TWRzSkNrVUtmTFpzVUR6dWhcclxuICB5T28rOXZIUEYvWXJTeG8xV0dxWUtST3g2ckRhb0xxTGlGaUJlTzVOVkI4d0JNUUhWb2xwSFBpVEJpRDgyUmk1MC9pamZiTFYxaC91XHJcbiAgejVMNHA0WERKUEYwWUhhdEVURFhJQTZOT2gzTjlaWmJidTBURm9RaCtSc0c3M3g0TTE3aEVhWkZGMzFLMlYyTGZ4c05tbEh4ZUFmS1xyXG4gIEtUOW1yYTR3TEd6eUhuL0FyMmNDL3U2cUFzeGthYndsWFB6N0Q4cGIwb0JzOXBJWEc0MllseVlJRFhRRW5SYTd4YjI0SVdXekluRUFcclxuICBWTURQS2l1L3ZKK3VhenFRT3R2bUF4OXQ5cHc2Y1RHZExJb0FubW51MEh4RGZHNXRWd1RjcExYZWExY3FjV1ZGQWxScERVamlxbWVpXHJcbiAgL0xsMzdkNzdZMW5VN0pocmYvYWJZb1dnTnEyTmVCalFsRGZoRVkyWHZ1U0ZwVzBtcmtDZTVJRzJpL1pMcFYxZWhVMGM2dHc1RGRpSFxyXG4gIC9BcGpZckhHR3NzMUs2NjR6Q3p4cVRNV2hBMTRPMzd3N1ZPdXZiYmczWXp6THlsRWQ5Q3F3OThLSS9FSmsvd05Hc2pJWDdKcVUyWjdcclxuICBDbExIVnM2akVIK0loNzFYck80T0FuLzZuVU9VNU1NM2s2OVRUenV2WGVIZTNLWno3M1lLeXFMdWhIZk5kMGJnYlhDMXkzNFk0UUhqXHJcbiAgakxkMTNSTGFCOTVSL1o1MFo3aDg1QnVveTF5RDdqTWs3M09LbGFjMkRqN25PWXVWUG8vdGV2RWxWeFIxOHJQTytuWlpRZGN3T1ZHK1xyXG4gIG4vMjh4OFovMkVNZjAwNFE3RXkzK2tCQVlnK3J0Mko1d0JBUXlJY0dtNzNZM2tFOFZLYVBhVkROZldhdStjaU9SNjAvK0tTUXBvMkZcclxuICBaanBZQU9JRWNlV0Fxd3lxd3diWEd2TFBuM2paWUxKVTlSemlZUWFGMVRRc25xVERQNEdsTUdZSlp0emNkYzdzeDZpUmNBRjFYb29CXHJcbiAgQ0JkMy8yNmFkUmhYYVEzekM5ejh2OTQyUElPVVRtaHoydGxuOXc3bXFjR2ZiNFQxNGN5QmZDdC9HOXgyM1BrVDdUSjY1dTcxUUdmS1xyXG4gIGVlYkNNREdDMTYvSjd0RVNFZlZxNVZtYjA2ODNGQm9jVjE3MTdjMW5qOXE3Q0gxRDZFQW4vVTA3UXpaSW4vYlZDOHY1SWQ2Sm03a1NcclxuICA3Q254ZTViUEdzbDcvdmFpSUF4ZGR5dkdHcjZkZGlUZXBKVTBFRmdtVUtpWHlwUDYvOFRIUDFUaVlTYWV3b0pOaDFoMUlTeks1Mm93XHJcbiAgQ042eHhlN05rVWVkVkdicDVJbllQRmtCZ1QwM2hNNjBwdUlHMkJZcnRuWE43ZU1IN2xEYWl4VkVCanZ1WFdJRDNqMys4WThyN1ZzN1xyXG4gIHc2NU1PeEoyRlBJdCtET3JmK0VTUFh0amc4Q2RocEM0NVNQdFVqNkhzYTVBR3VySUgvSTlmOXRPTkxwN0xnWkJ1SHl2eEtITXVSZVhcclxuICBiejhKSnRsMTNuMlcxaUNpUFYxazQrQ1QyZ25rYlMyaGVHTGIzazFJOVF1VExzb0l4cGthbENtK2NzcDVMZEdZcDNuOFFvOXQvdkpYXHJcbiAgS3cyVFE4U0QzNW1yRDVqbkgzKy9jaWJ6NjM2R2lqUmJ4cjdJY3hwektuVFlQY1QvZEdFVmdxSUttemdPK05qbnlnd2p6N25xMkxRVFxyXG4gIEpvRXdCUFVScHFZUmlnZGJnSHJvTUFnYk1KOU9yaEkzd3NtYWYxckRJSWhvSmM4MXVBMUNoS1RrSndiQWNZTkI0c1ZPb2RKSlU4VkdcclxuICBRU1lpSXRpdG9kemdXekhSYmNZWnQxUGEyZVRsLzNkeXVhL2hQWUpoUTFzZ3ZJRlIrdExHbTFiZXVnMEV3cHQ4ZlBta3M1dVBmMnlIXHJcbiAgV2ZJZ1BKTWpaRExjZlJQeGdzMkNacW1BRGZQWHY5N1JQNnNoblp4OHBGYkZoYnhEaUxDVkVwOUJmY1o1RjVlWkh6ZiswZ2FrbmZ4NFxyXG4gIFY5OEg4ZHNGZndjZDlQbm0xcGJBV2prRVNRT3dJYXlBRVBBdXBNMXZIVFpJWHJvdytiSDZySkc4TWIxaHBUQUs4Z3pDMVBlRDBLMFRcclxuICBJRjlFVUVlRjhVNGZwY3JjTFVmZUQ4TnBiVnRjZDkyVlNqbXg1TFJwa3poeHFDL0dINm1yenc0Y2wyM2lsRzhlZEo5aGtOdnNZTDU1XHJcbiAgWDFpR2ZXelcrUjg5Zjl1TzcybWU4SVFGbWswMldyczVvcDF3NUJ5ZndFYlQ3VDZ3YWZPK2JUL2FQajJrZWNMakYyNXUrb1A5SG9nR1xyXG4gIHBRSEhic3hLUUI1UUt4Q1VmYnNkUHRaWHJUTUwwQm5xR1dIM3ZwNHRNd2xnc0owdW5HREdCQWRoc1pQb05EVG1JU0R4MDFhd2s1cE9cclxuICBmdEliQllPeVFRN1AxUmtCMUQwemkvSm5Ha002dytMaXpwOEdmM0diZHYzc3RNSGtxd3RhUGt4b2VHLzJ6aitWVTRSc1dCaEVnKzBvXHJcbiAgNXJadDBCT0czMkgrdVpWdjgrcVhsbVd3NzZEeCtWYkM1THNGN3YzeDJOZGJiK1ZpYVpUZzMwQnJ2NGNPb3k2NllReHUzQkVTeis3RlxyXG4gIHIzTmhiMklOMG1SNjVmS2I5TU1FN21sZklTSU01NWt4aHBYbE95QUMyRjNLYk9PZk12bGJXWGl2VERTcUh2T1krWXNxcTdENXE5Y3VcclxuICA4azZlc1BYY3k0UDRuN2p3Z2lWdXo2blAxSzJyZ2M1NU5NNTl4MmJoVHg1cS80RzlQTFRVanYveVdjWFV2VG9TbmorckxVUXYybkRlXHJcbiAgbVd6VVVQNFhMclZlc2RjVkZyRHZUYlBwM0JrWGxYd1BHcnlFczNMdUlxdXAybEoyRGVIa3pSV2tWZDkzNFowNGhWRUgyb1lydFdkdFxyXG4gIGUxQVlzSnZkNE03L0t1MUFMN3o2ODV3eHczOFVtQjBpUU1ZMkF4d1FyRXNUQ25GOTluTmZhZk0zbWR5akMzSkFLeC9sRXg3N2o5YW5cclxuICA4WVNNMGNaaGJHRG1nSEkyMFp3Z3NvK0ZuL2o0c3Q5cHdZV29ZUCt0ck43WmJUdjk5QXVLN0tvR09lVUJCMzYyYlF1M3RhdnpCWnNiXHJcbiAgYmpSWnNQcEFQTzY5K29EUmE3bjdBZlhSbHZsUUdzMHV1MzJxZjY5UjVGN25DVFo3Mit2NmpYTTZjTWlUaGhHN00rR1BTa2NhVmlNYlxyXG4gIHZtbU5FcmZuU2RLbzl5amd6d3NYVEJxSHBXYWRaaDF1VkJ4WUpuYVp4dytWMHlDcmpTNE1HZ1RXQk9KSkM5d1BTb2Yvb3ovN2xYSWZcclxuICB2K0IrMEFBRVZpZTBrS3krMkJRSzhwMmRVMjdKWDBOY09XMFFJUUVIWkFHL1ZxeFdLVTZ0bEU5N1NkSStncTNldldFL1gvN2U0L1dhXHJcbiAgRk9RVVB5dTh0S1dVVjVoRm45NnpSQ3FjZkdZRzZ0dFFWWTVjSktaUlZsN3A1VVVvbnpMVm9FMWxnSWFrNWNxdndVTStwVlBYSjhnUFxyXG4gIDR1dGZaR0kvUDdjNS9aU0RtL1BiK3F6cmUrOTlEaXZ4cWVlNEJZbkQrek5PTzJTVzk5cktHV2YyalBkMXc0SDY2aDVNNVNxdWQyMjVcclxuICB3YjN5QzlKTFBkYjFXZDkza1hmeW9KNDl1M2RsMG1aUW1LRExpa2tic05vVnJ0c21Ca0ZhMkdxMTN5aEZtRFFNcXB0aCtISkxqR3BvXHJcbiAgRTFhdDRoQS9GV0ZRTHM4NVA2U1dEYzRKOXA3cUsvZmNkVmRaZlZEblJxU3NvcGk0NldMRmRqS0lwWm1UQ0IvNlVGd1doTU9rWVZhaVxyXG4gIEVWaFZQNkJZV0lFR2s4YXk4NjZmTEdhb2E3ZGg5NENOMHQxSlBRa1NqNCtaajV6R2F5Y3pvUlBoWmRJaTFKeEVXRmpuRXp6WDkxWTlcclxuICAyN2JMeG1HSVgrQ2ZPaU16RlVIaTcySlFlalRKb2dNL0xCenR0cGdkNTBjOTRLbVRNd3dMWTJBeWFHbDhObWdSakQ3a0lmTVU4eGZEXHJcbiAgT3QxTGxubFQ4NzJMaisvWE0xQ05aQWtVbTh1NTY0UEM4bytRL1BhWE04cnFEaEJNYk1LVWs4MmYvZlo1WDNObTJ4WjBEQVBqc0x3SFxyXG4gIFpwZFdMQXM4N2pITlZULzhhWFBHMTc3Wmx2azVaUlZwbjhla1lNVFJnVnMwWHF4c1Fmb2hGQkNXNURBNDV1QjN2Nyt4c0FjaDRVQk9cclxuICAwbUc1Lys3M054VTUxNmd5K2o3eVkrYzU4SmU2a2kvdHdrQTJDTDRsVzBtSjI5RzdpS2M2SDVaZTNXWURmclZiN1hkUU9MTi9NcW5rXHJcbiAgcmI0YS9HTGlhQkNTWHYwK1lldjJOUXpkUFJyeVlpVXUzQ1RoQnlGeERncmZkWnZkTkliQjZtUFh0by9NMXhLbFI4MzNpR2JCOW51cFxyXG4gIGQrWnNzSHlwajNjSC9WTk8ra1FwOS9GZlBxZGQzUy9TL09LWEVhNGpIclMwN3IzNitQb1poejZ3V0ZqQm9ZZWZVTFJ5Z0FHOExEODFcclxuICBpdHpqS1VaRmtTQXdacFRaUjRxLzZhQVgvNlh0Y3JsbnFkZXlPUTJUblNvZHplelNxWFYwM0xHbHhxWFJpN1BIZHRHWTgreWVtMzlZXHJcbiAgWnNQaWlsQXovdTNFelRPNERnckxMV0hNamgxeTQ4Q3FPcTVCNFN4eDdTMkllWElEVS9qZVhkWlVFRmJJNVpmM3pJMnJxNTEzZW1kWlxyXG4gIE9odVV1NnErOE02M3Y2RjBITVNBVFMwc0pwcDNWbitJa1RvaFREZGcxbW02eDVxNStKSWY5TTlkeHhmblQ5bW9HQjk2eUs3TjNYZmRcclxuICBYWFlMMDJ6Q1hsbjBtYXMwSzdUdmxXSEJCUjU3TDgwMGc3cjRFQ1gzWm9MU3dpcExYUWEvYVFmUks2LzhhVGtGVUhvTFAzR2hrajRZXHJcbiAgcUxVUGt3dmgvVk9QcnY3MS9oWklHOWx4cDRPS2JUSHlHUmFPK2FYUmx6clFKcFhSczVXTXNxMjk1cXVLTzc5ZElCektxNzRpOUJWZVxyXG4gIGVpZWNlRlpoV3htNHNGQzZTSjZ3ZElReGVhS3QrUE9mLzdiZkpnZkJrYm4xQkVRY3JnZ1IvdnVnY05LaUh1dWQrKzcxK0JQT0t2MXlcclxuICBHSklHOXQ3MUxVSE5NNmlyUVhYVGhVRTFSL1dTR3lXY2V0ZkdXR0lndko4RWd3VG5iT05aclhyMnZZSVFENU10Zlc1dXdMNlBNdFRmXHJcbiAgODQvbXJ2YVBEV2VTc083YUt4U1pZRmVPdGY0YlZpdVRIaFo1V2Q1OTRzSlBidjV3c3lOMHJiNW9YYzAwN3g3WXFiN0g3bHM5TUZjZ1xyXG4gIFpySVo3Q0NOaWUwakExUHQxcjJId3c0N29kbXlYVnBQRjQ1eVhHZnRXVzM1ZEsrME9OS0J1dWtPUXZ6ZzFVY21VYnVUMjlTbnh3MENcclxuICBIajJaQVQvQ2dYc21PRmpQTkxNWWg2VG5hcjhJZmpiKzY3QjArWXVndVE2Ym1mU2djT2tNL0FIK080RytNS05tV0FpTWpVM3hJeDd3XHJcbiAgN0Q3QzlHRng4SFBjOFdjMlA3NzZqRm5DQmxobU9vZzhZNU01NS92MWIzeGYyVXV4NDRmZTNqL0xaRmhkekUya2JoaTJNOUJSaHJEQ1xyXG4gIEkyOVJUd1o3eEMzbm9DUlBxWHV3ZXJFSmNoRDRpd3prd0FPMkwyMnUvbWI2MVZycmJ0VWMrdWxkQjVaWG03QktUWmlBWDJmZVlGc01cclxuICBDcGR5RFlLNG1LTFBpckZHTjV5NFdYVkc5SzBLRjMvbW9xM2I0SjNtd3ZKUFV3dDd4cmtremhqbmJpS0NKVE1vcnpXWWVGbSs5ZE50XHJcbiAgTjlxa0NhT0JIY0YzRE1UdXV3MVdOKzdDZ0IzN1htbkRkWHVzbjVsSnNkTzk2MmQyWWZXeHl4VDd5cHJoa2UwcWhNYWNpUTF0UHh5R1xyXG4gIDdvRC96ZlAvcHpuOWpBdWFqMzM4QysycSsxbk5GVC9JNW1Ka2lMd1BPWjAxMUdYZk83Rm94VDRnQ1FqVUZSck5IVWlqNmQ1VFZTUUVcclxuICBDdXAzMDBFNlRzSzdRdTRIWGNlQlA1Vk4vYlliSDJpZ0d1cW91UEI0Q1FycmNGQS9qOHNMZi9IUFdteFVYSWVGTTVERWtCOGtiRmhoXHJcbiAgZzhKNS80WU5QdENjOC9VanlreStUck8rRG9KdkR2bnU5Yk43ZTBHR3NiWUN3dGJOMzdGYjg1MXZmcUhJU3NpdWxOTTlBM0hKUXcwc1xyXG4gIEwvRmE3ZTY3MzVGbHR5NGV2TDBiQ0Q4UXJENitNa0pwTnFrZWZEZi9Hais0OGlkRjd2WHIzL3l1N09qRk5xREVRS1BuK2h2K1VEWnpcclxuICAvZUlYMXpWYnZldE54Yjg4cGIyTHk0YkxETjRoR2xBVGxDNlVDZUV3YTg0aFhqWGhnTWN0dEV5Um5ZeUtZeEJTWitQQ0xibmtmNVpkXHJcbiAgNi9FYjkySGhzT3BpRXNSRUNPdlppZ2szb1JmV25wckJ4Q1AxbFdzZ25KMyt1N1hmTS9rWWhyejNmYUxWbVBpOEk3Zm9IdU03RHRTMlxyXG4gIHMwZko5NDY1cERxUDQ1N25CSTlvSjBqV0M5aFhqM3prdzl0VjB6UGF5ZWV2eW1TdXNCRGIvTlY0VTd2UzN1WTlHemVidldQWDVxYy9cclxuICAvVzNiWjVkb3ZuZnBqOW8zVnNuUnZKcVZnTHk1N1ZQSGZvR20xZ05NQzZ1R0xNYzBlVG56dVAyZ09rZk5SdEZRbGxxeXQ3Rnd3WGFwXHJcbiAgWHk5VmFTN2xtTm5wSU9ZUnpBN0ZsK1Z3R2x2M3FwUFc2UTZDOTFRREU1ZHJmYS96TU9xWE1nNkN3WXBmbWhUWVVXWllORzVpZlRkNVxyXG4gIEdoYSttMitOQ1M4YklZbVdWeGYyR25EM1Q3M0x3N0xMOWc2RkdnVHVPMnkzV2QrY2VjSlpWZjdrcDc4c2RxTHNXM2p2MWozcnh6WDRcclxuICBzeHA3N2d2V0xpd29uWXFiRHBiMzVSeU9YMTVYeXJISWt4NWZabFkxYU1wWnBVcWZIK3dVa3dzMmdFRCtEUW9SRm9LSmgvYkdCTW5HXHJcbiAgVThMTmxkdnY0Ynh5aElDWmRBSlFwbEwrOU9lL05KZGRmazNieWE0cUJnMngzV3dxWTM3ZWlvM2NBOXVPNnEvOUVlL2FZdjB5bUQzOVxyXG4gIGFUMHROVWU1T29EcGtJTjM2UTJXYjMxdGFVUFp0ZisvRjExUjJGaTZxN1pOQlpNZllRZlZPZE10Vzc1cnozTHZQU3VyUVZoYjc5LzJcclxuICBvNFVGZGNicFBRTFRoWG9xaGdWZnUxTEpBNlJ0S3RPd3lRSUlHOVQ3UWVwNEJrRTRpaVlVRVlSYmVlV1hGemZuaUxqS0o0STBDTjRyXHJcbiAgVy96NTEvZDFPeCtHczg3NlZrblRwc1FYTC8yQzBzYlVzVCtJeDduOTA5RzZ3cnF5OFJod0Zwd3JEOEluL3VTOUJyZEoweGlGYUY0QlxyXG4gIGxWMEUrZXh6L3JkNTZsT2VXRGdCOW4xMFZ3dkhIM3RBYytycDV6Y25uM0orODVyVlh0SDJMNWFjbzNrVnRkMVpRNTM4NVlQSzJBRVBcclxuICAyQlVJbUZGWjBrTk5wZXZHVWQ5VEFmN1kvalBQV2g3WGlJYmhhMmQrcTFsempkNE85RzVqSE9VMkN0MXdUdDR6VzRIYWZWeGMzZ2Z4XHJcbiAgVHoxUVp4d1gzanZzSzVwWXRkL0VPU3BjM3NVdlpIWThiUGJrbTJFL1JZdXEvb2Jqd0MvRGltOTgvYXI5TUZaaGVPWEpEeitUckVwQVxyXG4gIEdLWklycjc2NTRWRnN0Y2VXNWRPWG5mY3VpNkFPclRCclY2dDFURGJ4ayt1ZWNwV0pubnUxcTE3SFk5QU0xQ0hOZ3BTRlkwbDR0VDFcclxuICBNSWluVnRVZDVuKytSNys0MldXbkxmcHMzeTZTTjRvTGJJdDE4NnQrdDk3cXpmM0JvZ1ovQmc3NXhoYXJNVW4rSWVtNVJ2a2x6K1BBXHJcbiAgSDBMT0pFY2RaanJob2ZhcnZCUm0xbHpqVlZNdS9Ea1VhN2l4eGhxZi92U3h6ZGJ0eENqdFhMMUU5aGUzWUsrMjNacFlJR0NqTEFKUFxyXG4gIEJ3OXBWeCtHZTNwVFZ0c21tRlNmVFdaWVR1aGk5ZFdXYmZiWis3M05XOTYyVTl2T2Iya0o2Ukl0d2JtMC9hNm1VMks1OTc2UGpUWmNcclxuICBzL25pTWZ0TlBUMkFWeUNnR0dZQ0VPcnR1VjZGMVBmTU5NYy9uSGYrSmZjNnZXNFNTUGRIUC9wRjI2Rjc1NjZiN1JObXBuSG1xbEZJXHJcbiAgMitwZ2xPMGZFRThkM3M1Z2JtWnEvdHlaUHJIaXFzdlFoWmt6emFDRUE4OEdPaWJERS8rZ09MamxsTGh1V2NSbEZqcklOTDV3TE4xaVxyXG4gIEQ1azlKYjlsMXQ2K08vYTRyelgvYUFsWU4wMTFrd2tBbU1WVFF1QnU1bng4RzErK1hSZmMzLzJ1TnhYamRUVFY1RFBmTjkrY0xNcnlcclxuICBtMERaKzBGQzkwQTRRbEFFbE5EZjNwZlVrMVhOcHUwcUJRdUxzTlNlSFhFUzd1dUFDTDB5NDJ2YllFWVRDUkNLN0kxUUgrTHlEUUQ3XHJcbiAgbzdicUxLMlQyN0wvOFk5L0tuSDc4Ky92RkVYaDVkdnpJQWh2SmFYc3dKOXlpRnVadWVlNnltcnZhRjdWbHZQSUkvWXM1bnE2RUJlTlxyXG4gIEd3YzRRV1J3M0YzRjhhajU1eXQ3b1hKV2ZBMysyTHV5cXo4cTZpbEwydVdvY2xpNXNjRjI5ZFhYOXRQTkNzVHpLUENUZE5nSHczNmlcclxuICAyc3pOT3dvanM1NWpjVytRZTZTY3dxUzl1Rm8xcEY5anNTMjMzT0RqcUFmaHBTL3RIU1ZndG04L0VKTTlkZHdtYnRwZFRVd21GY3lQXHJcbiAgZ3ppMTQ2d0cyRUd6TWlhelV0L2RWY0o4N1VUbjB3ZnZYTWFjQzcveC9iWXRyZDE4NGRnWnpmenpQYTZkVUNBYzl5WWUycGRWTE01UVxyXG4gIDhJQmVnUUJ6Mi92dnQyMjVyeXUrYm16MS9XWnYzN1dZc1FqcWQ5TkJaaDVKTS9HTXU0NERmOEN2aytnTVJnbGZZMVJjZFpwQi9XekhcclxuICA3aUNCWlZDSGQxVkdHa3NJaUlZK0ttMStEYUlFOS9YM0dBZmFPVnU4ZTY5WmhPSFN6eW9HN0pobWhYZ1VDTUV2blBIWmNpK2Y5akNrXHJcbiAgckFhVmd6NTVUTkd5aXVCOVhIa0dJZmxLNXdmUFZqQllRV1JaakZHYW1SdDhiVW8waUMyNTVIT2FSejlxL25KSUZXSW5QTmFXemtxOVxyXG4gIHVhdUpOZ3JVU0UwS3N0SklYZ2FWUjM3dEtyYXlHVmZlbE0yc0Y3SDhUanRJVXRPMW1zcHh4K1BDQjdXL3VzNG1DYThPclNqTmp2bnZcclxuICB1UStYZVFBL0NBVHIxRW1EYk11eHlJVG9Cc3l1dGVCaEVGZmlTRHV1Mi9OMFZoNjExaFZsRjZ2VjdvcXFqcHZRSDRHWlR2OFpCWVN3XHJcbiAgVElEYWU5TVpxM1Q3U254UEUxSkhNWFJCL2tiN2lsYldqUE11YVZjZlN6WEhIWDl1ODdTblBtSEtDdSs5Q1lpVmZqMGhoQWM4QWFrL1xyXG4gIGRDMUlyaXQvMWc4LzB6OHdVamRNWTJVY0VsZDloYTViMHF2dlI2R094NnpjK2VQdXp6N25PMFdtVVp0UUdZWTZEc0NPeVlFK3dhUjVcclxuICBJZUIzMmxzZzNMajBJZldlTk8yQjZKMmZQSnF0NWZUSEJhYzJOM29HL3QwYitJODRkUGZtSFc5L1EzRWZCUDdJVXB5aHdTUzFtV0lHXHJcbiAgeE9UOTVsdHViZjc3eFVzVVRSNzQvQmRPTDhlOWVwL0IrSUVFZWRZUlV4OXJyZm1xL3NaV3lMY3c0YkRpTlpEYUk3WHZma2MxcjI1WFxyXG4gIG9JTk15TlN3UVE1THBmNWVOYkNEL3F0dEI2Tyt1YnlsN21wL2lXOVVXSDZzeWh5d3hWOGRwbmMvbm5pQXlaR1ZKd1VOY3NXazZmMm9cclxuICA5S0hyUjNtd3dHcmJjaW5qdUxocUpGNWh1KzArYm9QU0h0WkhwZ3VzSzIySDVBSUJXWFhWVjViamhwKzQ4RUpGS2FOcmJkZCttOS85XHJcbiAgOXNMbUxadnVXTFlGM0g0SGhZWWZ0VVJuM3VhMlAvRTdlTmQ1V05FMStIcEFRNlhqRndMS21obHIzUkhxZS80M2Zzdk1RLzRSRHg5clxyXG4gIDltRFJOaXZFVDUwNERjYVZxUXpJRHZaSklKdzhzNVZFa09pZTJRMm4xcVd4cFV5RDREM0VqNWx3d3FtamNlRUQvdEtCc0hkU3Z6QXFcclxuICB2SGYxUUN5ZTJQWWExVEc4Qy9FQXovNzVSaG9wb2pycW0vRS80NXlqeXZXZWUzcnpIeXd4eURkWjc3VXJsMW0vUFBMM3VYWlY2dDU3XHJcbiAgLzRjKy9FVmxuNFQ3RTArY2RkZndQeHZxRGp0UStxOVlidU55QmExSEhzM3lhbnRheWhQUTJNTitZczVrMVpWZlVlcHJHUEdRanI4eVxyXG4gIE9zcFgzRjE1QmNMaCt4dEk2M1JxSkI3MTJOMEF5UjJHaFlYNENmSElaa0wvbWVISEV3Lys3ZmtoMU0ra3l6dC85Nk1RdHBXNkFHR1VcclxuICB4M2twaVIrNC9md1hvNCs1clZHbm5mNlFOT3JkNjNYYVVCT3RPUUhCdVhhVEhTVHp0cE1Mckh0bVVveEhYZUlCUngyeFoxR2J0enFoXHJcbiAgd1BQdGIvK29lY0lUSHRNU2oxdmF0N01TamNDa2JoQWU4Q3NRd0RkbmhocHNmbkkyUlQ1SVBsRDB0c0ZIeFJPTlpkUkpHdGd3ZlB5Z1xyXG4gIFk1b1B2UDh0L1RpU1pwNkhYY2VoOXU5RGsyTzRoK25HeDdRMmxsSWR2blliRno1KzZtVjNNQ3FzRGhKVElQa082b2Q1QzNzR3NyTEpcclxuICB1MEhBd3FndHk2YVRNZEJvSnpaQjQ2VEFnbVBQQ2ZzSXNET29MOWIxNHQ0TTNzbUN6RHA0cm9tbWUrZUxrd0ZrUUFCc082eW93TjROXHJcbiAgSGRBTXJ4YUt3NStualBsaFg1a2wxMGljcnRLcTIxTGR0dXAzMkZpL2FtZmR0TVJHQ2MxckNBY3BNelZWOG9MRUt5MnJHTjlxRlBpclxyXG4gIDY2R0d1THdibGgvcFdpSCt2LzkzWTEvbVZJTUczVTAzSVNhVEVZOVI5OFB5RUVSbG1MK2NzeUtjd1U4WkVzY2tjUVUxNitwclozNmpcclxuICBDTis3OGVTYkF1T01PMnkvV1pHZDFVY0R6QWtlMmE0KzZFdFpDVHhrM29jVk5pbmkrdENIUHFTNTgrLzMzZ0RvMk9tUDdiOXQyVGg1XHJcbiAgMnVrWHRPM2l5YzF2Zm5OOWM4bDNMMi9iSy85T0hweDE5YkZHT3laODdhdURKM1FQQ2dJQ2RyTEd5Rmo5VWVvUFhydlg5OUI5bmc3Q1xyXG4gIEQ2MGJCOVFOcGM1SGZUOEszWGlZNDJCaE5oc081WGxVQncxc2hKdVZsenc4YjRQZ2ZRYVcybXhFelJZYkZiNUdYYzhhcVVGNkhBakpcclxuICB6U3ByY3hyaXFTSE83b2JEVVJDZTJxMUIvQ01mM3FhNEVZSWJSTG9zTy9WKzFWWFh0dTcvV1FhYUlIVm4xM3MwcTI1c0p6QzBwYkFIXHJcbiAgQXJNNGh4VUZ3d2Jjd0N4ZVBZdWZiSWhkTU9rRWVmL1ZyMzJqQ0tuZjBxNGVKcWwvbXcrcC9mS2J0c1BVQ1RkSEU5UEdxci8xTU9SN1xyXG4gIEowLzJ3TkFhakFaZk1DcFBkWGtnZm9WZmV1bm50UVRXL3ByUkcvMFNSNTJYUWZlajRnQldpOTgvdFNHMlczWnRQZCtpM2c4eURuVzZcclxuICBhZlBqM0NEdWN3TWZidVBhYllvN1l4Vmk3NGZKRDVWd2g0WU53cTEvdUtpMHI0V2Z2SHl6eHVyTE5uLys4enpOdFQvN2VmT0RLMy9jXHJcbiAgdnYxSDg1QjU3aTZtM0dzQzh1MExqeG02SCtZQnJZVlY0L2ZYMzlTODRQazlBV3RtREdZUnRRa0N4ZWFXKzFvYnBQczhIWHg1Nm15U1xyXG4gIGIzL24rMFY3UkR3YUJXT0NyTXVta2FUVFRwb09QL3dtUHZzRG9uTnZvSE5nVU42UGlzL3UrRG9lVnpOajlXSWw4SVkzVEdiNWwzVmFcclxuICBNZ3h4OEUrd0R0Zis3TmRGKzJ0VVBwUmRHTHpwbU9QLzRyRmZMVzdxaEpWUnM5RkJZQm1XT1EwenRPOWZkblh6c3BlK3FJVHgxeG5zXHJcbiAgRFlBWWVxeS84ekFJYTBQYTVwdTlyc3gwc1l6OEVTR0RhYlR6RUpOTC8rL3E1cFd2YUw4dlFuelBQWDNiVnl3QTBLZmZhS08xU254Y1xyXG4gIFg5Q3VhTFREVjdUK1dkcmxiaGU1ZzZYa3lUOTdHL0l0bkdaSUYzK1paWlpzNitTTTVrMXZXcU80KzlzNUhSWld1eFJ0emo3M08rV0FcclxuICBLV0VSMzNYWFdXRnNXZFVKUWFxVlVMMC9BaEE2ckNPcXd0eTlsK2RoOEIyRkZSKy83dG05QXJJSGlnVGF4ZUtMTDFyY0JrRTZYYVM4XHJcbiAgaUs4VmlmS05LbGZpU0ZzY2R1ODZDbGJpbTJ5OFRyOWNkZjF3eTdmNC9ER25OMnVzTWRvY2ZZMWoydnBKSHNRSjZpeDE2eHFOeDR3TFxyXG4gIEVMYzVCVk5LNjIrMFEyRmRHZW9SQlJxQjg3US9FMUQxM0YwWk9CT2ZmSVFacU50dSsydnpwZzNXYXR2ajZjMlBmNUtqYSsrY0NqTXpcclxuICA1T3RldTFJNXpuY1lIalFyRVBBaFFyM3IrN29oVVV2RC80YmFEM1NmcDRQdUtnVHJwamJ6a2JnWkJOeGw1eTFteWRNb3hKK1ZCeHRLXHJcbiAgMkRBR01HN2VRZTdIeGRmMWI4WnQwSmEzYURpTmlpZmhyL3JodGNVZUVIL0NhdnpQZnZaaTVkQ2k2ZFNmR1YzT0pnRnhrV1A1anpvTFxyXG4gIFpSQ1NiMnd0QXlXaXljeTZIYlJYWDNsdjY2TGpJTDdmdDRNOGxVK3JXMHQrOG9WdDIyOGEyRjlqMXAxNjZhNWN1a2c1NDcvZWM2UHNcclxuICBBVVdCVHgzMG9hSWVyRzRUYmpwZ0lRQ3YyOG9UQnNXVGZNQzROUGcxTzhmQ3ZQeUthNHJKZmV3LzN3ckwyQ1kwR0JWUG5SN3dHN2VaXHJcbiAgOTVNSnk2TnRGU1M4d1VwWjJiMWFkNTJabXlZSElXWktoRXQ0SzlLYXRjdVVDT1VCTE9UWlFmcDlrT2RCWnBkb1hkWUhvYzBKSWpnUFxyXG4gIEFjRVNVN1pIUDJxKzVzOVQzNnFHTWVYdU8zOVEydHdURjNsMWM4R01vNW9kZHptODdhTzNOdGRlKzh0MjFmSFhJa2MxZ1FvSTJ5LytcclxuICB6bkY5VWNBZ1BLZ0lTRDVFa09mNkl3N3pFM1NmcDROeHJDeXNFTE0xczNBemdrblRxdU9ycjZCc1plWTBaZDVoWEh6OFFPSVpkajhxXHJcbiAgbnJ4bjViVmVrV1Q1UHk3OHB3NytZbUc5Qk16UTVCUzQ2OXVWNUpPZTlJVCtnRG9KUVRKRHp3eXVtMzd5NVQwekpHZC8vWWl4K1J1RlxyXG4gIGxGbWNRZG16MFhZaXhoT1BQUHJrY3JaRFRtUzBnWlBwRXJQWU8rNjRzK3c4UjZncFZzZ1RsVTRyRkpqZFBBVXBheUIrOHB5WVB2Zk9cclxuICAzaG1EL2locnVWMzRGcWxmOFRIZHZ0U1NQZXZMQ0pSSjBianZKUDFCcVBOZ1ZkdzFKRm1qL203dTdVU25OczB0OGJ1Znp1WTdNMzdFXHJcbiAgZ2VLQlZhZUpVREJ6WTJxdlgwK0NXdTZSOE4zeEI3ZUN4aGtrL2RyUG5JTGduTFZkSzJLOWFwNTVIMWJraUw2ZEE5QnNETzJDRW9uVFxyXG4gIEJzLzgrcmVhazA2ZVVTWmZuLzdNS2MzVG43NXdjOW5sckZrZ09tTHNrUU1FNTVDRGR5Nm5UbzdDZzRxQVFHYjRrRlVBSFB6cFk0dmdcclxuICBGZXFQMWYxd3RWMnQ2V0xQdlE1dDQzcFhZWVYwendlcHJ4blFJRzdqVU1jQjNYampac0FhZHlSbk40NzZYdU9pYkpDNFJ5RitzTlZxXHJcbiAgdzR2NUJwTjBpa0hwQ0FmQzF2ZWp3Si9PR3RQMzRtVm1vOVowNFFicVAzRzdUbExXQnlMa1h6dkN6MGFnSU8xS0daWEpqSktOTHNRTVxyXG4gIDJ5SnRiNUx5Sm41K1UzZUJtYklaTTVuUG9CTU5hMkMzMXJJalNQcml4VUljdDc4bjN5ajVxTU1IZVo5M2s2SnVCMUNIUCs1TFp6WnZcclxuICAzbkNOcWFmUnFOTk9uRFh5UHUvWU5QdlExTm4wczVQdllYaEV1L3BBSWd6MzFndlJwcG81L004S3R0R1k2NkdNZE1sM2Y5QXN0dWlpXHJcbiAgemRmUHVxUzU5bWUvS1Bhdkh2S1F2N1hqZ3BobXJqNlkzdm4xTDJaTVBRM0hnMFlHRXVnazRaMmFlWm1OMk0xNXgrMS82N3ZyRkQ2WVxyXG4gIFovYzJJK2JFdE5xdTFuU1JlTmRhNjlYTmwwODhhNkRXaFN0L09ySTBkUHhKMHVKSFdETTBiQ2U4ZWpJUWJvRzRtQWxuNEMrMnBnWWhcclxuICA2ZnJMMDNYWDNkRDgrQ2UvS1BHUkl5QzI2MDl3Y0UzaXNQZkFxa3JlZEE3ZlFCazEySEZsRy9RK1pjbzFnMzNxYmhDNGs1VkE4YmZ5XHJcbiAgWnMzWlp4N2UveWJ5Q2NwckJSRjVnSGdmMXM3UXFEVXUrNnBOK29lT0ljUzFPdkg5aWVRL2Y4ZnFmdUVMcHhjRkJyTlhNaFZ5QjJYMVxyXG4gIEh1RjArSlJ5V21rczhwUW5GaGFjc3ZNejdwdW9FOTlPL1lndjdRWEVZVU1lMHlZdzZwamE1RnViY2hVMjE3d0hFeDdxNnNQQW56RHhcclxuICBYNGV2NDh6ektQQ2pQUFUxN1lCdE13YzU1VjN2ZU56SldWZUQ1QjdpVFJ0TTNqeFRPaURmQXV5c1RUWlpwOXpQS1ZaZmM4dm1KMU5tXHJcbiAgU1F6M1ZncTByWHFhaCsyS3VPMmJOV2dUempqN3lOSjMyVml6Q3J6OTludWFKVi8wek9ZYjM3eTRIRWN3enp6M3NQemVZbWJZaTc1MVxyXG4gIDdFUUtCUTg2QXVMRDU2TUJ0Z0l6eGR4dEdqUFFnVE10bmpVbDZIT3FtS1ZkS2tTRDlCZG11dWcxeWt0YjRyRjh2OUVNdXNxZmt3eVpcclxuICBnL0E4U1ZyOG1QVVJWb1o0aUU5ZUlYR0haVEVxVHU4TWtzNVNlTjNyVmk0Mml4S0drTnI5dURyd3pwOC9nbkdya0x2dXZydnNHUUR1XHJcbiAgaE9zeHo1QnZNZ2pZV2dTYS9PUXZENUJyQ0FtRGlJTk1hQVR5UkoxVitvNmNmZVp6Vmk4ekxPN0NzOS9rSGFHbU9HK1pNa1d5VWpzZ1xyXG4gIHV5THVUbW5rLzRNN2Zyd29MeVEvM21NSDFPWWE1Z1pTOTBraitUT1Ezem1sTUJIQnRmWXNQL0pKc2NHa0FhLytiMU9hWUhZN08ydEZcclxuICBlK0RQYWtIY295RGRwTmNsSFA0QnN6VDJvSWg3V0p5SU05WVdKUVBveHVPWnRsenNzNDBqSHBDd2FlUDY3MG9yTFZPRXhjN0p5TDZQXHJcbiAgVVJBdTRidlhwejM5eVdVdmpQYVJ3VDlXY3llQk9CS3VLeXkzV1prd3Z1NERoeDErUXJrWGJtNFJqNzNiK0k5cXg3andIN1JUZFVQUlxyXG4gIHc5aGZ5eStDZmZmZXBsbGhoWmNXTSs0WFhmeUQ1a003dkwyZElGellQbC9RVGxSKzE4dy8zenpOMys2MG5wbEpQSGJkZVl0bS9UZE9cclxuICBkakxpZzQ2RkJUNkt5bU9QQjZndnNvdkR2VjR1MTB0SUg3ZGVjczd1eVlYUWxZWDAzR2JPbnVJK3lHMFNqSXVMWURyN0d5YUpzL2JIXHJcbiAgeEhTMGFyaDFUNXdiaFRvZTk1RU5jSnMwTDc0RDFOOGlibUMyemVBaHphSGF6eVNnZ0VBdDlrdkhIdEJuVlNaZnJsRGZCM0d6TjhScVxyXG4gIEMzL1lySm9TZ0EyS1lRL1Z5RUFCTVNNQzNKa0hXV3l4UmNvNThUVkxLVzJ3VHA4N05weFZaZklSdjBrajd0TmhUNEV3UDJ6YkNybElcclxuICBuaUh4eGZCajBwdWt2cnR4NUJwNFZwNXh0dUdnM3RPVnVHSmsxRDF3bnk0THpKVjZyc2xrOGxhL200N01vNHVjVmZLWlE0K2ZwVjdGXHJcbiAgMjkzZlVRdlM1d2F5NTRQZ25PcEV5SVhWNGlDNXgwdisrd1hOZHk4NnZ0d3YvcHcxMnZ2am1xM2ZlMEN6NktJc0RaL2EzSGJiVFlVdFxyXG4gIFhKdDRwenpqcE5CSjk2azg2RllnWUliRDFISTZtTTVybG1NbWR1aGh4L2ZkelpJeWkrSVd0aEk0dWJEdXBOTUJjKy9uWC9EZHdsYlFcclxuICBlRElEcXhzcG9kMmFhNzZxUDF2aHgwekZHUlBqa1BnU0o3QzlaTGIvM2U5ZDJieDZTcjJXdjZRL0N2RW5QdXdzY1g2LzdXQzBYTlo3XHJcbiAgN1VwOVM3UGVqNG9yNzlVYjRzSGNlUEpIYVlBYTdyajY5TjVmSEJrUTgwZU1YcjdNVXNVQW9PZGpqenVqc0o3a3JaNzFEUU9WMy9EclxyXG4gIHpkSVhmK2JUbW5kdHRYY3hPcGk2RkJlQ29Cd01HOEtQcnZsNUljaUVvZ3dvQW5WdGNmQW5YK1hhL2gwUjRCUkpsbnB2dU1ITzNhYW9cclxuICAyeXEvbmUvZ0ZMKzExMTVobHZwMEwwN3R3cjZNd0hzVEhiTmJlWU9FVXo5WWpWWkk4bDdxYUNxK2NkRDJuWDNOUnBSNGhSVXY1UHJLXHJcbiAgVnk3ZHI5ZHhkWnYyd2M0WG81UHk0VGx4eVo5N082ekg3YkpPWEFoMHZnbHdZNUJRM054Kys5dnJDd3VQaXZRbzhKdDRYQ0htL0FIeFxyXG4gIFlYL0tPeXU1RFRhWS9Oenhlb3d3OFZwK3VkN0VNVGEzYUNaUzUrYVBiTEgyZjBISDJ2T2M0QzJiN3RoYzFoSlhRRGd5blhuNHZJT0pcclxuICBCNkx5amZQL3A2elF0ZXUvL09XdnpmWFgzOVpjZHZsUDIvcDhkRHRoK1VucmZsdnoxOXRubm1WRGx2YmxMeDA0VXV1cWk5SFMyQWN3XHJcbiAgdHR0MjAzNEQwVEErc3QrUjViNmU0WEgzUVlPNEIzUHljVmRzbDRYMm9OUU50NzQ2RXRVeXRzNFBzeXJkUEl5Q3poUC9WSExoNlU5N1xyXG4gIDhpeGxTbnFUZ0YrREV2OTI5bnVPRmtuZWo0ckxlMUJ2eXBWblljaFZRUHdnempxZlhRaVBEVlg3Nnc2TzRWZUwwNGwyOFRkSmVkblNcclxuICBZaUN3TnZPUmNPdHZ1TjBzbmNSS0ZJc0VsQ2thZElPQW5ZUjFZekFoUE1hbWNWNCt0bUs5b3g1L0hWSkhZTU5hMkgrUStzWktTVGtCXHJcbiAgcTlVN2RVUkFXc2N4S2VSRitMUnhlMXpFbjdpU0ZqL2pJRzhKRjJXS3VuNW9OdldlNXlrNzlFZWhqZ3NTVCsxbXNJZHdHRVloOFhYalxyXG4gIFpRRWdxeFlUQnFBRTQvUy9TWEh3d1YvczE0KzJSOHV5aTloczQwOGU0dDhtM0VucWRoSmdYZGsvbE1FYThZaU1hdEJ1Yy9qMHAzWXFcclxuICBiZFZoVWx1OVo1L21iVzk5WFR1aHNrZnBQNW9EUDM1Y3UxcTZ0ZTM3MkxRelY5WU9PaHRVeGxGNFVMS3dncHBGQldsRVBuYjk4ZUtPXHJcbiAgRGVITUVFZDlCbDIvMHdHQjFNVVhNK2cycTJydkpOZEowUFZyRDRLemxlbklFK0xYK1RhZ2pmdjQ1QkR2ZmMvRy9YZ0gxUk5Na2o4OFxyXG4gIGJ1cUs0c0IyWWdTeVc0L1RxVnQrb2ZZZk40aDd6RkJrdjg5MDZyTUxjZFVyR3lxNk52RWhJQ0gyT2NJWXBEdHVkcFk2alBYZFBCdXdcclxuICBwWk9CTzJuT2J0NkRFMDg2dTUyNS82NnNPRjc0d21lWHdWZmMzWGdaSVdXU2Y5THZBYlFOcVNBbnJwVEZkL2Y5dWFmK2N4MkZoQS80XHJcbiAgajJYYSt0MjRlQUxzUm9kM0plMm9pSXZUdVI3MTBRVi92K3Z1ZG9Xd3pGVEk4VWhmRTc1dXg3bDNUTEs5VEhXNTg2NTJteHQ0eEpUV1xyXG4gIFZaZDFOUXcydTE1MXhhbmxmdFhYYk5HY2Z1cW4yblozV1V1RXptcE8vK3I1emUyMy82VjV5bE1XS2lzOFFuY21lc2o4R0ZpY0xoN1VcclxuICBCQVRxajF2ekhNODcvK0p5eWgvVWZ1cU5la0g5ZnJxd21XdWxGV2MxOStFZTZtZjNTY2ZnUDZtUUNodmlMWlVRTG5IWFJJUUs1YkJkXHJcbiAgM2wzb2RBVDF5UnVlTS9VKzhTU2ZTY09zbW03NU9MQ0NhN1kvQ01vTTA2MWZlVERZZGc4MGluc2RYK3ExVnVXZUc2RGxaRjhJaEFCTVxyXG4gIEYyYlI5Y3BrYnNJc20ySUNKRytJdWVOeXlXNXFRcEp2bXVkUjREZTJzeUJ0b283TDdOWnVleXl5Y1hFbWJhamppbnZYYlZ4OFlQVm5cclxuICBWZDRONTZyZHpycFNHcjE1Y1JEU3BoQmVMQ0J4WFhvcHdyUkVmeDlLUFc0ay9kcHRidUJaLzdsNjgvT2Y5ODZWbVdTZ3Bsenh3eCtjXHJcbiAgV2lZdkNPcGhoNS9VTEwzMGM1dnZYV3F2MG0rYkU3NThYdHRYNXkzZk5ocGJWak5ublhsWTBmcWJMaDZVTXBBYXRTb3AzcmtQcU9NNFxyXG4gIDdBWlAxVHZQUHJCN2ZIS3pUdXE4V2RyV2NVd1hOR1o2UXJtZTdTZ2RTN3FlSS9Qd2JQV3oxbHF2S2p1VG8vNDdTWm8yVTZWTUlBeFpcclxuICBpRWJ0L3JMTGY5UTNDdWdaUWNDZkh3YXphLzc0Wjk1aW1aY3QyWTlidmZScXBOZXBKeDM0bUVaSUhJSDR4UmVZRlRMbk1ZelFkQ0dQXHJcbiAgNHZ6b0FVZjNUYXFvQis3UmhwR0d1dlZNN2RsczJmTlByLzFWMFRxcjYyMTJnTDBudmVRbDk5UDVqOXV6TXdrUWVKTUZMRERhY0tsYlxyXG4gIEIwSkpJNGRUK1daWVhtUTMzUHpUdHZNZkJTc3lHL2NReTlqNnNxb2xnd0hocFMyZHl5Ly9jWm0waklzei9uMFg2RjY5QTJWemtGZWVcclxuICBSOEVPY3dQa0xiZmNXbFQ0azRZcjRYMG1TSjduaEhnQUdVZmtVOHpYQU1LcDNMUTdyVFJ6Z0pSQjJRRms0K3BrVXRnd2VQSnA1L2MyXHJcbiAgQzdiL1NRakk1eiszVDJGOVd6M3R2Yy9oelFlMzM3d2x0QTh2OHM3anZuUk9zOUJDRDI5Kzg5c2Iycmg2c1QycG5ZaHU5T1kxeTBSdFxyXG4gIGR2Q2dKeUErVmoxUXFHaHNCd1A1UlJkZlVWUkNRWVAxNTUvZnJkKzdUMUhGQlc3SGZlbHJ4V2pjN0lCUUhSRXgwRkVseGxweC9rSzlcclxuICB4UDJmejU5YTdDM0pBMkt5MUZMUEs2YTFKOW1MSUw5a1BPeEZBVGFLUExOOWM5ZmY3eXB4cHNNUVF1cGdUZ29jQmVIVkVkNjRrL1BrXHJcbiAgbCtWYjd2NGd2aE5QT3Fla0ViZEJxQWRwcXNzelpselVMTERnWThzTVBpQW5NRGpWZmlkQnJhamcrc1kzcnRhZmVVSUdIUG5YMGRVRlxyXG4gIHd2ZkRxNjh0cDh0NU50Z2k5TmdTYVFNUFJDaFQ4cWROWi9DbnYyK3dqdFlnTi9Yb1d0K0RPTEphVWg5eEh3Vm40aHQwbVFkWmhVSkFcclxuICBPd2lyVi9YbXBNQzZmUUdXMmJoQm1WOXBDK3NQNGtoY2Raek8rYWVjTUVsZStVKzRMdkdBMkpMclBVK2ZlQWlYQ1VvSWlRM0xOZzdIXHJcbiAgelh2WHFBVkhvUDZ4QXovWER6dW44QzIyM0dydlFqeHFvZmtvT0tKMnY0Kzh2OXkvWTR1OWlqcnVILzV3Vzd2NnVMbzUrSkRqMnY1NFxyXG4gIFkvUGlkalh5aTEvOHBxdytGbXI3S0E3RCtlZjJEbWliSFR6b0NRaFlnaGtFTlVCLzU0Zm9RSWlIRDV3T3B0R21rZHBuOE92cUdmR0lcclxuICAzOWxCajRoOHI4K1hYMmVkRmNvMWpabWVlSjdKSXFTRGVIQkxIa1lCOGFDYWF1VVVFTDZtWE9ta09uMGErQ1JsVVcveTlMem5QcU9kXHJcbiAgUGZYT0d4ZUhzRmY4NE1kbDQxM3lOMGxlRVVsaEw3end1OFVJbXpBZ0huVWlYOXhvZk5Da20wUlFtalRGUyszWVZSNFpPVFRERjZlT1xyXG4gIExsNkRwL0wvYnNwZ24zcnhqSGl3RlpSZCtNSm5nUFpjdDQxL0pxUmxnb00vbnpUbFgxNENNMXdHTERNWVVVYzk0WVN2RnovQ0pPL3VcclxuICBhUnM1UDRVdzM2cjArYzkvVnFtZlNjcmlORDlwelRqdjRoSnU0U2N1V0RUcjdIeTNVcGRYY1VtSExTeDdxZFNwdGo0S3d2RVhRaWE4XHJcbiAgWis3Z09WZGNBUEtLY1ZER3l3YW9PcXVqeEN1ZUcyLzg0OVNaSjdOSFBNU2IrL1NqV0ltT1cvZGF2NXRiV0dLSmRRcmh3QU5BUE1ZUlxyXG4gIEVDdkc4ODQ1cW94clZQVWR5YjNJSWs5b2ZuVE5yNXJycnZ0ZGMrNk0vMnNKN2xQTHBOcStJOUIzVGpucEU5UFN1dXJpWDRLQTZKQW5cclxuICBuWHh1WHc2ZzBmcWdPbEVHQ1hERko3ZVJMcXdzZm9OMHlrazYzeUFJZS9QTnR6VXZmL21TSmYyNnNkZFhEWTN3azFWWGFTV3Y0NEI0XHJcbiAgYU5CMW5rRllaUkd2NVRTTHFjOWF2TGM3ZUZ4NXZMTWlZbEk5c3FIRWYzMjdndkRlTXY2TU15NHM5L1BPKzdEQ0Joc0h1NW1WeThBdVxyXG4gIHZzOGZjMm9aTEdoV1lUVVNRaEw4OHVPdjdydmZZeER5M2hVeGlhYWFaMlZOeDE1NjZlY1hvbUdWSnQvZWhYZ0FmNm1mZ0QvdnVjbUxcclxuICA4NlNkNitIWk84ajdZWDhudk5IQWNrKzEvS0tMcmlpRTByZEROSnhiSGJhV1dXQUc2dVFIcU5lbUxmclQrdkkrNVFoN3l0OUdNbXhPXHJcbiAgckN2c2szR284eCs3Vk9MRm5zSHZwN2xrUldMeXBVNzVkNmIyMm11L3VsOEh3OEJ2OHVpZjhOb1VPVjAyRm5wWFg4ZEJIUGFHVU5NL1xyXG4gIDRzaVRDaXRVMkh4ckVBKzVoelJzcUF2YmN6cEkrY2dPWHZDQ1o1ZTRwUUhTWit3VTRrOGUzS2VNY3d0dmY4ZHV6ZmZidHFzTlpBVXlcclxuICBEb2NmdWxzNXM0WnM2UFZ2L0VCenhHRzdGNDI0dSsrNnE5bDFqeVBhdG96ZC9aTnlWZzFRRnFIZXpscjFuR0RPR2JRUEVGRHJOYmgyXHJcbiAgNGNQVzd0bFhBQVkzV2xrQnYyWk5zd3ZoY3pJZXBHRU51bHIySmgvY0J1VjlFT1RaU2dRTVNDQ2V6TUJ0YmlMYU1jZ3J5eVJ4RzlpRlxyXG4gIE54aUxrMzl4WGZMZEt3dEJvcXBvTUJEWHFMUFdhNGpQWDF6K3RML3cwd2tnay8rQWFxdlZUc293S1dJVFRUakEveGJlMGJydXMwbnVcclxuICBFNS84UXIvZVhjRTllY0lOTjk1Y2prbk4rMENaV1VpT2pyMTM0K3JSV2RJMnFFWTRpVDJBU0JyZ294R0VrS2huQ0hzdUF5M3dZejlOXHJcbiAgOGR2K3dYZWt4dzlZUGZ5bmZ1Tm5VdFR4NXB1bXpTc3Z4TTViWkh1VHFMN3l6eTlGbHNRZmVHZHlaN1dwSExYd2V4eHlraUJnczlrY1xyXG4gIEY5UjFsdmlVWmJyQzRNUUQ3bWx5UmZNT0VLYW9XZ2ZhZ3ZSeW5WdllwNDN2NkhiQ2tZRjVzSkx1ck5oaHU3ZVZpUmxzL2Q3OW1qTk9cclxuICBQNlM1NG9xZnR2MzM2bWJiSFQ3UlRsanVLZm1QT082NWJic24zL3ZJUHUvck9jd0JIdlJhV0RWOFlOcEptU240dUJsY25FZUJ5QUIrXHJcbiAgT2Y0bEVPNmFzZGNISDlYaFpnZkRkcXAzdFVQcUs5U0habzFETjN5dWVNQUdydXdHanNaSW5jNG9EQ3U3am1uQWNSVlhrRUZvSE1pWVxyXG4gIHpMeFpEQURwMU9pbW1mek83cmVvOHlqUDRvaGI2bXZVUFl4Nk53cTFYNXZxb2c3S3JiNFMvRnNOMTd2UXJRcW9oOHN6N1RzS0UxYUlcclxuICAzazhYNGhPUDc2OGQrRlpXR0haL0IxaGcxSFZUeDcxOHo5TTg5N24vVVFiU1NkQUwwNE9WRUJaS1ZMdWhMbk9PTFpnRUJuSGNCZWZLXHJcbiAgYkx6UjJ2MDR1bGR0NjgwYk1oblU2M2ZUUWVJWWRwL3IyZWQ4cHh3NVhiK2IwM0dpQy9HdXRQSm1oVjFscktleU8yNXdYbm5GWlpwelxyXG4gIHorN3RnY09PUHVZTFgyMjJid25LTmRmOHNsMk4zTm5zdC85eHpRK3V2S0pZeHpiT2dVbjAxODg0ZEtTSm1VbnhMMFZBb1B0UnV3MGhcclxuICBxSiszM2Y2QVdmYUd3SncyanNTZlUvM2lCbmkxNUExSncrdzBzOUtUVGo1bnJQWFRJUEZsZ0V4SEM2aFl6ai8vVExiR05kZjh2QWdlXHJcbiAgSjRHNHhSdWlZZWJMdGxpMHdtYTNib1NGaFBmTW9uSnQraUorb0U2bi9tYXpBK0daeFdCQ0kyVkwyd0FFemhrZVVYVTJVOFlTc0hJeVxyXG4gIE1NYmZPR1FsQjRtZllOOE1QR1ZJWE82VlYxNkNPUzFqWGJhNDFTWk5JUG5JUGR6eXh6KzF4R2IwR1J0QndtRGgwTjZDN3Q2WGJ2d3dcclxuICBhZG1TdjVRbHo3bGEyYW5UbWU1emozaWtmWGV2VU9jREVtWnU0R0h6dnJBUWplejNHQWNXQVg3enl4bk5rNS84aE5KT2Q5dmpNKzJxXHJcbiAgWXBzaUM2UDZ1K1k2MnpRNzc3aHBNYy8vdWMvMzlvVUE0ZnBlZTJ3OTlUUm4rSmNqSUZCL2NGcFJCTGhBUXdoMWh0b09qeGtld1h0M1xyXG4gIHNJSTVhU0RkbFlncmRrblBDdWlzalRWK29KN3RUQUlzR29maUdPU3huUENCbVhlbXRaUDRZOE9uUHM5Z0hPek9yczlQbUp1UXJ4cmRcclxuICB1amR3eEExUjlhME1KUGpnOWVheHVRRnhRYjRSU0I5WW8wV0lJZW1SRVZnbGRGR0hCODhwWjc0eHhGL2ltMU9JYXhEUmlCdlU3NzJ6XHJcbiAgTXFMcDgrcFh2WFNxcmljL2V6NXR5cDRxYkRocXhpd2JpSmRKR0cxUU9qWWJQdi81enl3cmtVbkxLZzVJUHV0cmtHZnRQUEtrNmFLT1xyXG4gIDAxNGFoMHhCeXBacnZaK01jQjZCQkNyNk5wdk9MVGp6aG53TUVKQkpXRmMvL3VGWGl4a2kyR1czZzVzUDcvV2VvaFRoTEpMM2JQUHhcclxuICBadUdGNXl0MWROVFJKemQzdE8zVkdJR0ZldENCSHl4aDVnYitKUW1JeGxFZjZwTEdNT3JlSUlIQVVHV2RhZnBnNXZ2WlJjNFFvU051XHJcbiAgYzFZYWJyMkx2ajRYTzQxNk9wc05JV0ZaM1dSRzJpSC9qMjVYT1RVMG9saHhuVTdaRURTREpuWUNjd2NPU3dLejh0VmZzMndaUUFKeFxyXG4gIE91cDN1c0k1bStJSUFVSGVhQjZ0cy9ZSzVWblpRTDdkRy9BTTdIVHZvYTYzZnpiWVhidnFxcDlPUGMwSzM5Y0FlbCtCdkdIWnRwMm5cclxuICA3UFovbUF3dHNNQmordXluMUIxWkQ3bGJXSnl6VTJjSlE0NUJ1U0RmQStwN3Ewa3MxR0RTZEJKLzRnbmlobGhFRUQvVDc1eXRQR2lpXHJcbiAgcFoybFQzUlBHNFg2Zm02TUN6WHM5OWlsbmNBaWhRYmpTWVRtbjJpSlFHUlRlKzUxV0x2cVhib1FjOStYUmVYVFR2OVdPNkZjclBuWVxyXG4gIGdaOXYvbmJublVVZ2o4aWY5T1dEU3BpNWhYOEpMYXd1TEtzSmFqUDdjdFVBdUVlN3hUMTNqY0VWdXdJUm9mN3BYY0xsL2V5aWwvYWxcclxuICBaV0JKSThScWV2ZTdOaXdiOEpaOTVkTGw3UEs4U3o3eHFoM2NGTmJXT0FoalZrd2RXUnowK2JuNUcrQUpScS83N2ZVbERRTXdEWXhKXHJcbiAgZ1hXbDNsNzcycFVLUzB5WlBCUGMyYlRZSzJPdjA3dmFGT2JxUDJuZDJSUUh3akJFMkpzZDk4TFNpRXBaWU1FRkhsdTBobndiK1ZDbVxyXG4gIDNQTXpwOTlzRktoSkppL2RmNDRMK0dlQXJPNm9vMC9xMTdVNjJmWURieTNxcmU2VlhUdkNvaU1nalIvNUt1RXZ2YXI0dWUyMnZ4UkNcclxuICBrOEZ3RXBCRjBHZ0RmU2RubXVjNTdkYlZNMW1mZzVySUdaUCtPQ1I4SFUrdS9vQjltbzJVM3BsNDVjeU5TWkd3dWM5S1gxL2NlYWN0XHJcbiAgeXNUdDdadS9vYndEK2JkQ29jRUh4aFdUekxrRmRxNmNMbWpWTVFuaGdOZTBlVDc0VXp0TlBmWEtvWC9mZE5NZmkxV0l6LzdQMTV1WFxyXG4gIHZ1UTV6UVVYZkxlb2c4T2E3WVNMc3NxazMyTlMvRXV1UUFJRFNXWUtkY09wM2FGK3BwWDFzZjIzSy9kQjEvOTAwV3VNUGIzMDVDTnhcclxuICAxdm5LL2FpOGpvUEJJY3RhcU9PQ0x1OFlTOHUxOWpNSnV2RUdNVEVoMzdHWkJOTXBRemZ1K3BrMTFSeTNHbVVJRm02ZDN3dzlka3p2XHJcbiAgYlBybE9udE1wbHZHK3dzcHIydEEvWklGQXlzTUsyUVdEY3pHNGVKMjlmYkJIVFl2L210VzFkeEE4bERuSi9mMTFYZG1ncjkybXdTRFxyXG4gIDRyUjZIblpZV3c5SW9URFRXM2xZUGNZc1R1S0VuTEJKcWFGVzlmYSs3bjkxbUxrQjhVVm9Icm5IT0NMeW1IWnljTjJ2eisvTEROZGVcclxuICA5ejNOVjA4N3VOemJtYi9kRHA5cTFsN3JGZTBxNU16bXBLK2NVOXpmdnRucnl0RUMwK21EaytKZm1vRDRRR2JNWVhYRW1DRFVzcEc2XHJcbiAgd1pnOWYvd1R4eFJMc1VIM2pJTFpRUytOSGhGaHhUZm1SOFNaSzBTSVhydVJ6MHhuMXRNbFRxNEc5ZDlmZjFOWnhtS2ZNYkh5emFsQlxyXG4gIHFQWTdDY1JmWTFUREpHQ2xWb3RGQmROdHhEVnhxT3ZLck5ncGkrUTYzR2pmUGZPWlR5dGFUSjdISVhIbC92NUF5aEpDbVB4UXVkVGVcclxuICBna0Y1cmNzNGlHaDRQN3ZFcEk2N216YTVtRlZQN1I0UTVsb2hUSXJJNDdyeEpPN0IxK216ckNEaHUvZnBLemtmeUR2dy9wOUpQQ0JDXHJcbiAgYzZ5clNWWWZUTGRmL244blYxcW1QZmE0UHV4UUtYS1BSWjc4MkdhWlpWN1l2SHZyRHhkVFJkdSsvNjFsOVRqam5LTkttTG1OZjBrV1xyXG4gIFZtQzVSbmk4MUZMUExjOTQ3QnFGVG9YSEh0dFYvRm51Y3pjQTBUWC84TDZIOXpjallkTllScy9KOGsvWVhoeFBLWUpnS3JzWk5Ib2RcclxuICBvOGU2d3VxU1J4dVlOQXl6emZyOUpGQU9Xa0EybWpuUkRtZ1hzWWVEUC82ZC83MnN0MEdxbmMyNjRwdksweW1uekpoSXhWTDhaV0JhXHJcbiAgL3IvN1o1T0FmTXVuNHpVUmFIN1l2cUk0d0IxWUNwMWt3MXZnZ0J2bDlqZDRBUFZEZyt3WDI0RlhHc3l0ckx2dWl1MHMrUHZGWDgzK1xyXG4gIHlMV0c5b0Jsa2ZvMGdLc0wvdkxQTy9uMlROMVYvTFdmWWY5dTJOcTlkZ01zQm1leXBIN2sxekVBcTYrK1hHRmpKbHo4Snl4L2NmOVZcclxuICBTMHlkNjgwc1RkaFozcXViNUdVUytINDJUMUl3U2IzVmFjbWp1amVUOTB6ZTVtd1VhV3BIMkdlVFFEeXNRTHlsRFdOanJ6TlBrazdTXHJcbiAgaExqeDcrcVFxR1VtT0Urbmk0VHYzb2RBMk5UNnBnMTZlMS9BKzd5RE9zemN3aU1mdFhSelZ6dm8rMWFUc3E4Tys4eHVmWllidWNlclxyXG4gIFcwSktMZ2xubi9QdDV0cHJmOXQrdjhXYTNmWTRwTmlEc3pHWTRQejQ0MmJ1ZFp2Ym1EMFZoZ2NSOFBwcFRBUTZWUnJLUTZlRWNxQ3hcclxuICBhRFJBeFpaKzlhNjc5NWFHa0VZMUp6QnpPdXJvcjVSNyt6M0VKOTQwVUJvZmtMd1FHdGFOMmtwb1VwQ2R2UFV0NjViN09nMERlanBHXHJcbiAgM0FsVnBSY1YzME1QTzZGY3h5SEtCb0Y0L2Eyd1FKeXBNKzdLN0NTM3VFMFg2aytlNVplZ1U1enlIeTJwd013TEVOQkJvSUVrTEUwMVxyXG4gIGNISmhrREtKTjNVUDJiVTlDZXF3Tk9NQzJrbWdERUZZSnJVYnRXRXJxc0FlRHU5OVU0VFRQVlpXd2xtZFdtRzZWNjQ2cm5FUUI4SURcclxuICB3bVl6b1ozajR2RlBlZHhiWlFTT3ZxVWFMdHlrTUZpTEI5dERuS3duSis1Y0lkZjZYWTZybmc3Q29vWEVGUXNJOHEwdHhtWWRlTTh0XHJcbiAgWmNxWlAzTVRxNnl5ZVptMGFXa0c0RWswcmc3WWI5dHlKZzcwSmxLOXZVSGFLNjdKQlJkZTJienRyV3MyVi8vb1orV2JnUDQvT3haMlxyXG4gIHA0Ti9lUUlDUzNlT3RyUzB6LzJaWC85V3VZYzBLTkJaRjF1MFo5OHE4RjRIbUJPOGZmUFhOWHZ0M2R1Sm5mVGt3dzUyNm9KSnYzNlhcclxuICBQQkNRbXgxT0I4SlRQM1NsSHc1TWs0aFQvTFV0S3FzUDd1L2Fjb1BTOFdZWDh1NGZoQjFqa0F2cUhmdlVRVlB1U1VGTEJwUkxXanJWXHJcbiAgYzUvN2pNS0h6eTdpN0UvZ3gxbnVycEQ2bkgrK2U1KzduazE3OFJ2VTdXQVNSS0JPWXl2eHhUejZJSWlmSDllYWxRS1VCc0NxVWh1Z1xyXG4gIExmak5iLzdmdmZJNFhVaURUTURFSmVrbHI0c3Z6c3IwVE1LUnZPVTUxK25zSzdLcjNHQnQ1UzlzM092NHV0ZmF6M1Fnakg5VTF1dDRcclxuICBFVXozMmx5djdjd3NlOXlBTEtiZVlEdzNRT05xaGlNbDJudEVkSkw5SHJ1M0U0UnNnb1lMMjdZZXRXdnRmYTExMzlkcysvNE5tdC85XHJcbiAgL3FaeVZLM2phRisvM3NydCtMVklZVm4vTS9FdkxRT3BVVGNNcUovWktucmJwdXVWZTlUY1VsbGpNbGp2LzdIUGxrMDM5Um5CYVl4elxyXG4gIGd2QXZlL2U5dkhTdmtMUUd1VTBIekdPOHJEcHdxZzZmY3c0Q2FSVVcxUnlXTVJBZkpQL0F6VUJwdGczVGxmT01RK29JYi92NXoxdThcclxuICBFQlBQOVdCaEpwclpkLzBPVXZiYWYvMStGQWJGTlNpZTNMdENCTkV6TVUrN0VsbW9FTFViYjhSV21qN3Z2NGEwc0dOcks3WnhCOC8xXHJcbiAgdDg4K29HSDVuUlFJeC9KVFlhR09SOWtRUnF3WWhMOStOenRwUVowT3BPOE1TdDgxS3YvWW1wUVJvTjRiTXJkQTQycTNqc2JWdU1HWFxyXG4gIGtkTnZYdkQ1UG52UUVjMkhIckpydVFkQzgxVldmbkd6Nk5NWGFWWmQvWjFGQzhzRTBISE5SeHoyejVkTy9FdkxRR3JvRk9rYzNlZi9cclxuICBXdXA1L1h1c0NyeFhQRy8ycEY2NFJEdmpPL0J6L2MxRWdQOWJ4elU3NktYZnN4cnNUM2h1cDNBYXUxazVRM3ZTTXZqbEFCdXowVnFXXHJcbiAgTXlsMEVuR0ZyeHpnL3h2SXBaODlERHBWak1pQnRMNDExZUZtQnltakZSRDJVOXp1dU9QT3dwSUpJb2VDT2ExZlpRVm4zNVA3ZUk1UVxyXG4gIHVjZG4vMTBac0g3OW05K1gwOWhTTjBIQ3U4NDMzeU9Lb2NHQW1pcVprWGYxUHl1ZnhLTyt1SVBKQ0pQMm52TSs5L0pDTnVZZ0tHRjZcclxuICA1dEo3Vm04WFhuakJzcG9aWndGM0dIekx5RVdBa2N2Y1M3dWJuN3h6LytsRGppdW4xVEh1R0wvK2t3TGh3RVpVRnQ5VG05Sy9hdE10XHJcbiAgU2QveEJyMjY2T1dGSGJONlVqTXBRaGpFNjE1ODBrMzZjYS96RkZZeDY4NkpJMnE3Y3dzaEhsWWVZZnVNSXg1V0VOLyt4akY5ZHFieFxyXG4gIDRvRDl0eTMzc01kZVI3YXIrb2UycTZSbG1uMzNPN0lveFJnbmJGU2UyL3M5aHVIZmhvQ0F3YU1lbUhTV2RJejYzbitmZlE4di9zcWhcclxuICBRb3M5dFpnN3FjMDhzQ2lMRC8rS2RqQ1pYWWgvMzQ4YzFTeTMzTkw5ZlNJYXRDdmh0S3M4RWZxYW5XNnl5VHJsaER5RHdQYmJiVmJlXHJcbiAgMTRQdUpFZ0hjbFVYMFVyRFh1R0c1V0lEWSswSEp0MjlQZ3FJQjl0T0JteEFQTVN2N2pPZzRLdG5veHZaaGhsdy9jM21CTXFUcXdIWlxyXG4gIGRja1gvV2RieHc0ZnU2NElpRm54ellDT0xhYURPbGM2TUFBeWYzM2RkZGMzRGtCeTVvbnl5RFAzRElEUUU3eGZWclNXRVAxZU92K3ZcclxuICBLRzQ0QTRQSkZDekVFSWZ1ZFhhUmRxRmVzYWpVdWJJeE5XSlh1SExYZ3l6VXhQV3l5Njhwd21yaFk4M1lmMUtJazVEY3FvTXc5N2R0XHJcbiAgK3NLTG0weklSQ0t5Rm03eVlyYzBka3VlSnhYSTE4QjIxWC9BYXNMZW9yU3J1TE5GdCt5eUw1N0Z6VDEvM2Z1NUJjY3ZiN1gxaDB0OVxyXG4gIEloN1lWcE93ZlM3NzNvbkY2Z0pFYUo3dndETERqMzcwcTJienpkWXBHbGNtZ0V3a3ZiSWRqejU1MEllbUpiT2JFL3pic0xBQ0RRVFNcclxuICBTSmd4My9ZRFBmNmlnYXBtczlnMEZBR3JRWURzb0g3ZmpXdDJjZHJwRnpRcnJ2RFNvdHVkQmx6SG5YelZ1OVBydk01dW8wOGN0TFBNXHJcbiAgY21LVWpydE5SNFROQVptRlhlaHpBK0lIYWJ2SFBzaFJ4RFlRcnJ2T2lzWGR6RkQ5TzB3TG9VNjkxTmYvSHpPUk5nUGYrdmIzaTVVQVxyXG4gIG13dHI4RVBXVlF2cHUxRDNpTWwwNjllS3cyQ1M3K1A3MGY2cnZ4blUzMjlXdDlsVDBZWEUxNzNQbWV0UXB6bkliMzAvdHlET1ZWYmVcclxuICBySCttK1NRQ2M3am1xdFA3S3RGV0hraE8ranUyM3k2N0hkSHN1dk9temYrMkJIR050ZDVWSml2T2ZDZTNqWlhxK3dML1Zpc1FRTUhyXHJcbiAgV2J1QnlVZm16aTMzUUUwMXp3WjM2b3VmT3ZqWVpvVlg5elNCdUZ1aW16VWx6T3lBZVdXbVFzSzZBUEg1Njh3YURwYldXbXUrcWp3N1xyXG4gIFBJWlpDc3Q4Zysvc3BwMDZpR0hIbkNmT3ZaYjVlT2RNaXZnSEd4YXhPR3EzU1lHRlFRdEZXSCtydWNBWkpON1pZYXorNGRaYi8xeFVcclxuICBnNVV6M3k1MTd2dVFFNUFSMUFZWi85V2gzSFU3OW13Vm9VNE1QR3Vzc1h6ZjJtcjhtZ0dEMlNyMmlQTWlmRnZ1NmxON012TVg1M1RiXHJcbiAgbE5rL3RWemh4R2wyai9XYUZZVTh1TExWOUxPZjlXekJNWW5qaEVrcnBNaW9wZ3Z4SmcxZ0Z5NFduNzFqc1FDU0ord2RxMHhJbmlEdlxyXG4gIDV5YklVcGRmYnVQRzhVMVdIcE9vNnNJSnh4M1F0djFldm1qRE1ZeFlFNDhQYlBlSlp2Lzl0aTV5ampYV2ZsZmhYbER2ZlVLNzJweWJcclxuICBjc1JKRUhiY3Z4VjhEQTB0MEloMHNOd2Y4NFhUeXoxNDFyaUF2cjV6dDUzZ0Z1aHMwZXFhRS9RYThqOEtvUUNORytUVmZmYWtlTVlDXHJcbiAga0NlRGZQeEI4amxkOUU1d214WGk4amVEZytRRGRQYVlBSSsvNllBR2xiRE1mZ2ZpY01pV2VrQ3NBbWtpbklNUWdiTTgxb05sZmYxWFxyXG4gIGdqcXlXZ3g2YmFaM2pHc05xcmJLejMrM0hvUlI5OWhvRU5rZTkwazFxbXJZaThOeU1SYW45QXlhK29SMGs3L2tBY3NPS3c5YmpkdFdcclxuICA3OTZ3dlY1YVZpbnhPeDBrRFgrVE8rbGJPWFBQdTl5bi9kcVRWSWVsV2kyYzkzTWJMM25wK21YRk1hbk1BL2JlWSt0WmJPQ2RPK1BpXHJcbiAgTm04emljS09PeC9TN0xiTFpvVjErdGEzN1Z4WTdIdnYrWjdtbm50bXJsRHVTL3hiRWhEUTBBeFlBWjFwRFFtY3c1Qjd5RmtFbHVRN1xyXG4gIGJMOVpPYU9hNm1NNnN3OVgrNTlkYU5BSWhTVnJHbi9jQTI0MGw5SWh2Sk8yZTI1MHdLZWJGeFpHaFRYYmdZVG5adm1mOGtVMTFTd3pcclxuICBicEQ3NmFiTEdHT0FyVkx2azBoY1RwZXJrYlQ0aWJITUlQV1ZLN2pQc3owb0QzUWtyeWwvdDB4WVR3WnB5SXJDMWhYMW9XNXFjK3FCXHJcbiAgZHdiMTFGZHRTWmdNeHZ2cEFydEtPaHR2dkhZaERPNmxUM3NwOFhGemI0TGxHaXZLdmIweHZkelBMWllWMlYzYWhobTVkL1l6dVpJaFxyXG4gIFlzRzZKN3RLK3hHTzdFKzR1WTNzTW9kSlZ4ODdmZWp0czdDZlZsaHBzelp2TS9jbzdiblhVYzA3My83YXd2MzQ5R2VPS3hZZURqbDRcclxuICBsMmFQdGp4ZDgwdjNGZjV0Q1FoZ0E2V2pRbVpPUUM1QzVnQTBic0E3czM3bUFUNzd1VlBham5OOWNZYzAzcmtCTXc1RVNpT3Y0MHluXHJcbiAgaVp0N2xsR2xIWGV6eU5udEVEa1NXTDEwNC9BY0xhMkFtMy95ay9zNno1UENyS3ViSnRnSUpUN2xjMkJPamJnSHlSOUMzNFc2cTFsY1xyXG4gIG52T3RYUkd2UFA4emdWVlpwMXZmQjFoSllGWTlDTmxNQ09xZ0Z2Sm5mNDMzckQwNzZURnhzL1hrZms0RXJQdDk1TWdTQndFNXVKZFdcclxuICBWdUhPRDgvQURkNzdyc2tEd21FUW54UENrVFR6N040L2Fabm91S2ZPNnNxVUIvbWRleXlzdE5OWWVaamJDUEZBSWllVmV5QWVIOTdyXHJcbiAgdlZOUFRiUGhSanMwRjV6MzJha24zL25vbHRndldjejFuUHlWR1VWN2N1ODl0eTV5eXd2UCs5eVVyL3NlLzlZRUJHcWlrY1prWDRTbFxyXG4gIDRaUGEyVjc5anRFNnNKbnJrSU4zYmc0LzhzU2lkeDFvbUljZlB0a3U3bkhBTHFPcGtzNm44OHVEaHM4TjI4Wjk1QmZBdlViY3B3c0RcclxuICBzYkRkOFBJeEtFN3ArdGY1R0JSK091aVdCYWpKeXNPZ2QyQ0ZvWTdxaldvQkZ0Y2dWbDJRc3hocVNNdmZqRDMzK1RObWFKK0VBYW43XHJcbiAgemgvcWQ0SE5qalgrTkxXNXMwYmtUekg4QjhxVGV1MXVTTFMzQTdEMHFJS243SWlWaytnZzRidjFNZ2tva0pCeGFPc2Ztam94VTVuRVxyXG4gIFpSYnNYdHcyT0FKektIbFA1VG4zWkI0SXg2VEhJbmVSZUZLR1BBKzdyLzB6SFpSN3h4UEk3NlNXcnFlRG1uZ1lYQ2NoSGx1MTMyeWZcclxuICB2YmZwVzBHZzhmbWxZL2N2OTNENEVheFgzTk1zdjl4U2hWQWZlTkRubXoxMzM2cTB2eDJuam9TNGY5QTAveCtZUjhRM1l3OTRLQUFBXHJcbiAgQUFCSlJVNUVya0pnZ2c9PVxyXG4gIFwiXHJcbiAgICAgICAgaWQ9XCJpbWFnZTMxNzlcIlxyXG4gICAgICAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF2YXRhcjtcclxuIiwiLyoqXHJcbiAqIENvbnRhaW5lclxyXG4gKiBAZGVzY3JpcHRpb24gTWFpbiBDb250YWluZXIgZm9yIHRoZSBBcHBcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmltcG9ydCBIZWFkIGZyb20gJ0AvY29tcG9uZW50cy9IZWFkJztcclxuaW1wb3J0IEhlYWRlciBmcm9tICdAL2NvbXBvbmVudHMvSGVhZGVyJztcclxuaW1wb3J0IEZvb3RlciBmcm9tICdAL2NvbXBvbmVudHMvRm9vdGVyJztcclxuXHJcbmV4cG9ydCBjb25zdCBkZXNjcmlwdGlvbiA9XHJcbiAgJ1RoaXMgZXhhbXBsZSBjb25maWd1cmVzIGEgc2ltcGxlIE5leHQxMCBhbmQgVGFpbHdpbmQgQ1NTIGFwcCB3aXRoIHJvdXRpbmcgZm9yIGRlcGxveW1lbnQgdG8gR2l0SHViIFBhZ2VzIHJlcG9zaXRvcnkuJztcclxuZXhwb3J0IGNvbnN0IHNpdGVUaXRsZSA9ICdOZXh0IDEwLCBUYWlsd2luZCBBcHAgZGVwbG95ZWQgdG8gR2l0SHViIHBhZ2VzIGV4YW1wbGUnO1xyXG5leHBvcnQgY29uc3QgcHJvZmlsZU5hbWUgPSAnZHRyby1kZXZ1ayc7XHJcblxyXG5jb25zdCBDb250YWluZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgaWQ9XCJjb250YWluZXJcIiBjbGFzc05hbWU9XCJiZy1ncmF5LTMwMFwiPlxyXG4gICAgICA8SGVhZCB0aXRsZT17c2l0ZVRpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IC8+XHJcbiAgICAgIDxIZWFkZXIgY2FwdGlvbj17c2l0ZVRpdGxlfSBhdXRob3I9e3Byb2ZpbGVOYW1lfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IC8+XHJcbiAgICAgIDxtYWluXHJcbiAgICAgICAgaWQ9XCJtYWluLWNvbnRlbnRcIlxyXG4gICAgICAgIHJvbGU9XCJtYWluXCJcclxuICAgICAgICBhcmlhLWxhYmVsPVwibWFpbiBjb250ZW50IGFyZWEgZm9yIHRoZSBwYWdlXCJcclxuICAgICAgICBjbGFzc05hbWU9XCJmbGV4LTEgcC0zIG92ZXJmbG93LXktaGlkZGVuIGp1c3RpZnktY2VudGVyIGJnLXdoaXRlXCJcclxuICAgICAgPlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgPC9tYWluPlxyXG4gICAgICA8Rm9vdGVyIGNhcHRpb249e3NpdGVUaXRsZX0gYXV0aG9yPXtwcm9maWxlTmFtZX0gLz5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XHJcblxyXG5Db250YWluZXIucHJvcFR5cGVzID0ge1xyXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxyXG59O1xyXG4iLCIvKipcclxuICogU2l0ZSBGb290ZXIgQ29tcG9uZW50XHJcbiAqIEBkZXNjcmlwdGlvbiBmb290ZXIgZWxlbWVudHMgdG8gYmUgaW5jbHVkZWQgaGVyZVxyXG4gKiBAYXV0aG9yIGR0cm8tZGV2dWsgQGdpdGh1YjpkdHJvLWRldnVrLmlvXHJcbiAqL1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuY29uc3QgRm9vdGVyID0gKHsgY2FwdGlvbiwgYXV0aG9yIH0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGZvb3RlclxyXG4gICAgICBpZD1cIm1haW4tZm9vdGVyXCJcclxuICAgICAgcm9sZT1cImNvbnRlbnRpbmZvXCJcclxuICAgICAgYXJpYS1sYWJlbD1cIm1haW4gZm9vdGVyIGNvbnRlbnQgaW5mb1wiXHJcbiAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBwLTNcclxuICAgICAgICAgICAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgdGV4dC1jZW50ZXIgXHJcbiAgICAgICAgICAgIGJnLWdyYXktODAwIFwiXHJcbiAgICA+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC13aGl0ZVwiPlxyXG4gICAgICAgIDxwIGNsYXNzTmFtZT1cIiB0ZXh0LXhsIG1kOnRleHQtMXhsIGxnOnRleHQtMnhsIHAtM1wiPntjYXB0aW9uIHx8ICcnfTwvcD5cclxuICAgICAgICA8cCBjbGFzc05hbWU9XCIgdGV4dC14bCBtZDp0ZXh0LTF4bCBsZzp0ZXh0LTJ4bCBwLTNcIj4oYykge2F1dGhvcn0gMjAyMTwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Zvb3Rlcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9vdGVyO1xyXG5cclxuRm9vdGVyLnByb3BUeXBlcyA9IHtcclxuICBjYXB0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBIYW1idXJnZXIgVG9nZ2xlIEJ1dHRvbiB3aXRoIGFuaW1hdGlvblxyXG4gKiBAZGVzY3JpcHRpb24gVG9nZ2xlIEJ1cmdlciBidXR0b24sIG9wZW4gYW5kIGNsb3NlIGFuaW1hdGlvbnMgYW5kIGFyaWEgc3VwcG9ydFxyXG4gKiBAYXV0aG9yIGR0cm8tZGV2dWsgQGdpdGh1YjpkdHJvLWRldnVrLmlvXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgYm9vbCwgZnVuYyB9IGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIEhhbWJ1cmdlciBUb2dnbGUgQnV0dG9uXHJcbiAqIFdpdGggYW5pbWF0ZWQgT3BlbiBhbmQgQ2xvc2UsIGFuaW1hdGlvbnMgY291cnRlc3kgb2YgSm9obnNodSwgc2VlIHJlYWRtZSBmb3IgYXR0cmlidXRpb25zXHJcbiAqIEBwYXJhbSB7Kn0gcGFyYW0wXHJcbiAqL1xyXG5jb25zdCBIYW1idXJnZXIgPSAoeyBvcGVuLCBzZXRPcGVuLCAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgY29uc3QgaXNPcGVuID0gb3BlbiA/IHRydWUgOiBmYWxzZTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2hvdy9IaWRlIHRoZSBNZW51XHJcbiAgICovXHJcbiAgY29uc3QgaGFuZGxlVG9nZ2xlTWVudUNsaWNrID0gKGV2ZW50LCBvcGVuKSA9PiB7XHJcbiAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XHJcbiAgICAgIHJldHVybjsgLy8gbGV0IHRoZSBicm93c2VyIGRlYWwgd2l0aCB0aGUgY2xpY2sgbmF0aXZlbHlcclxuICAgIH1cclxuXHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIHNldE9wZW4ob3Blbik7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxidXR0b25cclxuICAgICAgY2xhc3NOYW1lPXtgaGFtYnVyZ2VyLS1zcHJpbmctciAke29wZW4gPyAnaXMtYWN0aXZlJyA6ICcnfVxyXG4gICAgICAgICAgICBwLTEgbWQ6cC0zIG1sLTMgbXItMyBcclxuICAgICAgICAgICAgbGc6aGlkZGVuIGxnOm1sLTAgbGc6dy0wIFxyXG4gICAgICAgICAgICB0ZXh0LXllbGxvdy01MDAgaG92ZXI6dGV4dC13aGl0ZSAgICAgICAgICAgICBcclxuICAgICAgICAgICAgcm91bmRlZFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gaG92ZXI6c2NhbGUtMTI1IGhvdmVyOmJnLW9wYWNpdHktNTAgdHJhbnNpdGlvbiBlYXNlLW91dCBkdXJhdGlvbi01MDBcclxuICAgICAgICAgICAgZm9jdXM6b3V0bGluZS1ub25lYH1cclxuICAgICAgaWQ9XCJoYW1idXJnZXItYnRuXCJcclxuICAgICAgYXJpYS1sYWJlbD1cIkhhbWJ1cmdlciBNZW51IFRvZ2dsZSBCdXR0b25cIlxyXG4gICAgICBhcmlhLWV4cGFuZGVkPXtpc09wZW59XHJcbiAgICAgIGFyaWEtY29udHJvbHM9XCJ7bWVudUlkfVwiXHJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICB0YWJJbmRleD1cIjBcIlxyXG4gICAgICBvbkNsaWNrPXsoZXZlbnQpID0+IGhhbmRsZVRvZ2dsZU1lbnVDbGljayhldmVudCwgIW9wZW4pfVxyXG4gICAgICB7Li4ucHJvcHN9XHJcbiAgICA+XHJcbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImhhbWJ1cmdlci1ib3hcIj5cclxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJoYW1idXJnZXItaW5uZXIgcm91bmRlZFwiPjwvc3Bhbj5cclxuICAgICAgPC9zcGFuPlxyXG4gICAgPC9idXR0b24+XHJcbiAgKTtcclxufTtcclxuXHJcbkhhbWJ1cmdlci5wcm9wVHlwZXMgPSB7XHJcbiAgb3BlbjogYm9vbC5pc1JlcXVpcmVkLFxyXG4gIHNldE9wZW46IGZ1bmMuaXNSZXF1aXJlZCxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhhbWJ1cmdlcjtcclxuIiwiLyoqXHJcbiAqIEhhbWJ1cmdlciBNZW51XHJcbiAqIEBkZXNjcmlwdGlvbiBPcGVucyBhbmQgQ2xvc2UgYmFzZWQgb24gcHJvcGVydGllcyBwYXNzZWQgZnJvbSB0aGUgYXNzb2NpYXRlZCBIYW1idXJnZXIgVG9nZ2xlIEJ1dHRvbiwgc2VlIEhhbWJ1cmdlci5qc1xyXG4gKiBAYXV0aG9yIGR0cm8tZGV2dWsgQGdpdGh1YjpkdHJvLWRldnVrLmlvXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IE5leHRMaW5rIGZyb20gJ25leHQvbGluayc7XHJcblxyXG5pbXBvcnQgeyBib29sIH0gZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5jb25zdCBIYW1idXJnZXJNZW51ID0gKHsgb3BlbiwgLi4ucHJvcHMgfSkgPT4ge1xyXG4gIGNvbnN0IGlzSGlkZGVuID0gb3BlbiA/IHRydWUgOiBmYWxzZTtcclxuICBjb25zdCBpc09wZW4gPSBvcGVuO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdlxyXG4gICAgICBhcmlhLWhpZGRlbj17IWlzSGlkZGVufVxyXG4gICAgICBjbGFzc05hbWU9e2BtdC0yIHctZnVsbCBsZzppbmxpbmUtZmxleCBsZzpmbGV4LWdyb3cgbGc6dy1hdXRvIFxyXG4gICAgJHshaXNIaWRkZW4gPyAnaGlkZGVuJyA6ICcnfWB9XHJcbiAgICA+XHJcbiAgICAgIDxkaXZcclxuICAgICAgICBjbGFzc05hbWU9e2BsZzp0cmFuc2xhdGUteS0wXHJcbiAgICAgICAgICAgIGxnOmlubGluZS1mbGV4IGxnOmZsZXgtcm93IGxnOm1sLWF1dG8gbGc6dy1hdXRvIHctZnVsbCBcclxuICAgICAgICAgICAgbGc6aXRlbXMtY2VudGVyIGl0ZW1zLXN0YXJ0IGZsZXggZmxleC1jb2wgbGc6aC1hdXRvXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJHtcclxuICAgICAgICAgICAgICBpc09wZW5cclxuICAgICAgICAgICAgICAgID8gJ3RyYW5zbGF0ZS15LTAgZWFzZS1vdXQgZHVyYXRpb24tMTAwMCB0cmFuc2Zvcm0gJ1xyXG4gICAgICAgICAgICAgICAgOiAnLXRyYW5zbGF0ZS15LWZ1bGwgZWFzZS1pbiBkdXJhdGlvbi0xMDAwIHRyYW5zZm9ybSAnXHJcbiAgICAgICAgICAgIH1gfVxyXG4gICAgICA+XHJcbiAgICAgICAgPE5leHRMaW5rIGhyZWY9XCIvYmxvZ1wiPlxyXG4gICAgICAgICAgPGFcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgbGc6aW5saW5lLWZsZXggbGc6dy1hdXRvIHctZnVsbCBweC0zIHB5LTIgcm91bmRlZCB0ZXh0LWxnXHJcbiAgICAgICAgICB0ZXh0LXllbGxvdy01MDAgaG92ZXI6dGV4dC13aGl0ZSBsZzpob3ZlcjpiZy15ZWxsb3ctNTAwIFxyXG4gICAgICAgICAgYWN0aXZlOnRleHQtd2hpdGUgZm9jdXM6b3V0bGluZS1ub25lXHJcbiAgICAgICAgICB0cmFuc2Zvcm0gJHsnaG92ZXI6c2NhbGUteC05MCB0cmFuc2l0aW9uIGVhc2UtaW4tb3V0IGR1cmF0aW9uLTUwMCd9YH1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgQmxvZ1xyXG4gICAgICAgICAgPC9hPlxyXG4gICAgICAgIDwvTmV4dExpbms+XHJcblxyXG4gICAgICAgIDxOZXh0TGluayBocmVmPVwiL2Fib3V0XCI+XHJcbiAgICAgICAgICA8YVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2BsZzppbmxpbmUtZmxleCBsZzp3LWF1dG8gdy1mdWxsIHB4LTMgcHktMiByb3VuZGVkIHRleHQtbGdcclxuICAgICAgICAgICAgICAgIHRleHQteWVsbG93LTQwMCBob3Zlcjp0ZXh0LXdoaXRlIGxnOmhvdmVyOmJnLXllbGxvdy01MDAgXHJcbiAgICAgICAgICAgICAgICBhY3RpdmU6dGV4dC13aGl0ZSBmb2N1czpvdXRsaW5lLW5vbmUgXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gJHsnaG92ZXI6c2NhbGUteC05MCB0cmFuc2l0aW9uIGVhc2UtaW4tb3V0IGR1cmF0aW9uLTUwMCd9YH1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgQWJvdXRcclxuICAgICAgICAgIDwvYT5cclxuICAgICAgICA8L05leHRMaW5rPlxyXG5cclxuICAgICAgICA8TmV4dExpbmsgaHJlZj1cImh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vZHRyby1kZXZ1a1wiPlxyXG4gICAgICAgICAgPGFcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgbGc6aW5saW5lLWZsZXggbGc6dy1hdXRvIHctZnVsbCBweC0zIHB5LTIgcm91bmRlZCB0ZXh0LWxnXHJcbiAgICAgICAgICAgICAgICB0ZXh0LXllbGxvdy01MDAgaG92ZXI6dGV4dC13aGl0ZSBsZzpob3ZlcjpiZy15ZWxsb3ctNTAwIFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlOnRleHQteWVsbG93LTYwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICR7J2hvdmVyOnNjYWxlLXgtOTAgdHJhbnNpdGlvbiBlYXNlLWluLW91dCBkdXJhdGlvbi01MDAnfWB9XHJcbiAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICBHaXRodWJcclxuICAgICAgICAgIDwvYT5cclxuICAgICAgICA8L05leHRMaW5rPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5IYW1idXJnZXJNZW51LnByb3BUeXBlcyA9IHtcclxuICBvcGVuOiBib29sLmlzUmVxdWlyZWQsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIYW1idXJnZXJNZW51O1xyXG4iLCIvKipcclxuICogSGVhZFxyXG4gKiBAZGVzY3JpcHRpb24gU2l0ZSBIZWFkIG1vZGlmaWNhdGlvbnNcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XHJcblxyXG5jb25zdCBIZWFkID0gKHsgdGl0bGUsIGRlc2NyaXB0aW9uIH0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPE5leHRIZWFkPlxyXG4gICAgICA8bWV0YSBjaGFyU2V0PVwiVVRGLThcIiAvPlxyXG4gICAgICA8dGl0bGU+e3RpdGxlIHx8ICcnfTwvdGl0bGU+XHJcbiAgICAgIDxtZXRhIG5hbWU9XCJkZXNjcmlwdGlvblwiIGNvbnRlbnQ9e2Rlc2NyaXB0aW9uIHx8ICcnfSAvPlxyXG4gICAgICA8bWV0YVxyXG4gICAgICAgIG5hbWU9XCJ2aWV3cG9ydFwiXHJcbiAgICAgICAgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xIHNocmluay10by1maXQ9bm8sIHVzZXItc2NhbGFibGU9MFwiXHJcbiAgICAgIC8+XHJcbiAgICA8L05leHRIZWFkPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWFkO1xyXG5cclxuSGVhZC5wcm9wVHlwZXMgPSB7XHJcbiAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxuICBkZXNjcmlwdGlvbjogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG59O1xyXG4iLCIvKipcclxuICogSGVhZGVyIENvbXBvbmVudFxyXG4gKiBAZGVzY3JpcHRpb24gU2l0ZSBIZWFkZXIgaW5jbHVkaW5nIHRoZSBOYXZpZ2F0aW9uIG1lbnVcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmltcG9ydCBOYXZCYXIgZnJvbSAnQC9jb21wb25lbnRzL05hdmJhcic7XHJcblxyXG5jb25zdCBIZWFkZXIgPSAoeyBjYXB0aW9uLCBhdXRob3IsIGRlc2NyaXB0aW9uIH0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGhlYWRlclxyXG4gICAgICBpZD1cImhlYWRlclwiXHJcbiAgICAgIHJvbGU9XCJiYW5uZXJcIlxyXG4gICAgICBjbGFzc05hbWU9XCJzdGlja3ktaGVhZGVyXHJcbiAgICAgICAgICAgICAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgdGV4dC1jZW50ZXJcclxuICAgICAgICAgICAgICBiZy1ncmF5LTgwMFwiXHJcbiAgICA+XHJcbiAgICAgIDxkaXZcclxuICAgICAgICBjbGFzc05hbWU9XCJwLTMgZm9udC1ibGFja1xyXG4gICAgICAgICAgICAgICB0ZXh0LTJ4bCBtZDp0ZXh0LTN4bCBsZzp0ZXh0LTR4bFxyXG4gICAgICAgICAgICAgICB0ZXh0LXdoaXRlXCJcclxuICAgICAgPlxyXG4gICAgICAgIHtjYXB0aW9uIHx8ICcnfVxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPE5hdkJhciBhdXRob3I9e2F1dGhvcn0gLz5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS0zMDAgdy1mdWxsXCI+XHJcbiAgICAgICAgPHNlY3Rpb24gYXJpYS1sYWJlbD1cIkRlbW8gZGVzY3JpcHRpb25cIj5cclxuICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJwLTMgbS0zIGZvbnQtYm9sZCB0ZXh0LWdyYXktNzAwIGl0YWxpYyBmb250LXNhbnMgdGV4dC14bCB0ZXh0LWNlbnRlclwiPlxyXG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XHJcbiAgICAgICAgICA8L2gxPlxyXG4gICAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2hlYWRlcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyO1xyXG5cclxuSGVhZGVyLnByb3BUeXBlcyA9IHtcclxuICBjYXB0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgYXV0aG9yOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgZGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxufTtcclxuIiwiLyoqXHJcbiAqSG9tZSBCdXR0b25cclxuICogQGRlc2NyaXB0aW9uIFJldHVybiB0byB0aGUgSG9tZSBQYWdlXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5pbXBvcnQgTmV4dExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuXHJcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuY29uc3QgZGVmYXVsdEJ1dHRvbkNhcHRpb24gPSAn4oaQIEJhY2sgdG8gSG9tZSc7XHJcbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPVxyXG4gICdiZy1ncmF5LTUwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLXllbGxvdy01MDAgaG92ZXI6dGV4dC1ibGFjayBmb250LWJvbGQgdGV4dC1tZCBweC00IHB5LTIgcm91bmRlZCBzaGFkb3cgaG92ZXI6c2hhZG93LW1kIG91dGxpbmUtbm9uZSBmb2N1czpvdXRsaW5lLW5vbmUgbXItMSBtYi0xIHRyYW5zaXRpb24gYWxsIGVhc2UgZHVyYXRpb24tNTAwJztcclxuXHJcbmNvbnN0IEhvbWVCdXR0b24gPSAoeyBjYXB0aW9uLCBjbGFzc05hbWUgfSkgPT4ge1xyXG4gIGNvbnN0IGJ1dHRvbkNhcHRpb24gPSBzZXRCdXR0b25DYXB0aW9uKGNhcHRpb24pO1xyXG4gIGNvbnN0IHRoaXNDbGFzc05hbWUgPSBzZXRDbGFzc05hbWUoY2xhc3NOYW1lKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxOZXh0TGluayBocmVmPVwiL1wiIHNjcm9sbD17ZmFsc2V9PlxyXG4gICAgICA8YnV0dG9uIGlkPVwiaG9tZS1idXR0b25cIiBhcmlhLWxhYmVsPVwiSG9tZSBCdXR0b25cIiBjbGFzc05hbWU9e3RoaXNDbGFzc05hbWV9IHR5cGU9XCJidXR0b25cIj5cclxuICAgICAgICA8YT57YnV0dG9uQ2FwdGlvbn08L2E+XHJcbiAgICAgIDwvYnV0dG9uPlxyXG4gICAgPC9OZXh0TGluaz5cclxuICApO1xyXG59O1xyXG5cclxuY29uc3Qgc2V0QnV0dG9uQ2FwdGlvbiA9IChjYXB0aW9uKSA9PiB7XHJcbiAgbGV0IG5ld0NhcHRpb24gPSAnJztcclxuICBpZiAoY2FwdGlvbiAhPSAnJyAmJiBjYXB0aW9uICE9IHVuZGVmaW5lZCkge1xyXG4gICAgbmV3Q2FwdGlvbiA9IGNhcHRpb247XHJcbiAgfSBlbHNlIHtcclxuICAgIG5ld0NhcHRpb24gPSBkZWZhdWx0QnV0dG9uQ2FwdGlvbjtcclxuICB9XHJcbiAgcmV0dXJuIGRlZmF1bHRCdXR0b25DYXB0aW9uO1xyXG59O1xyXG5cclxuY29uc3Qgc2V0Q2xhc3NOYW1lID0gKGNsYXNzTmFtZSkgPT4ge1xyXG4gIGxldCBuZXdDbGFzc05hbWUgPSAnJztcclxuICBpZiAoY2xhc3NOYW1lICE9ICcnICYmIGNsYXNzTmFtZSAhPSB1bmRlZmluZWQpIHtcclxuICAgIG5ld0NsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICB9IGVsc2Uge1xyXG4gICAgbmV3Q2xhc3NOYW1lID0gZGVmYXVsdENsYXNzTmFtZTtcclxuICB9XHJcbiAgcmV0dXJuIG5ld0NsYXNzTmFtZTtcclxufTtcclxuXHJcbkhvbWVCdXR0b24ucHJvcFR5cGVzID0ge1xyXG4gIGNhcHRpb246IHN0cmluZyxcclxuICBjbGFzc05hbWU6IHN0cmluZyxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhvbWVCdXR0b247XHJcbiIsIi8qKlxyXG4gKiBOYXZpZ2F0aW9uIE1lbnUgQmFyIENvbXBvbmVudFxyXG4gKiBAZGVzY3JpcHRpb24gSG9yaXpvbnRhbCBWZXJ0aWNhbGx5IGV4cGFuZGluZyBOYXZpZ2F0aW9uIE1lbnUgd2l0aCBhbmltYXRpb25zXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5pbXBvcnQgTmV4dExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZU9uTW91c2VDbGlja091dHNpZGVOYXYgfSBmcm9tICdAL2xpYi9ob29rcy5qcyc7XHJcblxyXG5pbXBvcnQgQXZhdGFyIGZyb20gJ0AvY29tcG9uZW50cy9BdmF0YXInO1xyXG5pbXBvcnQgSGFtQnVyZ2VyIGZyb20gJ0AvY29tcG9uZW50cy9IYW1idXJnZXInO1xyXG5pbXBvcnQgSGFtQnVyZ2VyTWVudSBmcm9tICdAL2NvbXBvbmVudHMvSGFtYnVyZ2VyTWVudSc7XHJcblxyXG4vKipcclxuICogTWFpbiBOYXZpZ2F0aW9uIE1lbnUgQmFyIChIb3Jpem9udGFsKVxyXG4gKi9cclxuY29uc3QgTmF2QmFyID0gKHsgYXV0aG9yIH0pID0+IHtcclxuICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3Qgbm9kZSA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCBtZW51SWQgPSAnbW9iaWxlLW1lbnUnO1xyXG5cclxuICB1c2VPbk1vdXNlQ2xpY2tPdXRzaWRlTmF2KG5vZGUsICgpID0+IHNldE9wZW4oZmFsc2UpKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDw+XHJcbiAgICAgIDxkaXYgcmVmPXtub2RlfSBjbGFzc05hbWU9XCJcIj5cclxuICAgICAgICA8bmF2XHJcbiAgICAgICAgICBpZD1cIm5hdmJhclwiXHJcbiAgICAgICAgICByb2xlPVwibmF2aWdhdGlvblwiXHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJzdGlja3ktaGVhZGVyIHctZnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGJnLWdyYXktODAwIGZsZXggZmxleC13cmFwIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gbXQtMCBweS0yXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICA8TmV4dExpbmsgaHJlZj1cIi9cIj5cclxuICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHAtMiB3LWF1dG8gY3Vyc29yLXBvaW50ZXIgZm9jdXM6b3V0bGluZS1ub25lXCI+XHJcbiAgICAgICAgICAgICAgPEF2YXRhclxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC0xNCB3LTE0IHJvdW5kZWQtZnVsbCBtci0yIG1kOmgtMjAgbWQ6dy0yMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLTQgYm9yZGVyLXdoaXRlLTIwMCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSBob3ZlcjpzY2FsZS0xMjUgaG92ZXI6Ymctb3BhY2l0eS01MCB0cmFuc2l0aW9uIGVhc2Utb3V0IGR1cmF0aW9uLTUwMFwiXHJcbiAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMyBmb250LWJvbGQgaXRhbGljXHJcbiAgICAgICAgICAgICAgdGV4dC0yeGwgbWQ6dGV4dC0zeGwgbGc6dGV4dC00eGxcclxuICAgICAgICAgICAgICB0ZXh0LWJsdWUtNDAwXCJcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICBAe2F1dGhvciB8fCAnJ31cclxuICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgIDwvTmV4dExpbms+XHJcblxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBteS0yIHB0LTIgbWwtYXV0byBzbTp3LWF1dG9cIj5cclxuICAgICAgICAgICAgPEhhbUJ1cmdlciBvcGVuPXtvcGVufSBzZXRPcGVuPXtzZXRPcGVufSBhcmlhLWNvbnRyb2xzPXttZW51SWR9IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxIYW1CdXJnZXJNZW51IG9wZW49e29wZW59IHNldE9wZW49e3NldE9wZW59IGlkPXttZW51SWR9IC8+XHJcbiAgICAgICAgPC9uYXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC8+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5hdkJhcjtcclxuXHJcbk5hdkJhci5wcm9wVHlwZXMgPSB7XHJcbiAgYXV0aG9yOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBIb29rcyBGdW5jdGlvbnNcclxuICogQGRlc2NyaXB0aW9uIE1haW4gR2xvYmFsIFNpdGUgSG9va3MgdG8gaW5jbHVkZWQgaGVyZVxyXG4gKiBAYXV0aG9yIGR0cm8tZGV2dWsgQGdpdGh1YjpkdHJvLWRldnVrLmlvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuLyoqXHJcbiAqIFVzZSB0aGlzIHRvIGRldGVybWluZSBpZiB0aGUgdXNlciBjbGlja2VkIG91dHNpZGUgYW4gZWxlbWVudCAoZS5nLiBOYXYgQmFyIE1lbnUpXHJcbiAqIEBwYXJhbSB7Kn0gcmVmXHJcbiAqIEBwYXJhbSB7Kn0gaGFuZGxlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVzZU9uTW91c2VDbGlja091dHNpZGVOYXYgPSAocmVmLCBoYW5kbGVyKSA9PiB7XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGlmICghcmVmLmN1cnJlbnQgfHwgcmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBoYW5kbGVyKGV2ZW50KTtcclxuICAgIH07XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBsaXN0ZW5lcik7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXIpO1xyXG4gICAgfTtcclxuICB9LCBbcmVmLCBoYW5kbGVyXSk7XHJcbn07XHJcbiIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIlwidXNlIHN0cmljdFwiO3ZhciBhc3NpZ249T2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7bW9kdWxlLmV4cG9ydHM9YXNzaWduO21vZHVsZS5leHBvcnRzLmRlZmF1bHQ9bW9kdWxlLmV4cG9ydHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QtYXNzaWduLmpzLm1hcCIsIlxuICAgICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICAgIFwiLzQwNFwiLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJEOlxcXFxXb3JrQXJlYVxcXFxHaXRIdWJcXFxcbmV4dGpzLWdoLXBhZ2VzLWV4YW1wbGVcXFxccGFnZXNcXFxcNDA0LmpzXCIpO1xuICAgICAgICB9XG4gICAgICBdKTtcbiAgICAiLCJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgYWRkQmFzZVBhdGgsXG4gIGFkZExvY2FsZSxcbiAgZ2V0RG9tYWluTG9jYWxlLFxuICBpc0xvY2FsVVJMLFxuICBOZXh0Um91dGVyLFxuICBQcmVmZXRjaE9wdGlvbnMsXG4gIHJlc29sdmVIcmVmLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgdXNlSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi91c2UtaW50ZXJzZWN0aW9uJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxMaW5rUHJvcHM+XG5cbmNvbnN0IHByZWZldGNoZWQ6IHsgW2NhY2hlS2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuXG5mdW5jdGlvbiBwcmVmZXRjaChcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnNcbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXJvdXRlcikgcmV0dXJuXG4gIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG4gIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG5cbiAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcbiAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXSA9IHRydWVcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50XG4gIHJldHVybiAoXG4gICAgKHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHx8XG4gICAgZXZlbnQubWV0YUtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHxcbiAgICBldmVudC5zaGlmdEtleSB8fFxuICAgIGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIChldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMilcbiAgKVxufVxuXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChcbiAgZTogUmVhY3QuTW91c2VFdmVudCxcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzaGFsbG93PzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhbixcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICBpZiAobm9kZU5hbWUgPT09ICdBJyAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICFpc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgLy8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG4gIGlmIChzY3JvbGwgPT0gbnVsbCkge1xuICAgIHNjcm9sbCA9IGFzLmluZGV4T2YoJyMnKSA8IDBcbiAgfVxuXG4gIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICBzaGFsbG93LFxuICAgIGxvY2FsZSxcbiAgICBzY3JvbGwsXG4gIH0pLnRoZW4oKHN1Y2Nlc3M6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIXN1Y2Nlc3MpIHJldHVyblxuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIC8vIEZJWE1FOiBwcm9wZXIgcm91dGUgYW5ub3VuY2luZyBhdCBSb3V0ZXIgbGV2ZWwsIG5vdCBMaW5rOlxuICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBMaW5rKHByb3BzOiBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxMaW5rUHJvcHM+KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3M6IHtcbiAgICAgIGtleTogc3RyaW5nXG4gICAgICBleHBlY3RlZDogc3RyaW5nXG4gICAgICBhY3R1YWw6IHN0cmluZ1xuICAgIH0pIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBcXGAke2FyZ3Mua2V5fVxcYCBleHBlY3RzIGEgJHthcmdzLmV4cGVjdGVkfSBpbiBcXGA8TGluaz5cXGAsIGJ1dCBnb3QgXFxgJHthcmdzLmFjdHVhbH1cXGAgaW5zdGVhZC5gICtcbiAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiXG4gICAgICAgICAgICA6ICcnKVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkOiBSZWNvcmQ8TGlua1Byb3BzUmVxdWlyZWQsIHRydWU+ID0ge1xuICAgICAgaHJlZjogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3QgcmVxdWlyZWRQcm9wczogTGlua1Byb3BzUmVxdWlyZWRbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgcmVxdWlyZWRQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNSZXF1aXJlZFtdXG4gICAgcmVxdWlyZWRQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc1JlcXVpcmVkKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAnaHJlZicpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzW2tleV0gPT0gbnVsbCB8fFxuICAgICAgICAgICh0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcHJvcHNba2V5XSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IF86IG5ldmVyID0ga2V5XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wc0d1YXJkOiBSZWNvcmQ8TGlua1Byb3BzT3B0aW9uYWwsIHRydWU+ID0ge1xuICAgICAgYXM6IHRydWUsXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgc2hhbGxvdzogdHJ1ZSxcbiAgICAgIHBhc3NIcmVmOiB0cnVlLFxuICAgICAgcHJlZmV0Y2g6IHRydWUsXG4gICAgICBsb2NhbGU6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHM6IExpbmtQcm9wc09wdGlvbmFsW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIG9wdGlvbmFsUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzT3B0aW9uYWxbXVxuICAgIG9wdGlvbmFsUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNPcHRpb25hbCkgPT4ge1xuICAgICAgY29uc3QgdmFsVHlwZSA9IHR5cGVvZiBwcm9wc1trZXldXG5cbiAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycgJiYgdmFsVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsb2NhbGUnKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGtleSA9PT0gJ3JlcGxhY2UnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Njcm9sbCcgfHxcbiAgICAgICAga2V5ID09PSAnc2hhbGxvdycgfHxcbiAgICAgICAga2V5ID09PSAncGFzc0hyZWYnIHx8XG4gICAgICAgIGtleSA9PT0gJ3ByZWZldGNoJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IF86IG5ldmVyID0ga2V5XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgY29uc3QgaGFzV2FybmVkID0gUmVhY3QudXNlUmVmKGZhbHNlKVxuICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQpIHtcbiAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWQnXG4gICAgICApXG4gICAgfVxuICB9XG4gIGNvbnN0IHAgPSBwcm9wcy5wcmVmZXRjaCAhPT0gZmFsc2VcblxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxuICBjb25zdCBwYXRobmFtZSA9IChyb3V0ZXIgJiYgcm91dGVyLnBhdGhuYW1lKSB8fCAnLydcblxuICBjb25zdCB7IGhyZWYsIGFzIH0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5ocmVmLCB0cnVlKVxuICAgIHJldHVybiB7XG4gICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICBhczogcHJvcHMuYXNcbiAgICAgICAgPyByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuYXMpXG4gICAgICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWYsXG4gICAgfVxuICB9LCBbcGF0aG5hbWUsIHByb3BzLmhyZWYsIHByb3BzLmFzXSlcblxuICBsZXQgeyBjaGlsZHJlbiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUgfSA9IHByb3BzXG5cbiAgLy8gRGVwcmVjYXRlZC4gV2FybmluZyBzaG93biBieSBwcm9wVHlwZSBjaGVjay4gSWYgdGhlIGNoaWxkcmVuIHByb3ZpZGVkIGlzIGEgc3RyaW5nICg8TGluaz5leGFtcGxlPC9MaW5rPikgd2Ugd3JhcCBpdCBpbiBhbiA8YT4gdGFnXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgY2hpbGRyZW4gPSA8YT57Y2hpbGRyZW59PC9hPlxuICB9XG5cbiAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gIGNvbnN0IGNoaWxkOiBhbnkgPSBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICBjb25zdCBjaGlsZFJlZjogYW55ID0gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWZcblxuICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGVdID0gdXNlSW50ZXJzZWN0aW9uKHtcbiAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICB9KVxuICBjb25zdCBzZXRSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZWw6IEVsZW1lbnQpID0+IHtcbiAgICAgIHNldEludGVyc2VjdGlvblJlZihlbClcbiAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZFJlZihlbClcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbY2hpbGRSZWYsIHNldEludGVyc2VjdGlvblJlZl1cbiAgKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNob3VsZFByZWZldGNoID0gaXNWaXNpYmxlICYmIHAgJiYgaXNMb2NhbFVSTChocmVmKVxuICAgIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgICB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG4gICAgY29uc3QgaXNQcmVmZXRjaGVkID1cbiAgICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV1cbiAgICBpZiAoc2hvdWxkUHJlZmV0Y2ggJiYgIWlzUHJlZmV0Y2hlZCkge1xuICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICBsb2NhbGU6IGN1ckxvY2FsZSxcbiAgICAgIH0pXG4gICAgfVxuICB9LCBbYXMsIGhyZWYsIGlzVmlzaWJsZSwgbG9jYWxlLCBwLCByb3V0ZXJdKVxuXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgaHJlZj86IHN0cmluZ1xuICAgIHJlZj86IGFueVxuICB9ID0ge1xuICAgIHJlZjogc2V0UmVmLFxuICAgIG9uQ2xpY2s6IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKVxuICAgICAgfVxuICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUpXG4gICAgICB9XG4gICAgfSxcbiAgfVxuXG4gIGNoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSlcbiAgICB9XG4gICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgeyBwcmlvcml0eTogdHJ1ZSB9KVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICBpZiAocHJvcHMucGFzc0hyZWYgfHwgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpKSB7XG4gICAgY29uc3QgY3VyTG9jYWxlID1cbiAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGVcblxuICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9IGdldERvbWFpbkxvY2FsZShcbiAgICAgIGFzLFxuICAgICAgY3VyTG9jYWxlLFxuICAgICAgcm91dGVyICYmIHJvdXRlci5sb2NhbGVzLFxuICAgICAgcm91dGVyICYmIHJvdXRlci5kb21haW5Mb2NhbGVzXG4gICAgKVxuXG4gICAgY2hpbGRQcm9wcy5ocmVmID1cbiAgICAgIGxvY2FsZURvbWFpbiB8fFxuICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzLCBjdXJMb2NhbGUsIHJvdXRlciAmJiByb3V0ZXIuZGVmYXVsdExvY2FsZSkpXG4gIH1cblxuICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5rXG4iLCIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBpZiB0aGVyZSBpcyBvbmUuIFByZXNlcnZlcyB0aGUgcm9vdCBwYXRoIGAvYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgJiYgcGF0aCAhPT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoXG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGFjY29yZGluZyB0byB0aGUgYHRyYWlsaW5nU2xhc2hgIG9wdGlvblxuICogaW4gYG5leHQuY29uZmlnLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIXG4gID8gKHBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGgpXG4gICAgICB9IGVsc2UgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gcGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLydcbiAgICAgIH1cbiAgICB9XG4gIDogcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2hcbiIsInR5cGUgUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZSA9IGFueVxudHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrT3B0aW9ucyA9IHtcbiAgdGltZW91dDogbnVtYmVyXG59XG50eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSA9IHtcbiAgcmVhZG9ubHkgZGlkVGltZW91dDogYm9vbGVhblxuICB0aW1lUmVtYWluaW5nOiAoKSA9PiBudW1iZXJcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICByZXF1ZXN0SWRsZUNhbGxiYWNrOiAoXG4gICAgICBjYWxsYmFjazogKGRlYWRsaW5lOiBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUpID0+IHZvaWQsXG4gICAgICBvcHRzPzogUmVxdWVzdElkbGVDYWxsYmFja09wdGlvbnNcbiAgICApID0+IFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGVcbiAgfVxufVxuXG5jb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID1cbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2spIHx8XG4gIGZ1bmN0aW9uIChcbiAgICBjYjogKGRlYWRsaW5lOiBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUpID0+IHZvaWRcbiAgKTogTm9kZUpTLlRpbWVvdXQge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KClcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYih7XG4gICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0sIDEpXG4gIH1cblxuZXhwb3J0IGRlZmF1bHQgcmVxdWVzdElkbGVDYWxsYmFja1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ2xpZW50QnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL2J1aWxkL3dlYnBhY2svcGx1Z2lucy9idWlsZC1tYW5pZmVzdC1wbHVnaW4nXG5pbXBvcnQgZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZSdcbmltcG9ydCByZXF1ZXN0SWRsZUNhbGxiYWNrIGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG4vLyAzLjhzIHdhcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgaXQncyB3aGF0IGh0dHBzOi8vd2ViLmRldi9pbnRlcmFjdGl2ZVxuLy8gY29uc2lkZXJzIGFzIFwiR29vZFwiIHRpbWUtdG8taW50ZXJhY3RpdmUuIFdlIG11c3QgYXNzdW1lIHNvbWV0aGluZyB3ZW50XG4vLyB3cm9uZyBiZXlvbmQgdGhpcyBwb2ludCwgYW5kIHRoZW4gZmFsbC1iYWNrIHRvIGEgZnVsbCBwYWdlIHRyYW5zaXRpb24gdG9cbi8vIHNob3cgdGhlIHVzZXIgc29tZXRoaW5nIG9mIHZhbHVlLlxuY29uc3QgTVNfTUFYX0lETEVfREVMQVkgPSAzODAwXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19CVUlMRF9NQU5JRkVTVD86IENsaWVudEJ1aWxkTWFuaWZlc3RcbiAgICBfX0JVSUxEX01BTklGRVNUX0NCPzogRnVuY3Rpb25cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHtcbiAgY29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIGV4cG9ydHM6IGFueVxufVxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZSB7XG4gIGVycm9yOiB1bmtub3duXG59XG5leHBvcnQgdHlwZSBSb3V0ZUVudHJ5cG9pbnQgPSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB8IExvYWRlZEVudHJ5cG9pbnRGYWlsdXJlXG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVTdHlsZVNoZWV0IHtcbiAgaHJlZjogc3RyaW5nXG4gIGNvbnRlbnQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZFJvdXRlU3VjY2VzcyBleHRlbmRzIExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHtcbiAgc3R5bGVzOiBSb3V0ZVN0eWxlU2hlZXRbXVxufVxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZUZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVMb2FkZXJFbnRyeSA9IExvYWRlZFJvdXRlU3VjY2VzcyB8IExvYWRlZFJvdXRlRmFpbHVyZVxuXG5leHBvcnQgdHlwZSBGdXR1cmU8Vj4gPSB7XG4gIHJlc29sdmU6IChlbnRyeXBvaW50OiBWKSA9PiB2b2lkXG4gIGZ1dHVyZTogUHJvbWlzZTxWPlxufVxuZnVuY3Rpb24gd2l0aEZ1dHVyZTxUPihcbiAga2V5OiBzdHJpbmcsXG4gIG1hcDogTWFwPHN0cmluZywgRnV0dXJlPFQ+IHwgVD4sXG4gIGdlbmVyYXRvcj86ICgpID0+IFByb21pc2U8VD5cbik6IFByb21pc2U8VD4ge1xuICBsZXQgZW50cnk6IEZ1dHVyZTxUPiB8IFQgfCB1bmRlZmluZWQgPSBtYXAuZ2V0KGtleSlcbiAgaWYgKGVudHJ5KSB7XG4gICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICByZXR1cm4gZW50cnkuZnV0dXJlXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpXG4gIH1cbiAgbGV0IHJlc29sdmVyOiAoZW50cnlwb2ludDogVCkgPT4gdm9pZFxuICBjb25zdCBwcm9tOiBQcm9taXNlPFQ+ID0gbmV3IFByb21pc2U8VD4oKHJlc29sdmUpID0+IHtcbiAgICByZXNvbHZlciA9IHJlc29sdmVcbiAgfSlcbiAgbWFwLnNldChrZXksIChlbnRyeSA9IHsgcmVzb2x2ZTogcmVzb2x2ZXIhLCBmdXR1cmU6IHByb20gfSkpXG4gIHJldHVybiBnZW5lcmF0b3JcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgIGdlbmVyYXRvcigpLnRoZW4oKHZhbHVlKSA9PiAocmVzb2x2ZXIodmFsdWUpLCB2YWx1ZSkpXG4gICAgOiBwcm9tXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVMb2FkZXIge1xuICB3aGVuRW50cnlwb2ludChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZUVudHJ5cG9pbnQ+XG4gIG9uRW50cnlwb2ludChyb3V0ZTogc3RyaW5nLCBleGVjdXRlOiAoKSA9PiB1bmtub3duKTogdm9pZFxuICBsb2FkUm91dGUocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVMb2FkZXJFbnRyeT5cbiAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cbn1cblxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaz86IEhUTUxMaW5rRWxlbWVudCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcbiAgICByZXR1cm4gKFxuICAgICAgLy8gZGV0ZWN0IElFMTEgc2luY2UgaXQgc3VwcG9ydHMgcHJlZmV0Y2ggYnV0IGlzbid0IGRldGVjdGVkXG4gICAgICAvLyB3aXRoIHJlbExpc3Quc3VwcG9ydFxuICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhKGRvY3VtZW50IGFzIGFueSkuZG9jdW1lbnRNb2RlKSB8fFxuICAgICAgbGluay5yZWxMaXN0LnN1cHBvcnRzKCdwcmVmZXRjaCcpXG4gICAgKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5jb25zdCBjYW5QcmVmZXRjaDogYm9vbGVhbiA9IGhhc1ByZWZldGNoKClcblxuZnVuY3Rpb24gcHJlZmV0Y2hWaWFEb20oXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgbGluaz86IEhUTUxMaW5rRWxlbWVudFxuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsaW5rW3JlbD1cInByZWZldGNoXCJdW2hyZWZePVwiJHtocmVmfVwiXWApKSB7XG4gICAgICByZXR1cm4gcmVzKClcbiAgICB9XG5cbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG5cbiAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsOlxuICAgIGlmIChhcykgbGluayEuYXMgPSBhc1xuICAgIGxpbmshLnJlbCA9IGBwcmVmZXRjaGBcbiAgICBsaW5rIS5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU4hXG4gICAgbGluayEub25sb2FkID0gcmVzXG4gICAgbGluayEub25lcnJvciA9IHJlalxuXG4gICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICBsaW5rIS5ocmVmID0gaHJlZlxuXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICB9KVxufVxuXG5jb25zdCBBU1NFVF9MT0FEX0VSUk9SID0gU3ltYm9sKCdBU1NFVF9MT0FEX0VSUk9SJylcbi8vIFRPRE86IHVuZXhwb3J0XG5leHBvcnQgZnVuY3Rpb24gbWFya0Fzc2V0RXJyb3IoZXJyOiBFcnJvcik6IEVycm9yIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIEFTU0VUX0xPQURfRVJST1IsIHt9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBc3NldEVycm9yKGVycj86IEVycm9yKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBlcnIgJiYgQVNTRVRfTE9BRF9FUlJPUiBpbiBlcnJcbn1cblxuZnVuY3Rpb24gYXBwZW5kU2NyaXB0KFxuICBzcmM6IHN0cmluZyxcbiAgc2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnRcbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG5cbiAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxuICAgIC8vIDEuIFNldHVwIHN1Y2Nlc3MvZmFpbHVyZSBob29rcyBpbiBjYXNlIHRoZSBicm93c2VyIHN5bmNocm9ub3VzbHlcbiAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZVxuICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT5cbiAgICAgIHJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuXG4gICAgLy8gMi4gQ29uZmlndXJlIHRoZSBjcm9zcy1vcmlnaW4gYXR0cmlidXRlIGJlZm9yZSBzZXR0aW5nIGBzcmNgIGluIGNhc2UgdGhlXG4gICAgLy8gICAgYnJvd3NlciBiZWdpbnMgdG8gZmV0Y2guXG4gICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcblxuICAgIC8vIDMuIEZpbmFsbHksIHNldCB0aGUgc291cmNlIGFuZCBpbmplY3QgaW50byB0aGUgRE9NIGluIGNhc2UgdGhlIGNoaWxkXG4gICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgc2NyaXB0LnNyYyA9IHNyY1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICB9KVxufVxuXG5mdW5jdGlvbiBpZGxlVGltZW91dDxUPihtczogbnVtYmVyLCBlcnI6IEVycm9yKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT5cbiAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KGVyciksIG1zKSlcbiAgKVxufVxuXG4vLyBUT0RPOiBzdG9wIGV4cG9ydGluZyBvciBjYWNoZSB0aGUgZmFpbHVyZVxuLy8gSXQnZCBiZSBiZXN0IHRvIHN0b3AgZXhwb3J0aW5nIHRoaXMuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLiBXZSdyZVxuLy8gb25seSBleHBvcnRpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsdHkgd2l0aCB0aGUgYHBhZ2UtbG9hZGVyYC5cbi8vIE9ubHkgY2FjaGUgdGhpcyByZXNwb25zZSBhcyBhIGxhc3QgcmVzb3J0IGlmIHdlIGNhbm5vdCBlbGltaW5hdGUgYWxsIG90aGVyXG4vLyBjb2RlIGJyYW5jaGVzIHRoYXQgdXNlIHRoZSBCdWlsZCBNYW5pZmVzdCBDYWxsYmFjayBhbmQgcHVzaCB0aGVtIHRocm91Z2hcbi8vIHRoZSBSb3V0ZSBMb2FkZXIgaW50ZXJmYWNlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKTogUHJvbWlzZTxDbGllbnRCdWlsZE1hbmlmZXN0PiB7XG4gIGlmIChzZWxmLl9fQlVJTERfTUFOSUZFU1QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVClcbiAgfVxuXG4gIGNvbnN0IG9uQnVpbGRNYW5pZmVzdDogUHJvbWlzZTxDbGllbnRCdWlsZE1hbmlmZXN0PiA9IG5ldyBQcm9taXNlPFxuICAgIENsaWVudEJ1aWxkTWFuaWZlc3RcbiAgPigocmVzb2x2ZSkgPT4ge1xuICAgIC8vIE1hbmRhdG9yeSBiZWNhdXNlIHRoaXMgaXMgbm90IGNvbmN1cnJlbnQgc2FmZTpcbiAgICBjb25zdCBjYiA9IHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQlxuICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgb25CdWlsZE1hbmlmZXN0LFxuICAgIGlkbGVUaW1lb3V0PENsaWVudEJ1aWxkTWFuaWZlc3Q+KFxuICAgICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgICBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNsaWVudCBidWlsZCBtYW5pZmVzdCcpKVxuICAgICksXG4gIF0pXG59XG5cbmludGVyZmFjZSBSb3V0ZUZpbGVzIHtcbiAgc2NyaXB0czogc3RyaW5nW11cbiAgY3NzOiBzdHJpbmdbXVxufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShcbiAgYXNzZXRQcmVmaXg6IHN0cmluZyxcbiAgcm91dGU6IHN0cmluZ1xuKTogUHJvbWlzZTxSb3V0ZUZpbGVzPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgc2NyaXB0czogW1xuICAgICAgICBhc3NldFByZWZpeCArXG4gICAgICAgICAgJy9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzJyArXG4gICAgICAgICAgZW5jb2RlVVJJKGdldEFzc2V0UGF0aEZyb21Sb3V0ZShyb3V0ZSwgJy5qcycpKSxcbiAgICAgIF0sXG4gICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICBjc3M6IFtdLFxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKS50aGVuKChtYW5pZmVzdCkgPT4ge1xuICAgIGlmICghKHJvdXRlIGluIG1hbmlmZXN0KSkge1xuICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9va3VwIHJvdXRlOiAke3JvdXRlfWApKVxuICAgIH1cbiAgICBjb25zdCBhbGxGaWxlcyA9IG1hbmlmZXN0W3JvdXRlXS5tYXAoXG4gICAgICAoZW50cnkpID0+IGFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgIClcbiAgICByZXR1cm4ge1xuICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KSA9PiB2LmVuZHNXaXRoKCcuanMnKSksXG4gICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmNzcycpKSxcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4OiBzdHJpbmcpOiBSb3V0ZUxvYWRlciB7XG4gIGNvbnN0IGVudHJ5cG9pbnRzOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEZ1dHVyZTxSb3V0ZUVudHJ5cG9pbnQ+IHwgUm91dGVFbnRyeXBvaW50XG4gID4gPSBuZXcgTWFwKClcbiAgY29uc3QgbG9hZGVkU2NyaXB0czogTWFwPHN0cmluZywgUHJvbWlzZTx1bmtub3duPj4gPSBuZXcgTWFwKClcbiAgY29uc3Qgc3R5bGVTaGVldHM6IE1hcDxzdHJpbmcsIFByb21pc2U8Um91dGVTdHlsZVNoZWV0Pj4gPSBuZXcgTWFwKClcbiAgY29uc3Qgcm91dGVzOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5PiB8IFJvdXRlTG9hZGVyRW50cnlcbiAgPiA9IG5ldyBNYXAoKVxuXG4gIGZ1bmN0aW9uIG1heWJlRXhlY3V0ZVNjcmlwdChzcmM6IHN0cmluZyk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGxldCBwcm9tOiBQcm9taXNlPHVua25vd24+IHwgdW5kZWZpbmVkID0gbG9hZGVkU2NyaXB0cy5nZXQoc3JjKVxuICAgIGlmIChwcm9tKSB7XG4gICAgICByZXR1cm4gcHJvbVxuICAgIH1cblxuICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyY149XCIke3NyY31cIl1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLCAocHJvbSA9IGFwcGVuZFNjcmlwdChzcmMpKSlcbiAgICByZXR1cm4gcHJvbVxuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hTdHlsZVNoZWV0KGhyZWY6IHN0cmluZyk6IFByb21pc2U8Um91dGVTdHlsZVNoZWV0PiB7XG4gICAgbGV0IHByb206IFByb21pc2U8Um91dGVTdHlsZVNoZWV0PiB8IHVuZGVmaW5lZCA9IHN0eWxlU2hlZXRzLmdldChocmVmKVxuICAgIGlmIChwcm9tKSB7XG4gICAgICByZXR1cm4gcHJvbVxuICAgIH1cblxuICAgIHN0eWxlU2hlZXRzLnNldChcbiAgICAgIGhyZWYsXG4gICAgICAocHJvbSA9IGZldGNoKGhyZWYpXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdHlsZXNoZWV0OiAke2hyZWZ9YClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCkudGhlbigodGV4dCkgPT4gKHsgaHJlZjogaHJlZiwgY29udGVudDogdGV4dCB9KSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICB0aHJvdyBtYXJrQXNzZXRFcnJvcihlcnIpXG4gICAgICAgIH0pKVxuICAgIClcbiAgICByZXR1cm4gcHJvbVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aGVuRW50cnlwb2ludChyb3V0ZTogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpXG4gICAgfSxcbiAgICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bikge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGV4ZWN1dGUpXG4gICAgICAgIC50aGVuKChmbikgPT4gZm4oKSlcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgKGV4cG9ydHM6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogKGV4cG9ydHMgJiYgZXhwb3J0cy5kZWZhdWx0KSB8fCBleHBvcnRzLFxuICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0cyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAoZXJyKSA9PiAoeyBlcnJvcjogZXJyIH0pXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKGlucHV0OiBSb3V0ZUVudHJ5cG9pbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpXG4gICAgICAgICAgZW50cnlwb2ludHMuc2V0KHJvdXRlLCBpbnB1dClcbiAgICAgICAgICBpZiAob2xkICYmICdyZXNvbHZlJyBpbiBvbGQpIG9sZC5yZXNvbHZlKGlucHV0KVxuICAgICAgICB9KVxuICAgIH0sXG4gICAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiB3aXRoRnV0dXJlPFJvdXRlTG9hZGVyRW50cnk+KHJvdXRlLCByb3V0ZXMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHNjcmlwdHMsIGNzcyB9ID0gYXdhaXQgZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpXG4gICAgICAgICAgY29uc3QgWywgc3R5bGVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSlcbiAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSxcbiAgICAgICAgICBdIGFzIGNvbnN0KVxuXG4gICAgICAgICAgY29uc3QgZW50cnlwb2ludDogUm91dGVFbnRyeXBvaW50ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLFxuICAgICAgICAgICAgaWRsZVRpbWVvdXQ8Um91dGVMb2FkZXJFbnRyeT4oXG4gICAgICAgICAgICAgIE1TX01BWF9JRExFX0RFTEFZLFxuICAgICAgICAgICAgICBtYXJrQXNzZXRFcnJvcihcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoYFJvdXRlIGRpZCBub3QgY29tcGxldGUgbG9hZGluZzogJHtyb3V0ZX1gKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0pXG4gICAgICAgICAgY29uc3QgcmVzOiBSb3V0ZUxvYWRlckVudHJ5ID0gT2JqZWN0LmFzc2lnbjxcbiAgICAgICAgICAgIHsgc3R5bGVzOiBSb3V0ZVN0eWxlU2hlZXRbXSB9LFxuICAgICAgICAgICAgUm91dGVFbnRyeXBvaW50XG4gICAgICAgICAgPih7IHN0eWxlcyB9LCBlbnRyeXBvaW50KVxuICAgICAgICAgIHJldHVybiAnZXJyb3InIGluIGVudHJ5cG9pbnQgPyBlbnRyeXBvaW50IDogcmVzXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiB7IGVycm9yOiBlcnIgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgbGV0IGNuXG4gICAgICBpZiAoKGNuID0gKG5hdmlnYXRvciBhcyBhbnkpLmNvbm5lY3Rpb24pKSB7XG4gICAgICAgIC8vIERvbid0IHByZWZldGNoIGlmIHVzaW5nIDJHIG9yIGlmIFNhdmUtRGF0YSBpcyBlbmFibGVkLlxuICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGaWxlc0ZvclJvdXRlKGFzc2V0UHJlZml4LCByb3V0ZSlcbiAgICAgICAgLnRoZW4oKG91dHB1dCkgPT5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGNhblByZWZldGNoXG4gICAgICAgICAgICAgID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpID0+IHByZWZldGNoVmlhRG9tKHNjcmlwdCwgJ3NjcmlwdCcpKVxuICAgICAgICAgICAgICA6IFtdXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHRoaXMubG9hZFJvdXRlKHJvdXRlKSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKFxuICAgICAgICAgIC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgKCkgPT4ge31cbiAgICAgICAgKVxuICAgIH0sXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUm91dGVMb2FkZXJcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSb3V0ZXIsIHsgTmV4dFJvdXRlciB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dCdcblxudHlwZSBDbGFzc0FyZ3VtZW50czxUPiA9IFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGluZmVyIFUpID0+IGFueSA/IFUgOiBhbnlcblxudHlwZSBSb3V0ZXJBcmdzID0gQ2xhc3NBcmd1bWVudHM8dHlwZW9mIFJvdXRlcj5cblxudHlwZSBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IFJvdXRlciB8IG51bGxcbiAgcmVhZHlDYWxsYmFja3M6IEFycmF5PCgpID0+IGFueT5cbiAgcmVhZHkoY2I6ICgpID0+IGFueSk6IHZvaWRcbn1cblxuZXhwb3J0IHsgUm91dGVyLCBOZXh0Um91dGVyIH1cblxuZXhwb3J0IHR5cGUgU2luZ2xldG9uUm91dGVyID0gU2luZ2xldG9uUm91dGVyQmFzZSAmIE5leHRSb3V0ZXJcblxuY29uc3Qgc2luZ2xldG9uUm91dGVyOiBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IG51bGwsIC8vIGhvbGRzIHRoZSBhY3R1YWwgcm91dGVyIGluc3RhbmNlXG4gIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgcmVhZHkoY2I6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodGhpcy5yb3V0ZXIpIHJldHVybiBjYigpXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgfVxuICB9LFxufVxuXG4vLyBDcmVhdGUgcHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIHJvdXRlciBpbiB0aGUgc2luZ2xldG9uUm91dGVyXG5jb25zdCB1cmxQcm9wZXJ0eUZpZWxkcyA9IFtcbiAgJ3BhdGhuYW1lJyxcbiAgJ3JvdXRlJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2FzUGF0aCcsXG4gICdjb21wb25lbnRzJyxcbiAgJ2lzRmFsbGJhY2snLFxuICAnYmFzZVBhdGgnLFxuICAnbG9jYWxlJyxcbiAgJ2xvY2FsZXMnLFxuICAnZGVmYXVsdExvY2FsZScsXG4gICdpc1JlYWR5Jyxcbl1cbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcbiAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcbiAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsXG5dXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAncHVzaCcsXG4gICdyZXBsYWNlJyxcbiAgJ3JlbG9hZCcsXG4gICdiYWNrJyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2JlZm9yZVBvcFN0YXRlJyxcbl1cblxuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBSb3V0ZXIuZXZlbnRzXG4gIH0sXG59KVxuXG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZDogc3RyaW5nKSA9PiB7XG4gIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4gIC8vIHRoZSBwcm9wZXJ0eSBhc3NpZ25lZCB0byB0aGUgYWN0dWFsIHJvdXRlclxuICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcbiAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgZmllbGQsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdIGFzIHN0cmluZ1xuICAgIH0sXG4gIH0pXG59KVxuXG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkOiBzdHJpbmcpID0+IHtcbiAgLy8gV2UgZG9uJ3QgcmVhbGx5IGtub3cgdGhlIHR5cGVzIGhlcmUsIHNvIHdlIGFkZCB0aGVtIGxhdGVyIGluc3RlYWRcbiAgOyhzaW5nbGV0b25Sb3V0ZXIgYXMgYW55KVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICB9XG59KVxuXG5yb3V0ZXJFdmVudHMuZm9yRWFjaCgoZXZlbnQ6IHN0cmluZykgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZyhcbiAgICAgICAgMVxuICAgICAgKX1gXG4gICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyIGFzIGFueVxuICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoZW4gcnVubmluZyB0aGUgUm91dGVyIGV2ZW50OiAke2V2ZW50RmllbGR9YClcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2Vyci5tZXNzYWdlfVxcbiR7ZXJyLnN0YWNrfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxufSlcblxuZnVuY3Rpb24gZ2V0Um91dGVyKCk6IFJvdXRlciB7XG4gIGlmICghc2luZ2xldG9uUm91dGVyLnJvdXRlcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgJ05vIHJvdXRlciBpbnN0YW5jZSBmb3VuZC5cXG4nICtcbiAgICAgICdZb3Ugc2hvdWxkIG9ubHkgdXNlIFwibmV4dC9yb3V0ZXJcIiBpbnNpZGUgdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbidcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBFeHBvcnQgdGhlIHNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbmV4cG9ydCBkZWZhdWx0IHNpbmdsZXRvblJvdXRlciBhcyBTaW5nbGV0b25Sb3V0ZXJcblxuLy8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aFJvdXRlciB9IGZyb20gJy4vd2l0aC1yb3V0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogTmV4dFJvdXRlciB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG59XG5cbi8vIElOVEVSTkFMIEFQSVNcbi8vIC0tLS0tLS0tLS0tLS1cbi8vIChkbyBub3QgdXNlIGZvbGxvd2luZyBleHBvcnRzIGluc2lkZSB0aGUgYXBwKVxuXG4vLyBDcmVhdGUgYSByb3V0ZXIgYW5kIGFzc2lnbiBpdCBhcyB0aGUgc2luZ2xldG9uIGluc3RhbmNlLlxuLy8gVGhpcyBpcyB1c2VkIGluIGNsaWVudCBzaWRlIHdoZW4gd2UgYXJlIGluaXRpbGl6aW5nIHRoZSBhcHAuXG4vLyBUaGlzIHNob3VsZCAqKm5vdCoqIHVzZSBpbnNpZGUgdGhlIHNlcnZlci5cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZXIgPSAoLi4uYXJnczogUm91dGVyQXJncyk6IFJvdXRlciA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yb3V0ZXIgPSBuZXcgUm91dGVyKC4uLmFyZ3MpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW11cblxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBgd2l0aFJvdXRlcmAgcm91dGVyIGluc3RhbmNlXG5leHBvcnQgZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcjogUm91dGVyKTogTmV4dFJvdXRlciB7XG4gIGNvbnN0IF9yb3V0ZXIgPSByb3V0ZXIgYXMgYW55XG4gIGNvbnN0IGluc3RhbmNlID0ge30gYXMgYW55XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB1cmxQcm9wZXJ0eUZpZWxkcykge1xuICAgIGlmICh0eXBlb2YgX3JvdXRlcltwcm9wZXJ0eV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBPYmplY3QuYXNzaWduKFxuICAgICAgICBBcnJheS5pc0FycmF5KF9yb3V0ZXJbcHJvcGVydHldKSA/IFtdIDoge30sXG4gICAgICAgIF9yb3V0ZXJbcHJvcGVydHldXG4gICAgICApIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IF9yb3V0ZXJbcHJvcGVydHldXG4gIH1cblxuICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gIGluc3RhbmNlLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaW5zdGFuY2VbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICByZXR1cm4gX3JvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgcmVxdWVzdElkbGVDYWxsYmFjayBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxudHlwZSBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQgPSBQaWNrPEludGVyc2VjdGlvbk9ic2VydmVySW5pdCwgJ3Jvb3RNYXJnaW4nPlxudHlwZSBVc2VJbnRlcnNlY3Rpb24gPSB7IGRpc2FibGVkPzogYm9vbGVhbiB9ICYgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XG50eXBlIE9ic2VydmVDYWxsYmFjayA9IChpc1Zpc2libGU6IGJvb2xlYW4pID0+IHZvaWRcbnR5cGUgT2JzZXJ2ZXIgPSB7XG4gIGlkOiBzdHJpbmdcbiAgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyXG4gIGVsZW1lbnRzOiBNYXA8RWxlbWVudCwgT2JzZXJ2ZUNhbGxiYWNrPlxufVxuXG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbjxUIGV4dGVuZHMgRWxlbWVudD4oe1xuICByb290TWFyZ2luLFxuICBkaXNhYmxlZCxcbn06IFVzZUludGVyc2VjdGlvbik6IFsoZWxlbWVudDogVCB8IG51bGwpID0+IHZvaWQsIGJvb2xlYW5dIHtcbiAgY29uc3QgaXNEaXNhYmxlZDogYm9vbGVhbiA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlclxuXG4gIGNvbnN0IHVub2JzZXJ2ZSA9IHVzZVJlZjxGdW5jdGlvbj4oKVxuICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCBzZXRSZWYgPSB1c2VDYWxsYmFjayhcbiAgICAoZWw6IFQgfCBudWxsKSA9PiB7XG4gICAgICBpZiAodW5vYnNlcnZlLmN1cnJlbnQpIHtcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQoKVxuICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNhYmxlZCB8fCB2aXNpYmxlKSByZXR1cm5cblxuICAgICAgaWYgKGVsICYmIGVsLnRhZ05hbWUpIHtcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSBvYnNlcnZlKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIChpc1Zpc2libGUpID0+IGlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksXG4gICAgICAgICAgeyByb290TWFyZ2luIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG4gICAgW2lzRGlzYWJsZWQsIHJvb3RNYXJnaW4sIHZpc2libGVdXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGlmICghdmlzaWJsZSkgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBzZXRWaXNpYmxlKHRydWUpKVxuICAgIH1cbiAgfSwgW3Zpc2libGVdKVxuXG4gIHJldHVybiBbc2V0UmVmLCB2aXNpYmxlXVxufVxuXG5mdW5jdGlvbiBvYnNlcnZlKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBjYWxsYmFjazogT2JzZXJ2ZUNhbGxiYWNrLFxuICBvcHRpb25zOiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRcbik6ICgpID0+IHZvaWQge1xuICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpXG4gIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjaylcblxuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpXG4gIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKTogdm9pZCB7XG4gICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpXG5cbiAgICAvLyBEZXN0cm95IG9ic2VydmVyIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gd2F0Y2g6XG4gICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZClcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcDxzdHJpbmcsIE9ic2VydmVyPigpXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zOiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQpOiBPYnNlcnZlciB7XG4gIGNvbnN0IGlkID0gb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnXG4gIGxldCBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZVxuICB9XG5cbiAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz4oKVxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldClcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMFxuICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSwgb3B0aW9ucylcblxuICBvYnNlcnZlcnMuc2V0KFxuICAgIGlkLFxuICAgIChpbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICBlbGVtZW50cyxcbiAgICB9KVxuICApXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dENvbXBvbmVudFR5cGUsIE5leHRQYWdlQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCB7IE5leHRSb3V0ZXIsIHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG5leHBvcnQgdHlwZSBXaXRoUm91dGVyUHJvcHMgPSB7XG4gIHJvdXRlcjogTmV4dFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlUm91dGVyUHJvcHM8UD4gPSBQaWNrPFxuICBQLFxuICBFeGNsdWRlPGtleW9mIFAsIGtleW9mIFdpdGhSb3V0ZXJQcm9wcz5cbj5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aFJvdXRlcjxcbiAgUCBleHRlbmRzIFdpdGhSb3V0ZXJQcm9wcyxcbiAgQyA9IE5leHRQYWdlQ29udGV4dFxuPihcbiAgQ29tcG9zZWRDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPEMsIGFueSwgUD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8RXhjbHVkZVJvdXRlclByb3BzPFA+PiB7XG4gIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzOiBhbnkpOiBKU1guRWxlbWVudCB7XG4gICAgcmV0dXJuIDxDb21wb3NlZENvbXBvbmVudCByb3V0ZXI9e3VzZVJvdXRlcigpfSB7Li4ucHJvcHN9IC8+XG4gIH1cblxuICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHNcbiAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yIGN1c3RvbSBnZXRJbml0aWFsUHJvcHMgaW4gX2FwcFxuICA7KFdpdGhSb3V0ZXJXcmFwcGVyIGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wcyA9IChDb21wb3NlZENvbXBvbmVudCBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWBcbiAgfVxuXG4gIHJldHVybiBXaXRoUm91dGVyV3JhcHBlclxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbGV4ZXIoc3RyKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIipcIiB8fCBjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk1PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1BFTlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXFxcIj9cXFwiIGF0IFwiICsgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUEFUVEVSTlwiLCBpbmRleDogaSwgdmFsdWU6IHBhdHRlcm4gfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl0rP1wiO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5ID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHZhciB0cnlDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpKytdLnZhbHVlO1xuICAgIH07XG4gICAgdmFyIG11c3RDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q29uc3VtZSh0eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhciBfYSA9IHRva2Vuc1tpXSwgbmV4dFR5cGUgPSBfYS50eXBlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBcIiArIG5leHRUeXBlICsgXCIgYXQgXCIgKyBpbmRleCArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIikpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICBpZiAobmFtZSB8fCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY2hhciB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHByZWZpeGVzLmluZGV4T2YocHJlZml4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuIHx8IGRlZmF1bHRQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG11c3RDb25zdW1lKFwiRU5EXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5mdW5jdGlvbiBjb21waWxlKHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24odG9rZW5zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVGbGFncyA9IGZsYWdzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYSwgX2IgPSBvcHRpb25zLnZhbGlkYXRlLCB2YWxpZGF0ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIG1hdGNoZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikkXCIsIHJlRmxhZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YSA/IGRhdGFbdG9rZW4ubmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB0b2tlbi5tb2RpZmllciA9PT0gXCI/XCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIrXCI7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbGwgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHR5cGVPZk1lc3NhZ2UgPSByZXBlYXQgPyBcImFuIGFycmF5XCIgOiBcImEgc3RyaW5nXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBiZSBcIiArIHR5cGVPZk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG59XG5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uO1xuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgcmUgPSBwYXRoVG9SZWdleHAoc3RyLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5kZWNvZGUsIGRlY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGF0aCA9IG1bMF0sIGluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbmV4cG9ydHMucmVnZXhwVG9GdW5jdGlvbiA9IHJlZ2V4cFRvRnVuY3Rpb247XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZmxhZ3Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuc2Vuc2l0aXZlID8gXCJcIiA6IFwiaVwiO1xufVxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpIHtcbiAgICBpZiAoIWtleXMpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogaSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cChwYXRocywga2V5cywgb3B0aW9ucykge1xuICAgIHZhciBwYXJ0cyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpcIiArIHBhcnRzLmpvaW4oXCJ8XCIpICsgXCIpXCIsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgIHZhciBlbmRzV2l0aCA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZW5kc1dpdGggfHwgXCJcIikgKyBcIl18JFwiO1xuICAgIHZhciBkZWxpbWl0ZXIgPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXVwiO1xuICAgIHZhciByb3V0ZSA9IHN0YXJ0ID8gXCJeXCIgOiBcIlwiO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gICAgZm9yICh2YXIgX2kgPSAwLCB0b2tlbnNfMSA9IHRva2VuczsgX2kgPCB0b2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zXzFbX2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5wcmVmaXgpKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnN1ZmZpeCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiA/IFwiP1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIigoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikoPzpcIiArIHN1ZmZpeCArIHByZWZpeCArIFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKSopXCIgKyBzdWZmaXggKyBcIilcIiArIG1vZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIXN0cmljdClcbiAgICAgICAgICAgIHJvdXRlICs9IGRlbGltaXRlciArIFwiP1wiO1xuICAgICAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/IFwiJFwiIDogXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0eXBlb2YgZW5kVG9rZW4gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gZGVsaW1pdGVyLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTFcbiAgICAgICAgICAgIDogLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgZW5kVG9rZW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBkZWxpbWl0ZXIgKyBcIig/PVwiICsgZW5kc1dpdGggKyBcIikpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIgKyBkZWxpbWl0ZXIgKyBcInxcIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMudG9rZW5zVG9SZWdleHAgPSB0b2tlbnNUb1JlZ2V4cDtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhdGhUb1JlZ2V4cCA9IHBhdGhUb1JlZ2V4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEFtcFN0YXRlQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQW1wU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FtcFN0YXRlQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEFtcFN0YXRlQ29udGV4dCB9IGZyb20gJy4vYW1wLWNvbnRleHQnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luQW1wTW9kZSh7XG4gIGFtcEZpcnN0ID0gZmFsc2UsXG4gIGh5YnJpZCA9IGZhbHNlLFxuICBoYXNRdWVyeSA9IGZhbHNlLFxufSA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiBhbXBGaXJzdCB8fCAoaHlicmlkICYmIGhhc1F1ZXJ5KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQW1wKCk6IGJvb2xlYW4ge1xuICAvLyBEb24ndCBhc3NpZ24gdGhlIGNvbnRleHQgdmFsdWUgdG8gYSB2YXJpYWJsZSB0byBzYXZlIGJ5dGVzXG4gIHJldHVybiBpc0luQW1wTW9kZShSZWFjdC51c2VDb250ZXh0KEFtcFN0YXRlQ29udGV4dCkpXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBIZWFkTWFuYWdlckNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8e1xuICB1cGRhdGVIZWFkPzogKHN0YXRlOiBhbnkpID0+IHZvaWRcbiAgbW91bnRlZEluc3RhbmNlcz86IGFueVxuICB1cGRhdGVTY3JpcHRzPzogKHN0YXRlOiBhbnkpID0+IHZvaWRcbiAgc2NyaXB0cz86IGFueVxufT4gPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBIZWFkTWFuYWdlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnSGVhZE1hbmFnZXJDb250ZXh0J1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBFZmZlY3QgZnJvbSAnLi9zaWRlLWVmZmVjdCdcbmltcG9ydCB7IEFtcFN0YXRlQ29udGV4dCB9IGZyb20gJy4vYW1wLWNvbnRleHQnXG5pbXBvcnQgeyBIZWFkTWFuYWdlckNvbnRleHQgfSBmcm9tICcuL2hlYWQtbWFuYWdlci1jb250ZXh0J1xuaW1wb3J0IHsgaXNJbkFtcE1vZGUgfSBmcm9tICcuL2FtcCdcblxudHlwZSBXaXRoSW5BbXBNb2RlID0ge1xuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0SGVhZChpbkFtcE1vZGUgPSBmYWxzZSk6IEpTWC5FbGVtZW50W10ge1xuICBjb25zdCBoZWFkID0gWzxtZXRhIGNoYXJTZXQ9XCJ1dGYtOFwiIC8+XVxuICBpZiAoIWluQW1wTW9kZSkge1xuICAgIGhlYWQucHVzaCg8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz4pXG4gIH1cbiAgcmV0dXJuIGhlYWRcbn1cblxuZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChcbiAgbGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBjaGlsZDogUmVhY3QuUmVhY3RDaGlsZFxuKTogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+IHtcbiAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQoXG4gICAgICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoXG4gICAgICAgIChcbiAgICAgICAgICBmcmFnbWVudExpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICAgICAgICBmcmFnbWVudENoaWxkOiBSZWFjdC5SZWFjdENoaWxkXG4gICAgICAgICk6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ251bWJlcidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3RcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdC5jb25jYXQoZnJhZ21lbnRDaGlsZClcbiAgICAgICAgfSxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICApXG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKVxufVxuXG5jb25zdCBNRVRBVFlQRVMgPSBbJ25hbWUnLCAnaHR0cEVxdWl2JywgJ2NoYXJTZXQnLCAnaXRlbVByb3AnXVxuXG4vKlxuIHJldHVybnMgYSBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIGhlYWQgY2hpbGQgZWxlbWVudHNcbiB3aGljaCBzaG91bGRuJ3QgYmUgZHVwbGljYXRlZCwgbGlrZSA8dGl0bGUvPlxuIEFsc28gYWRkcyBzdXBwb3J0IGZvciBkZWR1cGxpY2F0ZWQgYGtleWAgcHJvcGVydGllc1xuKi9cbmZ1bmN0aW9uIHVuaXF1ZSgpIHtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKVxuICBjb25zdCB0YWdzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhQ2F0ZWdvcmllczogeyBbbWV0YXR5cGU6IHN0cmluZ106IFNldDxzdHJpbmc+IH0gPSB7fVxuXG4gIHJldHVybiAoaDogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4pID0+IHtcbiAgICBsZXQgaXNVbmlxdWUgPSB0cnVlXG4gICAgbGV0IGhhc0tleSA9IGZhbHNlXG5cbiAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSAnbnVtYmVyJyAmJiBoLmtleS5pbmRleE9mKCckJykgPiAwKSB7XG4gICAgICBoYXNLZXkgPSB0cnVlXG4gICAgICBjb25zdCBrZXkgPSBoLmtleS5zbGljZShoLmtleS5pbmRleE9mKCckJykgKyAxKVxuICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICBzd2l0Y2ggKGgudHlwZSkge1xuICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgY2FzZSAnYmFzZSc6XG4gICAgICAgIGlmICh0YWdzLmhhcyhoLnR5cGUpKSB7XG4gICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXVxuICAgICAgICAgIGlmICghaC5wcm9wcy5oYXNPd25Qcm9wZXJ0eShtZXRhdHlwZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICBpZiAobWV0YXR5cGUgPT09ICdjaGFyU2V0Jykge1xuICAgICAgICAgICAgaWYgKG1ldGFUeXBlcy5oYXMobWV0YXR5cGUpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaC5wcm9wc1ttZXRhdHlwZV1cbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpXG4gICAgICAgICAgICBpZiAoKG1ldGF0eXBlICE9PSAnbmFtZScgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhdGVnb3JpZXMuYWRkKGNhdGVnb3J5KVxuICAgICAgICAgICAgICBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gPSBjYXRlZ29yaWVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVW5pcXVlXG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGhlYWRFbGVtZW50cyBMaXN0IG9mIG11bHRpcGxlIDxIZWFkPiBpbnN0YW5jZXNcbiAqL1xuZnVuY3Rpb24gcmVkdWNlQ29tcG9uZW50cyhcbiAgaGVhZEVsZW1lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIHByb3BzOiBXaXRoSW5BbXBNb2RlXG4pIHtcbiAgcmV0dXJuIGhlYWRFbGVtZW50c1xuICAgIC5yZWR1Y2UoXG4gICAgICAobGlzdDogUmVhY3QuUmVhY3RDaGlsZFtdLCBoZWFkRWxlbWVudDogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4pID0+IHtcbiAgICAgICAgY29uc3QgaGVhZEVsZW1lbnRDaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoXG4gICAgICAgICAgaGVhZEVsZW1lbnQucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gbGlzdC5jb25jYXQoaGVhZEVsZW1lbnRDaGlsZHJlbilcbiAgICAgIH0sXG4gICAgICBbXVxuICAgIClcbiAgICAucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKVxuICAgIC5yZXZlcnNlKClcbiAgICAuY29uY2F0KGRlZmF1bHRIZWFkKHByb3BzLmluQW1wTW9kZSkpXG4gICAgLmZpbHRlcih1bmlxdWUoKSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLm1hcCgoYzogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4sIGk6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYy5rZXkgfHwgaVxuICAgICAgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JWkVfRk9OVFMgJiZcbiAgICAgICAgIXByb3BzLmluQW1wTW9kZVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjLnR5cGUgPT09ICdsaW5rJyAmJlxuICAgICAgICAgIGMucHJvcHNbJ2hyZWYnXSAmJlxuICAgICAgICAgIC8vIFRPRE8ocHJhdGVla2JoQCk6IFJlcGxhY2UgdGhpcyB3aXRoIGNvbnN0IGZyb20gYGNvbnN0YW50c2Agd2hlbiB0aGUgdHJlZSBzaGFraW5nIHdvcmtzLlxuICAgICAgICAgIFsnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MnXS5zb21lKCh1cmwpID0+XG4gICAgICAgICAgICBjLnByb3BzWydocmVmJ10uc3RhcnRzV2l0aCh1cmwpXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHsgLi4uKGMucHJvcHMgfHwge30pIH1cbiAgICAgICAgICBuZXdQcm9wc1snZGF0YS1ocmVmJ10gPSBuZXdQcm9wc1snaHJlZiddXG4gICAgICAgICAgbmV3UHJvcHNbJ2hyZWYnXSA9IHVuZGVmaW5lZFxuICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoYywgbmV3UHJvcHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoYywgeyBrZXkgfSlcbiAgICB9KVxufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGluamVjdHMgZWxlbWVudHMgdG8gYDxoZWFkPmAgb2YgeW91ciBwYWdlLlxuICogVG8gYXZvaWQgZHVwbGljYXRlZCBgdGFnc2AgaW4gYDxoZWFkPmAgeW91IGNhbiB1c2UgdGhlIGBrZXlgIHByb3BlcnR5LCB3aGljaCB3aWxsIG1ha2Ugc3VyZSBldmVyeSB0YWcgaXMgb25seSByZW5kZXJlZCBvbmNlLlxuICovXG5mdW5jdGlvbiBIZWFkKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgYW1wU3RhdGUgPSB1c2VDb250ZXh0KEFtcFN0YXRlQ29udGV4dClcbiAgY29uc3QgaGVhZE1hbmFnZXIgPSB1c2VDb250ZXh0KEhlYWRNYW5hZ2VyQ29udGV4dClcbiAgcmV0dXJuIChcbiAgICA8RWZmZWN0XG4gICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZT17cmVkdWNlQ29tcG9uZW50c31cbiAgICAgIGhlYWRNYW5hZ2VyPXtoZWFkTWFuYWdlcn1cbiAgICAgIGluQW1wTW9kZT17aXNJbkFtcE1vZGUoYW1wU3RhdGUpfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0VmZmVjdD5cbiAgKVxufVxuXG4vLyBUT0RPOiBSZW1vdmUgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuSGVhZC5yZXdpbmQgPSAoKSA9PiB7fVxuXG5leHBvcnQgZGVmYXVsdCBIZWFkXG4iLCJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4pOiB7XG4gIGRldGVjdGVkTG9jYWxlPzogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbn0ge1xuICBsZXQgZGV0ZWN0ZWRMb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAvLyBmaXJzdCBpdGVtIHdpbGwgYmUgZW1wdHkgc3RyaW5nIGZyb20gc3BsaXR0aW5nIGF0IGZpcnN0IGNoYXJcbiAgY29uc3QgcGF0aG5hbWVQYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KCcvJylcblxuICA7KGxvY2FsZXMgfHwgW10pLnNvbWUoKGxvY2FsZSkgPT4ge1xuICAgIGlmIChwYXRobmFtZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgPT09IGxvY2FsZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZVxuICAgICAgcGF0aG5hbWVQYXJ0cy5zcGxpY2UoMSwgMSlcbiAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWVQYXJ0cy5qb2luKCcvJykgfHwgJy8nXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIGRldGVjdGVkTG9jYWxlLFxuICB9XG59XG4iLCIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSBKYXNvbiBNaWxsZXIgKGh0dHBzOi8vamFzb25mb3JtYXQuY29tLylcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvbWl0dC9ibG9iL3YxLjEuMy9zcmMvaW5kZXguanNcbi8vIEl0J3MgYmVlbiBlZGl0ZWQgZm9yIHRoZSBuZWVkcyBvZiB0aGlzIHNjcmlwdFxuLy8gU2VlIHRoZSBMSUNFTlNFIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGVcblxudHlwZSBIYW5kbGVyID0gKC4uLmV2dHM6IGFueVtdKSA9PiB2b2lkXG5cbmV4cG9ydCB0eXBlIE1pdHRFbWl0dGVyID0ge1xuICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSk6IHZvaWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl0dCgpOiBNaXR0RW1pdHRlciB7XG4gIGNvbnN0IGFsbDogeyBbczogc3RyaW5nXTogSGFuZGxlcltdIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgcmV0dXJuIHtcbiAgICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIDsoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcilcbiAgICB9LFxuXG4gICAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICBhbGxbdHlwZV0uc3BsaWNlKGFsbFt0eXBlXS5pbmRleE9mKGhhbmRsZXIpID4+PiAwLCAxKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIDsoYWxsW3R5cGVdIHx8IFtdKS5zbGljZSgpLm1hcCgoaGFuZGxlcjogSGFuZGxlcikgPT4ge1xuICAgICAgICBoYW5kbGVyKC4uLmV2dHMpXG4gICAgICB9KVxuICAgIH0sXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5cbmV4cG9ydCBjb25zdCBSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOZXh0Um91dGVyPihudWxsIGFzIGFueSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdSb3V0ZXJDb250ZXh0J1xufVxuIiwiLyogZ2xvYmFsIF9fTkVYVF9EQVRBX18gKi9cbi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbiAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBHb29kUGFnZUNhY2hlLCBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQge1xuICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0LFxuICBpc0Fzc2V0RXJyb3IsXG4gIG1hcmtBc3NldEVycm9yLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSBmcm9tICcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0TG9jYXRpb25PcmlnaW4sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbiAgTkVYVF9EQVRBLFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vdXRpbHMvcXVlcnlzdHJpbmcnXG5pbXBvcnQgcmVzb2x2ZVJld3JpdGVzIGZyb20gJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qIHByb2QgKi9cbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgfVxufVxuXG5pbnRlcmZhY2UgUm91dGVQcm9wZXJ0aWVzIHtcbiAgc2hhbGxvdzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICBzY3JvbGw/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9XG4gIHwgbnVsbFxuICB8IHsgX19OOiBmYWxzZSB9XG4gIHwgKHsgX19OOiB0cnVlOyBpZHg6IG51bWJlciB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxubGV0IGRldGVjdERvbWFpbkxvY2FsZTogdHlwZW9mIGltcG9ydCgnLi4vaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZVxuXG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICBkZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJylcbiAgICAuZGV0ZWN0RG9tYWluTG9jYWxlXG59XG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgY2FuY2VsbGVkOiB0cnVlLFxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKSB7XG4gIHJldHVybiBwcmVmaXggJiYgcGF0aC5zdGFydHNXaXRoKCcvJylcbiAgICA/IHBhdGggPT09ICcvJ1xuICAgICAgPyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChwcmVmaXgpXG4gICAgICA6IGAke3ByZWZpeH0ke3BhdGhOb1F1ZXJ5SGFzaChwYXRoKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRofWBcbiAgICA6IHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgbG9jYWxlcz86IHN0cmluZ1tdLFxuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgbG9jYWxlID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGVcblxuICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbG9jYWxlKVxuXG4gICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICByZXR1cm4gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke1xuICAgICAgICBiYXNlUGF0aCB8fCAnJ1xuICAgICAgfSR7bG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bG9jYWxlfWB9JHtwYXRofWBcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIGxvY2FsZSAmJlxuICAgICAgbG9jYWxlICE9PSBkZWZhdWx0TG9jYWxlICYmXG4gICAgICAhcGF0aC5zdGFydHNXaXRoKCcvJyArIGxvY2FsZSArICcvJykgJiZcbiAgICAgIHBhdGggIT09ICcvJyArIGxvY2FsZVxuICAgICAgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSlcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxMb2NhbGUocGF0aDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmXG4gICAgICAocGF0aC5zdGFydHNXaXRoKCcvJyArIGxvY2FsZSArICcvJykgfHwgcGF0aCA9PT0gJy8nICsgbG9jYWxlKVxuICAgICAgPyBwYXRoLnN1YnN0cihsb2NhbGUubGVuZ3RoICsgMSkgfHwgJy8nXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5mdW5jdGlvbiBwYXRoTm9RdWVyeUhhc2gocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKVxuICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKVxuXG4gIGlmIChxdWVyeUluZGV4ID4gLTEgfHwgaGFzaEluZGV4ID4gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleClcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHBhdGggPSBwYXRoTm9RdWVyeUhhc2gocGF0aClcbiAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKVxuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YFxuICByZXR1cm4gcGF0aFxufVxuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpKSByZXR1cm4gdHJ1ZVxuICB0cnkge1xuICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKVxuICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmIGhhc0Jhc2VQYXRoKHJlc29sdmVkLnBhdGhuYW1lKVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxudHlwZSBVcmwgPSBVcmxPYmplY3QgfCBzdHJpbmdcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlQXMoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGFzUGF0aG5hbWU6IHN0cmluZyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pIHtcbiAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJydcblxuICBjb25zdCBkeW5hbWljUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICBjb25zdCBkeW5hbWljR3JvdXBzID0gZHluYW1pY1JlZ2V4Lmdyb3Vwc1xuICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9XG4gICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/IGdldFJvdXRlTWF0Y2hlcihkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogJycpIHx8XG4gICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5XG5cbiAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZVxuICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKVxuXG4gIGlmIChcbiAgICAhcGFyYW1zLmV2ZXJ5KChwYXJhbSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dIHx8ICcnXG4gICAgICBjb25zdCB7IHJlcGVhdCwgb3B0aW9uYWwgfSA9IGR5bmFtaWNHcm91cHNbcGFyYW1dXG5cbiAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuICAgICAgbGV0IHJlcGxhY2VkID0gYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYFxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWBcbiAgICAgIH1cbiAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKG9wdGlvbmFsIHx8IHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzKSAmJlxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID1cbiAgICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSEucmVwbGFjZShcbiAgICAgICAgICAgIHJlcGxhY2VkLFxuICAgICAgICAgICAgcmVwZWF0XG4gICAgICAgICAgICAgID8gKHZhbHVlIGFzIHN0cmluZ1tdKVxuICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAgICAgICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAoc2VnbWVudCkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHNlZ21lbnQpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAuam9pbignLycpXG4gICAgICAgICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlIGFzIHN0cmluZylcbiAgICAgICAgICApIHx8ICcvJylcbiAgICAgIClcbiAgICB9KVxuICApIHtcbiAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG5cbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZSxcbiAgfVxufVxuXG5mdW5jdGlvbiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnk6IFBhcnNlZFVybFF1ZXJ5LCBwYXJhbXM6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IGZpbHRlcmVkUXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cblxuICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFwYXJhbXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgZmlsdGVyZWRRdWVyeVtrZXldID0gcXVlcnlba2V5XVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGZpbHRlcmVkUXVlcnlcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIGdpdmVuIGh5cGVybGluayB3aXRoIGEgY2VydGFpbiByb3V0ZXIgc3RhdGUgKGJhc2VQYXRoIG5vdCBpbmNsdWRlZCkuXG4gKiBQcmVzZXJ2ZXMgYWJzb2x1dGUgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVIcmVmKFxuICBjdXJyZW50UGF0aDogc3RyaW5nLFxuICBocmVmOiBVcmwsXG4gIHJlc29sdmVBcz86IGJvb2xlYW5cbik6IHN0cmluZyB7XG4gIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gIGNvbnN0IGJhc2UgPSBuZXcgVVJMKGN1cnJlbnRQYXRoLCAnaHR0cDovL24nKVxuICBjb25zdCB1cmxBc1N0cmluZyA9XG4gICAgdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKGhyZWYpXG4gIC8vIFJldHVybiBiZWNhdXNlIGl0IGNhbm5vdCBiZSByb3V0ZWQgYnkgdGhlIE5leHQuanMgcm91dGVyXG4gIGlmICghaXNMb2NhbFVSTCh1cmxBc1N0cmluZykpIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpXG4gICAgZmluYWxVcmwucGF0aG5hbWUgPSBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSlcbiAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJ1xuXG4gICAgaWYgKFxuICAgICAgaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmXG4gICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiZcbiAgICAgIHJlc29sdmVBc1xuICAgICkge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcylcblxuICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gaW50ZXJwb2xhdGVBcyhcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBxdWVyeVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGludGVycG9sYXRlZEFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID1cbiAgICAgIGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW5cbiAgICAgICAgPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpXG4gICAgICAgIDogZmluYWxVcmwuaHJlZlxuXG4gICAgcmV0dXJuIChyZXNvbHZlQXNcbiAgICAgID8gW3Jlc29sdmVkSHJlZiwgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXVxuICAgICAgOiByZXNvbHZlZEhyZWYpIGFzIHN0cmluZ1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcblxuICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmxcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlcjogTmV4dFJvdXRlciwgdXJsOiBVcmwsIGFzPzogVXJsKSB7XG4gIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIHVybCwgdHJ1ZSlcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICBjb25zdCBocmVmSGFkT3JpZ2luID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKVxuICBjb25zdCBhc0hhZE9yaWdpbiA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbilcblxuICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpXG4gIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzXG5cbiAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKVxuICBjb25zdCBwcmVwYXJlZEFzID0gYXNcbiAgICA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgYXMpKVxuICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcblxuICByZXR1cm4ge1xuICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgYXM6IGFzSGFkT3JpZ2luID8gcHJlcGFyZWRBcyA6IGFkZEJhc2VQYXRoKHByZXBhcmVkQXMpLFxuICB9XG59XG5cbmV4cG9ydCB0eXBlIEJhc2VSb3V0ZXIgPSB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbn1cblxuZXhwb3J0IHR5cGUgTmV4dFJvdXRlciA9IEJhc2VSb3V0ZXIgJlxuICBQaWNrPFxuICAgIFJvdXRlcixcbiAgICB8ICdwdXNoJ1xuICAgIHwgJ3JlcGxhY2UnXG4gICAgfCAncmVsb2FkJ1xuICAgIHwgJ2JhY2snXG4gICAgfCAncHJlZmV0Y2gnXG4gICAgfCAnYmVmb3JlUG9wU3RhdGUnXG4gICAgfCAnZXZlbnRzJ1xuICAgIHwgJ2lzRmFsbGJhY2snXG4gICAgfCAnaXNSZWFkeSdcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxufVxuXG5leHBvcnQgdHlwZSBQcml2YXRlUm91dGVJbmZvID1cbiAgfCAoT21pdDxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdzdHlsZVNoZWV0cyc+ICYgeyBpbml0aWFsOiB0cnVlIH0pXG4gIHwgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvXG5cbmV4cG9ydCB0eXBlIENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxuICBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgZXJyPzogRXJyb3JcbiAgZXJyb3I/OiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHMgPSBQaWNrPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoXG4gIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gIEFwcDogQXBwQ29tcG9uZW50LFxuICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuKSA9PiBQcm9taXNlPHZvaWQ+XG5cbnR5cGUgQmVmb3JlUG9wU3RhdGVDYWxsYmFjayA9IChzdGF0ZTogTmV4dEhpc3RvcnlTdGF0ZSkgPT4gYm9vbGVhblxuXG50eXBlIENvbXBvbmVudExvYWRDYW5jZWwgPSAoKCkgPT4gdm9pZCkgfCBudWxsXG5cbnR5cGUgSGlzdG9yeU1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnIHwgJ3B1c2hTdGF0ZSdcblxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPVxuICBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiZcbiAgISEoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgdiA9ICdfX25leHQnXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZVxuICAgIH0gY2F0Y2ggKG4pIHt9XG4gIH0pKClcblxuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKCdTU0dfREFUQV9OT1RfRk9VTkQnKVxuXG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybDogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEpXG4gICAgICB9XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiByZXMuanNvbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5ub3RGb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORCB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qc29uKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZjogc3RyaW5nLCBpc1NlcnZlclJlbmRlcjogYm9vbGVhbikge1xuICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSkuY2F0Y2goKGVycjogRXJyb3IpID0+IHtcbiAgICAvLyBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhcyBjYXVzZWRcbiAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgIC8vIGxvb3AuXG5cbiAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICBtYXJrQXNzZXRFcnJvcihlcnIpXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBQcml2YXRlUm91dGVJbmZvIH1cbiAgLy8gU3RhdGljIERhdGEgQ2FjaGVcbiAgc2RjOiB7IFthc1BhdGg6IHN0cmluZ106IG9iamVjdCB9ID0ge31cbiAgc3ViOiBTdWJzY3JpcHRpb25cbiAgY2xjOiBDb21wb25lbnRMb2FkQ2FuY2VsXG4gIHBhZ2VMb2FkZXI6IGFueVxuICBfYnBzOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrIHwgdW5kZWZpbmVkXG4gIGV2ZW50czogTWl0dEVtaXR0ZXJcbiAgX3dyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmdcbiAgX3NoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuICBpc1JlYWR5OiBib29sZWFuXG5cbiAgcHJpdmF0ZSBfaWR4OiBudW1iZXIgPSAwXG5cbiAgc3RhdGljIGV2ZW50czogTWl0dEVtaXR0ZXIgPSBtaXR0KClcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGluaXRpYWxQcm9wcyxcbiAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICBBcHAsXG4gICAgICB3cmFwQXBwLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgZXJyLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGxvY2FsZXMsXG4gICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICB9OiB7XG4gICAgICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICAgICAgaW5pdGlhbFByb3BzOiBhbnlcbiAgICAgIHBhZ2VMb2FkZXI6IGFueVxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBBcHA6IEFwcENvbXBvbmVudFxuICAgICAgd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgICAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIHRoaXMucm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID1cbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydFxuXG4gICAgdGhpcy5hc1BhdGggPSBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIHRoaXMuaXNSZWFkeSA9ICEhKFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHxcbiAgICAgICghYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoKVxuICAgIClcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVxuICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlc1xuICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZVxuICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlc1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgICAgZ2V0VVJMKCksXG4gICAgICAgICAgeyBsb2NhbGUgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9yY2VkU2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCB1bmRlZmluZWRcbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGlkeCB9ID0gc3RhdGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBpZHgpXG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYhKVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0geyB4OiAwLCB5OiAwIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faWR4ID0gaWR4XG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoXG4gICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgIHVybCxcbiAgICAgIGFzLFxuICAgICAgT2JqZWN0LmFzc2lnbjx7fSwgVHJhbnNpdGlvbk9wdGlvbnMsIFRyYW5zaXRpb25PcHRpb25zPih7fSwgb3B0aW9ucywge1xuICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICB9KSxcbiAgICAgIGZvcmNlZFNjcm9sbFxuICAgIClcbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMsXG4gICAgZm9yY2VkU2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgaWYgKChvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHNjcm9sbCByZXNldCBiZWhhdmlvciB1bmxlc3MgZXhwbGljaXRseSBzcGVjaWZpZWQgdG8gYmVcbiAgICAvLyBgZmFsc2VgISBUaGlzIG1ha2VzIHRoZSBiZWhhdmlvciBiZXR3ZWVuIHVzaW5nIGBSb3V0ZXIjcHVzaGAgYW5kIGFcbiAgICAvLyBgPExpbmsgLz5gIGNvbnNpc3RlbnQuXG4gICAgb3B0aW9ucy5zY3JvbGwgPSAhIShvcHRpb25zLnNjcm9sbCA/PyB0cnVlKVxuXG4gICAgbGV0IGxvY2FsZUNoYW5nZSA9IG9wdGlvbnMubG9jYWxlICE9PSB0aGlzLmxvY2FsZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID1cbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlXG4gICAgICAgICAgPyB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICA6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gdGhpcy5sb2NhbGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzKVxuICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpXG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKFxuICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICBoYXNCYXNlUGF0aCh1cmwpID8gZGVsQmFzZVBhdGgodXJsKSA6IHVybCxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICAgICkucGF0aG5hbWVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2VcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsZXM/LmluY2x1ZGVzKHRoaXMubG9jYWxlISkpIHtcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGUpXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgKVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWROYXZpZ2F0ZSAmJlxuICAgICAgICAgIGRldGVjdGVkRG9tYWluICYmXG4gICAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9IGRlbEJhc2VQYXRoKGFzKVxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke1xuICAgICAgICAgICAgZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICAgfSR7YWRkQmFzZVBhdGgoXG4gICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBgLyR7dGhpcy5sb2NhbGV9YFxuICAgICAgICAgICAgfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJ1xuICAgICAgICAgICl9YFxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgfVxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7IHNoYWxsb3cgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpXG4gICAgfVxuXG4gICAgYXMgPSBhZGRCYXNlUGF0aChcbiAgICAgIGFkZExvY2FsZShcbiAgICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICAgIG9wdGlvbnMubG9jYWxlLFxuICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgIClcbiAgICApXG4gICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKFxuICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICB0aGlzLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSkge1xuICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG4gICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0sIG51bGwpXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgIGxldCBwYWdlczogYW55LCByZXdyaXRlczogYW55XG4gICAgdHJ5IHtcbiAgICAgIHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBwYXJzZWQgPSB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWQsIHBhZ2VzKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgPyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChkZWxCYXNlUGF0aChwYXRobmFtZSkpXG4gICAgICA6IHBhdGhuYW1lXG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIGxldCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICByZXNvbHZlZEFzID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICBhZGRCYXNlUGF0aChcbiAgICAgICAgICBhZGRMb2NhbGUoZGVsQmFzZVBhdGgocGFyc2VSZWxhdGl2ZVVybChhcykucGF0aG5hbWUpLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgKSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgKHA6IHN0cmluZykgPT4gdGhpcy5fcmVzb2x2ZUhyZWYoeyBwYXRobmFtZTogcCB9LCBwYWdlcykucGF0aG5hbWUhLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKHJlc29sdmVkQXMgIT09IGFzKSB7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbEhyZWYgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlSHJlZihcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZCwge1xuICAgICAgICAgICAgICBwYXRobmFtZTogbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICAgICAgICBoYXNCYXNlUGF0aChyZXNvbHZlZEFzKSA/IGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgICAgICAgKS5wYXRobmFtZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkucGF0aG5hbWUhXG4gICAgICAgIClcblxuICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwb3RlbnRpYWxIcmVmKSkge1xuICAgICAgICAgIHJvdXRlID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhdGhuYW1lID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArXG4gICAgICAgICAgICBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9lcnIuc2gvbmV4dC5qcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2BcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpLCB0aGlzLmxvY2FsZSlcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKVxuICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lXG5cbiAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICAgICAgY29uc3Qgcm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKVxuICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZVxuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KVxuICAgICAgICA6ICh7fSBhcyB7IHJlc3VsdDogdW5kZWZpbmVkOyBwYXJhbXM6IHVuZGVmaW5lZCB9KVxuXG4gICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgKHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKFxuICAgICAgICAgIChwYXJhbSkgPT4gIXF1ZXJ5W3BhcmFtXVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgXG4gICAgICAgICAgICAgICAgICA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGBcbiAgICAgICAgICAgICAgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAoc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGBcbiAgICAgICAgICAgICAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArXG4gICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzLyR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnXG4gICAgICAgICAgICAgICAgICA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcydcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcyEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhZGRCYXNlUGF0aChhZGRMb2NhbGUocmVzb2x2ZWRBcywgdGhpcy5sb2NhbGUpKSxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgICAgbGV0IHsgZXJyb3IsIHByb3BzLCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICBpZiAoKF9fTl9TU0cgfHwgX19OX1NTUCkgJiYgcHJvcHMpIHtcbiAgICAgICAgaWYgKChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcyAmJiAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG5cbiAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkSHJlZiwgcGFnZXMsIGZhbHNlKVxuXG4gICAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocGFyc2VkSHJlZi5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXMoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvblxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgaWYgKHByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKVxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0J1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHsgc2hhbGxvdzogZmFsc2UgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBhcHBDb21wOiBhbnkgPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50XG4gICAgICAgIDsod2luZG93IGFzIGFueSkubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICBhcHBDb21wLmdldEluaXRpYWxQcm9wcyA9PT0gYXBwQ29tcC5vcmlnR2V0SW5pdGlhbFByb3BzICYmXG4gICAgICAgICAgIShyb3V0ZUluZm8uQ29tcG9uZW50IGFzIGFueSkuZ2V0SW5pdGlhbFByb3BzXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuc2V0KFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUhLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgY2xlYW5lZEFzLFxuICAgICAgICByb3V0ZUluZm8sXG4gICAgICAgIGZvcmNlZFNjcm9sbCB8fCAob3B0aW9ucy5zY3JvbGwgPyB7IHg6IDAsIHk6IDAgfSA6IG51bGwpXG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlXG4gICAgICAgIGVsc2UgdGhyb3cgZVxuICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gdGhpcy5sb2NhbGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCBnZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3dcbiAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oXG4gICAgICAgIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgaWR4OiB0aGlzLl9pZHggPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5faWR4IDogdGhpcy5faWR4ICsgMSxcbiAgICAgICAgfSBhcyBIaXN0b3J5U3RhdGUsXG4gICAgICAgIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAnJyxcbiAgICAgICAgYXNcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICBlcnI6IEVycm9yICYgeyBjb2RlOiBhbnk7IGNhbmNlbGxlZDogYm9vbGVhbiB9LFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzLFxuICAgIGxvYWRFcnJvckZhaWw/OiBib29sZWFuXG4gICk6IFByb21pc2U8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoaXNBc3NldEVycm9yKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcywgcm91dGVQcm9wcylcblxuICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgbGV0IHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICAgICAgbGV0IHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIENvbXBvbmVudCEgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiBzdHlsZVNoZWV0cyEgPT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgOyh7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXG4gICAgICAgICAgJy9fZXJyb3InXG4gICAgICAgICkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgZXJyLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB9IGFzIGFueSlcbiAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKVxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgICAgIHJvdXRlSW5mb0VycixcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFJvdXRlSW5mbyhcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IGFueSxcbiAgICBhczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllc1xuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbXG4gICAgICAgIHJvdXRlXG4gICAgICBdXG4gICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGV4aXN0aW5nUm91dGVJbmZvICYmICdpbml0aWFsJyBpbiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgPyBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpID0+ICh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICB9KSlcblxuICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YUhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIGRlbEJhc2VQYXRoKGFzKSxcbiAgICAgICAgICBfX05fU1NHLFxuICAgICAgICAgIHRoaXMubG9jYWxlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXREYXRhPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4oKCkgPT5cbiAgICAgICAgX19OX1NTR1xuICAgICAgICAgID8gdGhpcy5fZ2V0U3RhdGljRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgPyB0aGlzLl9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKVxuICAgIH1cbiAgfVxuXG4gIHNldChcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZVxuXG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgdGhpcy5hc1BhdGggPSBhc1xuICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhLCByZXNldFNjcm9sbClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgYmVmb3JlUG9wU3RhdGUoY2I6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9icHMgPSBjYlxuICB9XG5cbiAgb25seUFIYXNoQ2hhbmdlKGFzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJylcbiAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJylcblxuICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2hcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWywgaGFzaF0gPSBhcy5zcGxpdCgnIycpXG4gICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlXG4gICAgaWYgKGhhc2ggPT09ICcnKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKGlkRWwpIHtcbiAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdXG4gICAgaWYgKG5hbWVFbCkge1xuICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICBfcmVzb2x2ZUhyZWYocGFyc2VkSHJlZjogVXJsT2JqZWN0LCBwYWdlczogc3RyaW5nW10sIGFwcGx5QmFzZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VkSHJlZlxuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgIGRlbm9ybWFsaXplUGFnZVBhdGgoYXBwbHlCYXNlUGF0aCA/IGRlbEJhc2VQYXRoKHBhdGhuYW1lISkgOiBwYXRobmFtZSEpXG4gICAgKVxuXG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICAgIHJldHVybiBwYXJzZWRIcmVmXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSEpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICBwYWdlcy5zb21lKChwYWdlKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0R5bmFtaWNSb3V0ZShwYWdlKSAmJlxuICAgICAgICAgIGdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lISlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IGFwcGx5QmFzZVBhdGggPyBhZGRCYXNlUGF0aChwYWdlKSA6IHBhZ2VcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGFyc2VkSHJlZi5wYXRobmFtZSEpXG4gICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIGFzeW5jIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIGxldCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHBhdGhuYW1lID0gbm9ybWFsaXplTG9jYWxlUGF0aCEocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWVcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuXG4gICAgICAgIGxldCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aCEoXG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgIClcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgYXNQYXRoID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuXG4gICAgcGFyc2VkID0gdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkLCBwYWdlcywgZmFsc2UpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHVybCkudGhlbigoaXNTc2c6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3NnXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKFxuICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgICAgICAgICAgICAgIDogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgIF0pXG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxHb29kUGFnZUNhY2hlPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpXG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICB9XG5cbiAgX2dldERhdGE8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMuY2xjID0gY2FuY2VsXG4gICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKVxuICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFN0YXRpY0RhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgdGhpcy5zZGNbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW2NhY2hlS2V5XSlcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCBhcyBBcHBDb21wb25lbnQpXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBhYm9ydENvbXBvbmVudExvYWQoYXM6IHN0cmluZywgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXG4gICAgICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAgICAgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gICAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuc3ViKFxuICAgICAgZGF0YSxcbiAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQgYXMgQXBwQ29tcG9uZW50LFxuICAgICAgcmVzZXRTY3JvbGxcbiAgICApXG4gIH1cbn1cbiIsIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cbiIsIi8vIFRyYW5zbGF0ZXMgYSBsb2dpY2FsIHJvdXRlIGludG8gaXRzIHBhZ2VzIGFzc2V0IHBhdGggKHJlbGF0aXZlIGZyb20gYSBjb21tb24gcHJlZml4KVxuLy8gXCJhc3NldCBwYXRoXCIgYmVpbmcgaXRzIGphdmFzY3JpcHQgZmlsZSwgZGF0YSBmaWxlLCBwcmVyZW5kZXJlZCBodG1sLC4uLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHQ6IHN0cmluZyA9ICcnXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXRoID1cbiAgICByb3V0ZSA9PT0gJy8nXG4gICAgICA/ICcvaW5kZXgnXG4gICAgICA6IC9eXFwvaW5kZXgoXFwvfCQpLy50ZXN0KHJvdXRlKVxuICAgICAgPyBgL2luZGV4JHtyb3V0ZX1gXG4gICAgICA6IGAke3JvdXRlfWBcbiAgcmV0dXJuIHBhdGggKyBleHRcbn1cbiIsIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIiwiaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG4vKipcbiAqIFBhcnNlcyBwYXRoLXJlbGF0aXZlIHVybHMgKGUuZy4gYC9oZWxsby93b3JsZD9mb289YmFyYCkuIElmIHVybCBpc24ndCBwYXRoLXJlbGF0aXZlXG4gKiAoZS5nLiBgLi9oZWxsb2ApIHRoZW4gYXQgbGVhc3QgYmFzZSBtdXN0IGJlLlxuICogQWJzb2x1dGUgdXJscyBhcmUgcmVqZWN0ZWQgd2l0aCBvbmUgZXhjZXB0aW9uLCBpbiB0aGUgYnJvd3NlciwgYWJzb2x1dGUgdXJscyB0aGF0IGFyZSBvblxuICogdGhlIGN1cnJlbnQgb3JpZ2luIHdpbGwgYmUgcGFyc2VkIGFzIHJlbGF0aXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKSB7XG4gIGNvbnN0IGdsb2JhbEJhc2UgPSBuZXcgVVJMKFxuICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IGdldExvY2F0aW9uT3JpZ2luKClcbiAgKVxuICBjb25zdCByZXNvbHZlZEJhc2UgPSBiYXNlID8gbmV3IFVSTChiYXNlLCBnbG9iYWxCYXNlKSA6IGdsb2JhbEJhc2VcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zLCBzZWFyY2gsIGhhc2gsIGhyZWYsIG9yaWdpbiB9ID0gbmV3IFVSTChcbiAgICB1cmwsXG4gICAgcmVzb2x2ZWRCYXNlXG4gIClcbiAgaWYgKG9yaWdpbiAhPT0gZ2xvYmFsQmFzZS5vcmlnaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwsIHJvdXRlciByZWNlaXZlZCAke3VybH1gKVxuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaCxcbiAgICBocmVmOiBocmVmLnNsaWNlKGdsb2JhbEJhc2Uub3JpZ2luLmxlbmd0aCksXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbmV4cG9ydCB7IHBhdGhUb1JlZ2V4cCB9XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIHNlbnNpdGl2ZTogZmFsc2UsXG4gIGRlbGltaXRlcjogJy8nLFxufVxuXG5leHBvcnQgY29uc3QgY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIC4uLm1hdGNoZXJPcHRpb25zLFxuICBzdHJpY3Q6IHRydWUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IChjdXN0b21Sb3V0ZSA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qga2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgICBjb25zdCBtYXRjaGVyUmVnZXggPSBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKFxuICAgICAgcGF0aCxcbiAgICAgIGtleXMsXG4gICAgICBjdXN0b21Sb3V0ZSA/IGN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMgOiBtYXRjaGVyT3B0aW9uc1xuICAgIClcbiAgICBjb25zdCBtYXRjaGVyID0gcGF0aFRvUmVnZXhwLnJlZ2V4cFRvRnVuY3Rpb24obWF0Y2hlclJlZ2V4LCBrZXlzKVxuXG4gICAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyYW1zPzogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBwYXRobmFtZSA9PSBudWxsID8gZmFsc2UgOiBtYXRjaGVyKHBhdGhuYW1lKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChjdXN0b21Sb3V0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgLy8gdW5uYW1lZCBwYXJhbXMgc2hvdWxkIGJlIHJlbW92ZWQgYXMgdGhleVxuICAgICAgICAgIC8vIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIHRoZSBkZXN0aW5hdGlvblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5Lm5hbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkZWxldGUgKHJlcy5wYXJhbXMgYXMgYW55KVtrZXkubmFtZV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5yZXMucGFyYW1zIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbnR5cGUgUGFyYW1zID0geyBbcGFyYW06IHN0cmluZ106IGFueSB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlTm9uUGF0aCh2YWx1ZTogc3RyaW5nLCBwYXJhbXM6IFBhcmFtcyk6IHN0cmluZyB7XG4gIGlmICghdmFsdWUuaW5jbHVkZXMoJzonKSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1zKSkge1xuICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhgOiR7a2V5fWApKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIG5ldyBSZWdFeHAoYDoke2tleX1cXFxcKmAsICdnJyksXG4gICAgICAgICAgYDoke2tleX0tLUVTQ0FQRURfUEFSQU1fQVNURVJJU0tTYFxuICAgICAgICApXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIG5ldyBSZWdFeHAoYDoke2tleX1cXFxcP2AsICdnJyksXG4gICAgICAgICAgYDoke2tleX0tLUVTQ0FQRURfUEFSQU1fUVVFU1RJT05gXG4gICAgICAgIClcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgOiR7a2V5fVxcXFwrYCwgJ2cnKSwgYDoke2tleX0tLUVTQ0FQRURfUEFSQU1fUExVU2ApXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIG5ldyBSZWdFeHAoYDoke2tleX0oPyFcXFxcdylgLCAnZycpLFxuICAgICAgICAgIGAtLUVTQ0FQRURfUEFSQU1fQ09MT04ke2tleX1gXG4gICAgICAgIClcbiAgICB9XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZVxuICAgIC5yZXBsYWNlKC8oOnxcXCp8XFw/fFxcK3xcXCh8XFwpfFxce3xcXH0pL2csICdcXFxcJDEnKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fUExVUy9nLCAnKycpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9DT0xPTi9nLCAnOicpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9RVUVTVElPTi9nLCAnPycpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9BU1RFUklTS1MvZywgJyonKVxuXG4gIC8vIHRoZSB2YWx1ZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgZm9yd2FyZC1zbGFzaCB0byBiZSBjb21waWxlZFxuICAvLyBjb3JyZWN0bHlcbiAgcmV0dXJuIHBhdGhUb1JlZ2V4cFxuICAgIC5jb21waWxlKGAvJHt2YWx1ZX1gLCB7IHZhbGlkYXRlOiBmYWxzZSB9KShwYXJhbXMpXG4gICAgLnN1YnN0cigxKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVwYXJlRGVzdGluYXRpb24oXG4gIGRlc3RpbmF0aW9uOiBzdHJpbmcsXG4gIHBhcmFtczogUGFyYW1zLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gIGFwcGVuZFBhcmFtc1RvUXVlcnk6IGJvb2xlYW5cbikge1xuICBsZXQgcGFyc2VkRGVzdGluYXRpb246IHtcbiAgICBxdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG4gICAgcHJvdG9jb2w/OiBzdHJpbmdcbiAgICBob3N0bmFtZT86IHN0cmluZ1xuICAgIHBvcnQ/OiBzdHJpbmdcbiAgfSAmIFJldHVyblR5cGU8dHlwZW9mIHBhcnNlUmVsYXRpdmVVcmw+ID0ge30gYXMgYW55XG5cbiAgLy8gY2xvbmUgcXVlcnkgc28gd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5KVxuICBjb25zdCBoYWRMb2NhbGUgPSBxdWVyeS5fX25leHRMb2NhbGVcbiAgZGVsZXRlIHF1ZXJ5Ll9fbmV4dExvY2FsZVxuICBkZWxldGUgcXVlcnkuX19uZXh0RGVmYXVsdExvY2FsZVxuXG4gIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICBwYXJzZWREZXN0aW5hdGlvbiA9IHBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICBoYXNoLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgcHJvdG9jb2wsXG4gICAgICBzZWFyY2gsXG4gICAgICBocmVmLFxuICAgIH0gPSBuZXcgVVJMKGRlc3RpbmF0aW9uKVxuXG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgICBoYXNoLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICBob3N0bmFtZSxcbiAgICAgIHBvcnQsXG4gICAgICBzZWFyY2gsXG4gICAgICBocmVmLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlc3RRdWVyeSA9IHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5XG4gIGNvbnN0IGRlc3RQYXRoID0gYCR7cGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhfSR7XG4gICAgcGFyc2VkRGVzdGluYXRpb24uaGFzaCB8fCAnJ1xuICB9YFxuICBjb25zdCBkZXN0UGF0aFBhcmFtS2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgcGF0aFRvUmVnZXhwLnBhdGhUb1JlZ2V4cChkZXN0UGF0aCwgZGVzdFBhdGhQYXJhbUtleXMpXG5cbiAgY29uc3QgZGVzdFBhdGhQYXJhbXMgPSBkZXN0UGF0aFBhcmFtS2V5cy5tYXAoKGtleSkgPT4ga2V5Lm5hbWUpXG5cbiAgbGV0IGRlc3RpbmF0aW9uQ29tcGlsZXIgPSBwYXRoVG9SZWdleHAuY29tcGlsZShcbiAgICBkZXN0UGF0aCxcbiAgICAvLyB3ZSBkb24ndCB2YWxpZGF0ZSB3aGlsZSBjb21waWxpbmcgdGhlIGRlc3RpbmF0aW9uIHNpbmNlIHdlIHNob3VsZFxuICAgIC8vIGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgYmVmb3JlIHdlIGdvdCB0byB0aGlzIHBvaW50IGFuZCB2YWxpZGF0aW5nXG4gICAgLy8gYnJlYWtzIGNvbXBpbGluZyBkZXN0aW5hdGlvbnMgd2l0aCBuYW1lZCBwYXR0ZXJuIHBhcmFtcyBmcm9tIHRoZSBzb3VyY2VcbiAgICAvLyBlLmcuIC9zb21ldGhpbmc6aGVsbG8oLiopIC0+IC9hbm90aGVyLzpoZWxsbyBpcyBicm9rZW4gd2l0aCB2YWxpZGF0aW9uXG4gICAgLy8gc2luY2UgY29tcGlsZSB2YWxpZGF0aW9uIGlzIG1lYW50IGZvciByZXZlcnNpbmcgYW5kIG5vdCBmb3IgaW5zZXJ0aW5nXG4gICAgLy8gcGFyYW1zIGZyb20gYSBzZXBhcmF0ZSBwYXRoLXJlZ2V4IGludG8gYW5vdGhlclxuICAgIHsgdmFsaWRhdGU6IGZhbHNlIH1cbiAgKVxuICBsZXQgbmV3VXJsXG5cbiAgLy8gdXBkYXRlIGFueSBwYXJhbXMgaW4gcXVlcnkgdmFsdWVzXG4gIGZvciAoY29uc3QgW2tleSwgc3RyT3JBcnJheV0gb2YgT2JqZWN0LmVudHJpZXMoZGVzdFF1ZXJ5KSkge1xuICAgIGxldCB2YWx1ZSA9IEFycmF5LmlzQXJyYXkoc3RyT3JBcnJheSkgPyBzdHJPckFycmF5WzBdIDogc3RyT3JBcnJheVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgLy8gdGhlIHZhbHVlIG5lZWRzIHRvIHN0YXJ0IHdpdGggYSBmb3J3YXJkLXNsYXNoIHRvIGJlIGNvbXBpbGVkXG4gICAgICAvLyBjb3JyZWN0bHlcbiAgICAgIHZhbHVlID0gY29tcGlsZU5vblBhdGgodmFsdWUsIHBhcmFtcylcbiAgICB9XG4gICAgZGVzdFF1ZXJ5W2tleV0gPSB2YWx1ZVxuICB9XG5cbiAgLy8gYWRkIHBhdGggcGFyYW1zIHRvIHF1ZXJ5IGlmIGl0J3Mgbm90IGEgcmVkaXJlY3QgYW5kIG5vdFxuICAvLyBhbHJlYWR5IGRlZmluZWQgaW4gZGVzdGluYXRpb24gcXVlcnkgb3IgcGF0aFxuICBsZXQgcGFyYW1LZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKVxuXG4gIC8vIHJlbW92ZSBpbnRlcm5hbCBwYXJhbSBmb3IgaTE4blxuICBpZiAoaGFkTG9jYWxlKSB7XG4gICAgcGFyYW1LZXlzID0gcGFyYW1LZXlzLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gJ25leHRJbnRlcm5hbExvY2FsZScpXG4gIH1cblxuICBpZiAoXG4gICAgYXBwZW5kUGFyYW1zVG9RdWVyeSAmJlxuICAgICFwYXJhbUtleXMuc29tZSgoa2V5KSA9PiBkZXN0UGF0aFBhcmFtcy5pbmNsdWRlcyhrZXkpKVxuICApIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJhbUtleXMpIHtcbiAgICAgIGlmICghKGtleSBpbiBkZXN0UXVlcnkpKSB7XG4gICAgICAgIGRlc3RRdWVyeVtrZXldID0gcGFyYW1zW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIG5ld1VybCA9IGRlc3RpbmF0aW9uQ29tcGlsZXIocGFyYW1zKVxuXG4gICAgY29uc3QgW3BhdGhuYW1lLCBoYXNoXSA9IG5ld1VybC5zcGxpdCgnIycpXG4gICAgcGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggPSBgJHtoYXNoID8gJyMnIDogJyd9JHtoYXNoIHx8ICcnfWBcbiAgICBkZWxldGUgKHBhcnNlZERlc3RpbmF0aW9uIGFzIGFueSkuc2VhcmNoXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5tYXRjaCgvRXhwZWN0ZWQgLio/IHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXkvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVG8gdXNlIGEgbXVsdGktbWF0Y2ggaW4gdGhlIGRlc3RpbmF0aW9uIHlvdSBtdXN0IGFkZCBcXGAqXFxgIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmFtIG5hbWUgdG8gc2lnbmlmeSBpdCBzaG91bGQgcmVwZWF0LiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9pbnZhbGlkLW11bHRpLW1hdGNoYFxuICAgICAgKVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIFF1ZXJ5IG1lcmdlIG9yZGVyIGxvd2VzdCBwcmlvcml0eSB0byBoaWdoZXN0XG4gIC8vIDEuIGluaXRpYWwgVVJMIHF1ZXJ5IHZhbHVlc1xuICAvLyAyLiBwYXRoIHNlZ21lbnQgdmFsdWVzXG4gIC8vIDMuIGRlc3RpbmF0aW9uIHNwZWNpZmllZCBxdWVyeSB2YWx1ZXNcbiAgcGFyc2VkRGVzdGluYXRpb24ucXVlcnkgPSB7XG4gICAgLi4ucXVlcnksXG4gICAgLi4ucGFyc2VkRGVzdGluYXRpb24ucXVlcnksXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5ld1VybCxcbiAgICBwYXJzZWREZXN0aW5hdGlvbixcbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBQYXJzZWRVcmxRdWVyeSB7XG4gIGNvbnN0IHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcXVlcnlba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5W2tleV0pKSB7XG4gICAgICA7KHF1ZXJ5W2tleV0gYXMgc3RyaW5nW10pLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSBbcXVlcnlba2V5XSBhcyBzdHJpbmcsIHZhbHVlXVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW06IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnIHx8XG4gICAgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHBhcmFtKSkgfHxcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdib29sZWFuJ1xuICApIHtcbiAgICByZXR1cm4gU3RyaW5nKHBhcmFtKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zKFxuICB1cmxRdWVyeTogUGFyc2VkVXJsUXVlcnlcbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiByZXN1bHQuYXBwZW5kKGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShpdGVtKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihcbiAgdGFyZ2V0OiBVUkxTZWFyY2hQYXJhbXMsXG4gIC4uLnNlYXJjaFBhcmFtc0xpc3Q6IFVSTFNlYXJjaFBhcmFtc1tdXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcykgPT4ge1xuICAgIEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmtleXMoKSkuZm9yRWFjaCgoa2V5KSA9PiB0YXJnZXQuZGVsZXRlKGtleSkpXG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpXG4gIH0pXG4gIHJldHVybiB0YXJnZXRcbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgcGF0aE1hdGNoIGZyb20gJy4vcGF0aC1tYXRjaCdcbmltcG9ydCBwcmVwYXJlRGVzdGluYXRpb24gZnJvbSAnLi9wcmVwYXJlLWRlc3RpbmF0aW9uJ1xuaW1wb3J0IHsgUmV3cml0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9sb2FkLWN1c3RvbS1yb3V0ZXMnXG5pbXBvcnQgeyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gZnJvbSAnLi4vLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnXG5cbmNvbnN0IGN1c3RvbVJvdXRlTWF0Y2hlciA9IHBhdGhNYXRjaCh0cnVlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmV3cml0ZXMoXG4gIGFzUGF0aDogc3RyaW5nLFxuICBwYWdlczogc3RyaW5nW10sXG4gIHJld3JpdGVzOiBSZXdyaXRlW10sXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgcmVzb2x2ZUhyZWY6IChwYXRoOiBzdHJpbmcpID0+IHN0cmluZyxcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4pIHtcbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhub3JtYWxpemVMb2NhbGVQYXRoKGFzUGF0aCwgbG9jYWxlcykucGF0aG5hbWUpKSB7XG4gICAgZm9yIChjb25zdCByZXdyaXRlIG9mIHJld3JpdGVzKSB7XG4gICAgICBjb25zdCBtYXRjaGVyID0gY3VzdG9tUm91dGVNYXRjaGVyKHJld3JpdGUuc291cmNlKVxuICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hlcihhc1BhdGgpXG5cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFyZXdyaXRlLmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIHByb3hpZWQgcmV3cml0ZSB3aGljaCBpc24ndCBoYW5kbGVkIG9uIHRoZSBjbGllbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc3RSZXMgPSBwcmVwYXJlRGVzdGluYXRpb24oXG4gICAgICAgICAgcmV3cml0ZS5kZXN0aW5hdGlvbixcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICAgIGFzUGF0aCA9IGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucXVlcnkpXG5cbiAgICAgICAgY29uc3QgZnNQYXRobmFtZSA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goYXNQYXRoKSxcbiAgICAgICAgICBsb2NhbGVzXG4gICAgICAgICkucGF0aG5hbWVcblxuICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICBhc1BhdGggPSBmc1BhdGhuYW1lXG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugbm93IG1hdGNoIGEgcGFnZSBhcyB0aGlzIG1lYW5zIHdlIGFyZSBkb25lXG4gICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZSByZXdyaXRlc1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBtYXRjaCBhIGR5bmFtaWMtcm91dGUsIGlmIHNvIHdlIGJyZWFrIHRoZSByZXdyaXRlcyBjaGFpblxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSByZXNvbHZlSHJlZihmc1BhdGhuYW1lKVxuXG4gICAgICAgIGlmIChyZXNvbHZlZEhyZWYgIT09IGFzUGF0aCAmJiBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgYXNQYXRoID0gZnNQYXRobmFtZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFzUGF0aFxufVxuIiwiaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vcm91dGUtcmVnZXgnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleDogUmV0dXJuVHlwZTx0eXBlb2YgZ2V0Um91dGVSZWdleD4pIHtcbiAgY29uc3QgeyByZSwgZ3JvdXBzIH0gPSByb3V0ZVJlZ2V4XG4gIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCByb3V0ZU1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSEpXG4gICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGUgPSAocGFyYW06IHN0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSlcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgY29uc3QgZXJyOiBFcnJvciAmIHsgY29kZT86IHN0cmluZyB9ID0gbmV3IEVycm9yKFxuICAgICAgICAgICdmYWlsZWQgdG8gZGVjb2RlIHBhcmFtJ1xuICAgICAgICApXG4gICAgICAgIGVyci5jb2RlID0gJ0RFQ09ERV9GQUlMRUQnXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW10gfSA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbc2x1Z05hbWVdXG4gICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc11cbiAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoJy8nKVxuICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcCgoZW50cnkpID0+IGRlY29kZShlbnRyeSkpXG4gICAgICAgICAgOiBnLnJlcGVhdFxuICAgICAgICAgID8gW2RlY29kZShtKV1cbiAgICAgICAgICA6IGRlY29kZShtKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIEdyb3VwIHtcbiAgcG9zOiBudW1iZXJcbiAgcmVwZWF0OiBib29sZWFuXG4gIG9wdGlvbmFsOiBib29sZWFuXG59XG5cbi8vIHRoaXMgaXNuJ3QgaW1wb3J0aW5nIHRoZSBlc2NhcGUtc3RyaW5nLXJlZ2V4IG1vZHVsZVxuLy8gdG8gcmVkdWNlIGJ5dGVzXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKVxuICBpZiAob3B0aW9uYWwpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKVxuICB9XG4gIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpXG4gIGlmIChyZXBlYXQpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpXG4gIH1cbiAgcmV0dXJuIHsga2V5OiBwYXJhbSwgcmVwZWF0LCBvcHRpb25hbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KFxuICBub3JtYWxpemVkUm91dGU6IHN0cmluZ1xuKToge1xuICByZTogUmVnRXhwXG4gIG5hbWVkUmVnZXg/OiBzdHJpbmdcbiAgcm91dGVLZXlzPzogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9XG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSAobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQsIG9wdGlvbmFsIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdCA/IChvcHRpb25hbCA/ICcoPzovKC4rPykpPycgOiAnLyguKz8pJykgOiAnLyhbXi9dKz8pJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignJylcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgIGxldCByb3V0ZUtleUNoYXJMZW5ndGggPSAxXG5cbiAgICAvLyBidWlsZHMgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCkgPT4ge1xuICAgICAgbGV0IHJvdXRlS2V5ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKykge1xuICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpXG4gICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrK1xuXG4gICAgICAgIGlmIChyb3V0ZUtleUNoYXJDb2RlID4gMTIyKSB7XG4gICAgICAgICAgcm91dGVLZXlDaGFyTGVuZ3RoKytcbiAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlS2V5XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVLZXlzOiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgICAgICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgICAgICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csICcnKVxuICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgICAgICAgIC8vIHNhZmUga2V5XG4gICAgICAgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zdWJzdHIoMCwgMSkpKSkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5XG4gICAgICAgICAgcmV0dXJuIHJlcGVhdFxuICAgICAgICAgICAgPyBvcHRpb25hbFxuICAgICAgICAgICAgICA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gXG4gICAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgXG4gICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT5bXi9dKz8pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICBncm91cHMsXG4gICAgICByb3V0ZUtleXMsXG4gICAgICBuYW1lZFJlZ2V4OiBgXiR7bmFtZWRQYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGAsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICBncm91cHMsXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuXG50eXBlIFN0YXRlID0gSlNYLkVsZW1lbnRbXSB8IHVuZGVmaW5lZFxuXG50eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUPihcbiAgICBjb21wb25lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgcHJvcHM6IFRcbiAgKSA9PiBTdGF0ZVxuICBoYW5kbGVTdGF0ZUNoYW5nZT86IChzdGF0ZTogU3RhdGUpID0+IHZvaWRcbiAgaGVhZE1hbmFnZXI6IGFueVxuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50PFNpZGVFZmZlY3RQcm9wcz4ge1xuICBwcml2YXRlIF9oYXNIZWFkTWFuYWdlcjogYm9vbGVhblxuXG4gIGVtaXRDaGFuZ2UgPSAoKTogdm9pZCA9PiB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQoXG4gICAgICAgIHRoaXMucHJvcHMucmVkdWNlQ29tcG9uZW50c1RvU3RhdGUoXG4gICAgICAgICAgWy4uLnRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlc10sXG4gICAgICAgICAgdGhpcy5wcm9wc1xuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IGFueSkge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuX2hhc0hlYWRNYW5hZ2VyID1cbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIgJiYgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXG5cbiAgICBpZiAoaXNTZXJ2ZXIgJiYgdGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5hZGQodGhpcylcbiAgICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZSh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4vcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBNYW5pZmVzdEl0ZW0gfSBmcm9tICcuLi9zZXJ2ZXIvbG9hZC1jb21wb25lbnRzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IEVudiB9IGZyb20gJ0BuZXh0L2VudidcbmltcG9ydCB7IEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9zZXJ2ZXIvZ2V0LXBhZ2UtZmlsZXMnXG5pbXBvcnQgeyBEb21haW5Mb2NhbGVzIH0gZnJvbSAnLi4vc2VydmVyL2NvbmZpZydcblxuLyoqXG4gKiBUeXBlcyB1c2VkIGJ5IGJvdGggbmV4dCBhbmQgbmV4dC1zZXJ2ZXJcbiAqL1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4gPSBDb21wb25lbnRUeXBlPFA+ICYge1xuICAvKipcbiAgICogVXNlZCBmb3IgaW5pdGlhbCBwYWdlIGxvYWQgZGF0YSBwb3B1bGF0aW9uLiBEYXRhIHJldHVybmVkIGZyb20gYGdldEluaXRpYWxQcm9wc2AgaXMgc2VyaWFsaXplZCB3aGVuIHNlcnZlciByZW5kZXJlZC5cbiAgICogTWFrZSBzdXJlIHRvIHJldHVybiBwbGFpbiBgT2JqZWN0YCB3aXRob3V0IHVzaW5nIGBEYXRlYCwgYE1hcGAsIGBTZXRgLlxuICAgKiBAcGFyYW0gY3R4IENvbnRleHQgb2YgYHBhZ2VgXG4gICAqL1xuICBnZXRJbml0aWFsUHJvcHM/KGNvbnRleHQ6IEMpOiBJUCB8IFByb21pc2U8SVA+XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50VHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBEb2N1bWVudENvbnRleHQsXG4gIERvY3VtZW50SW5pdGlhbFByb3BzLFxuICBEb2N1bWVudFByb3BzXG4+ICYge1xuICByZW5kZXJEb2N1bWVudChcbiAgICBEb2N1bWVudDogRG9jdW1lbnRUeXBlLFxuICAgIHByb3BzOiBEb2N1bWVudFByb3BzXG4gICk6IFJlYWN0LlJlYWN0RWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBBcHBUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIEFwcENvbnRleHRUeXBlLFxuICBBcHBJbml0aWFsUHJvcHMsXG4gIEFwcFByb3BzVHlwZVxuPlxuXG5leHBvcnQgdHlwZSBBcHBUcmVlVHlwZSA9IENvbXBvbmVudFR5cGU8XG4gIEFwcEluaXRpYWxQcm9wcyAmIHsgW25hbWU6IHN0cmluZ106IGFueSB9XG4+XG5cbi8qKlxuICogV2ViIHZpdGFscyBwcm92aWRlZCB0byBfYXBwLnJlcG9ydFdlYlZpdGFscyBieSBDb3JlIFdlYiBWaXRhbHMgcGx1Z2luIGRldmVsb3BlZCBieSBHb29nbGUgQ2hyb21lIHRlYW0uXG4gKiBodHRwczovL25leHRqcy5vcmcvYmxvZy9uZXh0LTktNCNpbnRlZ3JhdGVkLXdlYi12aXRhbHMtcmVwb3J0aW5nXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRXZWJWaXRhbHNNZXRyaWMgPSB7XG4gIGlkOiBzdHJpbmdcbiAgbGFiZWw6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgc3RhcnRUaW1lOiBudW1iZXJcbiAgdmFsdWU6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBFbmhhbmNlcjxDPiA9IChDb21wb25lbnQ6IEMpID0+IENcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50c0VuaGFuY2VyID1cbiAgfCB7XG4gICAgICBlbmhhbmNlQXBwPzogRW5oYW5jZXI8QXBwVHlwZT5cbiAgICAgIGVuaGFuY2VDb21wb25lbnQ/OiBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cbiAgICB9XG4gIHwgRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2VSZXN1bHQgPSB7XG4gIGh0bWw6IHN0cmluZ1xuICBoZWFkPzogQXJyYXk8SlNYLkVsZW1lbnQgfCBudWxsPlxufVxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlID0gKFxuICBvcHRpb25zPzogQ29tcG9uZW50c0VuaGFuY2VyXG4pID0+IFJlbmRlclBhZ2VSZXN1bHQgfCBQcm9taXNlPFJlbmRlclBhZ2VSZXN1bHQ+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgZHluYW1pY0lkcz86IHN0cmluZ1tdXG4gIGVycj86IEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbn1cblxuLyoqXG4gKiBgTmV4dGAgY29udGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgaWYgZW5jb3VudGVyZWQgZHVyaW5nIHJlbmRlcmluZ1xuICAgKi9cbiAgZXJyPzogKEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH0pIHwgbnVsbFxuICAvKipcbiAgICogYEhUVFBgIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgcmVxPzogSW5jb21pbmdNZXNzYWdlXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgLyoqXG4gICAqIFBhdGggc2VjdGlvbiBvZiBgVVJMYC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIFF1ZXJ5IHN0cmluZyBzZWN0aW9uIG9mIGBVUkxgIHBhcnNlZCBhcyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgLyoqXG4gICAqIGBTdHJpbmdgIG9mIHRoZSBhY3R1YWwgcGF0aCBpbmNsdWRpbmcgcXVlcnkuXG4gICAqL1xuICBhc1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcj4gPSB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0PlxuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxuICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICByb3V0ZXI6IFJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzID0ge1xuICBwYWdlUHJvcHM6IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcixcbiAgUCA9IHt9XG4+ID0gQXBwSW5pdGlhbFByb3BzICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBQPlxuICByb3V0ZXI6IFJcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0ICYge1xuICByZW5kZXJQYWdlOiBSZW5kZXJQYWdlXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBSZWFjdC5SZWFjdEZyYWdtZW50XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50UHJvcHMgPSBEb2N1bWVudEluaXRpYWxQcm9wcyAmIHtcbiAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIGRhbmdlcm91c0FzUGF0aDogc3RyaW5nXG4gIGRvY0NvbXBvbmVudHNSZW5kZXJlZDoge1xuICAgIEh0bWw/OiBib29sZWFuXG4gICAgTWFpbj86IGJvb2xlYW5cbiAgICBIZWFkPzogYm9vbGVhblxuICAgIE5leHRTY3JpcHQ/OiBib29sZWFuXG4gIH1cbiAgYnVpbGRNYW5pZmVzdDogQnVpbGRNYW5pZmVzdFxuICBhbXBQYXRoOiBzdHJpbmdcbiAgaW5BbXBNb2RlOiBib29sZWFuXG4gIGh5YnJpZEFtcDogYm9vbGVhblxuICBpc0RldmVsb3BtZW50OiBib29sZWFuXG4gIGR5bmFtaWNJbXBvcnRzOiBNYW5pZmVzdEl0ZW1bXVxuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBjYW5vbmljYWxCYXNlOiBzdHJpbmdcbiAgaGVhZFRhZ3M6IGFueVtdXG4gIHVuc3RhYmxlX3J1bnRpbWVKUz86IGZhbHNlXG4gIGRldk9ubHlDYWNoZUJ1c3RlclF1ZXJ5U3RyaW5nOiBzdHJpbmdcbiAgc2NyaXB0TG9hZGVyOiB7IGRlZmVyPzogc3RyaW5nW107IGVhZ2VyPzogYW55W10gfVxuICBsb2NhbGU/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfVxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBwcmV2aWV3PzogYm9vbGVhblxuICAvKipcbiAgICogUHJldmlldyBkYXRhIHNldCBvbiB0aGUgcmVxdWVzdCwgaWYgYW55XG4gICAqICovXG4gIHByZXZpZXdEYXRhPzogYW55XG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8VCA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPFQ+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8VD5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICBjbGVhclByZXZpZXdEYXRhOiAoKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIGhhbmRsZXJcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaUhhbmRsZXI8VCA9IGFueT4gPSAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPFQ+XG4pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNPbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IFJldHVyblR5cGU8VD4+KFxuICBmbjogVFxuKTogVCB7XG4gIGxldCB1c2VkID0gZmFsc2VcbiAgbGV0IHJlc3VsdDogUmV0dXJuVHlwZTxUPlxuXG4gIHJldHVybiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZVxuICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmwpXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nXG4iLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLm5vcm1hbGl6ZVBhdGhTZXA9bm9ybWFsaXplUGF0aFNlcDtleHBvcnRzLmRlbm9ybWFsaXplUGFnZVBhdGg9ZGVub3JtYWxpemVQYWdlUGF0aDtmdW5jdGlvbiBub3JtYWxpemVQYXRoU2VwKHBhdGgpe3JldHVybiBwYXRoLnJlcGxhY2UoL1xcXFwvZywnLycpO31mdW5jdGlvbiBkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhZ2Upe3BhZ2U9bm9ybWFsaXplUGF0aFNlcChwYWdlKTtpZihwYWdlLnN0YXJ0c1dpdGgoJy9pbmRleC8nKSl7cGFnZT1wYWdlLnNsaWNlKDYpO31lbHNlIGlmKHBhZ2U9PT0nL2luZGV4Jyl7cGFnZT0nLyc7fXJldHVybiBwYWdlO31cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9uZXh0LXNlcnZlci9saWIvaGVhZCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvbGluaycpXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4xJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWxNb2R1bGUpIHtcblx0aWYgKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHR2YXIgbW9kdWxlID0gT2JqZWN0LmNyZWF0ZShvcmlnaW5hbE1vZHVsZSk7XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJpbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnO1xyXG5cclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICdAL2NvbXBvbmVudHMvQ29udGFpbmVyJztcclxuaW1wb3J0IEhvbWVCdXR0b24gZnJvbSAnQC9jb21wb25lbnRzL0hvbWVCdXR0b24nO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5vdEZvdW5kUGFnZSA9ICgpID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPENvbnRhaW5lciBob21lPlxyXG4gICAgICA8SGVhZD5cclxuICAgICAgICA8dGl0bGU+NDA0IC0gUGFnZSBOb3QgRm91bmQ8L3RpdGxlPlxyXG4gICAgICA8L0hlYWQ+XHJcbiAgICAgIDxzZWN0aW9uIGlkPVwicmVsYXRpdmUgYmxvY2tcIiBjbGFzc05hbWU9XCJoLTk2IHJlbGF0aXZlXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB3LWZ1bGwgaC1mdWxsIGJnLXRyYW5zcGFyZW50XCI+XHJcbiAgICAgICAgICA8aDFcclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMjUgcC01IHRleHQtY2VudGVyXHJcbiAgICAgICAgICAgICAgICAgIHRleHQtNHhsIG1kOnRleHQtNnhsIGxnOnRleHQtNnhsIGZvbnQtYm9sZCBcclxuICAgICAgICAgICAgICAgICAgdGV4dC1yZWQtNTAwXCJcclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgNDA0IFBhZ2UgTm90IEZvdW5kXHJcbiAgICAgICAgICA8L2gxPlxyXG4gICAgICAgICAgey8qIDwvZGl2PiAqL31cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9zZWN0aW9uPlxyXG5cclxuICAgICAgPHNlY3Rpb24+XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgaWQ9XCI0MDRcIlxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JheS05MDAgXHJcbiAgICAgICAgICAgICAgICAgIHctMTAlIHB5LTEwIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgIDxIb21lQnV0dG9uXHJcbiAgICAgICAgICAgIGNhcHRpb249XCJSZXR1cm4gSG9tZVwiXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1yLTEgbWItMSB0ZXh0LXdoaXRlIGJnLXJlZC03MDBcclxuICAgICAgICAgICAgICBob3ZlcjpiZy15ZWxsb3ctNTAwIGhvdmVyOnRleHQtYmxhY2sgXHJcbiAgICAgICAgICAgICAgZm9udC1ib2xkIHRleHQtbWQgcHgtNCBweS0yIHJvdW5kZWQgc2hhZG93IGhvdmVyOnNoYWRvdy1tZCBvdXRsaW5lLW5vbmUgZm9jdXM6b3V0bGluZS1ub25lIFxyXG4gICAgICAgICAgICAgIHRyYW5zaXRpb24gYWxsIGVhc2UgZHVyYXRpb24tNTAwXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8Y2FudmFzIGlkPVwidml6NDA0XCIgY2xhc3NOYW1lPVwidy0yLzMgaC0xLzggYmctZ3JheS05MDAgXCIgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9zZWN0aW9uPlxyXG4gICAgPC9Db250YWluZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vdEZvdW5kUGFnZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==