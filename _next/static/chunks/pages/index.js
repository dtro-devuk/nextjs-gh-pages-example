_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/index"],{

/***/ "./components/Avatar.js":
/*!******************************!*\
  !*** ./components/Avatar.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Avatar.js";

/**
 * Profile Avatar as SVG
 * @description Main Site Avatar for profile
 * @author dtro-devuk @github:dtro-devuk.io
 */
const Avatar = ({
  className
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("svg", {
    version: "1.1",
    id: "svg3169",
    className: className,
    fill: "none",
    viewBox: "0 0 540.84509 539.49298",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
      id: "title3742",
      children: "dtro-devuk avatar "
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("metadata", {
      id: "metadata3175"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("defs", {
      id: "defs3173"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("image", {
      width: "540.84509",
      height: "539.49298",
      preserveAspectRatio: "none",
      href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGPCAYAAAByP4aCAAAAAXNSR0IArs4c6QAAAARnQU1BAACx\r jwv8YQUAAAAJcEhZcwAACusAAArrAYKLDVoAAADbaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8\r P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pg0KPHg6\r eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+DQogIDxyZGY6UkRGIHhtbG5zOnJkZj0i\r aHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgLz4NCjwveDp4bXBt\r ZXRhPg0KPD94cGFja2V0IGVuZD0iciI/PiMHdFEAAP6+SURBVHhe7L0HwG1XVSe+vt77672/l04q\r CQGBAAFBHUUHRkfFjn0cy98ZHUWxjH10HNGx90HUEUZFBNIgBNJIfcl7yev1e+Xrvf/Xb6212yn3\r u997iQGS37377NX2Pvuee85eZ5ezT83S3FNLFGFpaYmeeuo5euvb30v95wZMmkUtUQ0HQ02NEYKE\r YWR5RpqAEfMRLWSJjumQTSwHmC/UGV2m06/SMZLyRrSQGVvmS49Hzt7ojL1nc/YA81lRLBB14JcW\r 52lurJ+JBZNkUFNHDZ0b+O+st2zi1DEk4wIUCMW0OBeF6UpNihWVz7MyRHbVJskYXmKyAlSd0wuA\r 5LLOYxm1Q97sUhJWmSay42qoBCUKLy7f1xJ0heoCoYhS+dLiAs2OXARhEocl2rC+gx558G9o/frV\r Jnt5IHgBw/nzA/Seb/tJjgdNUoRwIaSVePYCKeBzlXGWt0jsnC6mgbiSTuUSRGS0h8lzOqWRn0qc\r HIAww7soKR+APLLlMkYyj3jEIlPSEfpxrFcamHZpBE6vAt2Fz8EQ9BURpU2tRWHBRAIwLgRSf38+\r l8jAgok8nCAohOKNBs3XpBayiHQhoRdJ8IiFWt70k1rkBEn+UcgbZsK/JYr2H4Wi8kvImKUsh/ST\r tzAkYt64kCiyCDp/LjErQfRAsImlQcQbhKyeISWWPGEjAoNjvMBY3vi8XkERcg5kcXFJnMdi+S2A\r wB9bQdEBzsjcn+YRM6CNlyircwgnlcqdzmgvcnIg0jnaQ/MqzC8pr+kkMtojLhMQ6SWP1FZlxpqt\r bN1GCQ4OJvOiSC8q3X9kwBAF3xfxJ3e3lIeWwEHTpvsEwLgQSNm/fVJ4A08GOEFQCMUb/3sQIn0K\r kzs7CUEcEITpJ9ZkmCRPC6kBh0tBUT4vdrgUZPIoOh789erUmkPpUVYkYt64kLXzMDnbuHNDkqiS\r YXofDF5UoGNoCTU/UXm1Y7xASNSGei1Vrhdfbsg5kKoQHdsMw8gcfED+RIes3mgRx7qUdieOwhMM\r oyXCxumM9iInB+L8vIECQs9GOom8glFUpsg2KBhMZ/LVj5npBgoD02KPYCK1VkpULgcH08dp+CZg\r YRJN7pLuK4+CtAKTOyHU2K/tO90/IAYWlFU4JgiF4o3LTxjTpXBys5FgogQqTD+Racz4fCwkyuWQ\r tbeQzTMXLiHJCkJR/oWGcShOxGE5RLa5fCNVYln4rwR4MW8QyuwEauPPRbCmCWlciEgxjOQGLZXL\r CzamEMICX0Pz4+c4Xv6G7OWES3MgAndwYxTw8oc5ZGnjJSq3C1mAcIzREsVywGiJYp3SaX4GOXFS\r u0BGPMfupFVEOiEjHjF4xzKhHyFVp5yB6Yx9CKaqlMaLHcMtkMXlnAejMK0JOHIXlpU8gtlpwZT1\r MF0k9GaOSBMYTO6NgyhABenHTBwhgTfJvlyohIxtnIeEElWaKhOKP0WWlxrKP0XWFnjjQqkir+RQ\r CZFdkk8k9mRRKQ2xKFeOLFTvrksx9XBpIqGwvBHDjI4hJZK8YGNCJvRakrZIQXh54hIdSHrAFRlZ\r cvCBmIlo/ycCMc2QP9HoovQSZeUcJDLaIz65Yp0XGowWE9kIi9idoIpIJ2TEIwbvWCb0I6TqlDMw\r nbH3jKh035EBQxSRyOlNAJWkqQbFaSU4mYfZuX17tWOCUEwkxOVXXYDJvLGJPFSQfszEET6tF1go\r Q2QTp5WQYzMhW4pqwkuJovLkQ/rJaHnjQk4QhBbKENkk6U3ktUWlMHgRb5L9xlCZP3+dqcDZuxCR\r JflpORi+5YE4DbU1S7R6dQ/V1qZpXw64jBaIQ/agMx3+MUaB3kU5Owf7840OOqMliuWAkxvtEU6k\r yEBjCB3rdBIZ7eHSA5FOyIhHnMlTP0KqTjkD0xl7z4jKpzaYvkIa6PLpqoBlU5zWKz2pcIwXqImV\r IatTmEwNPRuggvAxtSN8Oi/gUIRIH6eRkJBRiPdYFgpQZOYDb17yUFQuC4UoMtQQPpGUNwgJkwot\r FMF0SToTeW12jwYv4k2yrxgqc+ekmHlk0ng2I19aqDiTcc2aXvqzP/5FdiK9Jnn54DIdiB1gD+YT\r UcyANl6irM4h/pMLbCTKyjl4udMpXZgXhIncGIm8ghGfdBk7ERovYNqznEY+QnKQDTgD0xXKIPsM\r SoYI1cSLIwYqS+PVgpQrRJI2tgctSk8qHKMCUUvg1CCCYQRvpOrERAXhY2pHuHRBU4BIn9lPvEsN\r 8V6yIYOcCW+KQt4wCl8IKCqXhaLfIyFjmkPWwB3ZzNHNMqmAQxFMlymLRRyyezF4EW/8frLglKzT\r YGYCZ28CzyqxVGEcsba2VpwI4pcbLnMMJIL8G0YLYsZoRPaHKFLa/alZuQSJyuSOd4hPDm+gsQqV\r dnIhI57jUBagzA5gGjIRqS6Qygcw7W2BoBcxbyy1QYTOhAHCBY0K06hCyRUhk9and4wKRC0hlQeY\r zBuqVKG68DG1I1yaoMkg0kX5R6SFOPc4ZJCoeROHVMlh5XDleCk/l4bMb88eG/76kEOsTEsigTcI\r BYyFLEzubB3rNUnuHAzC8ibJP4bK3LUuZgJn6wWvoAQvzBhIOPKM7IE3WqICuUD/QEWBjUSV5E6n\r tOYVyxlyhhjtCDGRjbCI847DmMQOYNrnqTrZhg0HB6a9LRD0Il6BvZJWzmDAYNql4YAHQpcWXb/t\r ckjTKhyjAlFLSOUBJivJJ3xM5QiXcdBkYHJnl5IWAhVChETFmzgkysoIvyHz4XzKAqtf8lBULh9K\r Pssj2UEmROoEsSLsSQJvEAoYDlmY3Nk51muSnDlEZGm+KtPjYmaCrG06eI5hj9Wru1+WrQ/gEn51\r fDCZDkeakaWN938akNLuD8vKJUhUJne8Q/zHR/IgBGMBUUQLXDmA2A4htdM8jWXCmxTkmbV1jIhX\r YK8k9qX7C2CuKM3Sok07rDwLq6bGPYEOWFoTaBkRUnmAN8iolXFlFbEjnH3QZGDyKN84+5BjHCJ4\r MW9cKLPNwJXYfzhtHFhUHCqiKEH1AY9jLS4sFAZ9VKs4XRoqoMicQ/a3Zz+VkWQUBRMncEINLncJ\r MREYDlmYPLMfizgESuBZ3vh8Y6hM/nNxFPMaCZimOR/WrOmgP/vj98sg+ssRK3cgNXUW4+ArqYgZ\r oxHJn+CQ0kFVYCNRJbnTKa15ZeRF+xaTVK4XidJ5O+MRg3csE/oBia1XMGCHYKwQyoh4BfaqivYl\r EKEFEwlhjJCV+20FsozJWo7ZiVhaSyr7NA7iCKK0YCKBK6OWU1RCwM5JRJqByaM8XdYaAqUhghfz\r xoUiuwihjPbhNC4wm4ZCZI2WC5cOtCIX52dpeuA0TZ0/ngTIqpqiLSgqV6VQgIxJfNyyn3L4xFEw\r cQInDDlKiInAcMjC5NE+TMIhztEgLG98nhH4Rmx2tHwA/eU8/gFcUgukJjlY2YNutEQFcgHn4dmM\r DVgRVSf3/3ssF6HRQhifOUH0AjDGyQvssvnpR0jVecAOwVg1UEpUgVeIMBJFelH5PRlE6E2UcEGj\r cEFXAbFv0DSWVohcapNLMJHA7QsfYS3AzjFZmDzKz2WrIVAaDF7EGxeyNhFCufjDti4wm4YEWWVR\r KECRmQ+8ucQABzIzdJEW5xa5HquNAusW+E64IE1xKCqXhUIUGWZDhIwqPt7xpxg+URRM7OEEIScJ\r MREYDlmYPspbozg3g7AwMDm3PKp31C8/XEILJDrY8YGP/wh38AUprSeW0jmbFcoL8/Hli+QSOTmg\r 5XB0sItoAdORnX6ENHnQCe9YNVBKVIFXiDASRXpR+T0ZROhNlIj0oi5IUwX0/8jkJ5BMLZhIoPvR\r j7AWPMEhhsmivFyWGgKlweBFvCnNWxHKwx+2ld9TmiRWZEMGRSauPHHIGKWfrHYlYYkdBcaxirTF\r 0uJQoTRFv4e/uZBDkZELESKx+2/iTzF8Agsm8nCCkIuEmAgMhxgmi/LVKM7JkGGzqOU8Xq7Pfzhc\r RrsrPmhGywEvkAv47/FsxgasiKqTy3+flYvQaEcgEkOnQNqCcng7B6Yz+QmJTZIfI2PnGBFnbUGX\r 2KsK+/FKhgi9iRLGiMp+TzBgiMLo5ZC1s7TJPgHdh98TNhI8wSGGySwfl52GQGkweBFvSvOFJPqw\r nRzjUvNYUWhQYMKbXBn8HvkTS4tDHkVWlQPGN5YWcOfrO98zKE6XDymKLPKh4JfGx8VEPuSQNcgY\r ReL4HHafPLyxBRN5OEHIQUKe4BDDZFGeGsW5lOPl/PyHwyV1YaUH1miJCuQC/js86wjEHIQ1WlBZ\r rvlk5D7zSC6RkwPZMnCQyGgBZCYX6ImkJrIRqQJ2jo90Io54gQgjUaQXle4nQITeRAljRJW1B0Th\r zSKiCmTTAroPvydsJHiCQwzmJQ8EH3HQbQgGL+JNaZ6Q2Idt5LgWmsbCOERIVLzJ7Dd8nCQNKQos\r 4jxzoThJWcAimIvz0zQ9dKpy90lB2nzgTVkoTBBQpNWQOVJJvpFhglgRB0Mkcv912E8W3tCCiTyc\r IOQAM094JobJ4vxkBgNagMVO/OU+/gFc5i/HUXaR0f7oA/zn8R8i/1dGHiInA8rl/n+P5e7PFhiB\r SAydoqQMnndg2rNsLx8h3cYAOwRjHSFin8ogQm+ihDGiegHsVaGkwGTVIjHX/P1enA75eyYG87Jv\r BNVqCJSHF/GmND9I7MM2CGKSM3PCAmWi4k20v/AxdRQCMpo4Dx/yZtWhKGE+wGlMDx6jxblp5svg\r KrXiPKpCUbKi35szUhRpkiOc5BMZJYgVGaWJ3LkQ8s7CG1owkYcKXGpRCcEbBJVEMNnSIs2MnsY0\r OBW/ghwu0YFEBz35A1wM8J/l2VQurIiK5F5pscsnI/eZR/IkLdiCMohJbMcxeMcyISQ2y9ipDGKk\r 8QqGCCVSgDBGVC+gvRcHRlTYBGUFqF2yBxG59F5qYF53oKRKOATKw4sKdAa3Z/2vWJ8zc4I4GBIx\r b6L96MdxGgIyGpc23r8LpcgaVhOqhwySlwLOY0bJUhTtf7lQgpwpb1zIKRV5TcQVHWuPWJhRGuvO\r FffJwxt6MkAFLqWohOANgkoMaIGUzL5i25f7+AdwiV1YFskBd0jpoHKEJDDWaEFW7qB5aD6RXIRG\r OwJRpixagSod7CIayOQlHzGpbOcYFXsFAwIRGkAYIyrdR4AIvYkSxoiqWnsViAqbYFARzlKsheBN\r YXqTS1CthkB5CMsbn0+kY+gv4g/rpaw5EyfIKSIxb6L89eM4DYpI4tLE+3Qhh6xBUShGspuKIRyD\r fEBGml8pCvNxssqhHFAuFzLImfDG7ygOKach4nw6EyVwwozSWP/77ZPCG1lQqUJ1LpWohOANgkoY\r TRyak7BmzYaX/fgHkDgQTBu8cGGQFpd7gtkfaQdH8x+BP9LrgzxETgaUyzUPIJJ7IWKjJQo2Yf9A\r ZBOEDKajvPQjpNsYUjungwj7cbzEIjQ2slWV34NBhN5ECWNEVb29UFBhEwyqQ22dS8xMNq3JJahW\r Q6AEnuVNYT6Q2MfykuDhBBlFIuaN5a2fSMVBEUmcfSTKI1ZmQx4+yyTob4oDS6sMxZAVBND6WMKl\r CTu0NvJBXkGcyyfOvzwUlZu/uVAMKMpCBomaN5JpHFJOg1G+IJHSIxZGCmPl99gnDzGwoKxCGZ8K\r /8PSghxt1eH/CKGWr501a/pe1uMfQPLrq3qdrRxdd9T1oCv4wDvSywCmvZmTm0AiowVKaz4Zuc/c\r YlHLRljEOHEc7eXZ/ME7lgkhsVnGzkW6D69gQGikEMZAzLa2B4MIvYkSxoiqensR68bLFCaLRUXg\r Cqipa5PEAZaXpTeOQ6AEns3IDfor+MN6LaMIIzhBJPQi3kT56sdxDpHE2UeiFLEiDil8Nj6E8stv\r qCKPy4PmifGPqYGjHKMLC9UXulDSgOewWvp2mBN5oZD9benv18DSKOSh6fIhQqLijWQUh5TjvQbO\r 79xEHk4QCY31ZbdPCm/kSQUT/D/MDp/iuFJX4itIHMjyr7ONj7I/2gz8SUZm5Mpi4+QWe7mD5qH5\r RHL35wqMyNi4k1sR2QQhg+nIRj8gxRCUIrc/ZdxJGAA7BKOdTsSVbAEQxoiqensRY5PYA6LIi0sg\r OfBdlM/L0rostDwuGIQtkDP0F/AnZBDBCTIKLwq6QGlQGCd5IwRRiliRNxAJb0LQ8objGYdqUZQ2\r CmFny4SQZNkH19i+pq5eH+jN5VMQ4swLQ7VI08XHz+1KAkwTqH0aIiQq3iBEdjGXSNzOVGhwgozC\r WCmrfVJ4A4mknfeK81gWl9j+ig++njwqc3KjvdzB6AJ5YR4qVFp4REYLkC7QXp6xEd6xTAiJjU8L\r wMbxolRKxE4OiMCpGUYgYrnlboAdgrFq5El3MgeI0JsooYyIsUnsAVFEYs0zm3MhNFOfXO0DJRCW\r NwixnOH3k2ZgcIJI6EW8sfz0E1QK45ydsSmcMA4BPqkEV0bYxGE5ZO05hEwtFJv5sFLAefh02l2V\r DelKEFUgW6Zc4E0cCo2WQ2TLebhj7rJESGG2SYjgxbyRxC4ESoNRfkem8HCCSGislM8+KURp9Cuo\r hEt0IAAfdvwBcpzjg210kRysJHDykjwg8KwRWRumNR0Q2QQhg+nIRj7exilgg2CsI0QM2ilEEFgh\r jGG5fhxgh2CsEMaIKrU2oTdRQhkRY5O1R8ikSXL1RGWoGbYuOJI3uf2Cs4/bd6J2gkgoLG8sL/2Y\r mIPCOGdnbAonzCt9MglWthLbPDK2SWZ5dWUEw0v5oN99eugkLc1joT6XF1ojuBO2ULNALb3rqbau\r wVJV/wl5IlRA1lQCb1zIKSsh2Ln/JskqQbDVEMGLeSMJXQiUBqP8Tpj1MF0sNFbKZZ8Ujg8OPKzA\r m7V9+eGSWyDyHwrig8g0WBE5uQkSGVCShxciNlpkQe5Owko2wguLUwIfFdvG4GwAEMq4kymg2E7E\r YusgAq9WwhhRFeWLYKwQyogYmzJ7L9Y8hRU59IlBBUR2jixI6/Yg5cmpnSASCssby8tpERTGORtj\r A5wgDgqfRIKVqcAuj8gmySRVFUOVy3+WySZGbOwTcQUlvwcVFSDCCFaJsbgGlRfUcVgGqXnlT7As\r QKyWwBsXEkUZgo37D5MsPIJdCAYv4o0kciFQnvOZi8AAxgWDsVIeL8cxx5RpPJOjYc2aVvqzP36f\r TON9ueMSHIj+2Yro4MuRt9jLLfZyB5cHNk7Osc/YYlE7GVCw7wIbpwIhpLdxCo7BCxvkIsrlhWCs\r I0SMvL2CkbUzBuJCWwRjhVBGxNhUtAc0TxFhk0tTJZK0aXrJ3+03UTmBCT3LG8vLizgojCvMD3DC\r VOGylGNoeYdQhEgfEnuRhBxUUf6pmKwk8KZSKEg0PzVK89OjTAPOicRQO31GJJ++cD9JKE4mIYOg\r Kv5UkZADb1xIFEUIevdf+6QJgl0CL071Oc5lGoQMx3hBQmahT6DjGZDL6MD5EsGKj0D4Qx1hB15Y\r r2SYLJGrQPNwMob7QwVGZGzcCaUyZxPRiH0+bCsfFdvG4GwAIyAqzQswnUQ+ZwPkplMDECauZAuA\r UEbE2FRh73MVVmUxMAdiaWmxsApKUJDW5S5lSVTO1oSeVUI/QaxgSvJBUDbACVKFN+dNOB5Bn4fp\r fcIgykMV+U+BuRMmgTdxKDaysHLUNbVZSmxbOOD5gzg0UH1zu4RLQ1y+TMj+Nv7mQoQgTj+FxkCs\r cvsos/VQvTsXfDIPl94FgxfxRhKozoslGCU2JhTYOmTyKAOEqCKdgTd6BYZLaoGEA2mxRPHBZdrL\r nDw+AZyMoQIQFhBFtKSLbSzyMoBpz+qpEWycgmPwwga5ipRWiMAAwhgRx5YQiNBghIhTSxN6EyWU\r ETE2y9i7HEUkhOcMxrO8ZmllUxBd7lKOJFvHeIGxKtNPomUwJ/kgmMgDAhcU3pQ34TgEfYpI7xOa\r KAdXvviTMXUCH3jjQl7J4XJQlF8aauoaqb4F3SJw/ajAcHnGoY4WZqdYW5w+Hy4HBfnFx8dEPhiC\r KP0kRg7emDe5Y14E1blzxSfzcGkToYl4I8ZB5zhfPrFR54Fl9JcW8dBgWxTg1GH7ChwuwYE46MHW\r 4+kOqgkSGaB/tsIRsItoFwVDRkE6iSIb+9MVeirkbEBHNi4KFRYggsBm7CxnJ/BqJYwRsVcwIBCh\r AYQyIsZmGft4z0JUSOOSovqpZgqi5O0SIQgc4wXG8sb2ndEyTOfy8gATB4U3tfxiXQrTxXm7kECP\r UvqJEKcLO88qOFSLorQc4rxzYXkTYse/OO+WKEGcbUOi+2qJFqZGCtO74PZVqHQhGGVCtcikS/KP\r VAZl009iADiRBN4k5SyC6uT6dOYeLp0LBmF54/NWBA46/BVFDrzWljB5+b7CNgt/FKp+Cl2gB1k3\r QoTYyx30z1WZs+HYmziZ30jsTgqVOZuIRqwGQstH1AU2wga5ipRWiMAAwhg2rM6Ov1lbv18AhDIi\r xia2BZ2xT3IDUSFN0ASqKiSmmbSOtf16loOCKdk/gokEYFxQeDPehN8e9AEm9wlMlMAdm/gTwaWR\r wJtkfwjVIJPGl8eFAhFCPmUu5BG0tdwCaepYI1KdfZVf76qmtklaKvqoVnGuIccKgTfZUKjIpawG\r kb3PKxIblE0/iQHgRLnyZKFyd455cw+XLhIKyxsxVHmgioGxD13C5JUBdMA7kKqeQhfggFvsYbJE\r Dpn+kUHGSP5Vo6M/EHEwcXoEL2QwHdkIGTaG1MZFaeUtAmMjuYgtX4EIvNoTIoadVzBEGGjTSXKR\r Ox0gwkikeQmLjQRHODBtaVSjWw2ONHpZZNICPn0oS9AyJftGMJEAjAsKb2Z5xboUpnN55sxcOdwn\r grOXwJtkXwiVkLF16a0cGTYXAoq0Kwkpurua5QFPBWb9pC3JpcUlmh0f43LFabN5rjQoijTxcSgR\r RKESIjufRyQ2KBv/25EScKJk/0VQnVyfTIq5h0sXCYXljc+3GLW19exEXt5LuMfwR2H5p9ANcmzj\r A4yDbrGX259mtAKCiBYekZMBmk5hhEROyLHPGKcXPiCxFUrjyMbJVaS0wNsARkDE8sp2xmTtQBfk\r ie2KHAcgBDZewmDa0qhGtx7CZmTVwqXl4MoRcjEuKS9g8khoWXDI6wJM7o1N5OHK4D4RnK1LGwQc\r ypCxi/brSWWToMhKi0KVKEpaEEYn5qh3zUZmHCY4pE+mz02M0szYUGH6JFSNosTZUCDljQuJIGdZ\r hsjGZ2Yig7Lx2ZBTcuBNst8sVF6NM5G1yCquBJAkftljZW7U/0mA0cI6GaB/ksIRzg4wQiIv9H+u\r yjhIZLTAZAI9lWQTdsZIbVyUVuAiCHRs52gBBI5HbLSIY0sReLUSyuhuvcLAfCKK8vL2sQHTlr9q\r dOshbEZWLaK0aQ7G2X6DwjFeoCYS8roAk+fyA7Dv+BPB2bqdeEEZIhuXJiaV9UERS7KhAorMJfCm\r KBQbJ6GtkWjd+k00W893uA0YsAVwQzfOYYpDeBZhbpxv9uZLpvO6UFQOCcXmlVGUwIWMhDcuJILE\r qgym95mYyKBsfLbklBw8wSELlZc5EwygTw+eL3AiMrKo5CvwWIED4QNe1yqxBhfF/4D+KakNx94k\r knmh/pmODpGTMTJ5BHW5jWxFVNkGkToEpxCBV3tCxLEdkLVTRpJjk7NFMJYJnxs2FexVo1sPYVOZ\r yzEcz8qo4eshm4MvYxAyUoGYSHDyoAvwRgUmvqT8ieDsXDovKIPpo/1EpA+KWBKHAhSZ+YwtFBtx\r uHSMjo7T9PQs1TW2UkvvVs7OXZ6ouNKH2eanz9Pc5HLdzWUoKjeH7G/kby4UosgQISPhDUIBw6EM\r pnf2xjoo686knIIDb/x+slC5XNfOjKGvEs4C/wGO/StOJMaKWyA17qSWg+3+FPdHONrg/hHTKxnp\r fRrA6f1G4ygP+YDVjUizNspDZLRABIF2cogdLRCBAYQxIvYKBgQiNCghomS/gAgjkf0OJVWnnIFp\r s1eNbgWOzKSR/Nw+grgitJ8dF4MlSsoImNyEQvFmRU4jgf5q/UQAI8ETHIoQ6W0f8a5cUMSSVJMg\r Z8YbhLyCQ/UoSh1+e/FnXV8n77qG5uZmhG9s66POTddTXZN75iOf49TFI9wSGWCq7JNPtTIU5FB0\r 0BEKkTVSw0TCGz3knohCEUwXl8GgbPzLI4iIN34fWajcX0evoCqszIG4IyuRO8o46LxNZAwVgAiR\r l4HUdKYAYXpnw7EjmRAybBSwj2xkK6LIBnTGRkTYv1eIwKs9IeLl7FQrJ15QMJjO2PqcsKlgrxrd\r CjwZyRiSX7IPwNkkwhR8E9DUvYVq6psypvm0kr1uwKkwgely5QAbfwwgJMDeMxyyiHSWd7wbBIXj\r 4pBBouaNC6mCQ2Wk1iWfOP8k5DJIwszMDLW1tUlwsrrGZnYi11Fzz2YWwNnD6TdEoZ5mxs7R4sJs\r klcIvMkEdz4Xf9jEwvKIrTkk+4lUOcTKYOQ53iB4Jmg4ZGHy7H4tSn9ZBFHyxudfHcIaWCusNr+E\r scIWCEJ80Pmv8cc/yILQYomCTCtbpX0UMmIw7Vn7+zP7TfehtOYbycELG8lFZLRABAYQyrgLLaDM\r zm0cmPb7BTQfYbHRBOAMTJu9anQr8GQkY0h+yT6AyCYiC7GEqdoLmocgTSBZS0jlAd4go9Zf6j4e\r ICV4gkMRTGf5xrtAUDgulXokat4k+0QoR7Aq+PjCuJAkCOESMTk5zk5kinp782+4a+ndQh0br+XW\r CJ5Gj8c9aml+aoqmhk7LygNVIy5vEnhjwZ3/+Y+aVoaz0rw0ROIcYqUaeI43CJ6JbPIwXbw/Q+kv\r EJY3Pu9yrFnTTX/2xz//yhTeCJfWAhHwX+FZR3CclUkU9Lk0Gb3/83kjH9AhEcPpASMgqtIGn0jg\r 1Z4QsRcyRODVjhCR2HkFA0IjGX5vYiYbcAamLV/V6NZDyFQm+SVlASIbjqSHVgYAE6McFmYneRul\r ZaS/KcgVJsvtH6z7RDBzsfdMFibXHbsoY+24VCpIVLxBSITFCBbpJ1eAOCyLokTVh4GBARrkcPjE\r +UJ9fXMnta3ew04E45AYDwn99LOjAzTef5j/9mUG1XNhGRQlsWOU/6i6HD4DSZ87zglihSo9xxuE\r iLCQhcnj/RiUdaWOICw2uIrgkNOga2C9MoU3xiUeCT70/mDbn+D+KEEk80KXBijWexK2GrmNomAf\r Kqpsgyg9WbI2yqcOhpHLSxmIIwWD6Yytz0cir2DADkGlaodgEDaVSW6FZTGBkMrX8J3oDJYER7dG\r BcxPj8lME8lWgqZPYTK370gtZbKPh9jA1hlHOg+TW575rB2XSgWJKmE45BG06ceXMRhoKEXWsChc\r OvraG+TJ5472juKsLdQ1t1Hn5ldRS982FsBZ4D/Wlsf85AiNHHucpof7ha8OBTvJhRLkTHnDIf9R\r dTF8YkkbsylihSo9lyc4ZGFyK2NskpYUwPHE1GnMfIsDbrheGUDP4hIcCB9qOdbxv+BoxBwkSvUh\r jcljvUsjsL8ybDQu2Eda6Ykg0GYDWTg5IDO5wAgReSEDAscjVlqSijzSZfLze8MmsQWY1q9JI50I\r gwaQvDL5x3plVeY1mOTgZ++UY3FukhZmxpjyKSMw7/abqPTX6d4Mzib3W2OYjm0kWwSTKhwXJIJY\r 7PN3IQ/VhE9uZy4UImsUh2VQlCQJvKkQxsfHqbu7m3bt2lWUOBcwJtK9/TZqaEVXCt4dEh42nBo4\r SaOnnqH52Sk2Zft88jQsi6JELhQgZ8YbDumnDFHCbNkTpArP8QbBNhaKYIYZk1A6OIqi8AqyWKED\r 4cMrBzw+6o62OKNHBahcpPdpGO6P5I37+1TvbJweMEJEXsgotwlWWRvltXxeAYGqBUqIKCkTAKGR\r TPhcxEw24AxMYz+IHO/0QkY8Q/IKxoxUr6zKUg3z3LyubXTPEFTA0hLNjJ6lxXnXUrGckv0CUhr7\r GMw0lNtrIrBM8uJ0jjSNUnEwJOKE4ZAiaOwT78SFQsQGcShBkanflwVTlH+cRT50NS9RS0sLNTY1\r 0PH+oUKbolBbV08dG66i1lU7mUN3Frq11JEszEzQ2MmnaeriCbYt/vicsr+Fv7lQiiJjhAIkJlwC\r BP8pSxUlypbNIxaqQijeIEQEVBmYPM77FawIK3Ig8j/ER1kFIKIoyLTSVTpEkSzSe5WXAbAx0gio\r zRqcEyjt5CwrtgGcDb5eyIDA8YiVVpGTA0xn8gskKM8xYIfgpNgqpWTEM6TUSd5AxIi5bJSETMBU\r lK6+qUNly2BxdpKmh07QIhZehHmSREoTRE7vy+w1EVgm5cDvyFo5LkgEXhzrEVKoNHzcfkBKyMEp\r sqEAOTPeuMCC/MfMMuFSMDI4RP39/TQxgW6TlaO5ewP17nqdDLQHR6LjI+jOGjz0EE0NnhY+RlH5\r NaQfkcbHw0Q+FCJr5EIGXsUbDumnCD6BpTE2gROqwnNuowSHLGwZ96UwtvQKlseKWyA+lj/CaB8F\r mVeX6D3JRFB5IZPOBhuVq0NSWmJHOgIitvHinI0y7u7Hw+8LcDZqFykYEBrJhM9FzGI7huUpKtsK\r hIx4huRj9gGRjZDKR1IGU0k61eLZgdpGDLYuj/mpYZq6cMgPqoePQbLUfDVkYXK2cUUJVo4LEoEX\r l+gZKg2fJHOEHGJloUHeRPJUJv1EJhyqRzZlQXD7tDB0vp9bgXO0af2GnG4lAeMivbu/TB9AlJaI\r a5EssgM5ScPHPk9zk2VdluVw1iFkjpIvQ8awEMsYJep4T/gUwYzj/SdwQlV4LmwsKLCC9eTFo7YS\r L6ZMu+BW4cVLpIL9K1ixAwH4APpjaIT/MwD+s5fRexK2EmX1EW2RVuYOEBgZ2wQhMyU2uXwcj1hp\r FTk5wHSUnz+hsRFjUwiYZlmQRjohI54hlokIjAmEVD6SMpiKyqNE0KJ7o6lzXdWzRRZmxmny3AFt\r jWA5cZdd7rc5mBy/U6PIynSRJIh44/NECAhS/fhMXUgQKwoNMmre2H7TTzCpjNgyCi5fH4rNkhBh\r 5zp28gsLtHbtWuofrTzpoVq09G0VRyLPjtSgItQxksX5SRo78wRN8M3CEgaKs2UvLCxCOVLLzFH1\r eUdGOcTKAqNEldtDBibN7tfDCVQoFG8QbCPDHPoUuvFRwOwrXYU3P8365YyVt0BwPAVGyMF34D93\r Gb0XywdEsd4RUJslOCdQ2slZlrNxdKENw+cDKCEiSesVJjSaCZ+HRJEdaLNVKbZKKRnxDMkpk7dn\r hFQ+kjKYKkvDEJWlq2/pptVr1qqiCmBG1uxoP1cyT9HE+edpbmok82yB7cv2nxTD6SJJEBXoDCrV\r jxXeCTNwwkJlRs0b22f4BHU5YisL2TJlw4qRZnDy5EmixkZ79iPVXW5oXbVdBtr1IURAB4FnRs7S\r 8JHP0TTHCYqz4cAbO575UIzUKvoHio5nDrEyY+DFvOEQPkUw43h/Hk6gQqECW4hXpvAWYwVHg4+u\r P8BGyFFXoOJSFhsOEgW90MLaX16qB5RIK/O8XkRs48VV2zgOsdIqcnKA6cjOSq0mInc6gGn9coh0\r QkY8Q/KBzIsivZDKR1IGU2VpGKLK7of5LVuwnhKa4CsAO435ySFukRyk0ROP0PjZZ2h6+BTNT7ND\r WZyL9uyosM8gKtAZVKof/5vyZgynKFDGKttX+ARVMWILDlIGhLxqeRQlqhRSDA0N8R3tGhlEf+GB\r 94s0sCPZQT0yRoKuLZ1NhJuFyfOHaPjYwzQ7PiC2yyL7UyTwxo5/GvJILaJ/Knvsc6ig9CqXo+aa\r hxnG+/JwgrK0r6ASLr0LS04chVZeQkVRJIv0QeVkjCQ9B3yj/J1MYYSIIhvYL2ejAoMSkkz25RUm\r NJqJQGbsQLMsmJsOUcYWuch+vCjSC6l8JGUwVZaGIarMfhSikIoJ7y+ob26l3r7VKl8JlpZkqu/M\r 8Gma6H+WHcqjXOk8RKMnH6dx5icHjsod7ezEAM3PTkhfvr5LOoWWUD/+9+SK4oQFykSlRPiouBg+\r EX9dSMXlyBoWhWIUWUrgjQvd9ePy8jZM333u1MVE94KEaL/ov2/t20Z9u1+fOJLFuWm5QRg9+RjN\r TY5EKcpCCXKmvEFIhHkEbfRPZgufIFZklF7sctMc8zBDt58ExSleQTlqluaekrbt2bMX6KZXv5vO\r cFyMWqpt7rZF+MKBXt55GMlEUBXrXZT89T5/wNnEFpLAEEmz6WLWGDUps4v2UcFOo0gnZMQzJKdE\r lLfPpkgFGa2lySNNt3t1DT366GNU19hAt9z8anrqyEVZwXWOWxiYgfWio6ZWzpcabgXV1NXLHXEN\r OzT2aipjWvQ4p8xWbNjW8WID2rIsR2SxvHGE6o1zlhWTliv3bGjl/+VRNqml3bv3Uj/Gtv9NoN1Y\r wOTAMZoaOM6Uu4dcooa2XmpbtZPPl5bIshqswDoxrZwuaCO70iQlCi/mlpdReahmcW6Wxs7sp6UF\r jBvFWKIN6/vokQf/htavx43YK3AQB4KXqDz11HP01re/l/rPoUlbBHYgLexAavjiFnCl568RIyRy\r Qo4jvaq8gJHqZatGQhfpVeSFjEuzkW1SFkambCFJxg4a/SrtIGTEMySXRJS3z6ZIBRmtpckjmw5s\r DdVPHKPh4VFaWJinV992Ox04g+WoFYt8kcCJzHMLA88N4G5UFuVbyZpKLxFq2MnU1jdzaKK6hiZ1\r MpDB+dQ3coxgjsij6LjlkVgVJqkun0pomDtP/WdPE83O022vfyM9dxpPOr80UEdygil3rBaouXud\r dH3hmSKPqPYtr4izqMIyMalsH7RGVTQvUHpRsTPBM1Fjp58ocCDEDmT1Kw6kAOJAzp27SG97x3fT\r k08+V/5GQr5bqm3u4UpMWyChXjUiUwF78TJ6R5S3GIwQUWSTtbdoORsVZeSejVJXsNMo0gkZeMkl\r UpfZBilTkYki0gqZM2Dk08W/v3nmFA0MDNH8/BzdcNMtdPhCPMfd7DJZoAsKg+e4iOBkEGNuvMjx\r vAh0mCuvk+b5iz512M2LA5IX8XxBOqEacTi17HDgfOoamkWGFW/x/g28wAmz19Kj8eJgbuQYjV44\r R91r11NdB57feOkxNXSSHckp++vgOOappXeDDMbnkakjjC2pOTJYxipRl9sGjVEVsy1QelFwJjjf\r x07BgeRnxL3iQIohDmT57iuGdyDoUjCZu9iyFbWwVpWFjcLbBtnKnEeBnrFsHgw1KbcLZGwDqJ1K\r I52QEc8odR6RbaIGlwgCky+vQzYN2Ehg5MLAQZqbm6OZmdnIgYS0aRYpF9iMnKESk+fVjEJhJE5y\r KEGkLTBUR8e/xzk8dm5wXhLDmcHZmTOT1pY4w1m5y5SpyhWBZ2naqB7P07CjQQunvrlDFjRMz7Ms\r Kv8iYM+mVnr44YdpfmKCbrr9djp6Pn+3e1moWJHGKDacHDgetUjgSOaopW+TjKEsjyjPYrIAyxQ4\r UZfbBo1RpaYFCpeEb4RG2YEUnR+vOJBirNCBYBqbm9VjF0t8QXm6SufBUVrxRbS3iS0kgcHp8Q0W\r RTaabZkNSGMq2GkU6ZKyQhNsFbGtbrIpUkFg8uV1yKYBGwk8qcTi4EGanp5mJzJLN93yGnr+PB4s\r i7PIZAaIqEDOUClvi9WMAoUX+dQVYNrKRoxyA69JTCpnCOeyMDvFFce0PVDJzpd50Auz41yz5Csd\r PKzZgC5dbrXAuWBdKhnLWQY1k6dl5d2mpiZqW7PXpC8xMj8Pjnhq8BiHU8zBkWCMaoFbI1uopWeT\r 2FSPKHNXUWtUgsraoC63CxqjCk3zQvzu0VNPyjpxWaxft4oefehDrziQDFbkQOrYgehFwhekXJPR\r hekrVKvSEj3HjnSEiLyQGUeX6FVgKLFJKnWl85Ux056NUpfYqSSSCxnxjFzrxyGyDVKmIpNE48nE\r gJFNAzYSlKRrnz9Lp09xJcDiW259LT3XH697lYGI8nKVmLwgWaHQi5LUJTBtRaNipZcm6ooZLYOC\r tJEIrZf5mXGanxplbklWNJ7H8zJo7URoaOsTp4Ius8aO1TIe4zBw7DFqammhbdu20cDUCzl9VyvE\r wrryMoAns0OLpI5/Uy07kq3U1LlG9JeGqJRGlpe7wi/yqmpSG1VoqkJ0x46f2S9T1rNYt7ZPHMiG\r DZfzu7/0UL0D4WZ8nRsDkYsqurKiyj+ogsyTRqSVel6vIi9kJqK9TWwhCQyRNEnHyOQjXNgYmDZW\r o5gx2iA5JKKIsX0FSdYWiLRCZg3yadLjYnHWSFBDS0MHaXSUKztW3/7aN9D+k5k7qwrpVcLbvIpR\r KDSxT1kC05QbMIqVXpqoK2ZUgkyaS8nCoEl1Oz89TrN4Tznfyc5NDctsNw++AVuzfiOd7z9HLZ09\r 1Lb2KlO81Kg0OylAHQlmbcEZ1rGDbKbW1dukFZaimtyyiNIYWZ5Lhfy9qtgmSJkqyWbi/HM0O4Z3\r sqRYvaqHPv/wh2jTpnUmeQVAdQ4ErY+mHnEiNbIWjLviOHYkE0KGjcaRXraZSjyrV5ETLqcH8jb5\r yji1iUi3MaidSiK5kIGXHCJ1kW2iBldiX+o4oghIcvRkNh3AMv3S8LHPUV1dIy0ycxu3QJ45NeVN\r itNCavJCdYHQi7K/OUalPB2KlSJNVBUzKUBkv9KkjEq/qlqgT31m7AItTQ/Q5Bjf3S6FFktTx1oZ\r xG9sXyWtFo+i3ZZUei82YheTdSRNnX3UumZb0soSJGVdacEjeybLU1fI16uKbVRqusgEzzVNXjxs\r XMDWLevp3rv+hFuOG03yCoDqHyRkJ7K88yjXy3ZZ54F8nLBIj68XMvI21TsPUJEdeP2Cka0gYyc5\r RGrPiJlsIjVTlq9C9UKJKvABUGikQH6RjZCJgYF5zi/eHaZhLiwscH01L2Mhmkw2ondQie0np3aC\r SOhFSljKDMzIFShvwHCKoPQS3mj2XmKhEiI7l0EkKoOqiz8rQryvKGDm16b1q9h5zFADO4rW3s20\r at+b5H3neMMgusWGjz9MFw/eTRefu1ce0JyUbqNMRv43VQr5ZIVhBYiPR9uqHbRq7xuptQ8V6TTN\r jJ6noUOPcqV7Uo0dkv3xBiERVkJkx+myPy3ASVKpwKuKbVRi8ijzOnHiYALq6+roV37ph7n1Uf3S\r QC8XrMCB+I3G/hjr36B/lEOql+0yeqQPFkV6fIOF/9MFSuguym28OlcWfyr5bdYOFvIbvEgMAgm9\r IwVMBYYRaYRMlAzYIxjLhH4MICShlxiYZ3mSVI2pvr6eWyA6sKtxmlatkBDBBB45gYlU7sqWsWCY\r tFjJcIqgFI43mrUnLFRCZCfpIlEJXMnjT8UEDnHeSeBNrsz5cPw47tqJVq1iB7Jmj9BodeB5i85N\r 14pDQehYf4XocCd88cBdEsbOPssV9BGZbbY8ivefC3G5TZQLFYDpvcGRzHCr5CQNHPwcTV3EwHsJ\r kvwThkMlmI2VNy52ADgXMvDivN5J3HmA1mBNfdqamuebMFw/uJ5eQYrqHYgcYIsdyYSQcjI4OD02\r SifOw//z2CgNvYgEKlMYIXonhD6iTZPezXMc2fjUYWOAnZNga7okL1BMB5bh7BBkE6mZgswLVC+U\r qAKvEGEkisoLgMilAZhneZJUjZVkoPWxwK0PPPnd1dVlUmeFhAgqC1Cth2OxL/kkWoNJXX45AycM\r CuF4g2AbC5UQ2cX7QiiAK3H8qYg4Px94k5QvG6qDzLrq7eW72MqzmLCKsqxfteNWcSg9O2+XhyXn\r Zya5gr5HHMp4/wFxKC8cin4XB/fbI5EPBnUkb6CWvvXMzUrLaeC5h9gBXmCzZY57kmfCcKgEs+E0\r cREDTJ+RBnGxHhxmmTa29qkgwpNPPWfUK4ixAgcC8CH2x9xOC/kzDP6fNJmwGb0SPsrphcVG5cs5\r F8nS5wukNkJ6G6fg2PalEpMjSvIC640YYhBI3gQJb0tsRSz5eiXD+EiE3DwrarNJwDzLk12psZKA\r sDUYyxU0cuX1yPODLLY9pIkZksCCwbM+VQZm4PLKGThhUAjHGwTbWChDZBPvByEDFaefUsT5SOBN\r Up44XD7aaZgmJydpdnaW72Rxd1u0n+JQ19DClfRO6tx4DTuUN1Pf3jtkdhemGbsWCsYldHVdl+6F\r RlomCe6YGdu2egf17XktNXevIlqaYSd3mEZO7JdyAvH/op8CWF4aEoZDGUzP9nGRAkyfkQZxXo+Z\r c1k8+OCTRr2CGCtrgdgx9ieAHHyDp72RszKmkp5RpI/z1wQGJVRdbhPUeRtI1MJ0EhnNgC63fxeJ\r PC49U4FhRBohEyXD7L1Y9uZIDonSwDzLoQqajJ2wkWxpiRoaG2VRRck/UilyAhOpPCpVBEtjUQon\r DArheKNZOh1CGUwviQKbhYrDp9AIcCofcgIOl4Oi/NKAVXfnxselRXjo3JQ/HpcSsJw4KuvOjVfT\r 6ivYoex+He8D70I/zs7kkzR09HPiUHyCgvLkw+Ug5IMHLtvX7ePW003U0NZCc1MDXJ7HaSI7PiII\r /51+ChCy5hAzZTA927qfn1qbPiMNIiUw6SG99ok+/9izsizQK0ixwjEQRI6IDrCnNdY/LpI50hE5\r fURblJxSmqFBCU3ihNAjOM5Sh41BbVRickSSmfEMSe3ZSCeR5q0S3ubKZhpRBV4hwkikJY1Yt4kA\r e4RYAypwymZkBvTbNjTwXW+iytg6lvNw5Ym0DJO4sidKJwhC4XijRXI6hDKYvjB/hYrDp9AIcCoJ\r CWNhpSjKg4P9QItKwzXbu3X8qb6R9uzZJ6lfSKA1AofSu/M2cSit8mpboovPflICurrwYFxR2VyI\r iJKwMtQ1tlHX5uupY8Nedipz7NyO0sWDn6XJAXYkpdmF/1Y/BfBF8gSHMpiebd3PS61NH0uN3btr\r E8eRnHHh4hA9+vlnjHsFDivqwpK/VQ5ydHA9rbGykcyRjhBRtXpGkr9q0oqZY0eK3picDWsQOd5H\r RjMkdTBiRHaWn1eBCgwj0giZKBmpvezLaCEs/wDj9WuaQAmEzcgYmncN1bPjmLKuE6dJbD3rUmRh\r Bt4uRioUjjdaHKdDKIPpJZGxGbhSackKDTIhK6gW2XQc7MdYlA9muRzwvnM48NaODhqYaTIp4HJ4\r IYO+Ix0OBc4Eg9zA0NGH6AI7k4kLR2Q6cRY+B94UhYgoCOXAeE7fntdT6yq81GpKWkYXDzzAjkQf\r bq2cTfjv8cnBp/UEhzKYnm3dT0mtTW945oG7qLsvP+PqL//qn4x6BQ5VOxD5E+UYR4de/jwhdJvo\r OXakI/AHVtTjG+sjGltEXgbAxkgmhCyxUYkohdLIaEb4fQAIYyTSvFXCW+SvDCPSiCrwChFGIuRl\r DKKcPcA8vhopH9sIm5ExNGeW8ffWfXjoU/V470RiC9LSW4oMWOJ2niidIAiF86JUl4fpC/N2ovAp\r hEvndxqHapBJY2WRKA5mUR2cdT5gLbKJiQnqYAeS6l4MxPnzEaytZ2eyUxzJ6iveAgN2IocrOpMi\r +Bx5EwcvDBYWUmBSACYEqCOZZkdymAYPP0Lz0/oefgmSqbEFCGcFPhm4dElZymB6fDWKYDrG5IWz\r 1NcbJp4A//TP99HQUP4p9ZczVtiF5Q43x/JnGY1tTm+kI9jAiwr0qOyCRZE+0IrUJqjzNioxOSLJ\r zHhGYasDMLvIMlE7RqwyeQqdyTf+hUp4zgB7tkFkksQGZG4/4CznSDU+Pk5zGLStr6fmZqw8yxC9\r GkWmBpOkOzeYziAczByR0acwncs3Y6YiK7+EDJxYQsxUg9ieA6eXYsTBtJXhrMpCMfZtbpXnb8YH\r BsyBvLSAM+ndga4udSZYyt05k4U5LPVf/W8DvBVv4mCbTIgdyRZanBuVl5Nh3wFmKxkFNg93xuCT\r gU/nCQ5FMB3bye4QVCEA/3M/+wPGKS4ODNPf/t3HjXsFwMoG0V3sj7QSaeVZrPeiEn1AkT7QAgiM\r 9SdRiY1KTC6R0QxJm923i1gukQgY0T7NQCkhvcLAfCTyZQS8fWQA2vIPUlDGeTJoARXz1usdWFq7\r RLX1NbSwNK+Vl+0zZ+okeQUjFQoXNhaKYDr7TVkzPR76ySkBJ072g7AcIltOK7uPg9iUAdqysEJY\r ssOHD9sDnDU0stgesisNvKk6FKWvIhjgTHq23eKdCV5ve+HZT0gLJUVRJi4UQ7S8iYNtJGBWmTqS\r rTo+gplk7MxSBHvNxNgcwrmETwKXJtp3MUzHdmLK2HrdbfQ93/1uuv5V+1RnaX/5V/9YWpWvQLGi\r MRA9yEYasXzlH+lBC4uN0itzHtAH2p8wIkttVBLJJTKaITrPgjBGIp8zg6lsGQ1a9owOMi9CPsYg\r ytkDzOvXNIESCJnKlONtsi9ANUKxTruuiKamJiKNg0lyCidQoVC80aIHeR6mc2XKmOmR0E8Ozl5C\r zCyHyJbTya5dEH0ZoM2GKlGU1AfeIDBzzfYuOf5oCSoSw5KwEhSlryLEB8hC25qd1Lfny2j1lexM\r mIcjGXj+UwXOJIsoEx+KIVrehEOkjqRnx2tkZeNJ3tfo6afEthiSyDIIbBbhLMsofRpPcChCKv+r\r P//lSFJDR46eov/7D3cZ/wqqWwurtoHqW1dTjT3V7A5yceVvMmEjvbddTg8oXcm5CBk2BrVRSSRP\r 8gEb80ZLpHTQMuWZSCpk4BWxLciEcZsIah+kGb2wqUw53mZMcwJmr9pUR/ffd5+wnT09VN97tdDF\r 6YFUKJwXFSYwmK7AREUlaRNxiU0OaofVb9HlIi+7WlzQ93zgnR/zM8ojuHeFYKEjefEVO1O8NyRa\r ml3+I/4z5dW5dVjnDW81tLcb1jfKMxiIkRY6vIQKtthXbu2nDNoXL9KxY8eotqaONm7eRFP1X1zL\r gONY4iVTkxeOUOvqHdTcvVFfwhWtG1U9lk+Eriz3cCS6uopfZFWEKO/S3ZQsGOmFqXbi+XulBXLg\r 4d8X/v0/93v0vvd/QGhg+7YNdPCZf9TZjS9z1CzOPrlU8XW2NbXiPPjssYpXL+IXx3loLNvC/AFL\r GTYGtVGJySUymqEVhjGC1C62jBhGpDHbgLytZ3O2gPEcBU1kI2TEM5TjbSpmZATCqmzP2gV68IEH\r qKa+nrq7u6mm68qC9EAqDFkUGhtMV2KS/LcxEnGxDdaFgmPAyrZYLh3v6FhcYIcxE14cnk0Z86Dj\r 6qBoL05fXIJyJFMR2DGIk2lkJ8OOpqYebzpslBdQyVLuk/108cwZmb67ZvfNluilQ2EFWiXQEpkZ\r Pcf/wTg7k53S/ZXLccU7KE6AfclzLIy2NbuppXer0NXtILIpMS9de9iLl8SBAFOzoUV0w83vosce\r P2DcEv32b/5X+v7v+wbjX76o6T91z1LF19nCgbSvkzsvd/m8qM5DokivCYzyhNsoLI94m7WRtJ4N\r ciXjEsV2gDL5cgGpbfq7/CaC2gdpRi9sKkt/s0N5OqfZ1DlOTz7+OLW0tVFvby9NNWbfKJfm4f+G\r bN4JTFdgkvz2LDJ5470aC7MTstw5At4uOD896s3KcoIcZ6jTL6HlwBU5Fo1EjMqbmwZsUEO1tfXK\r w5p5tDDwzER46VN2L5xzpqWClg7Kqi0dvNmQaXujIWQskHRxmbK5wqKzo4sW6rtkjSV5EVVrrzib\r f3sUXN8ZLGchFTyH4EhiZFIvv7sIwRity7HTT8uS+C29W6ht7Z5MXtVkbDYVTAudCYsmnr9HyNiB\r nDrVTzv3vJ1m53Ql5d6eDjp08KPU05PO1Hq5oebMibuXllvKXR2ILiT2wjkPYQxKqLkXOoEgrUid\r nGP9GoySKJbGRnkbrwLlmUgqZOBTOyD61TlbQO1TacQJWaTlbSpmRAJPJkdd0FN3jo4cOUKNjY20\r evVqmmxwd3LBUqgoj3KwrkSd37PBxHOTw1wRjNLcxEVpVaBShiqbKr6Uoatv4QoX5x7fzdeB5oof\r D6jhPJQuJ+8ICpArUk5QiFUddXT0oX8xrjq4ey5ELjS2ddHM9BQt4EVT6P5iGQJ0jnbAb2tqXyX0\r mlXdNFar9IsKK3MxypWxBo5kauAYO+lWeblU3pk4ZPKruG8HNUJLxI3DoFsLz7cA6X1uNRmaTYlp\r 1pGsapmm4098NnEgwF/85T/SN3/rTxq3RN/1HV9H//t332f8yxNVOpD1etHGzmOFzkFF5fpy5xFX\r zpEeUv0q7ZDYgI15oyWKqz6mYjNj1CxRMFLbpALVBEIGqH2QRnohI56hHG9TMSMjEDbZu0ElzbNH\r 5SG2xbk52rB5M0036cUHWFJDPgeFyQvURXvFuMP8zKgs762ti2FvhZkauESz1y9eA4vF65rxmlRu\r QTS09ZgmRln5ImRMGupqaM7WARt7Vqddtq/dKIPaWE4E61JhJg2WBXEtDTx0WT9j70u5REwvNVFz\r Tfo+7aXm1TQzhecdFrgFUsctmBm+lvgI1ixJ1xzgio8YAcepobmdmls6qKu7l6ZbV/oa2RcAhZVt\r XojfMDl4vEKrJItMHoX7STFx/nmZpYUWJBaZjMefJLnPo4rMnE2JKZxJmQMBvvXbf4r+9M8/YtwS\r PfTA/6Gbb3bjiy8/VOFA6qQFgsFFj6hyd1GoVIQxVKfX7LzQCUBEppEeUv0q7SOjGZLSs0GuZJQv\r qEjtmFyZBLFtXDa/iaC2QZrRC5vKfI6JuDhdRspI09aNP0cXL16Ud4Fs3raNJuq3uqSGfA6KNJ8Y\r bq+odPEqV3nr3sSgxM7cxbg+hWYHUd/ErYiGZmrs2iBdSfUtnd6uGJW1UF+zsUGWSD/9/H4T/tth\r uhaDyfwL+SRpbWplhzSRcxzVAFngOM3WtKiXXZxlgXk+hogsliNSxw6qtZudXSN1stNtbm2hdevW\r 0cEzg9BGKKkdXwgUZq1CtBYQ4ETgTKpDJsOSok8NnqDxcweFjlsjMSSpT1+SkYfpC8zGn7tb4iIH\r Auza+3Y6fATL1i/R9m0bpSsLNyMvR1TlQBo6QheWnMpyNttFLqzRyhiq06cVdaoPKi9kqI1KTC6R\r 0QxJ6dkgd04otiyyyzuP2A5kwrhNBLUP0kgvZMQzlONtIk5tlE32bDBJRtEweYjOncUKrdwkX7OG\r ljoxnx3I56AozgdYmp+TwW3MysFgNsYFYOZM3TVYw06ioblTXnPawBVdLd6t4M8b1pftWlCuvGpD\r HZ07d04CLlS0JAbZOdbW11Pj/CRNc8UKOdacklYG5ulz7dxM4c1/ZZjm6rmmXsdQGudW7gRizNe1\r 0zwfqzp2ktzeoOZFN4W3Mhb4Bq2zk48X/4bBwUFZ+r2Vw9joALdeJtiL4CE/BY4Sjrerrpra+lhY\r R73rd9D8wqIcA4x5NTY30amLugYWHFVlLGuwPKIsJi4c8o4kbpFUt5fIqiAB8tXZWjXUs/3VVM8t\r tSKkv3m5PZveop3rm+iJ+/6l1IFgPGT7ri/n463n14//2LfRL/3ifxb65YYVOhA+G+U6t4tdWKOV\r MVSn/zdzHmYTrBhJbaa0miVWDOYjkc9FjYUMUNsgzeiFzWp5mzFLBJ7MlF9QnrZ55gidOamroK5a\r u5YdiL6oKI+iPLgynByWPui56VG+sLQfH5UWrjGE2vpmquOWRCNXYOIs2HlgzCLAMi3O3lCs2bN6\r UabA4hmKEa5QG1taZEVhvN99aWGB6hsb2aFxZc//VTPpOl/TVL+sw6jvXEddm6/iZDU0v1RjlQwG\r 3GuI616q4+IvssxVPrU1S1LChaXl7y6bahfpzLOfpQU4V3ZsGMTv232baS8f+zZ00cjwBRq6eI6P\r yzANXjhtmnAU5f9p7KTmllZaxKB9Hd9F8zHs7uuTlsrg5PK/Iw87GJeAifNwJEektdC2ehdL0ryq\r yzmyMhI3MINHHpCJDNoagZMqzk2kXlVsE6D6PRtb6fN3/1OpAwH+4cOfpHf+++A0Xq5dWStwIG5F\r VztdOQpVmjCG6vTFg/GApQobhdnH26zNZY13mF2K2DbKo4JtkEZ6ISOeoRxvE3Fqo2xcdodsOiAV\r dCyepONH+E6Nf9j6jRtptgUXcIw0D8yGmrx4jBZmJ/nCzLQw2DHIe7s7VlNj+2p9a1vhILalSLPO\r oFhzzaYGOn36tHS74eltjFNgnv3slI5L1PMduTgNRkt7u7Q0ZtgG2TUTtzjQgujbRm09q6i2qYvm\r 8CJ4Rn3tEs0bXRnV2FTG+f33qhdiD9TV3U1NG64zzYuHpcEjVM9/xbnTh/mYaPeX+yWIF2tbqY7v\r 0hdqGqQlCsARb9iwgVpbW+nieA01NtTS7Bw6y1aK5SpkxfTwGZocPEGNrT1S4YcxjDT98rlFFky6\r 1gi6SLu23BDNbCvOSaReVWwDjB+8K3kOpAw/9b7fpp//RbXZuGENHT30sZfdsyFVOpD1HFkLRGT4\r RqepIx3BlZYXFegvxXkol8pirNx5RFKzC4jtQCaM20Rgi0RUbq8UbyOTDGNssldDNh2QCiwpddec\r pcPPP8/XyRJt3bGDxut0me84D+c05qeGhYdY7lHZYdQ2tVEj37E3tvfJ7KfK0Awzf0mEYsWOvjk6\r evgITbGTcIPbXAuqEs2A2lp5n8kcOxS0QtA9g3W91m7aSRMLrdwyULMFbk2U7KIEKzIuRiYLbsRQ\r /1P3cEusgVsxi7TviitocEkrbOAF2GNVwIulMIEBFTZajgD+U+y/oY1bitxyXBztFznQsO4KPobc\r 0uI/D11oTd1Y8PByUF4xz02NSKtWlqBfs1taaSlC2vJcHNQCkzeGjj5ICzMTUWskRnFOOG8UeX21\r DgT46nf+IH3kH3Xa7zd/41fSn/3JLwr9ckF1DqQTs7DMs/KZGKo2YQxG8InoRQX6lTkP1SvnZIwo\r D0nl2dhGN7FlYCKp2QXEdiCNydkBahukkV7IiGekeTlk0wBxuYGidEAQCBU21EWn6cjhw8zW0JVX\r Xknnpldx3Twng97Tw6dlEByANUItO4nGzrXSyqhn56HQvIphOo6KrYqlV6wnmV6MlgaWmV+EF4DT\r wB9hMcY2Ftmh9K1aRe1obbBJK7cuhjCZyaE4+wJUbZhHadKgcFRH7Qgde/4pmp+dp5aODurcdKNp\r Xjqgq2eK/+vZ8QEOeMWslhdupbWlnSv0cXUuRb+zYxfdcsutdKD/ovLF9XCVSBNjPG3i3PMyRbtt\r TdQyTszSNJV3v6StkQtHqKVns7zUqhj5XETixUqsxIEAW3e8hU6cVKf8f/7yV+g/vPvLhX45oEoH\r skHHQPhEC1WbMAYj+Ez0ogJ9mfMorqRVr5zJJDKaIek8G+TuigiqSGdSFcVygHkvin5LBdsgjfRC\r ZjW8jUwyjLHx8XPIpgOCwJK5jUfr3DE6efw4NfId+xquiM+cvUiLc1NiJaGuge9I+/iOc6N0AeBh\r vJBFmlcK03FUbFUsXd8yLOMao8Pc2nG3f/gT4DPYYeDcWJyfp14uK55b6enpoSND0fszirMtQNWG\r AYVJVFhtbpNnHpUW1MLMHF1x3XU0OJ9/r/ZLjdmxCzQ9eo5mRs7InbsDnAhCXYUf23kVKsV8BVwk\r Wh6aaHZiSN7v3sQ3LYkjcUjyDkzZLvEw6vCxR2RadvvafdTSW9aayucgEhP3NU+UTuMtwpkz52nL\r 9rfQAt8A1XMr+fiRj9OGDaH1+aWM6h1IHV/k/nLi2J9sRnAFEM6/vH5555HXq8Tp/UYg6Tyb2sRW\r EcNQRncVK1K7OAcl87ZBEumEjHhG+H0aKfJp0lQAS3LCILBkbpNgnpvzMxf20zS6hAxSSTTioa/1\r 3NJYI+s8efgs8nkFqC75mzzK021oHeEL7AxdOHeOL1C+QvkCQ1cJzgd0Sc1OTssg/5o1a6S1cWyk\r qFyVUJVRQM5cBSvMJYdzz3xSfhtxy2ntlW826aWgmpKUVaHVA92Xs+MXpUvJORPsWWbRcUsUFfre\r Navo0OGjNHjiftE77L79m+j88MWoFJnyrLB4eMYDjkRmbRU5EiDJs3TPAm2N4LkU69KqWJ68srdp\r ZQ4E+MQnH6A7v/y9Ql915U56+okPC/2ljuocSNcGvujd4BCfZv4cN0JETpjXv/TOI5KaXUBsB9KY\r nB2gtkEa6YXMangbmWQYY+MyO2TTAUEQDleQYfAbXVMzY+d1mQ2G0+7YvZuGlvAsT2aAryCfFCbn\r qNiiJB2Lm8cP08mT6IdnvhYDtY2Esez5acyeIm5h9NKGzZvowhyevI7yKckyRVVGBWYqqDJ11dix\r eo4+e+99VNPcJM/drN17h2lWiJUUrGKluBzSxAuzU3zunJJZUzFaujfIpIkmjh1aOe2FwQGaP/uw\r 8FjBF68LGBjXyQ4h50wBqyivzto6VNmRAElexXucHDhOE/LcSI2sNOwH2EvLERRjBz65oi4shw/8\r 7gfp+37wF4T+nve+iz7wv35K6C9lVOVAGrs2aheW8O4st5ijUAUKY1Dii8d5ROlzdoDaBqlREgUp\r oBxvE3HECBmX1yGbBggCS+Y2tDA3I90RM6P9sj4TAA26pHp7WulcP9/1c9vj5ltuoaMjraIX+Cw9\r kYHJOSq2KJbu44oU4y5nzp7lu1qsYFtLdRzmuVJ1wDMKW7dto9PTURdPWTE8ljVQ5MyKjvHloDi3\r NY0XaP9T+/k/mKMbX/1qOjXRaZovYJRUpDJuMsiV7/nn/a/FmEkHV+gtq7b7emBzTx09fX/xK153\r 3foVdGEsdJHprjI7LK3IY0eyix3JMg8kJvkExlFjZ7glzjdWuUUgS/e/JA4EWEkLxOH7fuDn6QO/\r 9zdC/+Wf/Xf6j9/wFUJ/qSJxIOjmyIEdSL1zIC+188ja+yiuKJjyTCRN0gKpXZoktlW7IIl0QkY8\r Q3JKRKle2bi8gHEl6SyJbLDYH/qy8WQulgxxKvx39a091LJmN9U1tdGm1iF65plnaH5ukW644QY6\r PmYvNBKEvFOYnKO8RUkaFl+5ep6ef/55GRjH9Foca1kihANmV+EZjo0bN9LmzZtp/zl3I6JROZY1\r KDDJHtdLRUkuJeL60QN0+tQZrmkXae3Vl9N99QUErmDnJgZodmJQnAkg4yTNnXxDuZ4r4/AkeEfD\r HJ16XCvdIlz3lq+nY2d0ph+gdXemBi+o0OFI0L2F5Uvqm/DAYGmtr/DqYAfKdWk192ymjvXx81Bm\r l8n2qm1t9LmPffiSHAhw59u+iz5x12eFPnHkE3zerxP6SxE5B5K/JuuoDg7Ed3+YBUfhchXGoMQX\r ivPQZMEitQEZM7EdoLZBGtv6jUAp3kYmCSNkUQWXTQMEgSsSFiREf7WbcgtA1djSTc2rtonzcDJs\r r9lE9Oijj9LE+BRdf/31dGwMM6tyOzKYnKO8RUkaE8/3P0ZTUzM0bc9rxEALBE4DzxwcQQuoJKuA\r ZQ0yJkXHcyUoSb2CTLd2jNFDn9XKAlN4V+99o9Arw+X8ikzt9yJh8tzzNDM5RPPjfJPAPOoKWW6d\r Wwl6bWo51rTX0PMPflToIlz5xnfS6fPpuaIpo9+R+UlYwgQrBaTdWsv8bq9WAu9wuXjwXj7UNeyQ\r botmGgJmbNHYgU9IfKkOBNi09U10+sx52rZ1ozwf8qWK6hxI9yZrupqWo3DpCmNQ4sVzHkHmbLwk\r mye2ZhPAdMSG8vhNBLUNUqMkClJA8klFjEhgabKp4kgRGFBYPhwPYSEsLYZxDcyfx90UHEeMeA83\r bG+g+++/nyYnpunGG2+k4+Mdpolh9hyFlA55iYDF122plYHxI0eO0bT1fcNZoNsK6OjspC1bttD6\r 9evpydOYZiXiElRUKhKT7HFcCTIpLz0jj9n+z9MQt7wwk+zqq6+m8/NrTfOFjmUq4BJgwB1382gd\r 4PAhNHatk+dHMJsqYIlG9oeVjWtW76WlC7qWVYzr7vgaOnYuLNWipYrKZiSeVxo/h4F2dGtlx0cq\r /JZEpdN9EeD88i+tUuOxZy/fgfT3X6T1m3EzUUvf9B/fQX/+p1+az4fAZ1QJu9o4CpewMAYlXkjn\r gTTFzgO0y5G32TyxlSgj96zk7Ei3CeDESK9SbE0vkdEM1fA2iBgqDaTuKzEBF5kplMEWrYyRk4/R\r 0JHPSn80nAfkaG10br6Bune/LnEeRXuYncXT3OjiCn3RAbDlgK9GEUyXhYk75k/QPffcR8/sf5am\r Jzh/zqDWHvBbzy2Nm26+mVo23UwXltbSk2fKnIfbR6EyVfvj5z7VIslEQ1a0YqQZ7F01TyMjI/Do\r ssTKSpxHmtMLE1aGohziUAysQID3c6y55u3Uvv4Kqu9YQzMj/TRy/GG68My/0iS6uyR5modzHntf\r 8w6a79lK003arfPE3f8gjmbbWh3k1r1H/7adoK2rt9Gaq98mNuf3f0y61gI0lYYMElWNOqDVO6Vb\r buLccxBGSPOYxJTzS8S6davo3k/+MVOL9Bd/9VEZYP9SRJUtkM02BoKvsxDGoMQL7TycOCKYDCUQ\r eYGN7ibwWbuIdBuD2gVJpBMyq+FtZJIwQsZlBYwrSIM7u5nh0zQ1fMrPogJq6xp1Ngy3Amvr01lU\r 2dwFIqqhK9fN0qc+9Wm5qXr1rbfS4aGoC4ujfMqyvIAaunFHE+3fv19aHguzuv6UYKmWevv6aOfO\r ndrKKcgmoIIyURX+smWQSbHyDCJUmXjgaTp39jSb11BDUxP17Xq9KS4RKylzhZvuanFpWeRTLUyP\r seM4TFMjZ4RHPdLKd/hzF3TsxKHrqrdLvK5rgU6cOEUTE2M0OzpKzQtpRb3v9rfJMiuHz5R3dcmM\r MSbLZ2tV+HWmunDgLlmWB4syxnWTewXA4MBnqKXj8iZE/P4f/C2993t/nqka+tz9f06vfvW1qvgS\r wfKD6FyB1VfxHMiL7jxM78WgsjaMF8d5xHbQJIaMVK9sXFYgmwaokYFwPEE7N5kuyY35+Jg5Us+t\r DkFuFzmB2wjgQB544AF5uBtdWEdH+EJgdSYVIy8Johpa06BrU508eVLXpcLTZniegzNu7+qivXuv\r oJOF3WMOBfnHiPa1jGUBohQrT8yoPlGR5YWD98pLo/Bcy63spI8MVTPOUy2KMqpQKa4EVWazsr0t\r 0eLcNE0PnqRxm8GFgDoFp0zX1eo8EvAOtqypobNnz9LQ0JC+o2UQy6Sn6JKHGFOgbLLq77nnS7q1\r YpT/Ep3xdZi6t95MjW09YukcyOV0YcX4sR//dfq13/gLam9rprOn7qb29mhG5Bc5as+dG5CZMwC2\r SUDro52b5XiZlD+hOXakEZfvPBA7iVcynF43Xgwqa8PQcgRe8jUWqb0mawdav0o7nZBGG9LyARFj\r 9sm+BPk0WK9o5PgjErzz4OONpRgwyNe55QZ1HpKnqoFc7l4fyRi4GDELCkuCTExMxIfC4BMGeJES\r zVNHaP9TT8l7N+A80M/f1sYtGT5fOrq7qXXjLRWcR0H+Dk7lj1XyiyrAJ9QQs1UhTlCcKGvhgkck\r lJYYHwu8tOvIsHMekcFlhSIU2V1CKBAlwVCkQihGDeHd8K3SvfUO2r7naqmM0YE6xwQq+hw4sxMX\r lmiufh21r7qCrrvuOqpds42mG7pouqWPphv15qlp/hzt2YjXEwegHO3sONZezc6FmbGz+ysUDopi\r JRwPurSGjz8sjsRZ4TmQSXRPvgD41V/+EXrX191J4xMz9KY7v8OkXxqo+8j/u/tnzp8fLPbReBsh\r luq2ud8CX6FqrGwkM9JXCd4eUL1K8npJ41mn101sFRglsE2dGCObrxKJXMFaFqk00gkZeFBp+YCI\r ETIuJwB7BGMZ0yP9NHbmaV1OwrqqsBQ67qLa11/Jd0G9fNjRVZWmA5nNXVnVZNG4MEjnzp0XurWt\r hS9S99xFgb0XKXH1xlq6cPIZef8GBsd9lxX/lu7uHtqxcxfNtu1WWQKXkWSWIlHhl+R+TQmihBEp\r oSKyxvkEpRZFCheMwOyr02dO882tXjnta3E8xOCLAPEPKggFIh8iMiNOcOHAZ6TlsUCN1NjUQNOj\r 52XcAUcLC3TmwLYjk3i/yWq66sptVF9XTyPnL9BCaxeNXLhAJ06e4gr+BHW31dJiQ9qthFcKYF2t\r C89+UvJpbO8tLpQvbarENdfUtZ5GTz0h/NIkt4bqGunr79hHvRtfmLdB/vuvewv91V//Mz319BG6\r cGGA3vH2LzPNFzdQveV8hxfwHXFTzxYd/xDeHXiNlY1kRvqqwdsDqldJXi9pPOv0uomtAqNEWgYg\r tgFpTIldkEQ6IbMa3npR0AmEzVaIwR4tAbw/enpI32LmUNfUwRXPHjn5A0I6h2zOymZkHipf13iW\r nn5qPzU1N8o02vHGggrfZ6HEtq5xOnXqjKzphPdwePBB7uQWx44dO+jMlHWpJSgrCyPaRwWrDCLL\r 6hMxyo1LNStXCGqGnpauF7RAVq9dS3WrX2WaL2XkqgpFRrxvQyN97uP/IHTjqq3Usu5qmpEnw5/j\r FvGs9G5gjESdbjm2r67lCne/tgQwUWHaZms1NVFne4fM9LswG0/HJek+m58apa6tWMzSClZSbEWq\r HD7+KM2NX6Qm/vufvv8PaOctt5rm8jE6Ok6r1r6R5ubn6E//6GfpPd/870zzxQvUv7nD6wW17EC6\r zYH4yl7jtOLm2MhQYTsdoHqV5PWSxrNOr5vYKjBKpGUAYhuQxpTYBUmkEzLWJIaMvG2idhxHcBy4\r aGbH8ER4QENrL7XxxZOsRxWlc8jmHNiM3IPl+qW1DepAGhrrZamJutU3qYmDZBHy2dQ2LKvkyqwi\r YGGJ8A6O+voGWrtuHfWu206nh3DpxwjpEyTi3K8oQWRVXQJGuWGhpnphRWztGKWHHnpI/l+sfXXL\r bbfRifEu074ckVYhjVOn6MThQ7TuqjfQjjU1dOS86rGdvniUJvoP8rFbiBzJHtMWo752EX6aGmbO\r 0ckTx2lJ3gtTQ129vdTc1irTp58+oQ/VAlhM8fyzd3GrfodM103yLt1NUAzs/1fpevv4B3+B3vK1\r X6XCFwhPPvkcXXfju5laouee+Qjt3r1VFV+kQCvzZ4zOA11YzV0cuZcH6cV2+c7Db3jrlYxU78Wg\r MjaVnQfSGlNiFyRGIZJMYw3TgWVEjJBxGQGz5zDOF8lE/zP+aXGggZvKXZuvp+buDZl1qUI6h2zO\r ymaMPFjGZUfxnbajfoLOnztPdXW6lEhTt037lSxkI2xX8zw1Tp+U2VV40RAqRHTLtPVuoNWremn1\r litobKmHxqbdBebSavoEXozSu08luAQcIrIyig1jqddUL1wROhum5OVXcqz4WC50X2WaImT391KE\r Fxvp/vpPHpBngibwbpLmTb4IiBrwUqk1u6iWj9v8xACHQWk14OxqbM+si2ZYxNsjWb5Q30FtfZto\r 09pOOadHBgZoYmKSjh48QA2Lk1Tfrs+h4M2Y7bwPTPWdGT5LzZ1rObWVz6I8nILLdfEQdaxeT3/w\r 5x+h1pZmuv3268XihcDatX20besG+sj/u5c++Df/Qj/2o99imi9OVOFAujkKE3yl7vH/AMeOZCKo\r Ur1yJpPISbySkeq9GFTGJi0DkNpEpNsY1C5IjJIolaZlAyJGyLiMgNrjDWljp59KHAcGw7u33UTN\r XXivSvwmP+Sg6RyQa5KzmSRGHqrE8Ui1NexAxujcuQu0uLDIF18DtfbxnU4mn03d83Tg8c9wq2OI\r ZmdnJJ8ltq9vbqF1W/bRTMMamp53c/OQLt2Lh1flSl8CS+DSVUwQG6WGOWksEGFWIMLLRtPiIF28\r eEGmXrd3dVNjF17WVbQvBEOR6sUOHkXKbHhhsGd9vU715puQzq4uvmnCsuacf2Z3eJUABtxxdsGJ\r 4D01eIYE6gbvSFxIMU0t8vzJ6vZ6mh48QfU18/J+m7mpYeppXqJdm7vp4viSjI1gWR9M1wXw/ng9\r OzkUZy2YuXCI5ifH6bf/+/fSD/3Eb4vZG15/sypfALzqVXvFAX7s45+lRx55mr7h6wtmqH2RALVZ\r 1Q7kS8d5YGs6iYxmeL0XgTBGSOwjLiNQQzOjZ2n05GPyTgKH+pYu6tz8KplZlb4vHOAcoqyBbK7K\r Zow8WIZvogq27XWj3ALRBTLxgqY2diD6hm/Fqrp+OnbkOZqZmZIVZPEgXGtbG23Zuo2aVl9Ds0vu\r 9aAhzwROzMEdkQKrCEkCDaWIbCPEUq9ZXnCZiPPTMHTmWZrCQ5SMHbt203RtV5FZGl4KFJWjKAiK\r FC5Uj1NHnpKuvXk+Pj3bbzEpkMnPyIZ2diRr1JHAiaDVMMWOBIBOkUlrmG/spBuv2k1Tc0s0OTZI\r S7OTdHFwhM7299Oujd20Y30nnZ9Aa2S35IsAp6I52RlbkDUcCPDrP/ud9BPv/2F619f/KM3Pzb+g\r TuSON95CBw4cpX/4yL1y8/amO164sZZ/S+CwlfYK6hjIVsI6WLmK29dcVnEkeo71q7SPnMQrGane\r i0FlbKp3HrENwLrIzkPIwKflAvK2iZo5TMEdO/sMH8UwPgDH0dq7TV4hmsnQwLIk64yNZ8vT5jWp\r ZG3DKXr6qWfZKTTxTUAndaxnp7BQT1dtWKDBwUFdhmR6mi8MLK+OKZjNtG7HLTRPseMogBfnSl0C\r s6rKOG+UkywvuERUyCdStc8cokP2quD6xkZatfdLZPHEMpTXDoy8sv/pe2WQG++Eb1kdL1xYCSGf\r qXPP+Sm/kKKVgnGSPPL73tQwSPsf+5zQ00sN1NDcLG/j7J/tFRmm6Y5z/qv33SGv1Y2huel2dL+u\r XRU/B3LdDV9LV1+1i/7qL37ZJC8Mdu/7Kjp0+AT9/Yd+jd75NV985xIujfw/4SAOZJs+RBhXyp62\r SiRsNNav0j5yEq9kpHovBpWx0V0Gi9gmqcricgpY60Wxnd8I0nIBedtYLe935jsVvIfDAfPg2/hu\r qlEcB5BkyGA+I0pzZQibTQeoLPfzimxZtK7hLD311NNijwfd+vr6qKunj86cOkVTMzO0OLtAtY0N\r 8gzDuo0bZRrx2CycR0F+gBfnSlyAyGJZ47xBTrK84BKQzwOvWnXL4pfuY/SQOGC8DKuhoYG6dr6e\r j3He9vJKWCl1+eW6HC49ZQEKMtu2apEeeuhhWpycoHVXX8qiksCSdA2On32WZgeOy5Goaeul7u23\r ynEu/g1Bumapn57f/3nj1JHg/IYj2X8WkiUaOv4oNbR0SsskC+Q0amt4ZR8k/JZv+0l67PED9MTn\r /94kl4+RkTHqXoUpvYt09uRdsgTKFxPw/5SfV+ZAkiU0/MViFUnYaKxfpX3kJF7JSPVeDCpjo7sM\r FrGNT5mzYXDCIIl0mQs+LRcQ2+rGSfC2v4nzz9ECVzYOmKWG9YGaMIhn9nmwLBIrmRMwIpkHy/Sb\r QUbi2Rra0nKBHn30MeGwThX6XGU2Hd85yxO/7FSaW1q41XEtjS9iqex87oIozxKLCGaxrGGxQSIt\r Z5YFHtLUhR3xIOUczU+PMV0j8/1nJwY45ou0Jpz2Da3opo3Hpspx7pl/lS6/Rj521113PZ2a7KGF\r uSk+L+xGgvc7y/tHlyUmTeCtf3juAe8lx/HHvprwnMJLiuWq4UtDH1oAjz8px3bdFc6BXHquuNbG\r uXW/OHpOZkXhVQU6Y6tSrqpZXXuRDj35kNAxrrjuVjoz30vjfA3jHOlYt9c0AW4RyKIn0X/2/R+g\r 3/rtv6IzJ+/m6yptxVwqHnjgcbr99d9KO3dsoEMH/9mkXxzAlVn+X/BF1dyzXVogCjaXa9kqk7BR\r +ArbZBl9uFNL9ZGFVzni0pyH2gSJURJlpbwNIkbERA5oYW5aWhx4FagHVxItfdt0jEN4v4lgfCSO\r f7GgMB2gsoy/YxSlB4J8S8uALOeOY64OZFEcBwB+165ddH5pPXO5zBVRniUWEcxiWcO8QSIpZ3JA\r hYx3o2CZe1pC9YIHwrTPXGfzZLBs2fLIJtm7epo+/elP87kwR82trdSz81Lvsolm2LHMjuNZGz6+\r 7MzhcBYX2DGxs/lCdDDVuIG6iSN0+sgRJupo3ZV8bAoTVZNTCgyuT/YflGm/+E9a1+2Tp8cdinNc\r opGndVn59jVb6OK5c9Rco63LK6+9lU4v9MrbO4ePP0Kr9ryB6hrDlPpKDgSAE/mZn/tdOn/mPlq9\r +oX5r37nA39D3/+ffone803voD/9Y6yd9cWB5QfRW3rkBJe/zq4oqVKENgHgK1tv5DaCL3znAcIY\r IXUPuKix5s4k37FgrR+Hpu6N1LnxWr17hSBsIjAPUSSOf3HQRTIPluGbqMBkbIXNyzvqJuj8eX0S\r Ha2PhQUdo2nrWkUbt2ynwRqshprJC/BZoaRJaQtgxj5NEZwyGOQk5Yw4CtzRz4ycFYch/wHu7ls6\r 5Z0OaFWg0oXTwMJ4CAKXDYfFxXkZq5LX/o70853nHLcgJ+TBTuQPQIdVZVGp4EE0dGUtIMxO+TDU\r f5jGhtwNBLpaMMNtSdK6VwpjABn01OBJsQJd78oUAbImcRZcdvyGth6h67kig3OZkjWhsFYa8jot\r L1Sq9TdyLzaig2fBnQtxiLGmeURWLpidnKRVGzZQbYu1xnMJcoJl4WZsodVfw63JBThfjpt79FW7\r xTnyjdOaPRJq29ZQT8sijY7PUO3SLF04d4q60VvbvUW6sUZOPcHHecLfgLhB9P/2U98rcRYYTMe+\r 3vHvvo/efMettGULbsQuD7fcfDVduDBEf/jHH6a1a3ro5puuNs0XNnAcym8JuMnd3IMxkAb/7/gq\r Ja7ZrLKNjNxG8MXhPAxC6h7w1j8spx4DUwwxXuAG4fLldGBZJI5/raBSOmxzqqL0QCoHd8MWouef\r P0xHjx6VY4+3AjY2NtOqVatozcbtdGYyfXpXEOWX2VMBzKKiYV6ZSAoYVOZ4UhldTqE1UbDshSBk\r gG4ixyIPpEE/unZL1eTySHYtyEuKMHjobprhChIvjsLT/Qtd15imOmirY0AmV7guM1fepqJWUwYz\r bDs7PsT23RJ3rCsYXF75Df5lQnc4fvZxmsHYGjvVVTtuE9myyJV1+cLjeGHSSs3UCOFFyXggF93H\r gih5UU59dI6ee/YA1S+M0/RSEzU21NOrb3s1PTfUTOM2cI/nR5ZrgTj8v3+8h/7dO3+Q/vaDv05f\r 97V3mvTycMtt30gPP/IUPfHoh+jaa/Pda19owJVT/q85B2JjIKHiji84puXrdH4jyDkPgGWRRaRS\r QpMEi9imbD/OJkiMkigjzZbfwWzxylh0V+GJVoe6xjZ5/wFiwEzdJgOWReJclbxMulRTYCeivByS\r Pb3jdOLECRocHKbx8XGqr6+XFsju3XtppDH7Ah2D5VewpwzMoqJhqsyZegEfZ1SIEwOEpVywbH25\r s1DAHi3C+ekRceD1ze1Ux3fmdQ3pQntZ5ItbI11fcFYO2oqYktYAWjhFGDzyWdbp+09e9apX0eF+\r bslwutoGLYtDNc6gCOogMGbC6fmqxF2xPL9TCL1sx/oPsv1qn25F3V/lV/6KsK1nmj573318d9Ug\r 74ShrlDxVb2LnGHllK5bC6jllmj3ztvDWG0maczuW71ITz/xJE1wqw6YqWmk9evX0tXXvYoe+Pzz\r 0nJsmJuQxRQPPPz7YlMJjz32LN1wy7vo1375R+hHfviFeSiwqfVmamlpoOGBB0zyhQtcW+X/FBxI\r r7VA2FQuxGzlq1+lJQp6SeHZoI8tsnpNHixiG5+yxCZIjJIoliZGjIhhEt0a4/0HaHEuvIfADZDH\r T8nKNmwiMJ8Rxb82kNl0AFvmxLnMDKnccftWTcq7ydF1tbCwxK2ORpqdnZV3K7RvL1i8zRImZSyE\r NyxBXpFIjFGHMShP4i/OzZQ6jHmulBe5ModzwZPLGB/w4xqlZVBIa0SgDgrdr3D68bTNS6nga4Ye\r lxls8ifxXfb6677SNOVAiwNAOXz5Ga6yb6xy8F5bLpoGcduqHfx73HTrFFNDZ+R4zbGTbepYyw6x\r aO2yypWzoAoTh+aZY3T0oFbmN952G52ZyL5DI2RWVbY5o+JUOE9Gjz6EAyQWTXyd5pZFKSapd/4M\r HT2gk0yml2qps7ePtm3bRufmVtO5pz5Km3ddSRvXdtBdH/k1au0qOoYBk5NT1NZ1C/3MT30Pve+n\r i7u9VoLHHjvATuk/0Du+/Hb6p//3Oyb9wgQux+J/B/AOpFGv27DRWL9KS+R0kHglI+hji6z+pXIe\r i4tzfEdziOa4worR1LUhes+A2ss2bCIwH4mUzAoi3sMsc6qMoCC9427eXmetjkFZjmRsTB9yw2A5\r uhUwhbd2bbQWliV8sR0HHAAqSPeq2zKHgQpWxhu4IkDXVVzZCjK7cU5CB6FDvnnHkC+fVOomdpUy\r oDO35sXZyBplmaSDR/X5AlpYpOa2Nmpdf510k2G8BLOtBEuL4iBlvMJaRdV1TWnXVnPXOm4VzUm+\r zZ14grscSDM/zS1MbvkszExySwVPw+eBFgpWQJgeOVfc5VWI8iqhSDXV/xjfLfO1s7RE669+i0nL\r EDKosJeAnFE+1cSFIzSF2VpM40ahb+8bo4k/Zh8lc2QfnaUjT4cpv0utnbR27Vo6f/R5aurulZuv\r /Xf9Fm2/MX4gshy1DdfQ+14gJ/J7//tv6Xu+/+foF3/uB+i//pfvNOkXHnCZ5P8RB3Eg27nJ7sZA\r 3FXFsX6VlsjpIPFKRqr324z+pXIe00MY5zhhnALrf8lihzL4GeUjZJKRgWWROFcxL5Mu1WTsPFts\r de2GRXruuQN0iu+O8WwCWh14QBAtEHQftrS0UG8vXwxdVyd5ZfaSgWlLjfIKJ5FWxiSe+MXgdnHl\r KTaFXVdRvkaikscUWQyeOzvkW1S0megGIHYODlW1PIoyZuHZJ/6RL4d6LsccXXH11TRcv8N0ywN3\r yqjkXZmwjD9a9Y5v6uByFVyFruUhr2C9cFhtS5wwMMatZ0wlnxm/wM5in0kDFrjVNzmAc31R+vqr\r nbockC9kV90IHXjyEXkjI8ba1u5Z6VsZQ57lFZEhMchbDx68l2qsNdLoWyMOZh8lc2TNxcdpuF+7\r tOBEaiZH+cZxA40MDdL3v+dt9D8+8HOiWw6YQLFp65vou77j614QJ/Le7/k5+v0//BB9+p4/o9e+\r 9gaTfmEBvb25f0LvFxnsQFrYgegYiLuyONav0j5yEq9kpHpn4cSOeCmcB6bjyvsJon5wAG8BbO7e\r aFyUj5BJRgaWReKkavZkcTrNM0ZGIGwqC1wNXb+1hp54jE/+4UF2GrNUX18rrQ6cyHNzfHc8z3fU\r 7FR2795NF2t1vabcLhOYttSouCyp00AFl9pBL7Oa2Ak0tHSZjUOwhVPB3TdaA7DJOgBYzkxo62Nx\r flbGLDALDrikcQfOcGbMdXkp8IAouqgk32gsZPDQZ2R14nlu0V15zdV0aqhGyoA73Qb31kgGnGJd\r w8qfD0A5YqcHunXVds0rc4XCUcBBuFiRGuEcGD+H8RHNr+j4jPU/L04RrT7MarsUtM8ep+ef1+6r\r m2++mU5N8rHI1SjVIiRcNovEIDB40hxPs0OC7s+eXberwiNKGJE7eibp85++xzg+/twKxYOi3/31\r b6QzQ1P0oQ/+ummWx76rvpK+/t1f/oI4kWuv/1p69tkjNDP5qDy79YWGGr4Hyf0VzoGg/x8tkJq4\r v5VrPb3k7cKXyEk4NnFW7yyc2BGX7zwiuZCBT8sD4KLnu7Dzz0lFAZX78Vh+pGPD1dFdmSaUbdhE\r YD4j8uUFCtMAmi7VZOw8W2ZVQ1vbR+jc+bM0PjpG4+OjMvtlzZo1tGHjJhqa47uo8ROyqB3e7YH3\r eEy0VprRYTlnihGQL4e2IthptDunAQQ718rQLqmiu+YwiC5Tofm4Zx3GLDsLvMxsevScz0Me1lwG\r 0k1lQEWsA+4dzIXyyV2/R+kPF2xuOU8Pffaz8nwD32bTm+68k545Hy/Fnwe67fDbAO8YsNwNOyXH\r p2UoBmzhXDBuND18JqSLrlr3e9EFiGVrZCJAelnT5MVj1MjppoZOFbZO4EzQYm1bzdf7ClomY8cf\r oPGREXmwsm/3G1iS7ldQIFoeIVHF5IkyMBee/heq45sR1GXNudYIECU08mq+bzx06BANDAzIdYMX\r qf3hb/4w7bpqn8y2Gh7gc6BKXHXtV8tbCC/XiaA7etXa19HrXnsjfeJff1/+oy8keAdS6Nv44q3v\r 2yHNbcFlOQ+G//EaX77zAIySKJYmRowamZI7PXTSi90p1Lp6N1+g8VxutZBt2ERgPhIpmRVEvAfL\r 9BshYydsmUUNXbepRt7bgRlW89x6Gh0e4VZHo03R3UlHh9TZN9XN04Xn7pfurHXr1tHSqqIlqS3n\r TBECUsWccxpoaXTkWxHLOY3gdOAEFrVSNeBZjfmpYbEJzsLp8wV0lSbGIDBoXGcv5UrutKv8XQ4y\r M4tvMHIYeY4GL1xgB1IrXYTtG/GyogA8wyFP+V8C0NrCzYw8w9LQLBW8OolyR4ljOMNOFTO0JgeO\r U8d6W3OKWx2AOzZwPkUtFDxPA4eCWWhlzgT2HeuylW6KlvoFOrH/Pprnc6yG79bXXVk0/hH261Eg\r qgxNsGyyxAAtsOdomgP+bTgRP903QZTIyL1r5qRLGC8MWxwb8tN5Mcbx9BMfpiuvDA8xVsLeK7+K\r vuE/vO2ynciDDz5Ft772P9JP/eR30ft/5vtN+oWBxIHkLiu+KOq8A2GtfM1KopAiN13X9N4iq2ek\r 3pTpYKxk2BjUJkiMkiiWJkay1LN7Gxp+p2thoYnbvu4K/n3xxa8JQ5ZRRgLmI1H0CxWFaQC2zImX\r Txu4GtrdOyXOA+84x/RcqlmkmalpbmFso3OLm82OwYla2IGcfOpu6crAGEj9+uxAoOWc7i6CKjCo\r O3XxaHAK3l6Jyk4DrYyLpl+lDsPSz8+Oy7iGcxjQ5YuiElSISwvzMmUWLUUc8yIHFWeA3428Aazy\r ikoTwH6kBRDd/dfWNfG5UP5CqPP7Pyr5oQsBz3/MdV9nmhRzkyN8vNQBYR+0hHKukjfcuf1qa6u+\r ooNwmBm7QFifC2nwICVejlT2MOHY2WeppXezTEMNDkUv7rH+Z6l9zV7O75wMqCtCxYmuMPBZZ4JJ\r BTOjF2lueox1+QH4hbHTNIYB7LExWrtxI9WuKj4uKcJ+BRl2eWiCiskiJcaDRo58jnDUMCm/Z/fr\r pBu1GJbQoq2dY/TMswdo04ZV9Du/+gP0xje/lt74pm+l737vu+nd73qbGi2DHbvfTu/5pq+4bCfy\r h3/09/Sd3/1++qs//0X6hq9/h0lfelTpQPiulpWqN6uoNqzeeQBKL+s8gAKbIDFKolgajKTyO39I\r +ufx+/BD5cfyHSseBmzqXBcnZSgj27CJwHwkikqqKEuDbSIuSgekcksp27X152SWFVoe6K6CA6mp\r XaI9u3bTkTHrg7fkKJc4kKfvFjuMizRvfo0qg1EJVIHKF62Cls61wgf70PVU5DScDlNI0W0kd+aW\r Fl1SscMAssXAsxAAKn08gVxpbANjIPOzE1IxA5KnZagVdDb3S8PZxz7MLYRGOe7XXXdd4qzDHla+\r LziIWa7g3LEQx8Z0JeeiaZxDuhCcRQZwKNCNndHYAekxcwstkA6+eQLwNL3D1PBpeZAz23IZ639O\r nBfe8udw9vGPcasMv3uR1l/z5SpcEcJ+BRm2MoJxxWSsxLjaxNlnaGbgmPxL+QH2LCxHjrZ1T1J/\r fz/1H3qWPvIPv0V3vuMO+umf+V/cGK2t2ils2PwWeu93fs1lO5Ef+/Ffp//5239Njz3yoapbQS82\r MEwoRwu9nrlLQBzIThlEV51ZRLVhXGHH+tgiq/+3cB6zfMc2yXfO+HkQ+VYHV0p6J6dOMUAZ2YZN\r BOYjUfwLlczaA5om1WTshC2zYIq/Gxov0vHjx+W4YWohZrts5Du+nbu202NuApnl49I21S3RwKFP\r 09TUlAyk9+617oWQeQaqQLMfjsHP9jF7dQzovip3GqqzCh9l5YoODqS2sVmn6DodwxUDrQukb+3b\r LnfbZQ5D7dRRAFLRdmYr2uIfVyRdWuQWCpcZwM0FKuPahlZ5KA32CND3NE7IsXd1ytZt22hkvpNb\r Quq0Icad+rytkdZgYzS1jdyqsW61GJbNspg4f1i609RRVHYs3llInO+SgqOdHu2XFl/sTBbn56QL\r DfkHuZZwZpQdG+9vmq+j0GpRYNpsV/0UnTx+jA/Uko5/7LnDtJeKzJGp9kAJ1LhiElaipTVt7xpp\r Wb1THgwuR5Qbk8NP/zNdcdON9OYvu57e/Lpr6bOPPiuqap1Ce9dr6Md+5Bsv24m88U3fTk8+dZAG\r zt9vkpcWuE7kSMXzrDzgQFbt5Mo20kqkdFxhB31cteb16hecMNUH0lMMtQkSoySKpWqEhwAn+ERB\r d4fTwnmgG06XWscAo9oGKJOWLUZqH/9CJcvTpJqMnbBFFibjaEvrsLw+Fd1WTU1N4gzwXMeFJV0H\r KJim+QB1g0/IQDqw9pqyt565FsUg35XtDrkYgW4Z3MFlnQam1k4Pnyp0Gr6VkRkkRpbOYWBqKvr+\r iwbFYaNPhk/6vH3lmfuZ2V9eI3fZrqtyXu7w8aQ233lzXMvGDRXu8LNYOv8wXbiArqQZvh5qaeOr\r vto0BciVjY8flwVXGMqEChkXG8oGHuXQ3xUqq0DlIa0PyYedylhc6adYzqFAnnVI+D9xU4WZiVln\r MnYWXVzkWyWQNo0doONHj/G5MUdbd+6k2Y5KlfFKkTkKlQ5KgmBYlgTPzgwevEe6tLC06Kp9b+LW\r ZaUJEVFOTMKRAP/vI79NDzz8jNDVOoXahhvpfT/17ZflRCYmpqi9+zZ651e/gf7+b3/TpC8dcMrL\r ESpzIPXsQKQLCxADtXIVtsII0zsLJ3ZEroKOHIWvBhLnwWA+tgpRLGWav9PcRJ3hJjiAi1TXaOW7\r 1c511LpqB98NWzvLJ43yEDLwithWEZdGyWwagK1y4mw6IDVSzmQcra07J0+Vo9WB7pO2tjbavn07\r PT8ULRjImzSXgL7F4/Tcc7owXN8V2ZfVqONAdwZmKcV54M5bWxQYt4gdhzoItFvVEYtI8vFOAxV+\r pkCqt7to52wio7h1ka3YBGyaZgkncVH/YyywyGWtbe1h51pf4BwyhakC8RE9/dj/pSa+w8YaWC3t\r 7dySe6tpLgdp9QYngzt+lH2lzmXszDPimOBYdNpvflkXtBjQmlHHkOZS5EzGzh5kZ7GXsGxMGHMJ\r 6dAqwX7n2KnWNTTQ5s0baWimlfdv790XFJX2UpDJp+ps1bDIHMdi9OQTtDB6Tv7p5bu0AMuJo81d\r U5zJFL333V9Gh0+ek/OjWqdQ03ATvf9930E/9d++2yQrxwf/5mP09d/4X+iP/+B99K3f8jUmfWmA\r 4ydHptyB7JK7d1WqhauwFUaY3lk4sSNyFXRUw/oLtsAmtgpRLMWKpeM0yRfCgg2SA3AecHztfNcU\r Bs04nU8a5ZHJUxHbOjIriHiBWSXijE1BusAxxd9XbSZ67uAhmUGFJdhHRkZo1ao1dPXVV9OTZ/jv\r sgTx0Umh8tU1p+nw4aMyBtK4MTyJjtlGGJRGhR/n4Lp0xAl4WKtCHEpwEMgDq9eWOQ0IFrByKl+s\r WacBh4HncLRlk3cYYhU2UqFiaZPF2QmqZ1v8x8FR5HZcAZGtkUFSnM/pR/9Op+8u1VBHZyd17lpB\r V01SeyXMMgi241xRo1vMOctmNyZlNtlcY4dS1EJxDgOzvuqb0lWCoQPidBhDAWLZ2vqz9NjDD/H1\r VUedPaupbXM0QcMKlP+1ecnKkcmjqizVqMh09PRTNHNRx0Va2IEUz9LKwnLiqG3mBPX2NNOX3bqH\r BobG6U/+aPll2MfHJ6mj53X0V3/+/ssaDP+qr/5B+sd/vo9OH/8EbdhQedWCFxM4dnJEcJ+Ru4TY\r gTR4BxJdap62WKKoOsvo8xU008ZervOYHjpOM0NY+lpbHei2QGjqXG+tDudSOJ1PGuWRyVMR24LM\r 6CukSaUZG2GLLEzG0RVrZqTL6lz/BZn1g3Ws0PLYtWsPff4EN7otjzSXGCGv1olDMgCIGURdu14n\r z1PU1jZIpW8mgsnBE7o0eqaix4N/fuzCjOFMZLkPeUqf4TJh4I4VArQEUnCLwVoZpQ5DwBR/5Y6c\r bRs6VpmzwAUS7agQpq9gFlQxlUmQYc888WG+Y8XvqqXde/fSVPtVqqga5RWYh1dWtPIYP7Ofncoa\r Pk7n5bUC8QyyNIcl71AA7S4MFnAYmLmFFmh2dhdajVja3jkOjKNgiRdMTGkYO0BnTp5gx1pPLa0d\r VNPcxy2WtPLFObc4P80mLQW/qrrfWRlRHlVlp0ZZUyzvP3rsYTnP6vk8697+aqaqyVBtrly9QPNz\r 43TTlevo4acO06fu/XORV8Izzxyhq677Orr/3j+i228vml5fHeoar6drrtlJj+Mm5yUCLpfSoyUP\r ErIDiRdukwtOLjK70ow2jklHaXxJzgMaz5bYLC7SxNmnpYJzLkJbHQ3ywpnG6OlgSZfNj/GF5jxW\r 1ZySQW+0PIYGR8RxYIG3k1O9kVmaR0DIx6F24Gntv5+boWuuv4XOzwfHMcstAJkB5AfFIc20NmwM\r Q2TSRWVTcQHbDwZh8SpfdJ1EuxbEq8vGTiPYKTXH5YBdPe9P7ZxFNkeAZQViFRXZR5CksCmxy4g3\r Npyihx56SN5AyCcWbbrpa02zEtjlVUWdVGgiwkqJl8Thyo3T6Hmq79lsT5VrmjglnEnHhis53s+O\r 4UqTKrBEOqYLZ6f5wsm09m1Lxgn6n/xnmXw1z1feTbffSadH0DVcXEaMrUmXJ57sB9gsb1mctjpE\r aavKRo1iU5x7Y8cfo1p2eBgXQXevrIe2bIZBXzO0n1qaaqi7vYkeffhvTVqO++77PL3hzd9Bzz71\r d7RvX/XL4sS4+56H6E13vpf+y//3Hvrvv/BDJv23BS6Z0qMkDgTvvrAxELn4/EVmBNfCXlSgL5tx\r 5VNJlNos5zzm+aScOqcDe67VAefRyHcQrShv8iQtp8vmx1ix8yi0BzRNqok4TwZZQhnTPHGAhoeH\r qbu7W5YgmZ6alSVIjo5xZWA2SXkSeIMEC2cfpYsXtVtq10130thMjT0MOMCts61y56mJ1HHM811m\r K9+Runwgg3NA6yTOHOmdY0CId1vkNIJeKVR40xORTXKOAI7nOKNSNmvPEFFeHiSOsjhvmpMNHfgX\r mhgd1S4sPtM23fhOVRShYl3jlEU7dWCbwjziSbYGERQaM5Zo+tzzVMvHdnb4DLVvcC0mtXepJs4f\r opa+rTTBttmuLjgTQJ1M2A8eWuyqHabjx45TY2MDzc7MSMsj31WWLxtaLqhPkvqAzfKWeUn1iNIu\r m40axGYDB+7BCSz/UvOm6/hawPI/1ZRHba7bXEfjo3xujw/TIw99SGSV8K8f/xx9xVf9AF8Ln5PJ\r MZeCH/rhX5VX7H72039Gt95azXM4LyxwrEqPUOxApPLy/70RfDJ4UYH+UpyHfZX2kdJoFk9fPELz\r Yzr4hQDHscTlRP8lpuhaKgNzXhA0L6TzyNV9y6QLHFP8vXr9vLzJDU+9YqZVZ2enPLvR091HF2mj\r zyPNJYbmEwOtBWBdy5Qs747/oWPjtVLxt/uuBiSyQXGGa21gfSdMf/ZjG5Y5FuKbGjwmMpWH3ZY7\r jVAwtDLm2aaebaRLKqgMLMgczMJfLaICuUDlwSS1S8+75XHyoQ+y36il+oYGbsUt0Oabvs40K0UN\r X2QFl1kiKrsMWV6YNCMUtigPdGPtp6bWXmroXBddkyEH1zLBYHvbqvDOGIw94f/EQ5h42h9pOmYO\r 0cH9Twvd0NJGq694i4yHSasnt/ui8pSATVPrFaTNIUq7bDZq4MxGTjxOs0Mn5bEGHVx3SwBVUx61\r uWLtOI0NXKCHH/wb4SvhV371z+kDv/dBOnZYX797Kdh31VfTwMAgXej/lEn+7YCzyR+Z3HXFd/LN\r q3ZLF1Y48SyWyF2SvHVqJzG9ItUHlRcy1EYlkdz2i2cEps4dBCGtDhQazqO+tYda+U/GVOMoFcNn\r xgiatFwOsS3IhHGbDNgqEWdsCtIpZzKLmsaflRYH1t6BA8GyIzt37qRnL+hsmqQsCdJ8AExRdM8O\r AF2zx+jEieMyWN2Defpiqwmck8l2U7Wu3iHHUu1cl9ZFmYzgAE3qNNTRaM66RdfWwvyU6KGRcTRA\r 1QwmIjpO65Ee4Agmj9TxcVIqVubtK0MNT3/+b/nOmc8yTl/H5d9wfVELJK5YltmBmMb2ASqNdJ4s\r tuda3QiHjEsRJp924szT1Ni5lhYXl7yzj9PCmQBwKPE+XKukYWFYJnUszEzTtp27dJXnBJwmt9t8\r ObRLNJ0a7pHLIp++OkTpls1CDbBF62z87LNSz+BVum3r2In49MtlpPrb99bRM0/vp3/4P79Ce6+q\r PDj/s+//A/rUpx+iuz7xByZZGY4ePU079nwFfet7voL++A+rWzn4hQLOeH9Ecqd/DTsQboGEqYFm\r IVF00fuEJjG9h68Ioss8qRyY1q/SDmyDu5/pwRM0P3JGNAjSZcV3RBgkb+rSd3tHqRjMeUHQ5Mol\r iG1BJozbZMBWiThjU5BOOZNxdMOWejp48CANDF6QllVrSzt1dHTQKN4aaOnTHGKwJlJ6Z+DHMlQ2\r 3f+kdOdhML5t++u8HIgdB+Ccjqa3lgmTQc4s/2i8+hNLwLiFALWUoTB4Mhz/WUNzZnVXHLBgZumU\r ClFkIIh1iuKjEv8fsZ7pYnNDUGbNtjSdos997gH//MfWbTtoaU3Zq1o1dVq1GFda3xQoRJSXJ67B\r k1k75hPR8g5lkp0JWoP1bezk/QGMnAlmZfG56ZzJlWumuZL7OFcLdbQ4O0sbbsAU0jTPBLl9praY\r Lgx0rK+w0CcnSVOlXHWI0iybXA3GuTU2wS03OJGm3i3Usfm6TNrlMlqSltnU+QP07MN/Rlu2R0sN\r FQBOZGh4kH7zN37cJCvD//qdD9IP/NAv0T2f/AN5Z/u/FXDW+CORvYgw+NWCQXQ/gMYWYhRdxv7E\r 01hZr2UwbaxPldioXjknYzCJJRUmsRhaND0XzoOa2mUNK+nD5x1GqRg+M0bQ5MsFxLYgE8ZtMogr\r KyBjU5BOOd6a+KZtjfTEE0/Iqp9L3I5Cl9W+vVdGg+XZ3+RgUouKHAeAdb/wTMD5Zz4pfavIv23j\r q8TEOQR1ENHzHKycn5mgaSzmx87BOw5OMzuWtjZ0T9gqpd1TA9TE+3QvUlKw3szUUrdB4HgH431U\r oI9ESjqBxRJl/6MYkaLUhi+Ks5+ik8eOCY0nrd/whjvowLC7Y66Q0KGKykalvM2pMwJhU5mv5r04\r k6ZAn1hkWjDj7EzQbdOyPp5lpmmkVcJOdGNPHR3Yv1/GhJob6qn3iux6UGzP+aLFm1uzKyrHwtyk\r DVIrxs7q0+Ed6yu88IrTpyVOueoQpVk2OVYqGKThQ5/RVTr43O/ZaTcQPu3yZUAe0xefp3/461+g\r HVtW0a595b/xzrf9AN3+misu+UHDN77pO+j+z3ye5qbDS7JebOBK8Echd1lwBdPMd/n6HnDTJhU2\r U55RItzJAEHvU0kU2WTzYywtLdDUwHGaGzsnjsN1WcF5NPZsoRYZ3GIkaQHmvCDKVcjUMrUFmTBu\r E0H55OdlbTLpEsqYq9Yu0OHDh+nixYvytkCRXXUV9S/o/P7sLwowuUVoCeDJcYUKp4ZOUz1X4OJQ\r cGwuPMb7ucBkDb35zW+hz5+Oxjx8y8K6qdgBYIkX3F2quIZmRs4RFqDEwLruwZUN03J1TANPeScP\r 70UHKDkXhMQmkoH2bOaXx2kFysvWNpFE4dJEIsegVTQzel5oQJYfmRmnhpaejL3i/NMfY12zPIeD\r Jdy3vsa97zoY45xEZYmxAgfwvJHxwxi65tVqeeugpjR4MpIxlONtIk5tYt7b+6jANhKlDii1xXHC\r FN5ODMB71RL1P/1R+U/np6fozW95Cz0zoO+BxzLzc1PDNugOLMmgOY5VmSPRZ064dRM9KY+XXZW9\r WTEB55GWOOWWR2S/TFL8DiwNjw7YJb6R7o0fyPVpK2eC6wtLBO264U300T/8Ztq6I37gMsVrXvet\r 9BP/5VvoK96x0hdzcSnYedc23kDv+ro30d/8n18z6YsLXA3y6+NryB2O2sZWau7eJGsECdgoXObC\r GJRYsfOAxrNKzE0N0eSFw9zqmPPOQ6Yo1jVSG7c69L0ODDZPqxwRRFBG808UjNQ2yafMHttEnE0D\r BFlCGbO3b4aeeeYZGhoakpYBlga/8sor6ThewsNIf0+MkEdRqwODn43+RU1qC7vmabwT5Kw8SNi6\r UWdoZB0HlrDAsuCSlWRXQ+NnD4hd2tpAxGn4jgrvugj954zowMhvcKzEMWM0R7nfmhzciM7YKgVh\r ZKNGMqffAY4PFfbC9KhV2g5xOkvjRMjT7szPPfUvfKfNZ98CuuOaqHf3m0TuAAeBc3FuUl+r67Aw\r O+27fItWvgXAYb9YYVcW9GTMjPaLfVPuVbYhrVK8TbKLmEyrQpyEF8W6WG52DlEeU6f3y4ObDVhz\r jMVnn/wnkeOtjO65D+nesvzS2VtAlK8BS+PIcyumCo4EM7m0BTN+/hB1+JujCtDdRsjvrzIi+wpJ\r cVNwfv/H5P0i/OdS75VvDjcISbryTHA9Tg4cox3Xvpb+50/eya2RNbR9d/H0XTyt/tADf0o335wd\r X1oeH/7IPfQ1X/ef6ZP/+nv0pjtuNemLhxr2rLlDgMemcFU1r9pO9U3Wly0XmbuUeesuOicxvSLV\r B5UXMlge2cjKuRePyAUpTUYLKA+mJOKdHf5FN6xIKyARRFAmLZNDapvkU8E+lUacJ4NMKeMt2rdq\r VmZEYUVdjEng5U8YMD86juOb/pqAkAdOQAxEhzfHwQEM8N3gqM2cYSOzwzgEnELb6H46fJSdS0MD\r 3fHGO+jxc5iOHbdCuGKwXSAd5MFxhH1j2RAsSY4H0XxrI6rAY1vZBBUDvArSYx0bGS1RbKVUfJ4A\r GNhGWeem8SIjdr4sVicRUi5gTv/ksFzoaCHgnR2ooLEMB9DcZWuJASGZJ4898CfM8K0Lfzdv20J1\r G+80TR7ldUhgsF+3MCHKGsqRdzJTcGpWkeOJ8s5N1zBlem+mhN9m5ILIGVRqcRTaAZG8eeRJOvz8\r c1KBtre3U5c8kb9Eo+jeYrOVOBJ1GtCz00hUgRk7y/tiVOzWihAVlZHub3lE9iVJ0WIdOPwAN5P4\r nKqppS55ViR686RPV75vnIeYCfmer7mJ3vrW26inu5M2ruujHbvDzDfgqacO0bU3vIuW5i6tK+qr\r vvo/0T/9873s6J8wyYuHGq5Skl8MBo1PoKlnqwyY6lUVXdj+itZYWa9N9F6arTD0KzRejoMnyrlm\r 8K0OYJF1TWt2cYXmlm9gSKJMJRMYhuVqdilS27RC85sIap9KI07IIq3JLLpi9ZyMeeAhQTgPtAj2\r 7NlTtfPAHRneYR3ArQRuEmP9HpcaJ6ZzHMJzBbt08VmZMYNXc+7du5dOTWnrTRwHwAcJdghwGto6\r sRx5IwsBMqFPggMs1N1xZATg/luJAq02jrdYEGyclYIpzwT59Oh5+X2yJArXFFLpmhKrzOIufuTk\r 41IxA+Ic4qwENfJei4XpcRnjwWKEqCy11VxD9eyY8XIqYEPDWXrsycekpQVcf+MNNNQcloJxwHL3\r s1G3GIAFIhua9cnwpq612g24yK3pWukE8S8uCxedUtPD5lBYjxYlWjHqXFQvTgWwmjLpCguZMZmV\r xcpAi11Fm8iVsOzC/o/S7PQ004u0e/t2muy7PkpmjoShA+4q8zO6VuBIZCrx6lCh4u4/rCZRBTif\r sJd0f8sjsi9IiptcnGdz7PxxK9t1BRZiTJeDCemK9700cYre/dZ99Fu/9ZPCH9x/UJY3ue76q6i+\r MTywfdfdD9PP/8Lv0z13XdrMrJqG6+nd//7N9MG//lWTvDio6EAaOzfwxYY5+0UXuUq0XgjaoEfk\r iLweEiyPMHnxsDxNDj52HnwVyoCedgdYeonKKhxAmXyZgNQ2zkXJYvtUGnFCFml5G4l390zRsWPH\r 5DkPVFZ4zgMtj4HaTWyWpg/QPNAqALRrCqiRZnB9U0dYX4rt4GBQ8dQ3tcsKtnipUPu6vTR34jM0\r ODQo/2lLcwt1yZLuyDs4Du2D1nLIljfTg6f4BGxmp2KOw/6/eOuNJQqy8JvAOBpwNmX/nxLYYskV\r 3FRg3SetRNUO3T7gR049wU6DdfybfXKjUBFDPnziMUur0Io7WKPfHixemQtHoICeb1pGn6QTp07Q\r 0jw7ED4hr3vVq2ioUbsAcScKR5THErV0b6Ap5AuOnY8+O4F9w6GFywxLxOB9J/hjUK7gPNQBiqVt\r UE60orBfIP5N+I1dm19FI4i3YEkM20fIwEiTOz2wrDNJZace+XscLC78Am286Wtp6jSeBeHzaiPG\r SbwhO5L9EmuLhME6jG1gyRT3z4cWij6AiOOP/0HAWQXHouMjOlurhvnqWiOCuPgRVR3MviTZ0PFH\r aW74tCz/1LHvDnvQNoJPl8/gtTfvpKs3zAodD5Y/8KkHaW5unl7/pvAOd8zMOn3mLP3+7/20SarH\r XXc/SG9+63vp3k/+Ab3+RZyVVehAcKoibsBqrN0bqdYuBLnA/DWoxMrGPVSPhfywai76fbEn5O4C\r 7vmw7HYzBnQlb0srUVnlAyijZomCkdrGuVgCIQPUPpVGnJBFWt5G4j2903TgwAF5vmMKq7m2tsqC\r iBjzSMqQQPPQylIrFGB2fFC6ZVq64XhMxnflYNzYBxwHlpxwLYnacw/TmX52XMw1NzXzHdPbih2H\r ZYiuKkAdBwtNXvxfMpBQvhmZ8CZL9MIYggznARwGWhIt+M2iqpFjgNC95Qb+rehC499lhRVH0bOB\r hvli7t56ozkO65ZiE1S8LXzuwrniLhHOCI4JMmcTkDA09OQHaXhkSE9GPilvvOkmOj1j6QoAx1EZ\r eok55wK0sOMQnlVabrXBg5yjp56izs3XcutGB+fV+bGFmCzxb/48/+Yb1HGwA1GwXJzmBrZbtHNH\r 89RI6UJnUehMgmxH2wW6//77ZewD2Hjz13kbvO0Tb4n09iYvciQJmM06Em197PBZBagA66OFhTlz\r RsVgs2BZZRoPsy9INnj0IZrn8xZ1VvfeN1Jds04oSODThQzgQP72976DncMHqLm5iX78//t20xA9\r /MCj9MlPPUE3Xr2V7vwKHXP7hm/8Kdq7Z/0lzcz66nf+Z7r7ns/R6FD173JfKSo6kDq+o23u28F3\r BzYq4a8zJfRadsKgL6twJG+u9PBu8iWZpcH74AAL5zwaezbLvGtFmk/IieFqPYHSZuY2BqYjNq3s\r /CaC2qfSiBOySMvbSNyzcFLGOy6c1y6O5pYWeUDwAm1gszS9QmXiFBih1YHZVaekctUVAaxlwoS+\r l5wrYK74cTic4wBQgdaNHZEyNNQ3cNpaqu/ZLoO0WOdKwKawxoyuptYeHd+wmwXNRbe5Yw2WZV7q\r 9aKwbyQT0vEMtl+an+EK5ID8Ltx5w945DCyz0iRltDQcYXB15CQqTF18DrPFoJ2yu3cFS/ibVuia\r BypraRFw5Ypjg0obY2qumwpo6VEnceS+D+iJucCtivZWWn/jt4k8j+TS8cBb/YBpjrGfbN0JtLDz\r 8xD9kncwKP/QsUfYSaDbTBOP8h1/J9/tT5y3Spbllsyc6A36u6yFMj1yRta2wmq62joB2NglEnAe\r jnQyE/gtf+dP3y+vFYADWbN+PTVueq3oLIVPozDaotEz2lKJHQm6gvRhVUOUPtutlWuN9D8n8o71\r 7uG8kLYi2CxYVplGENlmkg0de1heXIcrpqdKJ/I/f+JO+vdf+0ah8WbDN73x1UkL4eP/dBc9uv8E\r veamvdwa0beI3nzrN9Kv/fJ/uqSWBLqyvvu73km/+zs/ZZIXFjKIHh8X0HjCG8By6C1927WfL6kk\r HOtkjEgfVEGPZzqmh05IdxUADQ68i3EZN63aSY3+rtvSWj4hJ4bfF6C0mbmNgemITXLJ2QJqn0oj\r TsgiLW8jcff8CXruIDe7UU4+ulgG/IorrqBjE2h5FEGl6M/PtjrmZ8YIb+tz6eBg8KxFfXObOhJG\r 1nFg5QDIZk/cR0NDI1xR1lA9X7B9V9vy0WyKYzGBJUv4JiEsLQKp7cl4hSQwyujM+QDep3U2ic4h\r 6FB54+YEd8yz8r5urVTBo9sGay/ht6ClgRzCHbzmoY4i5Izf7mLXGsFxkG7QYMZ3+XMyoBkL0QpC\r NxFmHZ597P9SfWMdzS8sUk9XF7VsTZdwl+sFjggtaNzt92wSOYAuRNcvjmdqms0piXPKVCaYdq1O\r ZqNchKA7N14trUiB7kgqqp5tN2tsTsUfC05Y19QWJldIPqqTLjHLY5JlaOV1Ry0Wp5PI84BzTio4\r 9ejfMcn0wgK9/o476PA4zrdg712JREYLgk1wJFfxdonGTmdaKAxZUsVaIwniLI1ZmNPVgQMSo3KE\r IjGqTCOIbCMSrb6ZoZPqRKw7qzBXE3bVXqQDD/++Mgy8Y/23/sd/oWuvTR+mvO+uB+j82fP05W9/\r HbX39nFFfcMlDap/7F8/Q1/+Fd9HDz3wl5c0q2s5SBVntEcQ1Ohy0W2rpRJyF5zWHeHiiysTLzUZ\r 5trP8Mk7P6Wv/ARwsJ3zALA/jHfUuxU7M3lHHIM5L1BCtmFjYDpik1xytoDap9KIEzLwCRWZra09\r I894YH0rN9tqy5YtdGS8JzaLgKmx+VaHPuehJxXSwQbv1nB3rlND3MLgiso9CIhuKUCciR374Wc/\r SnPz81zHLVFbWyu178HLkHh/XHni+FfrOIJOeUWss4BINxy5VIEH0MLQKavc8mCHoUm49cEtCZ2l\r tMF+I1okZ6WihAOJnQV+K7p6UFF28F353MQwtfS6LqYaWc7FdcehUm6JKvhAW7lisGhPw3N09913\r yzM6jc1NtGXTZprpe7XkGQNL6Pj3aSCrwloDCAoMCON3okXpnM40OxE4meBg1H7o6EPqBC25b7Ew\r 71o44rysSy60es6wk7mRKa3Wh49p60RgDgHL96M7qMiZ6DblT3z2r/g38k1IfT23xkL3lbM2wks0\r WqLZwZPUiMU5ITAVytdkXXIAHEnr6vAiLDgRTHLANPHsu0hSnp1Q4ZPstqPlEIrEqDKNwGyjJOhS\r nBk+pU7kijfzzUfREvYMFmYdCHDDzf+ePl+wgu/H//luevL5ftqxtp2a2jvo137zry9pUB0PGJ6/\r cJH2P/lhk7xwwGWd+62xoL65i5r4ZA8rtyJRfPExbayrMnAHiZbGDN9Vzk8NQyByaJ3jsCSyr7bN\r N6RPuzsw6SsvgQgMSsg2bAKiMiZ5FNmC12+EiBMy8AllzI1bamWmFZwH3iAI9PT0yEOCzw13RGli\r qPOIHYdMp53A62WD8xg/rzOuwECP4xvPTBvvPyiD5u43Sx4Y5yA4soty+Nvbm6mmYwc18L5kjMMK\r 5B1AwX/qjxt0QgZeKchBpfJpeQBxhltO+sBUcBqYwsqVB9uhC9Ov8izJ0cIwJ8IVp+tOwrmGO3Xc\r 2eO5C/x21ek+oVObU945eCdh+Tqgsq5r7pQXXU3zXWNzz2a+Marlejh0Y22sO06PPPII4Q2QeFYH\r KyLPby54HbDPNr18pgb13TScAdvgbF/i62cj36Vya8McR3Mvly9Jpgx+A9L37ng1DR55UH5n7FjQ\r 7967/RbR9XAc0rGT5GOGFop2e2n3Ss+2m2R1gXppEXFLBmMnBd1ZQ3wXXdYyqe//NB05coQp/Bai\r Lbd+g8RZJwNIK0Up3XI0dfopoVu4ZSVyM8E52tDuVkFgZNIqlMYNkK9zYrUxON+au6KZmoLEsBxs\r FiyrTBPbGTl0/BFZ/RhHqffKO9kh6hTfbI5dNXkHAtx4y7vo0ZIVfOFIfuV/fog2rF1FW7ato59/\r //ebpnrUNLyKfus3fpR+8Ae+0SQvDLCs/88YXQiZIVFXLw8Tah8ynrTFH2quwF1IfMHgLg3PceBC\r wUNSeD+5A6zdeIdLglV027e9WropAkwrUVz1M+WZSGp2KYJtnIOSxbapNOKEDHxCRWZoMZw6dUoW\r RkTF09vbS/v27aNDI52xmQcu7Fk+VvGDY3JRtaKC12m2c2h18DHEDBZkMt7/nDyFj9lWACqOpYVZ\r WZYbBwJOAwPprb1bJY++pgk6f35A9r/Id789u75Mur5wzHBcavCv4H+UgwghQi1HqlU+BJGbXtNp\r AI+nl/EAKGH9tO51MrCKVWBxCaFyg1PAYo945zbsG/kOXvLDzB6OsZQ8BkhbuYJFtx2cIhyBvDe9\r c620rOanxiSNLNTIxw9vmsRDaYhxjBBjmi66S7EYHtZJmxnuFxuUG3p0e4DHcUSM6buSh4RuGj3+\r EI2NjUlliAc9Mf15rIErfN6vvFAdcRKiY8jB59XWrXFLN4t535y37hO8HktcJ/hNsINzwzHv3Hil\r xHj6H91SsBuCM2FeHAU7HxwXyKe4JYHjiLEkyOBsIB9m5wFHs8DHETP2Ji4e0ZYq/ybNU++a8aIp\r dBViQB8D8ohFCXAM8vhT90pLGr8RswfrenaoTkz0NwuDUgtrOmz528D/XQPf7EycfpqmueWL/xJy\r tJ7R2pjFS7HkhqaGfwd4TCnHNcG86Jnv5NZI/wFpOcu1wekxNoIVK/D7cE6jNeLWZ1NoKZYFm6Dc\r iirTxHYW4Ryfmx6VHpfpi8eoxV6hHee2pW2Q/u9vvod6N+bXxbrx+ivoP37Tj9O3vCf/zv2de7bT\r 9k19NDW3QH/2F/9CI4MX6fVviN4CWQW2bd1A3/19P08/+sPvkaX4Xyjg2OXcblYA54Gl0uEQ4CTw\r 50ulj8F1PinRnYDXjeIu0U03jMGnn92/hL+nhvNo24T1meJDbLREeiIqmIrNjNGkiYIRbOMclCy2\r TaURJ2TgE8qYq9cuUH//GRlkxNpWqHTWr18vL4J69mLcR+uAO22+E+bfj4fbAF25doaaO7Vpj6xh\r I3efzMCxAO75DTgf/Be6IKIWBBUQxkb8E+J8cHqm99PBZw8S38AJXve62+jwpN7ZS6WnhH01n/B/\r qBy8SoxXIYs1ljtcP3iIB0L5/Ki39bDMBqubom8YTgRdOHidbdvqndLXj3wW5malC2OaW6zo5nEt\r DHQ/4a4czxHggUlxpAb8XlSmQ4c/J2sU4c4dfCg/oLT8Ai+O9TFU3v/A78oLvXAjgBd6rX9tNPul\r KGlyseQuJQYSmbzM1t99A0tyEwA1WipDhz+razB5G9bzMQGL6w03IG4p9cGjD4rjmMSxkGMIW22d\r SFcgt/70+aHdSX5j5w7JbCrp6mI50qD34IqNzfJCLQFeqHXL12M3SVqNNM61SiI7J8ZrZDukNWIC\r yPhGo3PDlWojUHkAmETg2Wm+QXAzzia44l7kcykMsMfIpC+BL3KV9okdk252Vj3Xj71XubXCzGbw\r Cfr0B3+Sdt6ig+NZ3HPvQ/SpTz1SccbVp+/5LH3ZnT9A/+0nvpVed/M+P1urGrz+jm/ne6BFuueu\r PzHJ5cO3QCodrqXFOVkSYnGOHQTf8S6ws8BdIk46BNzpSB/xUugKcECrw1VVPua7sraNeLqW9+4v\r SiMkiqv+2AZQRuuJRMEItmYlW0FSsTigIjRSENv7jSChIrPx84fZcVyUl0Gh2wMvhMKA+TO2HHsK\r 7ddHf7YbKEXLBXfFrksKrY6p4VP6dDnvR1sdW9le55qjlQEnra8pDa0OVMgyHx1l4x81wXdoG1a1\r 0NmzeKWtJKW+vh6aqMUdHP4J/A51BFrBWojlFsTeYm2B1NLIySeER/cbuqfgJGArd7qw57t111qp\r b+mQrjrcaLT2bpQptVhLC5UZG0seaInASeD4oBUyPQIHsVlCPR8f16rAXbw4D6yZxHmDxz4a2rSV\r 4cqsgXlr4WhQOrFhfZyu/5l7JMZ/2dLSQu1bb/G65YPlxWe6p708ssMn5p2ePyijaw2Bd7/PtVb0\r GRRuofRtkhYbzh04WryvBTci0hJr7WT7M+JYcOeO1kkD/wcYf8B5hWOMltfQsUfleLRxCxZOhknJ\r G+kwdfj4k/dIdyyORXNzC7Wtv1psYIYyCYGNCkrlyvGHSbRAhDYZvtoK1xaH3gBhrTU+r9khOB7j\r H+hqxM2KjoUsScsDPNbtQqscrbGmDj4fudWSfd+77EhCZfjiV2mf2HGEaeJT6LrnG6t5/s+aZcac\r 2gyc2k/f981vK2yBANu3baT77nuYDh48SjfdiMkGeWzdvpne+Pqb6Od/4Q9ow9bN9On7H6ep0WHa\r ubt8fS2H2297Ff3oj/+GpN/G+3ohgPq9YhfWpQKHzHVZAaiy4F7wjEfLun0sZ41TBoJJPbk87ARU\r KC3bRA4wH4mSXDSBkAFskYjK7RMqMltX00+HjxyS5zzQ5dHU1CRrWz0/rE98x8D7wjG1Uu8MFTpQ\r vkedA+cL54GWCe6oZNB8Ft1X4cly3HHCcWDWDTDOlYPrrpJy8Q+auogp0vPUumobddYM0enT/fI7\r EVavXkWTdXy3xkyosCwYLXKuxLS7Bv9akKGbauL8UemiQmsC41wNzR1SGWkX1YR0UUGmM580HaZs\r NrGTQPMeDhF5tvRslm4adGuhksP+xGHIuAS3bKbY9uwzTNdTvXULBWcRuoFCWbW8TibdB543mdGx\r vcYats4/Iv39GCxeWFigVatWUdP66yVNpcAbC9iHC6aPjp+XOd50vPHByWIbyJ1Tcd120A0f+Rw1\r 8PUk5wnflMDxIt0Qt0Twn9TUNshT3cgDzkPPP3Umw8ce4dbKzeIseAdyQzhy+mlzJDU0ys4ad/Q4\r DsCGDRuptsueEGe9FAsfjkGbgIOUWPLIypUL/OTp/dqFBafCMjgS162F8xc8HGZdfZOc4+osLso0\r bzgMzKTDTZN0YfUflGsEy+3AeWD1gtwDfgLZuZJlQBERHLOcvcBsOMJqELixRK/CIl/HTXxeA6tb\r J+nHfvw7+foourlUYCn2//nbf0m9PV2llfy2bev5hnVCVpl47S1X0KNPHaP7P/M4O91R2rFL64si\r 9PV10+joBP3Xn/zN5PmTywF+daXGxyUBmcJ5ODjn0dC5Xpb89ieRwBNC6unnkLeTbdgYmI7YJI+c\r LcAWiajcPqEisy1Ng7K21cjYsPDr1q2h7du305GxaGDQIO+FZrjBchnkloFyNLU1X7xq1uv5pIun\r 5mL6JZ57cF1YeGNgfXOnXCxqgjs2nVnVaGMqOAar5p6hJ598BqtvC3bv3kVjHbYkhz8A2L8dMSeT\r q8cdRa58eP8Y8EaZoMKgOOTu6W5UFqigMJtIKqrhs9TDlROgPKbVbmSHoYPbmEGmXXSbxGkgz6nB\r 01JBNLT1iKNB37bsH0oHT2fKKzBaZEGuFG+DiJEwHg3HP0z79+8XB4K7brQk57bjnRfLgK+g4hyB\r 6PIS0s9VMjDnBbGtszNZ6Fsp1WFMBF15PTuxiB7L+Dt45LPUu+NWmpSuLP6/xFQH5DE1GDTGQ9Cq\r BT94FIPvmMVFdOxTvy83RjKZ4Navpunabp9eI2w5FMk8bRpVCp/IGbIKr1WyYsPfaRkbWS0WuHHB\r asZuSRQ4GZ3+uyROJB77kAF1jLNwQowN4ZpKx0ay0DJUghWXsbytgn8ZJ+p/8qNUt4Qu2U10zdW7\r 6HW37aZf/oUfNJvKeP0d30L33f2nxhXjjW/6bvqZn/52eT7kM/c9SJ/6nD6YeeNVeBAxnXoeo7Xj\r FvqxH30P/ez7vs8klw6c99UelaqASgzBwTkPPCCIIBda4YWvm6BhyjNKmInbGJiO2DgHJWNbABWe\r kYJy+4Qy5qbN9XT8+HGZpouXQTVyq6Ozs13Wtjo04qYhB8BRyIN7lh6tDvDqLHQWFlTg4VgwEKcP\r imkC3FVpd5UCg8sdeDugqyj5i4uolnnXrSUpmW8beYSd3FFqaKihubkl2rKFWw3r3DLRSOuOluYj\r eUYy3MXhDhUtHkiHT3yeW0c2ID41LE8OC893v1hlVQb8WYe0cgcKyuLgNNiR9KD7CTKbmYSBYbQu\r NIHYi4EKMnIg6PxW9MqHmBGlUyrWWQyw3YXP/C8ZxwJQad544400uu7LhS+GO1YO0aWUXFWuqjSE\r GokRp4ntmBKmSJ/RFciHDj9A7VzhoiUiYBvnTNxsqZFTT1KXjUdAhiVWcLeP9Huaj9LHPvYx0WEt\r tT2veRdNLLVKPgKOscYXWogqC/vWyGSeNo0qhU/kjMlTT1FrND4yyi0UjOvp9eCSqi26NNF127Hh\r Cu0K5RZZ+5qdopsZtcF2Bq6pmVGsvFA0LhLDylQGVgeLZWwF/KuWFqn/iX8iTBHq7FtFv/TT30rf\r /r3frOoqgGdElhuvqGm4kZbmHjWO6J6Pf5o+99ghoW+6Zju95e1vEDrGffc9Qm9487fS0IXPUHe3\r nR+XiBe0Cyt2HriwCp0Htv6qM0Ki+GKMbQBltC6IFaldcjnnbAFUbEYKKtsrx9tIPNb/vLzPY2Jy\r ghr4TnV2bpbuuOON9PS5fLN0dnKYHQPGBJSX5jdXlOimQkHgPNC1Ax4XQR03vf0AMt/lY0DaOY8Z\r 8NwklvclyI/QVscM33W2cHMfTXr8fu06UP029lHHj5/kyhBvdtQxkIVWzNgK3SmgxV5kKp/mCxB9\r uC3d2pU2wc1xOA20ItBthSCzaVDOUTy7gXW42uSinmAHh7waueJCS0S6pzjP1r7QZYWxDJVtkbEM\r nZnE5bBuMymbjE2gjBk5YuZdWRHIZgl5PeKMjdgxH7qvsK7YcXHYsEMra+DIw9LyAOTOe9udMtFh\r cpDtpkY0sKNEjLG/xdlJuUHwOg4YA5pAvkzrTKFFamzt9WXQYOWS/0tp3uhvEFmQ63hKKHPQK10m\r b+ZjLZMU+DPMjgPHGd2Dznbo6Oek1aEykudOMJaAMSoInnv4o/IuFOdsZpca5dyU1NgnYnmSHwtF\r shMRGcTQS5aRTGmNvDKV86eBW89wGrhhwSQdzL7C8cSClGidwk6WP+E0Ot6hN0xoGYudjH20cWiV\r Y49uVJxbaIGoLjsuEkMKVQ4U15ssYyvAccDMv26a4Bun2alJunrPJrrjrdW/5wNjIn/25x+p+IbB\r 19x2HX3Hd/0Mfct7vkr47Tu30uteez2fnxP00BOH6TOfe5IOPvYk7d2zhRqbddx127YN7EQ+T3/z\r oY8WzvpaCV4QB4LDyZdm4jwQYucByKnij70REulJpIhtAGX0z0sUjGAb56Bk3jacAEBle+V4G4m3\r NmNM4bR/ERQqh6uuvoKeH9bVVx1w0aHybO6Kp+gOWlMaeXKLgO+M4DwAmRmzbq+OhbAerQx5uIod\r C3YPHoOfegHgKLPzGe2Xaaq4iPDb5be5H8gxLtTBuS6aHzoo/dioF1tamqi2a6fopDKVdBxQWXPF\r ihYHZkE1d64SJ4EWQ9vqXVxxbBAHhv533NHCuUhfPAdUKjgOACrbVv6vZYIFO5PgNHQAHGUPTqPH\r KnOrKBOHwcHo2BE4+7zO9NCJjcrhIFAmqSy5jHElj/0hxouQ0Fd9ZcdZ6ZIE0IWF1ws3r71K7Dm3\r 8LH9YV/yu2W/3Npbs0McPN4Vr78Dg9Ed/L9tk325Mk5ePObL4BxN6mDUDh8mfJCP1+kxQBlUboE/\r Kgdlthya+aZFZepMQHdsuFq7D80OEyF6tr9a3y3DLeShYw/py7QYfX191L33Tho+/gifE5gEEhxJ\r TY06D92/5sWCSGZlAkQlErUzsejly2VlJwLnMcPHCQ9rQqoD589Ily30cBLoxpVziKGD75C3ykQC\r nZSymm8ORmhq4ITQSIMbrnqbjFIMKZmSJQjFXt4WkG5ZdiK4lh58cD/tvWIHXXVVvLJ2OTAGgkF1\r rNa7Z0/xIPnOnZvonz/6GXr22ecTR7N95xZ1JHyj++DTJ+iJp4/QhVMnaeumtTIG87a3vkZegXu5\r A+o4AtW0x0qBDPh09ofSHdaqnAdgJ5QH/iEPpVWUWDGYN1GSQwXbII30QkY8QzneRuJdHaPyDvPh\r IR3PaGtto+ZWruDXpct8Vxzv4B8CHrPY0BLByY67PnkIkHeG7irc8beji0rSYuHDAW5+u4UPtdWB\r NwG2bdDnBQC9aIWyLzaQ1VBd/32yEjC6sFpbG6n32nerpenxxd03CPSRY/YLZul0bbpObHDHXcMX\r tLRw2Bb90fISJGbwsBpmnaCPV6fcnhaHAV7ANnBI+lY6V+mJQvJWRLKIFphNTh7x+GCwF4PFFw7c\r Q6v3vVF5m8UGGqaocPCaX5c2XjIcWD3wcb5Y7xMaXTZr166lrlu+VypU21kp0MWidnopuS4XgYhU\r PnHhKDvzWZlUgLt3HEu0UPV9LrqYIOAuyDZ5ENNxHMvXeGsZpHKlbSM3Mkq4DbpVjGYCXUBYXqh7\r h76qdRDvu2Bs712kxx971A+g77zj+2n4xBPiOOD44FyQDx5UdOXQfVkQEfalOrWxkid2kCEWBTYi\r k4g/sv6XLH2iwFggumvdlF8d/1gt+wGN50QwNoLnj9rXX+HPMek6tWVyMC7SIddbNbAylcCKyqhs\r B8yc+DQNDeq7jvbv/8dSh1AEdGV96IO/TqtX58dXHbDUyeOP/B+67rry3/aJf7mPHnnyKK1Z3UM9\r bfV0z/2P08fv+iwdfEZfFHYpwBFe/teXAImzzgNAhqnzwMZpAaM5ksrBQwQGJWQbNgamI9bnkbMD\r 1DZIM3phs1reRmbXb1iSNwli3GNhfk4WJ9y8eTNt3LKRnrXXegLodtInrZVHhYG7dHEm/PvR0sAi\r geDhOFCJuMFytDLcu8iRHLNKQPtWCwdU7piBVGdPcCNP3RVv5at2eqxVtmr6CVkReGZGK4PNt6EP\r VnVwHOjGgDMDsK4PVrbFhYd+ZOSjM2Tw7IrOIMNYxszIGbmDxewXTKlFOfVp53RcQ/PFvrhkKBMC\r ILGV3WiB6UWjSg0q5ijILxy4l/p2vZZqG3AscGd/FAqhAXTfyH9hwMN0bWt2SiUNi1Dpc+uB6c4z\r H6HPfQ4tlSV5cG7Tpk1Ut+PtUrnPTgyxIw1L8XhwedEFhMFrdxWp8wiX1Lg5BcjaVrl9Gu8cDe8T\r 5wpSta3eRiNYjRcVIJ8fKDcULsfgVFRo1bIZONpJYRDLwAsjQVVwJCfkd4iMP4OP/gWNDA+yHuMc\r i9Iyga6XY81D0w8dfVh4tz6XfoMeX5Fk+Yh2cZJORBqjdTjV/xy1Ydl4AVv6J9OXaISdBVofmNKM\r FM6p4PpyDsXD8sRDh43tPToJZVlYecrA6mBRbLu9a5K+7Z030ENPHaY/+sO/o472Vq5L7l/RA337\r rvpKOsCOpwz33fco/dCP/Bo9xk6kGjhn8hP/7Tfor//il+jr/0PBagtV4JK7sPD3lTqP3q3sPPQu\r VOW8dQaOkMgqEUHexkzcxsB0xMY5KJm3DZJYxxA2q+VtZHbzljoZWB0dHpYl2XF3isoFS1w8eT68\r kQytjHiJEFS4mM7nxzu4JYG7c/CgMUVRdJxg/NxBvmPa57us4DzQ6tBpiLiLX5JVjBs7V1t/M7LE\r LxcioV1QWS21zJ2l/v7z0iuE66driz68OXLySXktKRwcHB/+t3au0NBVhafIsWwI+pBx1wcbGbQc\r OCZ3b+j6wAWKbi44CXmoVLp0FuQOFQPiblxDptNi5767ynWtQMbB6Lg7CrbeTrp/aujiQW4dsBwO\r GF1T6BrCcUQLCftEwIBrS9daadmhLOiewh0+0rtuI+hYIDrECOhKXOj/vPzPsAV27dpFdRu/jPla\r qYikgjN7F9D11NDcrvvn/eh4F3T4XTgeWO6cy4JWmNwsaJcZ9tG+epfECDJ9tm8LH88JKZ9zHqxV\r p77tRho58ThX1DeIPbrBkD9uABpb+3w+xV1bTqa0HmfHa8C0YPAi48+Zp+6ixaVFKT9ulOr69soi\r j3hQEc+X6Gw6OE9ufXZvkinBUzZFnXOR/wfdS8MnHpVzy61tJsBu8AErIhEI6colEAFOkXoZG8HL\r 0nTpGy2zWy4e5wHGTEbPPkPNfH2gi0qdCDsVDjhWOBcB3IBBj2dFMPV5bmqUz+2CFXQTWEHKwCpX\r 5DK7icHj9L7vfTt983u/kc6eG6AHPvs4/dM/3kPvfa/2BlSDa67eTb/0K39U+q50jGuc6x+iT33q\r YXr969NekSLguZHXvfZVtLqnk779u3+G3nj7q2jbDr3hXwkuyYHgMCGhO1wu9s7DFngDcLJ4A0dI\r JBpDbAMoo39MrEjt4hyUjG0BO1E9yu2V4m1kctPmWnrggQf8+zymZ6apu6ubrr32Wnr0DF+YBvSF\r S9+qpcVJK3ff4LkA4jCsSwt38O7FQTCAo8GdKExhJzNLond1yPvh+chieq4eS2wl40DjR8oPZU4q\r j1Bp1I4fo4sX8Q52ra/3rW+ii2NL1L5ut9zdzY4NyIU/x3fZWO4E3VPIA91YqBhlaZCZMXF+mLaL\r wVbowTfyhTnJd9S4GMVh8E60kkKlzzsTx6G0VlaOZzqSJzZMowKSBxWZbuIyaIXUSe1rdmv3FLck\r 4FxRPlSwbvYNHB5WGHbjIGiBoGsNLT7YovJEBd2+dpcswCjjOjIduo9OPf7P/nketEDwPM94q3Y7\r Ymqx5JEJmPTAmfKeOSBmWzgLGefg/cBpQQ5HjQkVWNgQ6aS8+N2sQ4sEM5/w7I84F84LZUWLapZ5\r 3N0jP3QXQQd525pd0t2ERRNxzPCSMdjIqsXM63HUGPuRj8XgVWbH22Ty4XjL/BN05MhR5vgun3/Z\r rbfdJscBT/zDpm/nbYkjwe/FbKwubpHCkczxTQWOL2jOmJ3fTeJI6ppa+Bppsf3j3wIpe1eAcDxs\r VGCyGj5GjTR55mnCW0rx3+MGDA4X50YzO4pmbnU4e7SG3UOJcGT4T7EvpMMgPNLCBmNWUwMn2Y5b\r +bLjSqhsgCKrRd7u/In99P3f9GZ5gBAO4M//8h/lYcEzJ/vpK79Kl3ZfDhinePTR/RXHQ97w+hvp\r vd/7i3Trq6+iDRvC+Gsl3PLqa+nuex6kCwMjdOWODdTR2cGOGrV7dcDZvyIgQZy9O1zqPLax87BV\r QxlyOvjjmR7YhCtg5BzKpIkRnXpmlrVli0RUbq8UbyOTG9gH3vvpT9LI6AidO3+O/7hx6uzolJbH\r I6eDIQaUa2r4iIgIzmJQ+9qNl24rrjQA0G7VWIx1ILi7NrQ6AF1pFJIamug/wJXFbn22Q85QvZgk\r jmjYojKSCtrslOe76yZtJdXW10toa8NFTNI1gYsI+4ezwDMceFIc8+1dXpgI0NKnz2qg3xvPc/Tu\r eo3Msx/mSgSOo40rR6zFlTgNpAcfyXCMPC/HS2m50xYZV47sPFEhoIJdc+WbZKYNBprhMORdKJbH\r 5MXjYj/BFSccGdJPsR10WKYDPGJMW8UbNeFUdN/YLx9XrrTlwUT+zZMXj4h+dFRfZwtgEP1c3zsk\r n6oC8uaAfKaGTgrNNSvraqiDy4HuKXQTtXHFKsuI4HdwOshB4wbi/DOf5FYfO0m24R8rv6+hpUec\r g9vP8OknJY8LB+6mNVe9RRz2wKH7xaFgqSHYoKWGGOndfvxvlzgEsXEylJljeXMm03U4Xzj/Rw+P\r iaPt2327/PeDR82R7IIjeYidw+e5NbVTxsNwXknrifPBYo94FgivCYbzQ0sJ+ctZi/NT9oeYeXH4\r xnPwNgjIVOhaatt4rZx7U+d1sgO6V9EyQmsYdrDGuBLssaYYWo4IKA9aJQC6tOBs0RpBFxZu1tz7\r 1yWDirDylAHFdERkN8c3JjE+/i+/L2PEf/yn/0C/89t/qcIqgCVOfv03Kj8b8r8/8BP0nm97n3HV\r 4QO//VP0u//7Q7Rm80Z6+KGn6JEHq3+XOv9r1QGHA8ZxAneIgvPQB8uAcPgyEEWszdPxNoB5E+mp\r YhAybyvnnke5vVKJseDQoUM0NTFHLW0NfI7zXWFjoziPQxM68wNAt5UsbGh5wkHgDhM8HAlaFB1r\r +e6TYwQdLNfBUjwUqOMdNb7LCndMAPrcJ/qfpfb1V3FenJn9GHdRye93cvAiwwWIf8fx0PGF3NPD\r FQFXCHV8F8fhU/ffLxUn7ujgODQPtDjQ1bBJ7tqxGJ88Fc53mGhxiOPY+RrJE08/Y5ZL767b5Ynz\r uDJytFbUqLy0whe9VBhlFVqdOA7cXdfU1XsZ7gxxlwiHgUoS6cQGv48rWbRI0G2FVgn2jwoZNqik\r UZm3cYxFAuXJYKmstTWAbjjcvWI/6655B/WNPeQXwUQXZVdXl/xHcUD5cLeN/QI4dkF/WAJanVI2\r DhjoRVnGMYbB++ncdB2fC3tln5CjfJhMAQeDB+lQZkyVxjEaOPSAdAPigUrwaC2iCYnJCPK712Im\r XR1dePYuWrXvDVIhOhkeBrxwEMux1LEzuVf2hzxiRwFdOPYaUEbEmGXoVifGzUfv7tfJeeH0ffy/\r iyM58qCcD9oieUi6kfCMCRwJgssXrTdNq8cFz56g1Yi04FmZ6KX1KA5FeZEhABLXUOvafewQsFy/\r yuFIxi/g2QfM4lor3VvQo6WBawqtEbRS3HLweModgLNHmpwTsd2Vo4IBq1xxwVyxdp527thE6/bo\r xBhg587NdPT5j8mL+37oh3+ZPvOZx1RRBfBcCAbVy4Duq3d93Vvpl375j0yyPK6+ehd927d8Df27\r r/lBuu21N0p9US3wU1H/VwSMEOJs3TEK3VZRPycDJ0hgjZBINIa8jZm4jYHpiPU55OwAnHRGCpKE\r biNIqMisb/64rKw7PqEvv+rp7qFrrrmGDgyFKYDof27uxGwkvsOY4ru00X6+iNHloc4DQMtDWiAd\r a2XwG5D+WT7JsbvFhQWueA4lXVYYoK6ra7J3dbBMxPqb9JiqncpAO5nGaqN63I1tbzlHTz7xOE3P\r LnCFX0cbVq+l6VW3SGUIR4I33+FuERc7nkjukn72OhkIR35wJHhHOrqxcLeHfHW/IHW/cTl0/1FQ\r iacnBrjinB6nrs3X8W8/Kg6hle/AMf4CR4CuMHThwB7dY6ig0QLBdGIA3TrDXGGBb2enAj3eBIcx\r grXXvE0qkg52LABeZwsnc+7pf2Hdl9OELR2jkFJJhBLu/5A+ITw3t0D79u2h5hv/k/ArRRggjhEJ\r mMTy/ED7mj00Bppl0jJhAmWmpSVxRhcO3EVrrn6b8Oee/ldae/WdfD4d5nQ7JEdZf4wdChwkbCA7\r v/8T0noD8PwOBuFX73uTOBs4YfyfskO2dzEoxx/75G/Q9NQUNfAN0xWvexdNN6HFbPZiazQojuAM\r 0OqorW9gXuViZ/TQEV2MEV1Z0kphOZ50x+rLsuQ5zC2NMRKHvCLeaAHz49wiq+drS2+8dNYWaIx9\r zE4OyewrmcXFtm5wfZSdibRoMW7HkKfa7Ql3cTod0Uwn21VlVDBi1brGc/Sm111Jv/JLP2TCgD/4\r w7+j7/6en6XGhnq6eOEz8s6eaoCpvfdyqLTo4p4r/h3d/Yn/TZs2ue7yyhgbm6DO3lvpiUf/Tl5u\r NXhhgHpXa89JJeB2quIYiF72yzgPTJEToWq0EhGS4QkmrTIRxDaAMlLPJIrULs5BybxtkEQ6IYs0\r TEVmmK6L1gecB2ZbrepbRTt27KDD4+Epcwwou6fLxVlguYI+vjCZx5PmuEjRPYTnKnQgHetCoWWh\r A+3YHZ4XmJsakkpQC4BnQ/gE5mNZ18yOSu7CIOZfLMcNvNo5mfASojs443GhoCvoIreepy8eooYW\r 3NlzGWbmqGPH7dL1hof6cKeMrirc7aL7DMvw4/fJsxotXdLi6Nh0jdzZubtK3Z/bZ8wzjTt0dEtE\r skm+00NLAHbo7sBKr4tcgchv5zxwB407YpQXY0m4S0b3mM5o0y4nJvjYrZLWUGPbKtmHjmfs5nJ2\r yl36+ac/xnfBt0kl7GawoYxwGmhFYqaOlEnuvkMZ1w9+hA4exDLzvBvG9u3baHHVjVLe8uCOdRpc\r nu7/kI+XaUDXCcrHjJQJg7qwnWDnwLlIK+n8M59gp/d2lfPvh1Od4/OnA60RvhrP7/+4dMfgP2xq\r 7xVnLOM8nAHOTThmtJJW732j5IFuMjzHgUU3MdaCVX7huJGXK2fL6Y/KqtLIBC3utt1vtfKjVPb7\r In6ej7+stWUPEsY6l6d7WdYsXwsou7wAi3WYyoxX246cfFxWL0AqyAXYlcWOAal5G5huxAKk87N8\r o8H/d8c6aXHouIiOQWJcRFZ+4Bs5PCMCJ4TnSDDeh0F5GUtBC0XGRTAA38rn5oDY6j4sVEQFA1bN\r cFne+dbr6YZb3PtWAm684Up6/ImD9Oyzh+njH7ufvvO73mWaynDPh2DPZc9wXHvNbvpP//nX6Fve\r 85UmqYympkbauGEN/eqv/Yk8XNjCzuziuQvU2l7puRmcPRWAAsIgNnK0OI+eLQXOw5MpWFYkVlja\r 0sQKnJAeJbZBUp5PANtEZru7RujQ4ed8ywN14eYtG+n4NKbSKjDrB33VSOdaGrqsuvKorJAluqxk\r TR4w/MOwiGDcZQXIQDvAejzfIReE2YNwF6FcOInMKjCOpVLij1RqzKPVgSd3u7jSR981Lk74ooWF\r RZqfmqepqUm5G8MAKNLirksXKcSYxxlxfnjYD44Dd7e9u16r+0D+iK3rI+0SMZ7tc10kHGMq7Oor\r 3ywOAnz3lhu064kvLrQQcGetziSkl+4xpnnDd9R3ijNDRSrdQOag2rmiHb/Ila7ta921XyEx3lAn\r ZcH+JSBfF4yXoHosSgcsLmLdp1pqbm4OtqXB5eeCyeN9JvvFMdHjkh4rZ6vlbsfb9ZiW38J6vAMd\r /6/YYZkRtkWrAo4TTgCVMrrnwMPpoFWD/NHaWJybkTwWZibpPMZN+DjiNbyYyYb/A12DrgxIg3XA\r Zmdm7MFTjOGgnPofaDnN1mLMKsOSKcNcDid3OrRM0LUFGtN98RZE6ODUcA5jgsHoqaekyw1Lsks6\r +Z16njPBW+QVeJEhlpsrDfVcho6N19IcxkGY13GRa2QxSBZIF7KOf3Ba/i2uJYIxNcwwBPTZETzh\r zhUpX8twIsI4RGQxyg0wpvSGm12rN49/+Pvfoquu2UOPPn6AfuSH/rtJlwdaHz/+E//DuDzQlXXj\r jVfRP3z4kyZZHt/5HV9Hh4+cFOcErFqrXeqVgF9e2AaDgk+H5NCAh7E6j83U2I2+UWiCFf72wBph\r NrFVYJQwE7cxMG1snFrJ2A7AyWWkoNxeKd5GJt3NizR47BEaGsJsJLme5H0Qt912Gz1+RudrowUh\r LQ8G3smAabeNfPcIwHngTgfl1OdBtHsLA+UgcKeJGO+8EMcCJQODeXgwMIx3QIrfovpwAYkUAuPB\r BR52eNire+v1sv/G1m7pl8YFO/T0P/LvqZU+18W5RXr7l99Jn3l+nG1v4osXr0KtZcfhXlKkXVc6\r i8yVI8Qii/arJDaoPFSHi7euoVVaXlhSAne/uPMF4nxMIGkcDd34hcM0ya0ITCBAxTh+/nmqrW8W\r x4aTT/eHIImwkdhn6WRe72yAYKfgFtCDv0IHDjwn8oaGenrta19Lw5tfmDe36cWVvcSY9yKzkMgJ\r nd50GV5XNObzEwPuLDr31EfZCb9NWl7onsFdN7qv1l51J1tp9w/GaOS5E6ZdfujWwgzC1VfcIfJn\r Pvw+PgZcKdfXS6u7ds+7zBb71XwkIWKfj8oGn79fVD27XkMDhz7DMpIxEX174s3eDnlgtWA8b6T/\r i+aBmxd0Oek7ScRS5E6vPLNejghxkGMhRbRCnB4OAi0L6DGWhgdiVa4LNQJoqXduuEKy8G+1ZEa7\r s1wXjuYniMhiBINNjRfooQcfpEOf+QDtvEUf1ixDZ8+raXJ8kv72b36DvuadbzFpZTz99PP0P37r\r L+iP/uD9Jsljpe9Sx4ysn/6Z/0X33/cXJqkM+IQE7nKr6DzYcYjzyEAuXJ8oTu0vaUZsoxA2bAx5\r O0HODshXCh4Ze6V4G5kAMxefo8FBdR4AlrLAswB558EVHFdoaE0E56Er6eJX4unxMueBdaFk3ARK\r s+V7z3SwnIOrZOM4tDpiXgMuCIzJ4OJD6wNPh9c1tYvzQPcB7nbnuQVC83ifQh31nzsvM2P0pUxb\r uGLeLLQ8Sd63VYLcJeOu0AL2E9+tilxi3FXXyyDzxQP3ih26AtDawMUIx4HuFAnc4sBsIzxjoOn1\r zhtpMKiMbhncXeOucdXeO6TSQ0XYsXafzPeXO/U6C7Zvn48vr9HCo9vObESuOt5Y4LJzPDk5yXo+\r tAxMOhjZ+s1mu1yw/ci+mEd+LE9bGgiq03KYrelcGYJdrDed4y0PjJlhQgZoHKN1176DBrkVgNbv\r xLlDMklAxlQ4DaaN45ijpXf+mbt8fnAeWGZjzZVvkanjTcc/LJMIZFruwjzV7ft6LT/sOdZ0IXgd\r aA4YbO/d81qmMUPrdg6voeGTj1PvzlezSM9rBJyTTHASN1mCy8g3PFMsl9WBJT+c33qew1Z52AYe\r cZwvAl5rO3b6aa9HawQLKYLHK7kxIwuAk5E12hjowh098yxylfNVWivMpC0RBENEFiMY9Pf3ywD6\r hiv4+l4G9971J4RHfd/97h/mekhbxMvh6qt305bN63yLAVCnGnD3J36fvuqrq1sBGLjjja+Wlnic\r ZyXwGRrGQNxPhzA+TvyXps7DnjBXI7VUMk5lNEf4+z0KbFSUkUdsmt5vDGobJJFOyKyGt5EJ0DN3\r mI4e1SeZ3cKDW7duoQs1OlsjdR76fnIMGgI4yaSvHTob/0D+OmV3q1SmEKClIRUzwD8Ys6zwznAM\r AMsBkICv0u7iSC+ScME6HRwGns/AGlXossKzALhIMaaBCwJrFzX//7SdB4AfRfX43/VeUu6SXHLp\r CQkJJYVAQugd6SIoqIgoRZoFUeyCFbEgAiqgIoKAgNJ7SWgBkkBIIb23K7m7lOvt/z7v7Xy/eyXF\r /w/f3X6n7Mzs7O7se/PKvGnZKvX1TXqtNBPR5OXkyq6OfMnt75szud+qYabAjiOGcC1HXlE85Ed5\r iCYQ6zHzRREOkUB80tbmnl0hrFlFg4S9TEBiWslt9rU+IiksvoizBzwiqaCnSM3ItDwT+4U+IbrS\r OG1YX0yUxaHlCa2cnwMx27lI3OXlwpFq74fZKR4A6ta8JY2NTZovMnjwYGnOGGiTApulaiaLEpnd\r B2u6cGCBB2dE/5khMzaYNDA2GqrX6z3rM8jIMSJIvu3nktcnesd+H6E/5MX7qI1G58O56N6sblRO\r y5iJuMZ5f+ShX8FooO+ow2T7uvmCt9qga4Ko8xHTFu8LqyTMhuFW1817ytY60T4mvB16z+imjGux\r a/k1Oc/h14/6Ev11L5ej7z3E+WNrXjgeJjrkApiHFypBZNwC5Netw7usckI6pqlHuwZEozAkuqez\r ikqlfuMiw1UQSF/7sdTeZXpmvt4TJtzuiJHFh4QW12fBuKQ8RITQdSLuoNHBLuRBFO0d/GSTfgs3\r Xv8ZmTZz79vPDhpUYs5ZX37tXXnpxTfl0n3Uh+D/6uJLvpdwiujPOwkjhpfJn+/6j4YD99nn1ehR\r 5XLVtT+Tr1z+6Shn96Cj1CE8E4hHHCjQK/EwiHe2l7gFey4T/+0NbAAFsGi8rMb9P4LYOYv2eqYL\r DMncLJs2bTCioROwyDX7SKnLdEseJx5YZqQkiEdozJFMIB7L9BwIUgzZ2AzRCjrnYcgI0BfcpgMU\r V9v+YeihIS/eykehpx2JUCZ+HuQDEkBJj+knymS4ENuPQ4mIm136bM98U+XmuR6kqV1aGlqlualJ\r Ec7QPXIcdkR5dr0Qj0Iza9VrmF5DQ1eEp9nK5IZta6RFOaLKj16ysii5IRaYtJI2TkPTPEtmz67X\r oN1oxh3FKZuYhZMXXdvzQzxN7410VN7q6aHndyqRYLvWnVsRTynRINRyvCtmnhAP+t7Y6Hv3MwaK\r iortnO1NHl0Ti51CRcTk+THBDlbrh36gFMbih7q2f4s+8I62Rp3dr7M8rsPCTTM51joQsF1bV9g6\r iZqVb1u/aKcLR2L3k4x7fuw+Nd/yongoG3RBfYZPU2LynF2vctHzNi4xBa5Y8oJZa2G1BnfSULvR\r uDAsr/jSS0pKjDMp3f94Mwnetvz12LX8Gon+REd8/IR8dDQcxGvQqem1i4YcmCiD2EojURzdiNZR\r 4sG3A+dMfzXTxj3Pz8uSov14Ojof5eWXH2hbrZp4VvMwDsHLL8Xz+kM4fd8M3hdExOPOiQAQEuOU\r tDzfN9+ZJQxCqBCL9gSdJNbXy1FTHY/sC3z3O5fKjBkHy/wFy+T662+JcvcODz7wK/mUci67g6ee\r +J1c961bo9Tegf1F+vcr3icuhOf8I54Dh77WLkA6EI+M4sGSZcQjemoWeJwXGLJjEY3amQh6lrHf\r 5E8EGo+S8doejZcDGDhR1GD35T2mv7EihdmdUrFuib3ooPcoLVX2NsfN+txTKus+9IPvhXgEpbgT\r D5SfKTbTtMVtWgeugwVkicWBep6tZnPwZ2Qd97zE4CfOXywdPsaQJg7XgRWJOT9UgpGlrLttWaqD\r ng8PriCv/zDjQuAuhvfplPUbN9l7BFrZg7xgcA/CkUAIcQTRDVlAOJjZYc1CHO6DWSyLANmnHesu\r OA23UtPZrM7SWXOSqjNxOBR7ZprPrNytY/Kja/i9OaIKcQ05F+VpxMtp2jiOqAzncLOPGTIWTBAG\r xIMgiG0rXpf++x2p55e5XyQtGzgI2ktb+2/b9hfgEvmTvmjvkHUD1n50MAlAzxXq0j6zf0fo9MUP\r ZrsaSRymoMVowtpBqeuiJxZt7tiIzmqKrQfBKg+OaOsHT9h44R4QtWirVpe2rC/R+PD8bnmUS5z3\r 6zFmQwgy5DwTHUyAyYNb7FP9sqxft87MyjMylWvMSDeCApeCGAixK3oN40hKsdzSayeu0y0ehfyZ\r C3kMNEKciY3GKcPKdlzmQJhpgUkGs33WxWDeiy4O4wst6kC1qG4yHQERu24U1x84e7wM1G9aJJn6\r fXAfmPkyDvk+cbjIO+6NEyHEiINnhKGAczH6Puz5efsJiEXjUNK5QbIyOuW66y+RTOX49xXOP+9k\r W8Px9tsfyNFH7pun3Pz8XLPkoiu9lcfn1ubNVbJ06RqZOnXv4jQAV/JfuuyHcs1VF0Y5vQOvo9OH\r XVcgLxCP9MJBkg2yCaUs8HjiNzqViFhWIlMTsXiU71nd8mPJRP0e5QA92yWrS8XwY+Ax/Y0VIZG1\r /QOpVOTR5n4GpW+fQnNhsXR7H0XQDQnxEzoPxCsBAvHgXH0X4gFSId+JB0gmSTy0Hoo5lHokLI97\r 8JC0f4REk2lCS9s55SrgNIqccHAKs0jWoATiQBkU4uaLS0P6kr72CVm5crVk5WUosuqwWcPgY6/z\r NmPX8OsTd+STyNc/LKZI+3oNFuVpXBEMM9hSlLWaxnW2L9LS8lWsVxhtM2AW9KHXwOQUKyBHatGo\r 4zL2w/WTcQ/ieQTWOyIWBms20ohqTJatZXjmlNix1WeUQKFyfCAKDz+KZpxLZNNrvzb3EBkZabYG\r ZOK5N7sBQQL0StHlAThSjCdsy94YmJI3AtpNgLI14VoACBMIaZsda9zytQnb74L8geOsn77Ibakh\r Mcxe0QW5mFt/QqhHIi+W313JTHrrh08b9wlxZcc88ps2vivb62rt+WZkZMqhhx4qdQNPM04RwGLL\r FlHqH1wlF0Pxbu13ojSMrhVdr7c4ngKYTPUZhZL9DZs4sK7IXOIrwKGgu6M8e4zwDqyutoEVF/7A\r aMeO0K6GpImFfE8TWqYduzYslLwhEy2JiDUtPce+w+Dtl/IsPmRsAIn3EcVt4qGwc/NSex9R4xHE\r 4rFo66Z35CfXny+XXvvFKGff4cmnXpMzzr5aEJK3tC70zH2AvW1A1X/AsVJd8UqU2jvQ3o9+8BXj\r SHYHzO3i34dBF+JRoDMQIx5xiNeIf2BRxIJuZRLg8fhvAmLJgCp6Bz3X5XSXiuHHwGP6GyuSld4p\r xS3LZONGRbzRSy/Iz7EtaSEeJgONiAezbPbmCLCvxAMw4gEG1H+sisxCxDqidxeQNIeluWPS/kYS\r 58iPzqEoh+uANUdmDLeBl1iICOfZi8MW/m2HeJSbApWy/fr66vmO9g7p1FkmH5/P+vVa9COK25EQ\r pSTz8XjK+g36Yaa3ShBQiiNuwfoHgkI55OaIplCEw2HQFs8HpEt7uA8BMZJv7dsRiWQYibF4OJIi\r nTTZ+v7jJoaC40M8VaAfPzoIxEkQE/oEQiC+U583ca0s+f1HGgfB7nvh/rC4IWxq8r1dAjBxYJMp\r xHGNSux2VHxkhGhndLCGBRFdSHOOI4jOQPa026kcBiFm1Fw7PEvuhQMzZkLyOKye3W+q3Rf3x33R\r Jq464BZxgMnzCOKvZJt67Sgenqe1bXl+LqQHHXS6iZFIDzzoEybuwmRXMyQ9PUMKCvJleY2bMfNu\r SyeeJFU6Sahe+qphCxNtTTjBXOeztqfLuwzX6SXOpmd9x8zUeIr005CFpORTH90IK9oZu4wxiCQT\r IOL41ApWXHCYmmmHfR/aZ7sGf4m0pZJpPRBptSGG0qRNcDTE2zQEDG/JlC8sm9iLOMs9CgSRFybW\r iEO93QCxeCyK66PjpjsR+m/h9NOOlmuvvtCU6ifsYdV5d/jJjdfIj268w+J4Vqit7aqMf/ThW+TE\r ky+PUnuHm358tXz58j27SkQA0AX0tSeJR15/28PcISrZ/Xkl0vGWeCUBNNatjP0mC0SQzIjX7rWw\r JuOlE9CtrMf0N1YEyG/baA7jAIyTcrLdPfu6ljLbxN/1FRCFGmWzcS4WWWL9F8TD2rDBLCa2ytNZ\r twF5OugJ7dASDHYb8NEREADtEYfrcOIxWJqUuIV1G1iv0B9fv6FchxIOiAfn+SjD5k2NiiQhkLgo\r SM+JVgxrffuACfXAzBdkE8+vZ52AhsWsGjfC4e5EQCROONxNB4PF3IjQjiJGuI2S8cfYOdY29Gct\r CfU07QguQnIhL7qe5eFGgXSE6K3N6PzgKZ+0c3zsHMjmOzrarA2c+XXqDJ22IBQoZh0pp0m9znzZ\r fGuHpjErRvzFgrNdijB4A0CYSLB+BtEa5dBPIAoqGnyAIhs/MC3OVWIa0uajS8tQnmdP/SKd7eI4\r kHfaosgfsQlxCJMRE+1vZ3ubhcl792fPYWIwbTUQFThORIOml9Hzu7QN4hDKisUvWl07DJnrYc+O\r w63QnMBE6aiMp9MkffnfIx2Qu24fd/DhppeC+6hY4m0PmHiKrYivWvJyhMTTbE0JHgysrXi7HIm4\r 35tmaJgc13g2QDdCvGbVHHOLoydtzEJEWpVTtQlQ3RbpMxIrLl9XAiFBx6c3GLVJGP9ueJtRWsPE\r N6WQoe8fIkIKkS8RJopw0U5EIBxdiYhZZOkZJoJYcDFucAOPqM0aSEAsHkXLBvaVQTH3Jf8t/O43\r 35aJB4yVV2fPlf/8e9/Wchx++CS7PLoLTLH79Cky45AARx01WblsP78vMHPmZFtcuKfy+gaSQCIQ\r j7ScYskqVYTBifBULIjiBvF4BJrVJbeXIp4XP9G9UgQ9ygE6MKLYnmB3ZSaWNkjV1k3CXjnZ2emS\r rmO9rKxMKtNGGZuO7JPaNmtWAJkAtvq8N+JhsnDPhz0GksQjxXbiy49mwp7Xc9CHgW/xqFw4Z4pE\r zTPisZ1dDgdaiNkjZc3hIVyHiaxcR4VlFR+l782xSdIGT5e+ffsqQvQd5trbO2XwjllaNCCv5AfJ\r gZtr5N3WrwSCg6D4Cl+4jFCe2ThmteZjSp8Jcutdyn34BlTerpd15JIkGhGCsTRIR+NKPBwBoXNY\r JlvgOPRZk0d60/v/0d6zMK7RyvQZOc3b0GOHIlVb0ElZfeZwByDzXSaOmCCt+tFDCLSiray3cPCB\r RlS5TRbPYYEX2mOWHg7ra3SwUj4jCx9g3n/ceDjROMCeDe3Sh3CNTo62VkX4B5o+jfrcC0QGd/gQ\r NaZxwVqso7XJ2uL+vL/O1bCrHSYu9IG9WGiDGTQuWii7RZ8NeiB7jtoO5fQn9v6itMX9IL5qzQZp\r U6yC7gNx0uYNPhEYcIByJwecqoTkeVO6W54SkYDQQ30fJz3b9Tjvm+fkR4jn6BjB7JcycCOMMyck\r MywPqzBfhKgcyIYFNinrq8Qq7IZoYjNemh72R1xDS0f54eDP4hpCRFqNiKQ4EVEIRARRFaWciLjo\r E1El5+2eFIibBaEWZDJpkQT4NYCi5lVy/VfOltzipN+8/x948P5fGRfyqfO+Js3NLZ65F2CBYeBC\r gNWrN0pFhU9qgdtu/aaevytK7R0QYV379V9EqZ7AfM+U6DyiQDxS9ePPGchsRxMGUcQCj/uLsahC\r 1/OJbGLdyniRZAmDWDpeu0c5znbJipdN/Bh4TH9jRUjUVy6XrVvdHpwZ1+DBAyVnwDhpaHWEQBmc\r ybU21ZldOcBg8e0zeyEeEbeCzJ8V6oF4UKdp27oY8eCfj4uIH0HRyZn4wCfOH1wHCLm9qd5moCgh\r WbVLiD8puA4Qi3MgmOQqEVGOA3NcRFeIPYi3pORKftNa2+9C2FtECUhxcZG09Zmg33ryY0d8Y20h\r GmvcbjoMxEK+d4Y7KUxJzzCrr7CfBtwGykUcAjon5spIu48EMuO+QX5+v572/ERaD2bnLEijTpHO\r ABHhmOsXTbP4ErNTlKHuNiZFtnzwhCnz2RSLvm7HhbiWLVTkjHm165x4hx2mLOZa7pKFcKCUbn3Y\r 3NYE7qOkpL/0OeBsa4P29374fSTS0Xv0gz6X2vUYR37NUrPoI6Qe3G5KZ4pxTMxqQVgYIjCusPxq\r Uu4FRS9tk5fJPi16gFBZR8Fz3vz+Yyby4iDNdSAmmBCzD4f2xPqS6FsUkk7tbJM1c/7FrZvjxLy8\r fBl4zLdMN1JfucLeLforW0Oy6Dlb4EmcNugTf9wPepEG5UDDWh9Mf+NlLK4Qrmt/FhepXfGmTczs\r /UTl0If0G3WYmfGiV2NdC3oQiLXpYnTCgoky4lwDLuWxKB7LCNHoB+V6q35XZtyRnWecKObVbOSF\r pVZ25FvLPEPoN4+BA+cZh8R5L0wyGe/BKKEr6GSvfav8/jfX/VfK896gpKSPrFq1QT5cuFzefGO+\r XLSP+5ejAMdX1sEHj5PS0r5KRDZIbm6OuSsh/ehjrypn0XefFPSUeejh56zN3sqbCIsjEA8SObaw\r jQQQRSzweCzaDcIQADTWrUzv9eI1Yid7K9clr3vZZNpj+hsrQmJYzlbz9QPCUA7PLK/ySsZIVYOv\r UPUKSgyqV/lMR6GH2EoHMx9Gknj4BjrpcGzhY4fFbWtW4oHyjX5wZ0lE0+VD1o/bPnD7yJNx3FMg\r P2fWH/wJwXXkGhFJch0QCiMehP0jlyTKdZiLdY17e2mSWjxCWttTzKUJ0NTEuofovCJvZpJYwoQ4\r C69wfAjRoD/4mqKscx96N6kZ9mHTP6xVQBpsxRva9BkwRMNnnUmi4YQaKyNm0eR3tLdYGoIxeOq5\r SjzihI3+pflMXa/LM4ezok1ESJxva9ypg7dTSg/CBTvPFQ7iACUkepQfoM8Ps+bQHn1xkUtNTY2N\r ASA9PVX2288tpP77w+/J+hyOeL4emmn3wfMlzjk4jKJyOBw3b2XmTZ9BXgUDx0szpq1ax7goLQvh\r gHg7MV1k7doz1zZBhNs3LrC8sinn2kJRu7bWr17+uhFbT3N9noH2ZcML9kxREvefcKoMPugU69ug\r g083XcnWhc9KhR7UG3CgcyS4ReEe+C5wnUIcbnPAhJPMmAIdCeXJt+sRJ7TrdsvTo9/YI01MjFiL\r PBZEshARsS2OGNGNkN9XOR+sClljg+NMnDMy9pAM6MUS7RFqJPl9aRjShKSNE9lZYXnOifgOnEw8\r dvBcyddvmffgeksH8ljrBRSW4RHYJ6J2jQjK0rbIJ06eIfl9XXLxf4X77v25DB4ywERZP41xFnsC\r lN73/v3xKCXSt2+ROUsM8OTjv5GTTt33xYVwIXGuJg5GQALxSNVUZi7yfnvc3SCe00tcg551AiTL\r dC21m0o9yjkkc2LnupX1mP7GigCDMzbabLOlxVlB3HYPHTZEGlpCQQ/NXDeyuEJZGYgHjg7dHXtX\r 4oH5JbMZJx5KcJR4pHS2S1ZkshiIhQ1e4t3DXs4h5y0YMNpCX2eBvsOJB8pFOI/AdXCuqW6jEQxf\r Tb7ROA9rK/YRNxQfLL5PtHXbnoPlV68zhBzK2qIzHQd52oZG9D+JBJmB0l8IByaebgo6OoHEKEM7\r 4WO2dAyJcsD12foLLQfBoH1MgBEzpUZlvQ0X3Wya95iJpFjrgQwaV/dwX3BITiQONKQLZwQ3ZiIn\r Q5B6PetT8vqGwFnso/n9Vt9hHpchHACrsNsnfzdRtsdhbe3p4Drxa4UjIqSJw4lXvG+a8LJRO6Xj\r j7fziIzIQxxGOZAl4w5PyQWIt7RMvY5RF3EVma4lvC84E/Qs1G9tqBFc3Pi1/DzHplVu4cOYbauv\r UkTTx67r5WKEZFGSkKTnFloIEUN8hq6k36gZyoUEXUyqxl+2kH1LaMdNrb1dDvpt3wXxKA8lO3n9\r xxxheUxiEGn5ZEHHvxJTF+O5Z1/GP9wYTjd9zUb0DcW+J0sTRnkWi9IZyoEmiUipWbihezECrpwf\r 5YyIsFBYiUiwmmOcBsLBDoiMTQfaVZq8YYOMHlRk8Y8LZr3yN8PPP7rpThO17gvE3b6ztm2WEiA3\r lnD4/ne/LHff8+8otWcIVli96UJSA/HIzs6UIYMj17/+LBSiSCJNVBO9no8V6qVM/DcBsaS/3gDd\r ynG2e9Z/BSlSXV0tdXW7DFEAOtQlJX+YKPNq5wH0HnHiYaIqPWfig4hdNft8iIdWgXgAgXjg5bOz\r tVEyIy+y8cGbSBNGeYkwFmd2hb6Dj8i5Dtw8bNaz/hGZ2xEjHuWmdITNh2CAVCAibmWS/DADQslp\r 367RNFOu8T1DQHzV+ChjxSAccBxmoqvXYtEfeg1b8Kch7sSxoKLdhIWVzpIDYrTrRciHMMxySaOk\r RKxCPjssgkCylLvaPB/isNREE6EuYix0HxA2PubyaZ/WSU1fi2MCyrOCqzDXMVwrcV2/liasfcLk\r eT2n957onx7cf01trcb1YSi0tLR6vejYrjPRcIT2cBEe8nZW6kw0XnaTH3b96JkkDi0TvzaHlYva\r 9byu/QvnibseJlUJy3GWhpDDvTAO6D9xFiliFGA6CdplxJgiP1W5uk/ZuApjgfO52+dLxQZ9F8q5\r tTfVSvouffeF7so/+e48PuigM+xoV06R+phmVyx+ztti7CrxRtFOmn4PmHiS9mONKdrb25osz8sm\r 74k8y6evdo7vAA7kTQvRjbAgM7e/TmQ0jX6JnRDh1nC9wuQpMyIofCfs9mjvknb4Ix59UyHfjnBO\r DycirhMxI5Rt66w9uJIkEcGlCRZbEI5gIKOciOkmISjKKWo/HVKkqqpKTjxCifvHCCNGDJHf//bb\r pg858cQveeY+AKvUQfoQkFNOnikPPvRsdIZFi1+UL1/+0yi1d4AL+e4Pfh+lkmAEhIfZntohW2v8\r AfGYw68HXXJ6hS7nuhWMNRGDZAYvMAG9leuS171sMu0x/Y0VIdG/dYVUbN7KfNrMrvKyM6R0oA6Y\r lEI7D9iiwUhhzswfaxuAGU6QdUI8zA5cq5iM3TgRJx7cA6uvzeRZn6fdUzRQLR3CKD+RttAtrVgg\r iL07MyryIR5wHeZVVwc46zp8fYe7IGGGxkKnLlyHfYxdDz7apkxl1etWS1NzmzmV21pZLcWt6yIi\r osRDP/jgaoTFXCAQ6iETxiMsRATC4X6YIlFV+PgNKUSIx67pyBARFW5AUHq6J1k8uPbTj3GiNh25\r ANc8rIo2zX3ElJeIagZPOdc4G+u7HliSEc/rP9JFPtF1OBcQUuKIpW32H92H56WZ7T/xzcUnK9Fo\r k9ZoERAuXnZs9HMW6mjBFQshaQ5bLa1pDhTjIZ908dBJisiGmByda3BsmHN/FF9s7QZCQ7+9P3p0\r 6z99TZ735xjuNxDkoYdeoMX0eeg4GKiInbxGCIeGBabrSZWM7CLZPO8R49ysrj7rbctnWz3SK956\r SNvT8aLTR5ToA0pLk32JQo0k4xqaq33ty8CDTjPzXwhJyYQTbZU7SJSJAmItTHwZz9S1Vfla37iR\r 0H7ssGtE44B4v7FHaZgitWyqpRMpVslzHuIBp4OejxXtjFvbA18nUhAPLMLgZP0biH1b+nYsHoWJ\r c1E6QzmpQESYpPC+AHRn4Tt0TgRxFivUnVjwrSQ4ESU4TLTyGpbL2P1GSMkI5eI/Zrj6qgulT59C\r eU05iXvucr3V3gCF+k9+9meLs5hwwIB+8uJLb1kaePmFO+W73/9DlNozwIVUVtaYPiUO+tZE1qzG\r yiJFSgqwQNoT8NCjaIhYkMhU6CXeW5l4MkCPcg7JnNi5bmU9pr+xIiTG5FfL2rVuHZWRjoK8UwYP\r GSYZfZILIzFHNT9QmkRM4Nunupw3PSvHyjFgA/FAhwLx8JXN/KdE1la+0jkMTj/pH0g83wd28gOC\r YHEu+LECEQXiAcHoM+JQm2068WB9h+s48F7Kit3AdSQ+yjgCiOWhKGXC0N6miFMJaVEu+2/3M+Jh\r Og/9CCjb3FBj/YFwZLDXBApVJRrBgR+IoUvbUZ5fJ91FVNE52oXtRxRiJqwZ/mwhfOWHnK/3iqLX\r xVNexxG+tx8QqKd7IKAIoYZzfp46Sig2K9LWcMM791uZ9YrMrZxebfumhTK82RdUUU2zJDsnS4nA\r wUoQFmp5TDfHRaa2/r442PuCMkYAlQjH+wLicQW9p/GEXKRli8r92K7tmu8sRX4YRGxb8UaSuGgn\r Ns192OqZqE777SI7P8IzsCO6R7sXjbPamjzEeUOmJR0gtrfskiJ0mVF6iD5rylKPdFu0HgiCkpOT\r bS7tt7zvepJAdDiXiEdhuD5xLMsgspj9shYJjhU9CXqQ/mNdFAWihStCP2L19dAfD6O+eZ63HfrX\r d+yRvhpdx/k29CJKPNwlvG+DAPLmm+DAMgzinttvhH43TrC08eg6fGvRdxeF3dMQEb4t0hAR4gBu\r ghKcSKETkezigRomORHW6wDoDzduWC9f++Kpktfn/2Z9tTtAlIUQ6vKv7N77bnf43ncuNS4EJXqb\r TpZqanbYwlng2GMOkb/d+5TF9wXu+uOP5JIv/yBKOaS+//5jiV2rqnaikAJ4yCHweCzaDew1RKCx\r RMIjvVaJQbx2z9J6dm8NKOypyOrVq6W5hY+F8aozxeIi2ZkzSmpbIAxiq8zN1XjUCMicWbI524s4\r D4hFelYgrinOiZiC3Hq4B+JB/wljH0k0uD3f9R0gUIiHi68gHpGyXGdxEAwU5NQ1Nn71HP1QUJo7\r 1xFY/Hj7Fo8h15Dnvo6UgESrf6u2btB7ddciLN7CvQZIoA33JEowTEmurHqY5cY/8EQ8QgLEzdcU\r 8egcbD8rnzGxRflJWezpN+nM2EQnyt3BdWklKRhyUKS/iNqP2kmkY9exo8u5NCO8G+Y8YPcNstYT\r RgyKFXlTJoShHXNfwivgQejYKCwsiOp5+4h/ioZN8nuJDhAYHAQmwsZZRe+Qw4kEC/00rtwIz5Tr\r 7FBiBeJh9T2baHHfKMtxqgjypV/0s2zS2RFB8YPrdeFW6Hd0YDsZT3teRGxDWq9fOCxarKfnkNXX\r 16y1Z4+5NCJdc5qoE6rSAQMldb9zZdCk02XzB4/roYSEetGzCPFwODFJk/yS4eZKHu4dB44m2tID\r 01/KoR9hW11rQw88AOPrCoISf3/hvIc8T0+HsY1exDgRnZyg6yHuyvUUnYBEE6rIqCSIfa09PPtF\r bRFaPPou9cfCkKbeLn1XpIljAQmYCxTlHK2cQuBE4HZoA/EqeRPKsyQnO00u+NwZVu5/AXjfZbta\r eOZ9XWAI5xAU4Ii03pu7SJ55dnZCH/LAfT+Ts87puVtib0BbcEBbtybNglPpFFA+ZqqFXcEfmkMv\r cZ69x3YPVqBb3SgZXopBvIhBspxD97LdK/QsX1i/2Pb3wFYZQP8xatQoRaA6sBRMbGU+myypXMYG\r +9CxqgJ5hhPoNoyY6EBDZh8nHnyYvREPQyDRLCieRzyEwfV64DzMXYPmO+ehnEjxILP6gHDQAh9K\r v9Ez9RzEA6Vj9FEQxj/4bnkMdj7agoI8SJcfqSn2PEyBrmUwQ05TpLlLuQ4WTrHVLvm+cjzWbjyu\r B/GwVkMxi+VhS49+g3Nm+qv5QTxl3Aa/aRmmv6EMq5IhHsS9z078QvscIW2HlgHJwlWglyAPV/Jw\r B+E8YRau8zWEMLBV7/ZNH9qiPD1pMzJjx/zV2ASD58o5c3OhdWzlN+9QERFrTwwhWTo6tO1wOPFI\r xl1f5O+6ZWeFzVARc5HHeeIsgqSf1LE9vXm2+qzgXDa++6AUDztYqlfMViL8lBbpRlDs4Jl7/fh9\r Q0TLD70gUY7zhoB57nr9iueutxvGkARgjRCImInKwANPMQS6+f2IkETEyt5LPG7Xcv0IPsHKlMMc\r dOBpdsCRcF24kZLxx/sY0HTphJOkr3LT7GNiupqobxZae8l0PA+dB5wIB+OI0CZS+l3AhTOhYu9+\r IyK1TL7cYjEQI2uTl2xpYv5eNJFIE+brGGwJ0gDWW+1wH2lmAaecCBymg347+q0YMVEuhHVTH374\r ofz2psvl7vuSeob/Bfzz/pvN99Urishf38MCvzj84mdfkx8rEcGM9wufP1Oef+EtWbbMpTIsLty+\r 3Z2J7gv85a4b5ac/d7EYoE/XYcOKuVEsAp5vBBZNpGMnuse7lYn/OsTLxMDyep5I5sTOdSvrMf2N\r FSExPGuLrFm7wRbNYbnKQy8rGyyrGsMgYDZRadwGgGiLgYg1BqKG0CDchinWdYDBusaJB2aVLsZK\r DkI7YyED1/PsjzCKkwdygnC0tzYlxFbE7YOBHUdUpTMqRCl8NOYETvvHxwDxsHb5MOwD8bh/cLSf\r RMBsJ+tO6VJkyGCU8/QN/NFpK5A7O5TrUKLJ4j+uFSxm9kg4ojj95vmEfAjHpvmPWhw35pTDNDKv\r 3wibtdrMVdsvUM4kIKBAOEK7hKQD8gj5lhflg9x3GBI+2EQLIEwtaOchEgFRY4YZ4iAhs/Mvxm14\r qmyr3kbgoMQDZJrb1y3ZzExa30efYVOiPqS4510Nd3dkZLNwMkrrH+8XYukX0X5pGsIRvyfKWn/h\r dDTuffVzTFgoh35r0KSzZP3b/7D7NZ2L5q9/x0Vyybai59M9LwoHHfQJu0a/ccfI1grn+jDlLipW\r bujQb0lWXl/ThfEs+o1mdq/dTunUiQALFN1qLlzD4npY2zGiAhHcuog1JKsS3EhD9SoTjSJShJul\r HK5RMNpob2vVNvVCtGNt8/y6xrkeIlozn9V4/zEzTddiEyl9Nja50vy+ypG4STvfUbNPwiAi/HEN\r LWPvw+J2c57PjXKtEGpfTGylf0w2+C4cdCKA2yAlIpw33WcEiOlqt1XL4QcNl69e+1l59LF93wXw\r vwWkKE89fruJso45ft/8bB166IG2LgTYb7/hMmH/UbJ+wxbZtq3O8n70g8vktDOutvje4OIvnC1/\r uOOfhj8AfaK7Ax5ugHg8Ap53FDXoVsSSvVQLYC9st6Bn93Q6Ai/Se0Fs/OPAPg91ObgW8PJmcaWI\r kyTiKvsIFLAeCSa66EBc7+HEI9iE03e84boCnZQ2Yh2m3x5afnTOB3DIV2SS2DmwQmcvdYasYL9x\r mJckHjqzMpHVO7bQjBlR8N9kHxz95aOIjhCPi65MVNDZoRyVK8g3tgw0QtShWAIWlg1vGAJwH4hg\r mEntC+EgjlUV5sukbfUu+g2N02fyBk0+y5zPkcfaBY1YvAhRlV4rQeS4Fw1Du93zAnIJ+YjZLD86\r B1LmGHb4xY6I9X7qAuegZQLSpg8QK3OJwcZbzc2SmZFmnAf0p7S0ROtPNmTdd9SMiFNJtTw/pnSL\r TzECEw6eWyKtnGSf4ZPtSM9mj3e9d+0OaSPQelgfyQx91P460XHiw37odZrPuhh/7v78qEudYTMu\r kg1z/mEEhYO88IysXHQEbo44XElp1X+kSScO7HnOzffr59Zs4Tln5DpXOGTqp+zQTJvIhDa6vK94\r XA/cxww6+Az7ZlC0Dzr4NH0u++kxVor1vZPPJII2KV+z8nVTjiPKDG3E2w55hHDFTTXrTS/ChIeJ\r ESJc56BpD0sqXw/FgkxW1QciogXsvJXT5xzaTORr6Od0IqDfGWFIY8yBGx++fb5RTkFEGmpxj+Nr\r RXJ3LpbRo4fJ8krXLZxx+lEyaxZ7mvxv4Mgjp8qRR0wxBvqmfVwbEsx6mSghyvrNb+/twoXU17fs\r 82r3k088XL75rV9bnKfYE3imEfjDjBIhYkGsUG/x3srETwXYQzmHWKJH2Qi6lS+VNVKpMwL9dgyK\r i/JlqyRd0eOu2zgPTSbNdSOCgeghisfFVu5Flyq+JsR0Ilo/DDaLEdrBIPV41xDiwSKoyTZ7BwLx\r MLPcNe8Z8QC5G3uOrHf04fZxQ9iM8wAZRR9A4BbChxcOBryLCHS2j2WVvmbMcpsySqQTU0y7cqc0\r NOySgfnt1ibu323fkxj3Em87xOGSmJGyiZW5cNE8ng/XYoZGf9ERWJ2or6zyNU4jQjhx5belLc/T\r 3fNCuZAPAgGJD5uJDFjzDfEusLKGgLUf+KFC8Q+h2L5Bn7eGesKR/vBDrCxqINadMJUryMuVkn7M\r +JP33vPwewmclHFTvR30mfu20BFfIDia4X2wfiiB0X6x1Sqhv0t/nxwQFQgDim/uCwJJPmPF2rZy\r Lu7igJiQh+UX5RJ9oVwUkl6xwhfCMZOlfp/++h2E85SNQsoSh4gMnHhSMl+PrvHkRCDkE8JxYOrK\r YkQ4kjrltCiDwcpA3K9oGda59Nfxwspu9COhbnxc64+FHDklI4wbwcFinn4Lbc0NxpWzFw7lIYhO\r RDbrpCDdPCskiIi1Ez3jxLca+ux5Vkb/cP++y/Rhnsb6DHEVxhMsOATylFtFJwZhWbF8mXz7ynPk\r lNOOM4U1SLq9w637/lfw/DN/Mi6EtSGrVq73zL0AhGPp0tWmS0Ei8+DDzyZ8ZcGFnP+Z6y2+N7j7\r zz+WP/7pYYvrE+wNeKB7hmQJHnwUjSK91u6SGSUs6Fk6mRM7162sx/Q3VoTE8NwKWb58uezc2aiI\r WG9QWezBY6dIGjvHKYTtaEO9jFw2iwoEw4kEYpng38p0HooEiPOHwjwjWgdCmkFmMRuQxKMBGTvs\r Q9B83FlDPNhXgrQp6xCXGPF4N2LDN2tfM2xmxQyLAW7WKJhnxj50a5Owy4ebZoQD8QAfFlwH7L6Z\r 5ep5ZoLS2aazT5zsad90CtO4mT008BrsbcXbjceDqApRjUYkI6+/PRu4o0AosGSrx5Y+uudiJRqE\r 8cOoekhHfedwsZQemxYq8nRldpe6lFXCg9v2gPA62poMUQw/4otSvXy21nEiwYLJ8kM/Y2WGH/El\r C0Hadk965Mz/gWzZskWamlqMA8nNzZWGyT9N9CV+zXCYRVIsHcrQly4HebGje/n4wXmbIGjoxM2J\r Cu+GsGjoQQlOhTYgJDl9ENmkWX6fEYdpPgjcnynPduiML8Ty/HDC6AcL3bJzcowD4+Yzp31H86P+\r xPpp1+SI7ike3/LBk7IZv2S9lLFQ0zjgZDKG9R0ONSESHa3NRlRwA8I6GogJZbECHDjhpERbFnY7\r 9CcK8YF2qHIvbwp74JCHWJJnhnkviyL5nvBEzTXNchEiot+Z9U3L0Zb+eNy+4Sg/+p75w4Ovre/Q\r dBBbcT5YYwG5+i7Sq+bJ2LEjpGxoVzcfxx4zTR7+l7vD/19AdnaWeewFLr3shxbuDTDrveLKm8yk\r 95yzjze38W/PWWDngi4kvthwdzB48AA5ZOoEI5b6RnpCn1weJo+LB2pRhShiQSKzd+hRJhm3NncL\r vNQougfYXZGDy5pl/vz39SGgIPStaYuKiqSiMdqSUiv61rQOyFUhGrbiPCIerLkwLkTLouMwH1jR\r oNqTwrxHXA/iNug1n3aZPZHu6GiNEY8hSeKhg54ZlBMP50CaapRVp16Xj9Tb9biG0Tl8eEFo4FbY\r ryLsAGjeRrUO8txx48ZLc0ub4grtBzywtPdoq3vcnMtpfYis54OMMHmcaM/E6usfGwGlprtbjgQi\r iPoG8jckFm8/OiAa7G5o5fTAJQcivJCuU4LCzJrr4w9r/Zt/k3Vv3Wty8KA4Lxl3rBMJbQei4nWT\r bfp1/blhgdTY2Cw4T8ShJsg09MX6S9mon+EI7dhBGSwzIvl/vFy4Ro886mjcD+9XvE8JJK/PqXjY\r VD2fpvczNbonP8914abW6f2jA7IFmHpu07xH3fIr1pf1b99nLl4qFj9v3Al1t79yva1kbm1ttbEy\r YWJwb9+V0IR3xdqNjXMfsXj18ll2HdtDJLJAs2tF9xWuG/qQyNM0u0IiyuKdomRnU6pCnQhwPjE2\r dawiFkq0Y4dfw9pKXMefHS5Q0GsRb8P9fnSORYBYTRoRMTGw6xJ7JSLWvoY6dj1fr2Fxzdc/PDi3\r RFaCLNaMExHzyqD5uG3/xqWnS24Ba8rcUims2D7vUyfKzb/a/f4c/1fAYy/oHsuofVWoX3jBada/\r T517khw67QC57vpbbDwAcCEXXfx9i+8NWFh4w/du7Z2A1DZ08hh3AzzaADzsKBpF4r8J6JY0sLw9\r lYsleitLulv5TZvcyy5Ha2un9O1bKCOGs97DThvBCKIrftCBgJTwlUQWh8tjSbj5LqIa7hidh3vi\r 9MFFSMHEYLQ4g9zT4SMg3zd/8jTsNKa6SeLxXpJ4oMRvZbtZZY/Rd8ClGNGhTa3fhbX3MMRZp8KM\r CeKBhVNY0wHXQX3EdIQDB8BZiWRlI4YRqdmqHEP00XdvF1GVux/H79REe1aGYLQdPqhNc/9li7ns\r eYBQtQ4K+yDeSbYFQvI0dYmD1OA0OFAe9xk6WfvhimTENVjaaGEj4szMhx7+BUME7KHNbH34zEu0\r HX8e8SOOROOHn3dEyQ6UWtMMLBqb2qRdKSmWTnUb3hf2uFg3+y7TleA/ipADqy9ru1v7dev8PAcm\r smtm323WYbWa5pqEFUtesjBZL4msQeDer9g9RM/IDr1eEH9BTBDXwVWZWE7rQkxw9heX7a976+8a\r pkjturky8MBTjSvB4nD9+vVGOPy56bMuZu1TdM3ovuJjAbcxGrP3jAt7PSllk86UwYecL0Omnufl\r 9dg8//Euda09Dk0TRzdCuIvthSuWmUiLA+ss9Blm+ajjFn9qOGY0EShtRQcWg9Ze9L7DNXJ1rKEX\r YZIXiAnnML0lhFtDlOZExK2zaiOHm9YGo8CeNaMhxMmnfY3rX2bxQNmlxJp0nBNBtJhT96EMKO0j\r 5aOGdSEc8ThIOsT/F/DPf9xsROT0s/dNCf6lSz5pZr1wIex++NFHq+Xv9z1p5+BCNm5MmujuCbhH\r djhMU0piO4bc9+g82VHjC2jS8n2DIv4doogFdiaCnmXsXcRKxMvEa3q0azmvGyBRKfwYeEx/k1kK\r KVKSskE2bdygs0mnptkZqTJs6DDZ1OEEBLv94IIkQUgUmOXjtBBwiytfjQ0LzEyJD5M0G0Ihg/Xn\r wsXpb/d4NPBsgCbzkdWyYI6ZfEHJaPNNhFLcicdhCeIBsPCusXaD1nQ7eBvQtBd9jIkw5Gv7uDSB\r XWcxFwshzX9WWqZ9MJRBl2N+q3QWWLez0ZRlHc010t7WoUeL9Jt4RhfEQRyuzCDKQwnNzAt3DxgP\r NNSss7UMLGADyeOTKlE/Cp3gOXIkjYiKDxAFNYQCW3u4jWIlHnAUOUVl1jYuV1Ag2xqCzjap+ugV\r qw8CxdQZom5txhCLH1w7+R44yIMw4H23bsMHpnuqXvyMLaYymqdcWL8+RTLitJ8YUef67AVOnA2w\r IJCMHZSy1O1+cI0+I6ba+8X6B7NsZPvmPUCfP+nWBt9XhDT7aWxZ8JQ+lgwjiLRBGe9uuA8fO/xz\r wv6i/OCB1sQ2RnDR74g9T1ygZ+X3VS5tsT6rySYes3r6l73417Js6VJ9nt4mprv9T/594jx5NBRP\r 46CxJTKAYC2GiSuj8/xtmv9vnewM17G13C3r9A+wsxb1ciGGKItvELNf9Ac8IyZsKNIHHnCylWLs\r tirnxEZp6OToD03E23HwWHpusRERW1i7bYO9M8zuMbPlPJ4U3FpriBKm5SZWhTPBrDrRlgah1WTc\r I8TTtU0mT2zljKEL60LwirBp2dty43WfkU9//pNGJALhwGstR8i79+9PmP7hfwHoM3BRsnlLle1j\r Pk0J1t4Az7rr1m2WI46YYtzLv//zspn3sqCUc3/522NyzNHTotK7B+5RPyGHuBmvPUB/it0g+foS\r T9fAI2HQJCFeJgZ7LdezEh9wz1yRjLROKcpokKqKzYoU3OMk/eADySjCoaGY3oNFSAD6B2zeAbx7\r BqW5LaJjpqRXwSoppy9E1BERMs/88IHYTWrMBnY87mUTSCzKr2NxoCIXFlCFDzAzv8Rmukni4f1h\r NspgZwbFwj5HjiBK2vQ49T2tRK16rZi3XkXIuF7BAgWOA7EAi9UQWUE4zG8PREHDrPIZ0lbnilRE\r fGZ5kWjbfVGh2wDP0F/yIWQYDSBfZqUuSJd84z60XURWxnVoPN5fiAdpRFSkbWGehiiI/XyKchJf\r 9DoaJ+2cyYeyc9NiW4jYf7+jZfiRzLjRYfjzDYe3kTy4LpyAP/f3Ze3r99jMH8+07CsBokaJ3trU\r rG/W18HwpvLzXZZOPVzS162fp20pkh0xzRauxa+ZPPz92rWUKCTytQ+4aSFeq/kctqOelmMMEKcP\r KOj6ar9wiUKdhf+63voajuR1aDM5vgjj50jzbNgKl8V1OP0bps/U6URURtvHZBvdB1xeR1u7pKfh\r 1DF5PpS1dBSy+rv8sAv1/R6UKMe3AEdiYk39JjFYGNyFG8HnmXNVzq1G7Wpdj6eYSMsmA3qYyxr9\r s7Gq45Yy6OzQ40Fkwm6X1sf4QZ6151y6i3qH2USHyWFY32TEA3GwfhtwQnAi9MHFWT6eNBLFGQ3x\r uF8Dk3TLBzSfSUZh/RL9flJl8RL3iRWIR5z7CPDDH1whd9z5UJT6+OG+v/3cwmu/6uHegD7CheTl\r 5colF58jmzdXyq23/SM6N1n+9cirFt8bwMHw9Azq6+YnFhM2V8QfQHhwiZhDl0SPZA9gkCShZ+lk\r TuycRUOaTwLQdKxImubvqN4odXV1hhAtLy1FSktLpakj08om9B4axwLLFszpDJv9OwA4D+T3FACB\r JvYm0P9WFgvpzNvTehALAy3EE/kMOM/jgHhg0onYCmRkdbQMiL4YJKL9hXgw6I141Gy0mSVWH95O\r aI8Pxet6nous4FZIQzxMd6MfHsSPsshoibv7eURZ4+wD4uMbONA9D9Cki7O9Te5dI37/mgZJ0BZe\r UOFs4DbY3hNrK0wlzbJKy4UPOrQT4nAcEDNmx25O6yIqVxRrGR1+IHaOodM/a88qEAtEVkY0Yu3R\r dji6ch/uqRZkzUdfu+59u4+RR11u5+35aojF26Z3H5SW5iZ99J3m2gEYOKBUkfZ86bTXqJyOvqva\r tfNk9Wt/tLUMIC8Qv+0tou34gfeAcjOLRuC7+rU/uXhE47VKgCiDEQN9g8AEXQZxGwt6nv5ChCEs\r tvBP//BvZc9F+wMhYQzZ/cYO0uEI9x/eRd+Rh5mYC+sz3kvVsllWZvPmzUYwUXxl6UyzeMoXTU/C\r kWhXy3ubyet42745FnEQtSZs0jJk2qeVTjghQj/CxMO2EY765HWSYjonKGk2DlGiU49JDVvrUh5R\r Fk47TS+i52yLAB2LTkRCmx7y/t2owdOBiEA8SLuJrzsY5bvCPZHrRJhUaj39pa3QnkaiOGf8SMT1\r PBIDs/ZSwPfVxo3rZVj5APnFLd+2RXq9AYg6nPvKFecrYfnfmPYecshE4xgQZV38hRs8cy+ADgNC\r d8bpR8uBB46V2+/4p8yd637A/nj7d+TlV+ZYfG/Ak0tAj8WEXYCHGaCXuAXd8hOnYvnxIga8qCja\r A5InPKa/sbIZOh7TOxRxVK5XZNBphIO2sHGvTx8k2xqdm+hN72F+nTQHf0cQCM61Ne/U8Z2hMa6T\r Irs2fyQZuyMeGiYHm39cIY8/1niAEPGS6go8t6X3xU5Y0mgp/fiYKWEVZoNckYkRMi3n7fGBRGHs\r gPMAyTPjgniwch7zWu6VvoSFg4MOOs3KQzyS7aVJ//6uB8HgAkV6SsU7XlfPs1Me8mjz94QyWtsj\r TT9MM6bt4tDQFlfyAdNmaDsWD7oN5POkw8p5LIkgGJrQ5xMREo37fh8gm9COPh+7d64ZpaMQ7mLN\r 7LsSB4iY/qNUBjlTjrBmzRxhoyVk5BgVVH30kj6L/aS+sUXS9Dlw78w5MLvENNTcyesfzvmozzHq\r 2CuVUzjEFiHihgXkHg7264CrQY7PCmurwy6J/Gk/N733kBFcTRoHrZlGZCAwoZ/hQBzI+RR9/3UR\r p0I7IC7Ov3/fZfYcIHT+jLiGhvaMwvP3PCPER3zJ8vDgu/GRL8j6tevc8kohNydXx91mWxyJMnpP\r hCTRdvReEHkyo7dJlaaNG9HvhPECx4phheXP/7eFoX+hLc+DiLBhnU7/dBCimA9+1nwVe4oSEt8F\r ka2SIcSVS17u0Y6F9EsPOGDXibguBJ1IICKEbDrGO9OK/JuSfTsTDRLRc9OIHVzf8kOcfD0P0WRH\r w2FZlVJePkgOmzpWcgoKTTz19tsfGMFgH444F4LlU4izsPl/BX+84wc2lu+9/ymdTO/wzD1A4EKK\r iwuFPdhrarbL3X95LDo3Wc446zqL7w0SOhAgrgdJz8csjYfngT5KjwP2UANEZ5I/EWg8Sibq9igD\r 8JKiaPxcL2V90EQJhYLMZp01L5NdO3cp8VBEkJWhiCFV0guGSLp+kLtqt+rg8T3d3Xw3qfdg5zwa\r q69yVyEA7swLTaSlbH5Hu35Hab4qPTGIuJMojOdZvxjUUb7GkbHyQvF3VLuW3dR8Zma7BSrRIAyD\r 25TsWhpln7Wjs6ouYdQm18HTKSKQtqZdvt7BLK30WUAY62sdQSrCJ9xZsULYs8D6Zx8aM8BUZb8X\r ycZNG6Wt1cWC7duWSNaQwwwB4PaEPiN/RlzBzBY5PToOZOuIMwLh6L4WAudA1oUAAP/0SURBVALA\r ympmaugpjPuIuA04PnNOtwskjNhnnhK9RuMyTFegR7hPP/y5+jN1xImiG4IGQkccBhK2RWP6ruAa\r 2OEPqzDqoj+BgK5//W57j4hbUIRD1Da+84BkZWVLa5tOHtLTZOjFT1v90A84lXDQFv0Bkcfzw4FM\r nD6EepQP52gTKzHiEGMznNBy9Hvhw98wcSCEYssHj9s7K2PF+Vv3yshjrrDnQ18ZJyb6Gj7ViBWI\r 0Z9vmRLPP1s+79CeEzHrr8fteWpYu/AR2b69TjraO4z7gDvvLBhua4IQE9kiTPMV5uV5Ps7RRO3o\r n7WrIesvmNWTB3Fs3lmhROrYxM6Jnuf75bDz4pYFT+tYZIuEqCWasZiH1OM7Yey2NFSb/gJOGkAP\r YhxI5Sp7TjYZRC9iZ7u1RV81wvOqWT7b3ONgLgyxQ/fFdsutTdtt8oXyngmD7SsSEVIaCb0CvO0I\r QlxDFs9uWfq2fP9r58pPfvFN+enP/iyf+9wZ8u57C2X/8aPk4IPGyd33PGpmsrf94X45dNqBpm9A\r X8AOgT++8Y9KcHpzG/V/g379imX58rWyePFKWf7Rajn/06dGZ3YPQRdy+IxJ8q9HX5AlS1bJ6NHl\r Mn7cSBkzeqhUV2/rdRfCOOiXmoTAgYwvTy66c9hL3IJu+YlT8fzuEAZBN7C85Alizv562kE/1I5t\r UlXBnsXM8KJshZ2Va6StcqF+rK5boIANkiiOo0ADrWRrIBRMEWzrPRS0TAOmvRFnYofm2b1wMY6Q\r FyE8R37OeRBHbAXigvPoO+IwY58p57sF6qDWAQzxoD4IMO5R10JF0l3SeoBk8HSKrJjtNkHQtuWn\r Eg8+LogGIgE4DoiH3Y+11bWfzWUnSWbxaOgAInHZ2dBkM0jKsONcbskIE+uRxl+TRizORxlmookj\r 6icWQevf/nu0wBI5cYlZViFOsa1bNY84IhzODzr4TBfrWCeiNhLt+vXalMDAYbBBUV9FICOPvtxC\r 6sPJrJn1Z1NcU37Na3ealQzImWfbrteEkxh57FX2rvBoPPK4q8yjrr09rqEhM7Au9xO7ftf07o54\r ufiRPB/ujT3cWcNA/MDzf2d95TxEBU5n/t++ZIgSgqEn9JFm6D3+yYgQZYnzDFHaUw/kum3564n2\r nbDHr6lxzWPtR05urqbdrL38U39XDuUSey78rX/rb8qNIcvU+lp+6PTP9eBIesZTFPF3Jown0L1s\r eu9hExcyEeFd8E2a0j+qS50Qj4eMU8RafItYaplbHR3LIHrGOhw7IZwI34DV1X50bSu0jbuWo3Vy\r tt70iDwvDA2waswqGGCTSIgGz9mlAb6QVyvrP8/Ow5C2vBDXcFxxnWRniHzmAneaOPPwSTZ7/+Q5\r JyQ4DZAvcOABEE6f7d919yMW/+EPLv+fibIeiCyyHnvqNVm9au/cTuBCxo4dLhMnjJGq6lp56unZ\r du68Tx2v5/5k8T2BPv2e8JEOuATw7KKoQZdEj6RDb5mWt6fKvbaUyA2+VwKM77dD1qxcYTeQoVgw\r U1mQ5vpWnVFmaFpkixKWkmxMcrGo2mjsZ7Asok1DkGBPBWT/vtJc0wxIDfP1IzCgCNkWJ5IcUInB\r Fh3mTbdPmc7CF5rYirzMnD7mBI+PoHb1HCMebNsJIgkfHqx38mOg3SjkI4k+WD4cm43B0uuHhX0/\r 1x8w4UQjQIgAti58xup1IR60ZW0gg6ZdnU23VktOaqtyMGl6KlWam9ps5m6iiLJItMDz1tvCYi0o\r UeMfbWgLURVx1rIwkw0mpehnEFWh70AE5rL8FBlxpCJJIxw6IejSXvK+yYPQbHz7H8ZtcY/kIaoC\r iXKOGTOTAoiFm2Yq17EceX+qjFaiMUoPEydpuu8ofdZGRJUDnH2VZCjXgR8o4MADfaZN+34wUXFO\r jcP71vVIlu1+JMdCPN/vze/Pj2Sa82WTz7Fwyhf/poRC+wqXpQRj/t8uUW7kSjcGiPa8GHnMV6we\r zwGk2l+RZWgTAoTeRBNRXnQt5b6aWXGsr7Q/W61qPgfKdqyWyqaep1wn7umT/eZd8o0QD20l416O\r xYJYNRHHXBZi0n/skVamavlrxnXRZ7hl9CNhLId2PNT+xcYBrlCwzGIFO+MQkTOInvO4wDeiYkQk\r PL/kc4yHfFMQEcSkcG1cB90nKA+9I6IzxFhORNhTxPVXXt/fIX+EHvfT8+fPl89ceJrMXeCGKCDh\r hQsdrwTRVfcQ+PKXzk3EX5v1joX/C2DjKX0KcvU1+7ZZ1FVXXmD9Ou9TJ5n0Bous5194085lZ+cl\r +rw7SOlsXZjAzOMOuTTBhWQN1JkSEB6eAQ8zikYRnm8sUyFZJl7To13LeV1g9+U8pr+xIiTY33zh\r woWKqBQBKuHAJBOnidCEdsd9SlXHycrqDhuEZJgIodhFcwwunOcR31mhiHOQLxBE79HF4sruP8R1\r cEXx8BGFAQcSR7cCAWG/B0RYrBFgxoO7+MB5BLEVg5zVtGEDnR4fAzcStW3EoyRJPOAyQMBwHqEe\r IjqN2EyOjyTRliHOqE39Q2SBi4eUVU/I+nWL7dl16kz30Ituk9aUfDvPLaLId2W6329ojzY8LcYF\r IGaBUJCPmAfT3JRUnaLpjNbPKeFQgGgYWF3aieLWniVsYyJ2foRoQBTq1s2V0gknm3twZoxmvaTl\r WurrpHLJ8/ZcQVCI1oyDopkEaEpv28HP8Fv36Kfl/fffl86UDCWS7XLyCcdIxVB3jV27Jvlh44MM\r fRg6MvbjNnft0b04dJp5Ns+HCQPTbXRPWTpRgfM0n10KTBQQYSFycog+NwsSn56DtuE5XcusfvV2\r IxzoAdg/HPNvngXiK87XrplrOilbMKgw4qjLEm1tfvjT5r4kXQkEfq/2++J/7Bzgk7JOJVB3W9rc\r pVBL8zfOfVgRP1aNneZ3a92bfzPOhHSoZ2F04NyR3SOZUKDvgQshhAtkHNAb9Ehm6ajlTSdk7XRo\r QBseQmgY44im+Z4gpJTF+AXxJ7pC9hphYoOS3et5W91Dvhd28MRSkXR7S5OO6VEm2sLKErNfHJrC\r xbMWzI1YMJNO9sfai9Jj8irlrbfekt/+8Aty6bUXJ4gEEOLxvMf+/ZKJsp597nU55eQjupx74snX\r TIH9cQOLArNyJ1t8+ZKnZPSYaB3cHgAfWc8+/Uc5eMq5smz5Wlu78ubs++zc8SdeJq++7OOjN+ii\r A6mv2iCz3sKSBR0IM2j+Y5+lffAWSf4m8iKIpRN1vaBFHTTu/xHEzlnU04lf/edlGjLTREl+h9Rs\r XW2bo0gbC6NcFIGLjsbmVqsH/m1tbZGMAQcYsmUA4t6bPmGqyZoDAO6DWbf3W89qGNd7JBCoxQNi\r 9rQhQptVuXgGO3c+GAY2xIqPBUQCMcFKCNNaxDmIn9A1uFPB0C7thFDbjmZrzNxZtGdEZKC7JuGa\r EA90FOgnsIpqa9xhH2qyT4S07bNp2sThoelK9MPs3DJHKitqJEMpL6uT2Z2wJW+oyb4hBMGahbqh\r L+FZYFFlC6o0D3k8oioIB4sVzVeTFkP3UbV8tvQfPcOJdrgnfRfh/qgPV4EdP+2wCRMEgbJwcEHu\r TZvc5/aNi/QDH2x6HfoJYqYtxCWhb3avdt/+XD3UfB0/EKVls+6VppZW6QA5KNRu3y5lM68wR5KI\r PLEiyiwoldHHX2uzWNM96HX6jzlcicFh+k73N9fw/ZXwg8j6jTnCzmP9hGiUCQRIaPCUT9oYwTAC\r uT4z3cWPfku50HfNNHjL/H9bX6nLULK+2xgjGvWfDmoYngnjCgQ99LALTHTFegS2jDUOTCcwOF7E\r o0LSe4LIgidvFjwz8P0MHz5c8sadZdeJ/u06iHh4X7jER8THGbxSN+/Y4kRFC8Lx0SYJa9naT8ax\r 1CIOR91v1GFGLJoR46ZlmtNBxFt8g3xrFSjNbfJDe95iCBl37CuD3gRu1r5bnVTAlfjmWWn6PGuM\r G69h10KzWgu1HUKM742tkfHzxkLK/NKR9t3ZwkIlFia+YmJn4Uarw7caIOpeot1NS9+WfsXZcuft\r 39G+ZCfWehBWVdXKypXrjEBgeYVivbLSdQibN1VayBHObd1aldCNfJyApR3bNrzw4luyQonBhRee\r Hp3ZPSxfsU6OO/ZQ2bK1Wt58833FBx1y1BFTpbx8oNz796fkCxftvg39ipNw3FHRLDEB4dEB8XgE\r PbKSGcnXCfSsGy+ZAIv2LNsdmquXybZtOtvPyzBLGvb8rdcB1tTeYj7vIR7pyplsq1WkkJFioivb\r OEn/dlUsjRToceJBSjmRLUsMeSQ+FMLu8ShtiEoP0mwKhVwaouEfuyIGHZQs7GKRYtgEip3VUEJS\r B/ksoSO5gOiieISwcXsNAjP5L6x7pZvomqJcuRCIEtfSH0Ng8T65WMDFVhxYOSGmCKa5w4ZG+iFc\r vmiweWulcUahDWvHEH4ybYemEU9BNIJVC3XgMCCiWJahg0GcVzru2Kg9+kNfIGZeHjEUpqrb182T\r vqPxB+X3v+a1P+q5edbPDe88aMgRYoFIasSRX07I1EN5V+RHz8766+3X6Cx95Yu/k0WPfsfic++5\r SErW3m1rhfwNugz/8EMPMRFHqrYB4kN3Qnt1+u5QMrO2ggMRHXn1OmbqtW/Ew0E96ngb0+251Ok1\r yetjRN37dMil/5QyRfLoYyBG9IJ3PPfuzxlXsfqVP9h9hPsjTNxbFGKlRP6QQy8wJTOTi1HHXJkg\r yMECj7KNL16hxMMnWITmodraSh6cDPGS8ceZRRRxuK0i3nH0/lnYuf6tvxsB66IfsdDbII7VF2Ew\r WNATpljH5Jd1JYhKc5UQwmFwLtlGMsT3HByGcSuatvVL5t5ey/OneXAXLG4kJJ18Tsl7IoQgss8P\r 3xt+2iAmSAHy+rvLICCUDW5PaIvr6o/lc5SnrZOC/Ay545avSm6R78UOvPG66zMwpQ0u04PlVZwj\r Iex+rhv6/dgAcRnOEp9TIrKm2xa0vcHPfnKtnHDSl+W0U4+S8eNHGiG5/Mobbcz86AeXy+9uvT8q\r 2RO63MHUmS62GlWKS277T0Ii4ZH4bwK6JQ165PFyo2gPSJ7wmP6GLNhSTeDvCjfkOMLrgPvQXKxK\r CkaeIFmlk2RgaX8mm8KWrZzr2DrPZ9NRQ+bRVoGBEqyvaLeVRXJlvtCPtA+ieNwHlLWj6XDeNoXq\r M1hna1U2m0QByDnaB5lYqAgSJR4D3uWxDFgf7F0HvKYjBNhQvVpKJ55kRAniwe5u5DvxWBEhDO+f\r ia2oa32K2ow+fMqE6wRTSV77xqITuRNN8yuyfVuFzqp8Twv9sXJe35E0iAMkgtiqUzmWhCmuEY4P\r IlFVp6URs2DhQlvWnhIP2qE8hAMxBR+xiaQsb56X8w7Z+gpEIG06a0Qn0H+/YxL1vT8g63C/tA/B\r eNfWbbx3F8jYkTq+ssqnnW/NTrvsAdlSwT4POrnAZI9L6VG9DaSqxESPLR8+bWFh+UGybfU7Jsaq\r Wj5L237H8ltZma194mjWWTB5HFybstRZ/uzN1nBhhDw5Rz9BTrjAZ0wgb+ceyOcdjzr+qzYBwCKN\r Oi9+d2yCoCT1MYRhQuDhyGOvSbjUL9FnNO+vFxuyhKvjWSxevEQfjbusR3l+8MEHy9rZf5a1r9/l\r bUZjxMec9wcdBO8SM2BbS0I5yuiY4X1BFOBKPD96v6EMobUJR+K6ERMvwp1onAlGMPfF9DzRdtRG\r PCwsGy9bFzwZiWRTjIhgYcX4J42lFty4h2Fzqq7jNuRBRDC2yFfCBQcCEWlQDgQiQn/hRnCM6OtE\r 4kRE2+Nl6rF06VK5/rIz5cTTlEDG4Lvfu1x++5u/WTxushsAQvHU07O6EJFm5YCBo3TCzvqLjxvg\r QK695rMWv/Zrv7BwX+DwwyfJAdEGg+9/sFQWLFimfZwsv/ndA5bXG3TRgQB5xZOlIDVHJk+aKu9s\r 9hvlAdpzNPAIzzeWqZAs4w89Ai8YA15yFO1SLvFj4DH9jbLQMbCafEDKWlm0aKlxH+2t7VKUXyDp\r Q6ZLU/0OG2CFsk02r1kqzbu228waGHvoqVLblGHch1td6axoqyuM6YzpFpQl9o5xzWjgEJJn+WGA\r k+cDdLvOoE1ev26uITonSuV6Xf3cdGCyJW3cCmXbyjdM9BHSYYCH9qx9rWd+gUz/4OdBuogl+Hho\r s72ZrYe9b9yP9yvWlolwojb1j9k8Hy2zPvbyxpqFsu/94UwuhxRQ0rWJQ658VDkSJSL6RxuUoQUI\r R3H5JEMA5OmPB5TTCNwIHx/KSD9nJy1uCEX/Wpt22KwSvcaIo68wUQ5brdrzU4TKbBMxxeZ5jypi\r 1Bk1c5voGt4a14qyokiNtoHeAh0F+7swUSC+8qXfG0JmPFQuek5GnfA14+LS3vq2zH7rXSnIzZGd\r DewHki4Dp12os+bjpVrfTVtDne0HkgS/GvfFJKErJD+bmlXJRVcYSIAwEYPiSwsRXL7e2+jjv2Zj\r jvPGLUZt0w4xkDx9hwiBpNkCeNVLtxq3sku5ntaG7TLquKujq+qvRaI+aGWT0ytAdPoMn6bHVHn5\r RxOsXaCkpEQO/MrLXs4y/YTJ+bHdIQztROcJ8HiMOIoxiA+s9Mxs2fDeQ6Ybci/VnU4sqGv1gh6i\r 0ycbZhdEsU793ibY4lKuAYHYjrcBbSOhDwl6h5hepGrpayYqtHVCWs++Uz3HWCbOnuSM9Q7tT74S\r Cm/L9SKhjd50Inyn9dXrrE2bAO7aJiyYZYKHGBICg/SAui2rX5DcnDR5//W7d7vfeeAqWNW9YoWL\r sm759d/kum98IXEuyXnEdSbzNOwu+fm/w44du2TQkGOkobFJNq9/RQYNcqnL7mDt2k0ya7ZObPR7\r vearP5e67TvlsxecJn/7y0/kjTfw2Nue6Hsc9CvtCuVjpsrOjkaZNe/1KEchjPUIPNlrZlfokRcQ\r TzewvOQJj+lvl7IpMqW8TSq3bLVOo/xN14EzdOhQae90FwuUycjrpzPgIsnI0EFl9ZQbqfwoRjwQ\r XSWJB3U69SNJgF2Wn4AI/XAk3TXMLPCVyS7HppwiEEVovATEVhAPxFYMcAamEw/q7p54WNqu5/mG\r +LLyfOal6STxcFbfRVVez+rEiAcz/R16rxAPLKz4GOBmkFNjNdOnTz7flXkutmYaq6M2vC1m+RAP\r xDAgMV/TAdeB/yUqOAdi7lqQRWteeD7Wp0jfgZKWGaSJ97TvcBw4kCROnY72ZpN7YymHqa3PtP2c\r t+chacRRq165zWbo/UYfJiOPudzaMtGOtrdKiQdWTVRDLzT6hK+br7BlT/3EuQ0F1n+AxHAmOP7M\r H0s/RVD7nfodmXDuzdrWDOk7OhzT7UAcaQ12OfwZ8wlZHTumy+gTv26m1sQnfPLnMu3yf8n+Z95k\r CwULB6Hox5R7s1nksY84bUA0KL9N80x/sPF946IgpFwfvVkfzcfAYeVLv3VRFwSelxaFQXwHkekz\r aprUP/dFe7dAhhJK7nX1rDtlzaw/avejvut9+HN17safezyeYgiccrz7jGw8JOj7UkI/9LALEyKq\r 0F54Vx53s28stfRRG5HBSq6w/ADTl2CabeNSJzdMLBJt2ED0+oQl4462dx44kcolLyXOm8n6gLGm\r G+LS8XqE3p/Qv67iLDgRzrvX603mn4t1SUwWWGSpFaK6+gyqquRbV5y5W+IRh7Ky0oSL9DjxQPcR\r wjhAPFgb8nEDYv0rLnfu+4bv/NYz9wDoYv5273/knLOPk379iizvgX8+LZWVNdrHybs16dUn2xWw\r wspsjWfThQBRPJ5lkMzQRx7FgB4FY9D7ud3ldiqSmfX6LKmpqTOLq+ysdJ3Z7S+1aUNsAJqllZZb\r t2alDCgfLVk57sKd72vtmjXSr8SV5iBkIyQ6MAA29CkIoisGDD3glJ2P8qJznsezUSSwfauxwszK\r ISAoehmMyHkZwEmx1UyrB8LytsIg97gPdtr2fPrHOdLMXhH1IOcO5zViITP2RDv20cXbTjPiwToC\r 6vKRouDnI4Z4ZBfjyiRV+vfvZ0gGr7R49djx9i2a7W2gKGcGCXfB3hM8I/JxG87HD+EAGdIvVj4n\r n5HXh3jwgSNOcZckyglBjIyIUEbT5iMLN/A5CbNmF894O/oT5SkRmn2XEWUQLOanWD4hHsKViBaI\r xFYg8K8ZgoA7QVaPaIl2pnzxXsnJzjJOq60VQwsl/Dk5Uft+jcTx3/zF6yX6DwL2Z6MJP/SeMZkd\r fdLXZfC08zT8hux/9k06Tqbrae//3LsukMYdWxMEZfWrdxqHNfqEa+2eWJ/DO0U8uFU5K2bzq19G\r bxI9r+h69AORC4BhydCh5TLs8/+JyqUYIcFFC+V85pC8B9oIz4RxBGHGrTwu5pnRI0qFmFCO8cGs\r PdQPY8frasjHp6G73GfCVZKYvAyYcJKGPrmBCzHdXGwcJ0N8ck1PmKZj2IDFYRDHMsZCOdolTFzf\r 3kX3NhkOnFPioc/UxFcREYFbMULMuYiQwH0MGzpQzv8ME5TdA8Thll/9xeLf/taXEvqQldF6jCDe\r iutAfnWLu3o/7thplvdxw9eu/Zzdy73/eFLq6323xD0B7k3mzl0sP7nxGktjaPLbW/8utbXbNc6D\r 6wn6VHtCc4u7PDDoVq/XZnrL7JEXvbzuYHndT2i6W1bj1vnS0cw+FozTFGnTWWR6YZnsagEB+WZR\r oc729jwZMrjMbi4jI804kaJOrIYgRDiv84Io9MxRmnVM+2fX7Rq3D4PBF8sLnlY5x8cE8WDmwkyX\r 84gpqNOqbDEh3IfPksLgpl1CH6wW6o1BPDiSFiopJl7BAovyGAPUm3LR91Lw+lHoD0bTEA93LQGR\r 4YOFiEBk7QPTNtOyCmxmOGKE64OcC9HBvnKlpLbuVOKxwLgO7s3XckAAlBvZ8IHsUKTBZlu4E8Ez\r buL50AcjDG5ZxWI4uCbMMHls/CBmoHyowwyV0NY+RG1YYQ0pgyJ68WM3yHt3XWiEq59yBdwjiHjk\r UZdpSTiOW+1Y9+bfjGjUrHJ9BJzAwZ+70+pw0B5rP3BbYtu5KuTluc+x+AEXAALf8O6DFnK888dP\r 2bHwX9+UZc/8XFa88GtZ/tzNsvTpn1p+KIe+ZMWLv9H4HOuDISMda3bPhPZ+uM9wPe431foKp3Hy\r rzaYB2XuiwkKBJPzpl/RMQWRGX3CV02XNkgRe27pSCMmL3xnjBKS26webWbNudY++uzsTGlpaZPR\r oxHPojPx9TH0B2/K9IH+cKyZ/Sd55abJSpT1mob4OefnqUvIKvm+o2Yax0l6+4b3Be+5EJIN7z5k\r kw4v73VDvRBnW1smDUxkmJSQzf4unMOFDmKq+PWSIXq+8SauImQsByLC9xw4kYQ7n1i9OEEnDwU+\r HqVtnYhydLgDCkSEfUX4thFzYTU3rqRF22+S3//scsln/cxe4LpvfjFBCPTWbGX4JV88J5G3dp17\r +QjwzevcFHjmzMny5lvOtXycwMZPX4WIaPyWiFjtCSBqt952v5xw/PSEnpCdBxcuXCE3/vAKufLq\r ns4ae9WBBMgeFG2ub+ARXnosU0HjUVJfl0cALxgDXmYU7VIu8ZP8jZ0OiV1rXzaxFQAHMnr0KNmW\r 5VvRepmonh6IQ4YMHiKVaxbIrh01irg6pagwT4r79pemvq6opOCuLUukgNm9xn2Qe34Y8KTtnmzw\r ecgAw2YcWT4y60A8kgPWQxuUOsPpmu+DOBkPbWtakYvJy/VDcCIyxtwuIHbCqgk3HoROPLr2Kd4O\r ixZNbKB5EA+/ls7+8vqZ+SNxQ9yG7BUB/+M8qayuk3Qtxj4qM778J9m+s0mJxyTjflgrA+HQK9iz\r oX7gKELanxHJFKle8YatIWHRFma9ECOICM72+o1Rrqx6nSnZnauiEkAfCb0tFqFtWzZLxp/xI0Oe\r nKNo4DQdsSrHpPeHQ8zhR37ZRJLWjwCJtpOw9o+Hy+o16+EFpUXHRH5+ngyccZkSnbcUaQw3mXeA\r MSddp0j7LYvDVXIt9q93SLZtHKcCZWmXxXOIanAfDxGAE0OEh+IZsRimpwMmnmQEPiFjUjAO1SPh\r J4JO2TT3UVn40NfkkMse1LRPUOjBKOVMsDQbdfy1Vm6VciPDDr9Itj91kSz4YKFOsjqMiBzxfeX0\r AL2eXSe6LuPLthHQ9OpX7zB9FJMCP68lo9DSerhOoVNw5InI0hZ0KndRtew1I2q0bZZ1SmCGTv98\r VDfoIvzajG1Ei3ha3vDOA/re9DkopGZm2x4wrhcZF9WJ6zE8NG5axwAhbmRsgfDWZWY9iREIRIZy\r rBHyevE2kvoRVszjnt2egX6/jEvycbZYjwsUJeSrZ90l119+hlz7zUtlwIC9ExDg5z/7s9zwnUst\r jriqq9VVz/UiKNhP+8RR0bmPXx+CTmbwsOMkPy9Hdta9G+XuHugXSyJOOe1ys8bC2ANCd9OPr5L9\r 9j9HVq/wvUMC6JfbE1IaI+1Bt2+w5yep0Ftmjzz9tHdbrtdWu8DYgtoo5qXzcnOMeIBQHHRGtW1N\r Ig50pOVI39IyE88AdTvqZeeO7RrjvO9rbqIr0tY5PxwZR/HoXMgjNKSgYeBAUGonOQ9FbBoG4lGj\r yJR0kmD40R3p82GFNHtDQzww2cXMGKLBffYkHsk2LVQCxMzQiQfWL0nigcwZ8RGEI8z6Qz0Wl/F9\r AUw6ql79hdUhE/9ETjw0rUOlSAmH+V6K6lLO++OeZXEtwkdNcWaDOIakLKumcZ3PGg64AVO6Ut8I\r h4usKIe4hll2ekau6SbIDyIedAwQJAgK/RqgM/ApX7hHDvr076SobILV15/ooG367BwFStN37jxX\r 1mzYbNZ5HKn6N3RIubZ/uBxw/m+VwzlYCdxMGXPyNxXRH25ImsWlnGf2D9Jzk4JUX7XNn16rZvXb\r eo23zTiBjw0LtX46S8eaibpjlLuYfNHdFqc/EBE8zq54/tcy6xcu3lzxwm+s/6HNLvei12N9B9wJ\r z469Yta9cY90ckrLjz7ha4k6o4+72gjq4sWLdT7CcxUZNsxNs0N7dh098M+29cOnZc2rd1oap4rk\r 0Rbl5t/7ZVmr79P74kfgchGleb5yiTo+WNfCebjSPkOnGLcIN8J5qxfqa9oW/2kcxTwr162MAm0E\r kVZXTiS04SEcCHWQOrBgF+6DdKZypS7OcoepcU4k2UZo07dfZn2Oi7E2WBsJ6ywlqs0rn5HyQf3l\r u9+93PYR31eAeICEgTjx6K77CADxCOKu2a9//GIsdDJHHzlV6usb5V+PPB/l7h7o61e//gv5xtcu\r Mi4EMda/HnlBtm7dJr/42TWJewugT7QndOZ0z/aX7EEUN0jGGfxJiMe7Q+/nPFd/u5z2xMaNvsgn\r HU5UQ8x2k+BlWPjEIGA2guhkZ0u6NOWOkDQ9nZWJ03dll5WA9EupkJZdVcn1Hv4fxYn54YMu+TGH\r kPUezGJyzc+WIgRFqNj0c/8gCWaYsMXU77ffUbH6tEe864CuXPKizVorFuN9NEVKJ5xoxIM6gw46\r w4iHm+mGPoQPIdY3/aiZkVnfNA/TSULOgayrls2O1g9QJy4XTpHCQnf6CLCGpk0RIPlwMuZ2Xf8o\r iwwe4wDioW7oT9MOZtqpen1mWeyj4SKpBkV2VIfw+L4f4Rkk7588uBPcVHia0y6aov7Kl36nbboY\r h3wQ8oSzf2LIPd6W/lgcE1s4p3fu/KQ8e12Z1K5828QsY076pgwq6avcq2luJFvvFeJZq5wDayfy\r S8caIa3R8mk6G8Y8d+0bf1HiMcesxOAwQIotTdr+zkrzXkDeNn3fiEIQz/UZ6cSOfoAMIUgQH9Jw\r X5xjDRLjZKwSqlHHXWN9R9RIuWevG2xrFXZLULTnQw45X46/aYk5/SQfIrBSn9XKF2+V1S/9Xlbd\r daw0NbUJzkDTlFVvG3KKrH7ldmsr+bx83RAK92J9Z3AfnW0tmu1lWFwHNzLimCusrPfB6yXikWgO\r R5Lk2xqg1HQlKHglQO+BwUXXsUbbpIvLfQJhTi6tLRakVpijRMS1Qbnudb2Oh8k2+N4Jg3GJibGI\r 69WTnLwTkWRd+pFs0/RnNvh1fCv307AN4jFMcqvesDUz3/va+TL3w5URx+AeOvYF9Ao9oDsx8TYd\r GWvPDL7/vcvloYefi1IfH/zz/l/Zbd7wXb6lfYOrr7pQBg50r92r12yUpctWywnHT+uhTO+yEh3o\r 4pG3IFpsprdoN5n8ceClRBCV6FmGM/Hkbsp5TH+TWQopcmBJo7li6EzplI4W5Yz0xQ8csb9UbNlg\r M3Ve167K5WLuxbU88nlCnCOmZeZLdutW2dXQJKn6BDu0elpHgzS0sq/xACsXBhbtJAcZYZRmOGjI\r BlDZxS66Ql6KFRBsPB8bFjYgABYJwhqzyh2TXZBuGKwhjMdZQY5rdNK2QlxnRDghRNnIroUQObbR\r xQoFZTb98PqxMCIeQSTk7sN9f3TECxAClJB+zeiDtbj3o0H7X7WOtR0QaJ1da3tlx3zD1rdkK5fl\r bumnmiVYqBfqoufAVt9X74ZniM+i2ZKZ39fEE6xj6TfqUCvv9bXP4lzHqpd/r3k+e2QTJn/Gvmrd\r nu3OikhsNdruwcQt1n/ks4T+HOACWOkMB5ienWecGosihxzyaVvABlGgfO3Cf9v6IShFcZ/+knfk\r 942jXPn8r4wYIMpa+cItSsBXS52+Tyx1mCxoz+1aIC1curPVMRwWbcJ1sPiQ/bxXaN3aVW8qMv+t\r bHr3AW3zTa2GW/cHNf2QcjfX6/0st7bgJNhutlavw3okOLeBB51uyNVFZyky66esy2JiMoO7tbZs\r TOo/CJIQpFmr973x3X8akshL3aHIr9bEtijPx57/RzNQgEgbBxuNZ2tQAWUxhg1w1IScwooRIgyR\r xnx+7j2ft+fppszU5R2m6LsqMx9y7k1adJxMsjjWWevf/Kt5fuAZmqdeakTXJI73ALwX5PVllbjv\r etjR2qjj0LdXSEvPFva08bpWOwr9l+8c01veBc8AM25WrVMOvBBEUllKlBxCC8k20tIybT2KWWUR\r 6vjCzQmEJyu1XT574aly/AmHJxD/u+8uNL3C3mDY8MFy0013Wh2sm6hPuHTZGhk9eqitRA/Eg/x4\r mW3VdRomRakfB7Co8L5/PClrlBCccfoxezXpxUvvxo1bpbAoX7kiXyiJ148jZk6Wu//yH7nqK+db\r HtBDB9K4c4f0L3cfLdllbmoJ+MsPrwDQeJRMvhqF5CiJoOvASYBFPZ34jZ0OiYGd62TJko8USWfo\r AGmV/D4l0n/kFNmywWcZNM5HaQq1DpTsGZ5nnMh4/cDbpUKRXGdHp3EwEJH99x8n1bmR+2rrHH0k\r 7gjO80Lcw7p1H9gMH4TtCDTFzDFBao5UUUyyOCm5wpyZVSgbV+SFPNxR5ClyhCBBgJCbcx8VOqvE\r ZTazuF0Vy+xDTvYlIAC/ppvpupWWcR72HJ3zQEzgBIo3RD2vY/U1h7UZzZvelU2v324Dl9zMjFQZ\r O3aspExCrq4cFzLxqLzVpZSGmOKG/IB48MnUosiAWTaIB2eGoTwlvbxzE5ZtZ901iutltC0lNgsf\r /KoRY2bwID8Hb8druM4BwmDbzepf/zFHGaJF3g0R6Dt6prlRgUMAtj//DVm1do20RotPc3LzpHjc\r SVI+4/PWIuW7AIX+vyD2OUVRfJ7V6IQCwXD14hdll86yhx91qRLaN+Wwq/5jFlFsg7tNy3FZOCFE\r d/Sd+8Qi6907PimjT/yGclLf8AIRcO9+nU756PYZsp49J/RVK+40I4nUUWeZFRd1KAaRtfdi1cgh\r 4uGa1/6s3OortmYFceKIY75iIkUAvReuRcxgxdpK1nMdg8dx+ggBMY/Clm8lzOlioo52zvURncax\r 4DqHNVRe2M+zjwsKdyNiVtZ1GaFeyGPyFNIsKmR9CMSJCQ94gTomNrP6sbqKCEIavQzfINxPZg3O\r KNvk5zd8Ts694IwE8cDtCGsliO8rhLohBBBXQUDYsOm4Yw/rVU/yl78+Jl+8+ByLf1zw0stvywkn\r XyonHj9dnn/2z1Hu7uEb3/yVnHfuSXLYzAujHJHf3nK9NDS0yOEzDkz0VYdaV8gpSPqC2SP09oH1\r yAPpRNE4WF5vJ7rCmPwa20lNh5RBsVLEkUNKpLJyqxMPbcMWECnShWAwiwWceCD2EXPtXj54kCne\r QYA6XmT16tXSN51NV+gDfdQwQk5+JBGth4hnpthsmrzG7b45FF49w/4TfOzIULeteN3OGbI2pE0b\r UdoOb5eZWkdHqw1cziFjh4viPIsIXQSA9UlP4pFoBwJl13DigYUJ5yEeWMYkiIfVC9f2dkDazLqw\r tsorws2LA3uENDY2GdfBEcon20g15alGtLS2rX/mEVeJB3n4+YLoYGAQrhmuW7P6PeU6bjVuop+J\r e/x+8AmG3HzLgidk9Yu/k4MuuM3MXM3dR1TX+qB/uHCBE0CshK5i7Cnflv1OvcGuser5W6Ru9RwZ\r e/K3TCSz7NlfyPLnb7ajvr7ePBdEvIuMGT1WDv78nxVRHyl9xxwRXUevYNZS3ud9PfQnedgnRZjM\r 66uEcLT2c+wp35IZ170kJ/5ilfWxRPNXKPczT2f4eN6FE3L9ixKO5bNM7IWoq7/mmQJd22KisVzv\r EzEXafuLroPtf1ZOeqIHAGbNiLdYH0M5zKBXvXybcX/Wf+snNVJlxNGXybRLH9TnPk1GHnu1nk81\r nQqtEceViSH66H2Eel3jiP7uMcs9vCkUD5+sz71RKpa8FJXz64UJFTo7kLzdg14HFyjkM57dBH2J\r maR7He9HCENeMGnH1BduJDUz15Tj4AjOQyC8rF8/OZnytK8PWS8D0rbIyhXL5ezjD04QjwCBePw3\r oix8UQHUCzqQ8F4gHrTfm55k1Mi9O0D8b+GoI6fKsKGD5IWX3pZt24IxyO7hjNOOlpycLOOwA8x5\r Z4GcdebRXcRYPURYb736ptz30LMWTy9wVx/WRKwhy4mSNgADeEGLOvCio+huyiV+Y6dDoqlmpbll\r x0IoNSNNygaWSWX6aGP3E4MByqDlMZllr3HycBaIKKijtcnkqrlFAySlqcrMOCEgrW3tkpfWKO0F\r Ebdg16evUZuxkJk26zxAWFj61K5915S2zKJh65G9mtxUOQ/Kc2Tk9YnaiAZpghPx0GY8Wp6ZF1wL\r fYUIghxdfFUnrcqOw77bhxXaifdN26RPzAxxkdF/3DE248L1+sZ3/mmWPpS18rGPnPaCG5K+wyZL\r 7aaPJKvPcJ15vqEsfYp5Mma9RN8pOvOw6/Eu/PnwLEDyZkCQaDPFzEnpM/GkT66obnR9EBaiLsRR\r ZvKsM1w9acemef/Se18h407/viFQyw9taF1mzR8qV7LxvYeV2EwyQs5iwRZFZpvfe0hn92+5uEmf\r yYZ3/ykb333Q2h926IUyRhF1+bQLpLDiWdOlZWVlKQFql0EDB0rBZFxyeD/hElCmgsBQclcvY1/o\r FFn48HUmWkN0CYfQ/cDqbMVzN2vfHjK9GOOBnQo3mTfbXSaKTC405QC4PycsRiROuV7KDj5LOprr\r pfKjl4yQ5PQfYZuHte6qsWdrjhv12SByYm0RhGTNq3fYrBnOK33WJeZluLGx1SZcAwaUSM748+W9\r P51vHAyc1rpZf1YOb7qmD7Px+9HjPzRFMmnrWfTD82CxIt593XBDTJwJoMSG2EHczfWNV/FQAZEg\r 909O6f7H2bODQ8VvG+dyigZxBSvrYYq1w0JgVkuV7H+8Oeo04qHvAn0IaUSH7EUeaoZfvnkzvdXJ\r G999iz6rbJwv6gQCZ44AY86+rbx+wn7+gLcQ+qA4Qeut/nCWlPYrlMcevFneemehIXU4j8efeFXO\r P/8UeeedD235AKKmfYHJUybIAw88JQccMDYhtnIi5OKq6upaU3L/4/6n5EhF8FmZGebAEBFWKPNx\r AU4WV63eIO++t8iMkOjHnoBrf/oCnbyU9NFJPIu0fXX7kCEDtY2P5NIvOYfUQ4R1910PybXf/KXF\r Dxw/UZZvZ8MdUuGRAxqPkuEFeNC1jNcL0Hs5j+lvMkshRQ4sa5J3333HXhiQlZEp5ftNk4qGsMF9\r VEcvEuc48EmFKIj4Lp25FEQrzrO2vWucCywYwOrrqVOnyobOoKCmPUdaIDzP89k2ymHYXd8zIVVa\r FTFk5oUFVLgoebOXVeZJBGuzrYiIBBNdkD3uwpkxsY8HC8QGHHCqbF3wlLnkKNH2kn1K9ocwcD0m\r ptKZmlmz6MfHveO/aOCBbGVL3ah+4n4gHljHiBGPYGGVWr9RPvjPz8mWdGXiqDbjBrwyexv8ISpo\r b23QDxU7emZWnNNAf/j46DPPibKhHmC+oCxNSmfAynlghov5MzL0hpq1th+41+Hf61F/28q3Zd2b\r f5Vhh3/RziE+6WhtdtGGIhiut/q1Ow3RAmNPvl6RKZZN9h+Bx5b/Tgnrxk3SzC6MmjVACUjhoV+x\r DbQCB4vILIC7zklL5KHk3xPgrBN5vCnOtSwHxKGv3q8Tm7fsHL1BPwY3Yh9e8icGmtZ/1pqs1mOk\r ciFuNeRiRiy5aDMAoqHimpeVgHxgEyTEtIcffqgUnPWotbPyhV+bXoYxyk6Oo4//qpn/wi0OnfE5\r qVRiWTIWsTXXpTUPrWUNjNhbMjqnB9wpyvcRR10elQt1OkyMZWUt7QdcJt8SKVOiRx6CTbREroY2\r sdEQooEHBGtP07hAcZf5YtyG1bH2XYxFHMeScEfBxJfCuDrBpJ9yXCNfx24QWyXrdkjprjdkyaLF\r wpbWD9z9AyVULoUByW7aVGF6DxB6yHvp5Tly/HG4o9k7BKIRj+8pLynS+t+4OEnJOEBKS/pKxeZZ\r Uc7uATfv9OWY4/X7iwBX7z/8/pWSm5Nt/VPM0hVQvgbIyEyPPj//ddB4lEx87HuF3st5brI9B09U\r VlfKjp2N0tzcqpxDq/Qr6S9bdiCAcGA/j4CkktVdOUdGgnh4tmxryZeRI0dKbi5EgBW6mbJokc5w\r MpujdmKHpkG2KErNskjjmGnagNc4Sl8QAogZ9ppNdOKiq1DfQ88LyD/k0bcORcikBx10uuTbTE/j\r k86S/ooEvX5P4sHMEV9LCVPYqAxWP8zAksTD8+P1zdGjJZ0L0Vw715E/TPJzM2ww8PpZD9K5C1EF\r 9TDRnafjotXWc7BNqZ6wtTAQWmaXyO9NDxIRqnAgKqE+M2DMW9FrQDzIw4AAUVG5cgneV3rj9c3y\r ac08WfH8LTJ85iXaqTY9g9sUTIiZDQ+R5TpLf+eP5ykimybTr35CZujBzNzb0UIctKWIls23Kqtr\r jHjoGwR/SFFhoRQPnaJI/QhT2u73iRtslkwdZvt4FTbjCEP+TBCOsAPECbFkHQNp65AeKHBxiYJe\r g2vTLs+H++2/n7t+p29WXoFyc35/unE+KMDhovxcdGgcInPyrdUm7sIXFpxJp56CS0Mhj8kxx9iT\r rjfFub03vTcmR4Vn/1tb8feHOPDkX220haFwu4wFRFv5g7BgUk5hv2PlhRtGmZiLtL8HRoO/F9zx\r +26K6Lq8f3C/7FFCeasThdSzZ6RcQDPWeVF5xibPjCTiVZtQ6fu3UP+o5y7jlYtUDpq85Bj3Pnl9\r 7xvtxuP4iiM0D9sQGa3hJr7KgSAaJq2Tt+T3wDX9utuqq6SwMDNBPEDknAepdycexCEeIW9vEIhC\r iMcJRRy26+weuObqC/Ub7NAyU0xP8nHDjOkHSVVVjRkE7A1Ymc4EfkBpcg3Mxo0V0q9vofzoRtej\r MEq6wGFTI6QbQJ/xXsHKxAvyYqJoHHqU2z1sr63TrwHT0gzb77d88BAbhF7fkTtQrzNH26I2tM3g\r sDMRaHrXZhYMTpSanIOVRe1vbGyalqpXAlWz4lWNRfVsQIUwVdKzcvVDwTbe1yhgbmuL2GJlmR3x\r GJnFhvzkwE4OcI1YugHTwkjG3qisPnl4ut0ZyX63fvCEIa9k/dCeh8xqg6UVoho+MhZkhcWDoe8h\r DO1AMNpb6y2dnplrC/1s0ZghC5GyQQOpbgQEqJpzp6Q2VfpsUk9AANA3WSE9mrZvlozsAm3OTTX9\r en5NFK/0jTUKtM86GTgsdC48PyysRhx9qYlkqBfqIpapWcWq67eUYLXJ9KsetzIFQyba9sIQjWXP\r /Uo2vH637Ic+IRCN6P35/TrRWP7cL80zLvH0rEJpbHBXDun67LnF0pISPYdzS5D+G1KtCB290PJn\r fi7v3HGuIr9KWfTIt2SFpnFzwXnaw2QWJ4mseVn2zC+UtsHRpli9Rf+63kR1y5/9ufXDzam9P4RO\r VAiPtPQBn3GEzbqhfmNnGkGBE0Iklnie0b1BTE5VYpLbd7gRVnQnr//qWC17i7Q+92lpbGzUsvq0\r 9RHg98rqRs/D/jSEkAydfpFtt8w7QReFU0vKsBiR9wXytjrRQdxEjkow5v3lC/pu3zP9ViAy1ctn\r J+JWR/+og2k0VmUhH6suxoJ5w9Yi7pgzGjcRd049iIhtXKVpMwIxLpvx7qvW0Yl42ejeojjtmLhN\r x6MvoPVtD5BMsGEU+hDGIJZdyTr6Lax9TNatWyffuryrp10miwHhY74eR/5OPLRD+wjHaJ0AYc0H\r Ii0gtId1FGGfPkVy00/cN1a69vfjhjtu+75Nor7zvVs9Yw9A39jz/corPh3l6MRnW53c8Udf0Mo+\r Qj1EWEB8NXru4BmmgG7riB4YL5wg9utBFDfgxUbReH6sXOI3djokRvetkeVLl8mOHTuktbVTcnIy\r JCVvuA0CILgxAOqVRWUmxcwL539cOC66YiBBQNiilgEzLGWFvPPOXE7ZniFNOis98MD9pa4wyO69\r jZ0sdFJWGwUxcn1mNsxQQWihXPCumxiQfL12Lj6wXVlYueQFGXDAKWYiCOuMlUm4lnvfHWPp+MG5\r eOi28b54EVk49xhWnkNEhh722eiaPFc3ldWIcxuKOFHON9VsMP9fcAws/OI8M8bW178t77/7pjQp\r okWMVVgyWMpP+L42k2VlQSD0w61ytI4ikX6mKPdrEBIDwZpjQX1mICm4D3ftou9BkeOwma53MIhC\r RFWmONZZuIuheMbkk/emKUR5flMv+buLqAKEdhTwtIrMHgQy7rTvKtfxoiEUTGTxtPvOrafaVsc8\r lxYd+KNHjZSa1DIZPPU8JYYuK8ctCO8bogKiZI2E35VEyD9A10+mGu5TQ3KxrKP/iAeZ8a945pc6\r NtttHQrEE061fNpnJAdrPQXux8Vjnbb5FO9iuRIm0oW4/lCilhR3xa/bqYTql05sNIXPq+aWNuU+\r 0mTkqOEy6tI3bW+PAQee4h3jJ6qPOGfV87+WFS/+1ogG7lG26zeCfgOT6LC6nfU8Vpp6VrdTz6O7\r 6pSWndU6nk+2c3FLrVDO6yAm0vORRRbiIiz02A2QhafkmfWdiZKiesxgNI4olg2+mHTAeUCo2a8n\r LTPPFqXSVxNN2TWi+hpCPCAcbp3VYXqPjLxinbitNZEpYy/UGbDzNfng/flSmJsuC96+V/L6uMlv\r IBTz5y+RnTvruxAP4MMPlynO2E/z5moeu0LuHW5SjuP7OqMHQltJcZWnn3zqNTn9tKPlo49W274c\r wD8ffEY+8+lTLf5xQVbuJGlpbZMdNXPM9fueADHWQ/+8RQYMTu6e2F8n9H+688fKteX1VKIDP/tF\r UsueXuiKdHc6rYd/TxokIuEnCfqSkjm9l/OY/iazFDzRUrtaKioqbTack5Np+xhU1DSZ6IAyiAtM\r 5ryzyhTZXK9lZ6WwRzZXZsdBWHXyG3TQ2f7mIFadAW1P6S/lRU1SqWxcVna6PsgOaWpqkOF92mRX\r OgPM9R58/NRBAQpSQjQWrkUZF2scZQgBvYAjbb1GgogEIuChW4SkWr9Yg8ICQjzcguRoC0Jo7jis\r jl8jHueDwF8Qtu+YeGJDjxK+VZ9Bk977gP1Piq4V9SOqa8RDQ6xhdmkb7LwHFxMnHpzPysmXndUb\r ZVfNFpvF1u/aJaMOPUdad1VJzoBxprNg0ViWXpPd9mwhJdfSNgghFgt1Bg5CJo/1McCmeY9Y++m5\r RVI26QyLWz36p+Xm3P5J4/TGnPB1Q/b0DQ4EDgalNiIe9gU/4Lxf23mv6wdiIMQ/yK472lvMXDPM\r dNnMCr3BtlVvKEL+mS32o6vmal/DvoddIeXTP2tjCsKLGBJla4mGvGcU02YcYQcGErwHDi4d4n5Y\r mb5elnYwkICAki4/7AI9PmuWPkY8uGZeX3MOCVJ85/YzZYgSFBpG78I2q17vQhszpk/RZ4BV08oX\r f2McF2UBdCoD6mdJZWWFNDe3cXvGsWdkZEm/KRcZ4l2p3Mo7d37Ky0eEmXLoUfDBhT4NU3TuFQ/B\r gCvVU2Tz/EftPricXVF/MKDgQARpZuwax+kgCw8XPvR1M96woqGCHnilhkjTJtspo0zvM2ySheYa\r KCjW+Y8uhh4TnZeNc/1e4Dxst0glBi07qvQ7QKle4vWiK/HLxlOIlVNSOo37aKrdYN8MHC3nWFdk\r a6yUsOAUNCc7xTaJGqeTyAAokEHqLS2tCUR/0UVnWR5K9UMPPdDioey+QCBClA87EdJnlOYjRgyx\r cyee6GtOpk6daNeES6nZtl3LfrzrQgry82zf8/IhA+UQvdaegDUhKPtff2Oe1NZiuSpmpXniCdPl\r D7c/smcCMljZ/Ma0fhHxUIgGLhBenAfJfDuTSMbyY+WSp2PnY2Xrq5abshvOY+DAgbJqS1uv3AcD\r DITNzDavHyaser4b98FGUZk6AB2hOlJtzi6XtF2rdHbRZFnoWFpamqSsbLA0dObawDZLIz1ph14j\r 1De/SYogEGe5YhMrGx1EUVkLTURF3MU7yF7r1r5nstiqJbgqGa0He3I4QWE2xcfhdUJd2kvGmfGB\r vFkgaa7r9RwElBlce1O9IUL/+JL9qF7+ht7L5sgaxhXmIEYjHlqWVfShbGf+MNn+zm2yY2eD7S3P\r hK5QKiWteKQRWMr0USLEVrN+neS1WDWOmAfiwTXsTUbnMXUeOPEURYoRwdE8/THHgwsf/LpxHNjs\r 835ZXMcMHtEPhGPooRfa7BuE6nVpOcVm3iBViAL7bpgrCh2lbPGKHgIOoloJx4Y5D5h5ZlblG7Kj\r bjtFtLYilvx8mXLlE4Y0Ofw5e8/RE+3YtMTqhQPOBuTPQk+effxc9bLXpEYJGVwdCygrPnzK+gjS\r ZIyEtskz4qLEiPspm3y2EQCIBubfuA3B/Hn5sz+z22TdiOlYtB5b2KKDw9/USz+YYAsXMQGm3dp5\r d+sHXmVyc0SzWBju2LHTDD7QlRjHpi+z36jD5bWfHmLjBW6Xi/CHz7Oqj16VD+6/UkrGH2tirc1K\r 9AdPVaKj/QhbvpII98GBF16IIu0wueAYdsQXzTVKX9MbekkHnkdZREQcehIR327a/6PK2jYr1OG4\r SUI0MHfHszQGIxgt9CQiSkQ1jwkmEzTGMdvjhoWGtmBXCUrLsodlzZq18kvWe1wY3wPGgcV3++8/\r qguXAARCEOI/vvHOhDhqb/D3vz9udQKBIo64ivqBqLDgD5Nb7oX0/8Iia9y4EfLLX/1FVqxcJ1df\r iQHL7oHrXnzJ92zL27feTjp8xM17R6d+/72JsMYdcqm5dQdyBmNWCegtRW8ovDADG1QxsIEZoPdy\r HtPf2OmQGFVUrazjfGlVziA722WASfEVH7gvGky2oXlKQHyVLUo0XJeDjGFV2xWHZ1g8IC5HmCmS\r 314hG5fPk0ZFzCgfmXUPHz5U+uosvzqNfaGpkmbcCMu0mb0hikGUYW0kiIq36fEojM4hvkLmyqC1\r cxC7ypXaP+zWU2TLgqd0Vn5WgptJthP6mSqb5v7LkEBu/6HGniMTDmKr+m1rZceGhYaMutcLFlbo\r OSoXP+/GBZqmDEffYXzkHuePcO1fT5G1G5RzUAKij0QGDugvB1xwh/KsB5s1VT+djVodIKrH/iea\r sMPOROftWYHAFCHZlN/Pmp6DmImrTrlelj/3K7MKYlOuze89bGap+53ybemrnEioQ4i4kNk4yAGd\r V3wmHsqx2rpq6StK0CFyzNCPNCRcc++RMnfuPHNZz2AfXDZIhpznu8iB9PEDZfHls2XkcVebfJ44\r +SBu13P4+e4Q6u7YuMBETgZ6EUSV1GWSQ1g05GBZ//a92m/vE4VAbknoNFEYAFHiPZKGaGQoxwIC\r 7DcafU2yDzynRb87QNav32D3C8c+adJBsrP/SWbBBaBsH3vSN2Xt6/cYgodrCwsu/WkQaF/0D/Pl\r nVg7KYw64auWj9gNCy624/UO6xGVR5zVVzkP4qZL0fziEVNl/l8vkckX3WX5iIoS19IQv2isccpR\r oolhAObqnEf34aIlakWhprevX2ATLrwD8B78HM15u4VlYUOqpBgrnjb9iYZM2BBDY5mVtfZhWbZs\r mfQrzJaF7/1jt2vferPAIj59+sGSmZkhN950p/zg+1do3r6LsgLh6B72du7uex6VL13ySXn2udfl\r lJPjItT/O4wcc7KtbVm94rm9EqczzrpKfvC9y2XmUZ9P7KaIyfGPf3h17xzIH+56MuHOJCMSYdlH\r Gn2vEaqI0lHcQM/Ek7sp5zH9TWQlz21Y9rYprdJZNq7Qm+4jXt+JB+wnhATikeQ+IAAWjyn5CMlr\r TS2QvunbZVtVleBEkI9v587t0ic/XSorqiPFoSNNZtfMGtOzCnT2Pt84EAYziCEgbMIuSFyvTYjL\r BWzTzcmgIlJEPeYcEYKnZUGIvo91T+LBeSyuMPmlP8x+manBebCXNtuYFugH1Fu97IIBNnPEDr9k\r vyNtpkcZDj76EPdnov1SBN6+8Q2p37VDES1fqMvVc7Izpak90xagJev4NXAiSBwTzRadKXIOwsHu\r hGNPuk6fmY6dQDyic1gbMeuFcBJnxf3muQ/Lh/+8RvY/+ycy9tRvm0jF6ugBcYUA8p4h3sxiGQfo\r BngH7KGOoQOOK1sb3Apt6HQXSRnnom1sf+9PsrWiyta40GpGZqaUTPmMIWoIAIQBxa0ZTOh7gxtE\r F0J9iCByeIA0s3SuQfu8f7daZCY/1XRkcFCMD1xoDDroNJsl4yMKb8qDp5wr7c31sl45GtebpMiG\r d/5hYjMebVIM5lZbbDXAzB4xY5NyZ2UHn2ncZPHwabbR0pLfT5KNSvDxuos+D6Q2btw4KT3198a5\r Kea0GTv7lMP9rnnxdzLk0E+7El4JDC7L4Ux4KDwXkCs6EO4Fjwq1q5gciOlI3vvzp42r8nfj5eG8\r mVjQjoNzI/jQWvb0zyJCyV3yZ1G9xhgjhuz+CPJnTU9eyXC7V7jk7pxIVtEAU5532pTGN6Zq3qlj\r zUv5N2GWgVYlCj22azMi4nHGtcN1oBtpX3iXzrxXSX5Wilx96dly1LHuTbk3eP/9jwy5VlXVyowZ\r kwyxA6NGuYsnkHxNzXadjW/bZw6hNy4kiKvAeSwGvVfLkEb/Qrkxo4dp2bka//hEWQUFufL4k6/Z\r YsG9mSSPHjVUaut2KCFT/FDvxhrt7R0yYkRZ7xwIEBTpzoH4CwXCyzGwaCzN2USy93KJ39jpeAK3\r 7QEm7j9Blmxo1AE2WlMpMe4j1Ne83XAfAXE5gowQq/7RwYBw01P04698T9YsX2Kmj2wwtGNHgwwq\r GyjZ488XLK+oDwcQdBvMgkv2O9qQDov3ktxGQN4hTDNngOgdcGS4ddGzZq4bymDi2BopAykb+hn6\r RmjeSZUjYpEacnTyIQi237gRxeS9eH1vB8spOC9ETqSZfZqCU+NGPOLPQeMQD02ZsvzDW6dL9bbt\r NGWc2ZQpk6Tfuf9K1tE/PsgFD1wt0y5na9MOW2Tn5/nX52WbapHldSAUWC71V0Jm5pb6h7NCiiCO\r gpsYo7NpB2+H58xHj4wewoF4i3bZxwGkM//eS2x2DkAEArIy0ABikF04yDiXiudukK1bKuws6H7U\r yBGy/zeX2H4e4077nix96icWYnaMiAevxu0t9UocHGlhvWPOOncDIHxcuEdXN4DTCB8WxAZrJQgM\r ejr6SpoDM2Y2htq+6UPTMY0xyzVQP7Npi9qiRERKWIWtfvV2W3nPseTWg2T16jXaNy2kFx89eriM\r v9r3preqzMgVFj36bcnMLTZiiFhr/Zv3Sl7pKCN+CQ7RK9isHZ3aqz8+2HZTDG14ix06CZjj7uMt\r 38sHxbrlReXhfJf8+/uy/1k/tjLJ8qwT0fES5TGZ4DyLVAnN8wJWiBqPcyKEcNWW7uiUosETzGrO\r z8OJxF3Aa3m9N9LGgWg7xHF1sv75H0n11q3KPVwjnzn3ePNNtSe4UZH7D37wFfPIW1GxrQvCJ57k\r Gj4+LgSnpocdFnGzEQRu5+OE9KyDzE39pvWvRDm7h1M+cbnk5mbLY/9J4mdWtoNBdgv5WelyxJjd\r mJLZ1xL/ZDQeTwboUa47JM/tX8p2rQ4paZlS2ZgbEQ/pIroyc1LyIiU0bTjxgPuwpP04UvUMQ1cg\r rSiPEF1F+qBp5nUSay+IR2ZWhiKbrZKXsssRVqRApQ2QGjb9fPhGPED4EXfTte1UW3vAugeIB58O\r sx/OoTNhNTdOA9HX6Ncb1etKPDzNZVNNoYqVFfmp+lx2bMTkN5QL13XiYZv9RMTDVlDj4j1OPKxs\r /Fp4UsXP1zT92Bbr/WfpRZPQHOk/KMeByGrDO/eb0tvMc9MZH5oPN6J/iEdoN7TN2gL2w5hw7i9t\r 5k5bmFSvUMIB8Zj6ZW3LiIeXR+aNFRLPmlX5ThyONEQLwn/71lNl/Vt/01nx12W/076rx/eMMHE9\r OEZm19XKBbS3NMn6t/8ueDa2x8jNKPAuiouKEuIiiAdAHXPkqCWZiUM8ED9BHJx4oMM4uuuhRIKZ\r M5MJFuKFfLy8Vq+YbffDsezpn2h7bfqc37eyXIt2aZP3OmjSGSZi4T65R46tHzyZqD/4EDdMmHju\r zbb1LveAori+fhf40iArK81mh7hv4VnYn4bEJ37yF5Z++w9nyms/O8z2DOF5QMjWvvkXeebrA20h\r HtegTo7O6E+9ZbNU6qQHERbWiK5gT7PnHtaLhPJmjadxrOUsX//rdBIDR8lCz9APL+/rRDjIq1v3\r vo1TzuH9GWV52Hvfvq2oDumEqbp+t+wbQhwOnfZ3KLdh16F87JuEywncfuuHf5LqikrlIIZKcU6q\r iahA2HsCiAdlAvEgjk5k0qTxCcRPyIx+X2F2dM048WA7WQBv2BAPiBTAecBFZXvu638LOEfcsqVK\r li0LW2HsHtra2uXKr3wmSjmsW7+ldxEWgCK9palZH/YoWV8bjVIFXk8UCT8R8KKjaDw/Vi7xGzud\r TKRIZkuFbKthrYcO1awiSSkcZXHOBcsrTF6zCiJrLJ2hBiWaKdR04Fv/mFFpZyxuyM8Hk8UTeawH\r SNcjQ6nwQKmq2CJZ6e2mUKdoTstWSSs90BXljTts7QT7D2QrS93e1uzXsnaj9rtwImk2a8XahjRu\r q/kQEV2BzHHnwGzTra5c1GWDP2qDWRPXQWkOUsdKZWdENPiIeA4oaMN9JPqgHw6minA35uJCZ5dm\r oqplnHhouQTB8ufD7nqjjr/GZuwgufYNs5VdZQtLLWLPvkMGzbjc6mIWyqyv38iIw9C2Gus2SsXC\r Z2T86d8XTIs54UYEKbJQZ8wgYcRVTVoOCymuuejhbwjb0u5/1k2GgCnLUbHoBSW8zxnRQEGOdRQc\r yzt3nGWKcvYaLxl/nOZ/TicT7LLn9wFCRqEN0sd9BS5sfPdFMXFSXt37Ul1dbfcEFBYWSM5+p5lo\r CoML3gPtDDzgFCuPuIeJAjN2OJ7+ynGStra6HCOsTDiHOw2ORJ4pzIfbu+D9IE5hJ0Dqbphzn3Ky\r R+l9rbP+sygvM7eviZuYoFA2iLpQ4Acxl+t1jpTFtx9uXBVSWohIdla2jB4zSoZ98h7bNXHBP69R\r olBnXBr1cJtiCxJ1AoNYEPEiB5ZI06/6j63m3/KBr7uxl6v/JeOOlW2r37JJC6SXPTsQpQKb5z/m\r OrGoLBswsVEY3CZeeMlDnMW7XzPbDQQC2PhTYGzyPWQX6ZjVOGM3R8e8GbFoCHjJKNR66PKwzIqa\r kIzsQmlpqJEU5TCyCgYkygMeTzEpQGnTPNODDR5cIld96UyZPNUdAiIiChzF7gAFd0D2AHXmRPue\r E+c8ehHOk94bHHLIRFm0aKV5xWWXQups377TwpGRRRbxcIT0vX9/Uvu5b1zOvgAT53888LTg9v/k\r k2Lm8b0A3AbrPh5//JWEHgTYswhLkenRxx4l76wHOfEqYq8nvMEAmk7mRDELuufqbzJLwRPThnfI\r K6+5S4oABSNPtBDEY15vNY5rgnz9uMznP9Ykmuu6j0h0FR2JuCFMkDp5vYWY7c6TgeUjZenrDxnt\r QSeSpTPrMQcpu7+t1RAaZUN5Cw3ZJ9tI5nGk2YfJvs/sTwHBoyyECKIS3LYH0VWyDfqMIznfNxoT\r ULZWDes7NipCKSw/WHDTHi9P/br10axNsxAfsCZmzey77PlgYplwM2J1iKXo7PAO2+aUNQ+er/1Q\r IrLovoulRTkygGdx7HXPyqp5z5uoyWT+WjSvZIzJ7zVqu/dZZnR91nXMueMcOezKxyyfZ9qp72G5\r zo4pf9g1bqlEWUL8SSFqop+shQBKdHa87OmfC4YQJkJUJOZiKgWtiCUZXotDujdgRgxib190r842\r 2Uyq3ZDt9MMOlX4XOwcSB8QzmANXL5vthFgRIIQAfQvvDP1IcG0CV2Krx40f8DUQjCPWwGCpB9E3\r QmScBhD7zDS69Kmb7Fz18tei0F1LsNAvIGkAf1CY41Yufsn0HwFW/nm6LF6wwJ+ttrf/hP2k9Kx/\r mOkqF1iqz459UDDagECytwz5lF2h72HZc780bgbuwaaHegLCgu7Kk/RXDw2ZZMChMj4gGgiXMIaA\r UEPMSFvD+nDZ2pfN2lD8Iyarr1hp3MaqV2+XkUdfocX0alHbIe4iLZ7hwRqfZ7olFgozWUqKpZIh\r HDN18Zfl7k8gHqV6GlPdEkubl2Zrv0OKNz0k7777ruQpHbz+qxfItV+7WPDrhI4DiHMCu4NAPCjz\r s5/fJd+54cuWt2LlelN0761+dwiiMSDUfeutD2TGjIONoMHlVFRU6+S2v7BHyPnnnazl9l1Mti/Q\r 3Nwi2flTZOCAfrJl42tR7u6BNSFsCf3iy2yP4LBHDgT/52s3bEgo0g0BeST8RBCQARDLj5VL/MZO\r JxMpkp9SJ1u2+oIu4ID9J0hdm3sCTc/BH1dKYtEgeWkZuSY+oU+9cx8gZfrVFTl3P4dug5lSZv+x\r kt24WhoaGkz2397WIfV1W6WkQMv0j9aRREeId+U6uuah+ObjTSB7za9icZt+zJWLX7AQJO914/1M\r NcUhCIgtN7FOweqKGRkea1Fkejm/H6und8SsDBEAIdwEuhV22cNDcQ/iocfmD/4jQ2f4ymLa4Rl3\r trFffLq0r39V6hsajXjwLBrXvir7X3iP6SG8jVTZ8PbfTZxRgiiP1qN2tyx40jY5mnDOzzRXyYbm\r pabnKDH4qRGggz7rIg3rv5ZY9cofdDKw0vQcyL7JxmXK27edYTNRxHdcg5k8J5mRb3j7PjPfHXHk\r lw3Bg4CDSAgFbeWSl6w83Mugg8+UDW/cZeIdzFxBXRPO+63U1VQagYET4NmwTzbIhjgcws7Ni6xt\r iAJu7zXbkGUAiAnECY4CN+eILPHphbEEVmCsorbzyhmxlzjXhauibxAb51qGJTgV5zr21/EyyQgt\r 1lbsjwFBWvrUTw0Zr9e+cv9902ukYstWqdmIchmT02xb+9HYlmnrS7A2GveJ79haDUR/KJrdoIBH\r mGJEEG6ECQDb0bIHR/mhnzHuY5sSP4j/yKMutXvmB7EkIkWeXoeOEZTWcNiI0dgIDf9m9uK0LGbe\r zfoOqNumkyc4WN5rRma++aoyk/cIwhjA1BxAt0UWnCRhkhPhrQAeskcNHAtrSsKZfDzqKqdn5u6F\r vt8F4y996d2ydu1aSetokgf/dqMMKBsobCPr7kKSymyA+O4gcAMg90+eo5xwSV/jPFBAo7PgXoqL\r C6ytPbUTgF6zbwgQlOarV2+wupwjnDdvsYUTJ4y2OFzO08/MkrFjfBHq/xVQ2uPmfenSNbZYEY8f\r ewL6ieju7Yj7AvZMQCKAgIQXmAyiuIG+xkQylh8rl/iNnU4mUiSrrVK21ejAi6C2OU/Sc/vpKW0b\r pKx5iKyQiwPYuVNvj9wHCHY3hCSEIIg+toNeimSW6oyndomw6ZCelebWNvMEXDpgkLSk4x7CEXYc\r 2XcnIhAHFKUm49WvG8KGMp5FcCj8CSEEce4j1EVZitgKFyFbPnzCyuCJdOfGhXbf+ODy68buQe8P\r nQQfNR8ce5YwCwORQTz4YMMz4KAOfqYQR9iHq+3gmgLLLqynSvc/XtqWP2ILLW3Sp1fA900qRJSn\r Ql81hJAXlLoYyfuTYsiH8yOPvVKaFLHqGanWWe37910uB194pxED7zME7HEzUQZBgtzI52CPD2b2\r LHSb+KmbnXDQjiJU1mMMm/F5uxYKaRa6cQ4kvl6JCgib9TAm5tJyiJ5AQBte/Lk06jvlXlDe9z/o\r TEnJLDCdBM4OQd65/TDdTjEDCcxtBx14uiJWRZZFZSYGyshllbL3PX7QPwgZ99GqCDMtPSuhUwIQ\r U7mhgCv54Sjo19Inb9RkirlIDyIyOAX2s6E/lGVbXJTmmJFjJRYI5bw7T5XNK983SxigbPBAOeib\r bqWG0QHmuGwLy1bGEPqh+txxuwJhSlVC41sEiOmkGipXm0ud0nHHKVFwww/W7bz6k6mChVawuqIt\r PF4ve/ZnMmTqeYbkWfuC2HLzPH2PRkSsqOYNMctFRg97j5jrHT3JadZk2U6EEdCPbJ0UUcbc6+gk\r KHjR5VxPIqLlNd3WrMRDC0Cs25TAs1bEKug1w2SyaP0/ZNWqVbJhzRr57U8ukz4DfDOo8z51siH/\r cEBIBg8ulTfemL9H5A9xOOmkmbbwD0LC4kJEWSDWM8881s4fccQU69feAOLx0EPPysSJY2TI4AGm\r h5g5c4q1QX/iIX266+5HjMhs2Vy1xz7+tzB06CD5+z+etHUve7PGYlHh1q3VCXcsANhgHyF6KBbE\r H5DGe3tePcp1h3AuRQ4a1CDLV4b9zUVaW9olWzkCL+PlXHTlCwh9oCSCUEQazXlaqMMQ0lDT9kIt\r JDuejspFaY6+U79sCsn8PBelVFXXStWSFyW9ky0/HdE78nakTN1QH3NTPOrifI48ZtaEvvAv1dZr\r 2Gr5qE5oIxx4mK1a+rLFccvOfh5wIEMUeYQ9OMK19EcP70vh4Ik2q+X54Mp98/x/a3lfLNiVeGhc\r 0yy4g2jgqsIWICoRZDY3aJIiVv0ru+Ax4z5AuFhT4xVA6lbYrNpAm+uvyMXugYRyfe/d/VlhbUe6\r IgEIAItPl7Hgb8Wbctpt7o7cKmodXGWA6EYcc6WbGevMHrNPDsQhKMbNA6+WR/7PTn8gYpAnSu++\r eu3BUz9p5wOyBeDaBux/opWlb+ypsfSpG6VNES33Y7fPT2ONIWyIUP9xIG8MImhrllRF7WEhZyIQ\r zW+o3WjIjTqYz8YPkD51GpS7oP7OymXKXfrqXtIfKaEYe8oN1iYHbWiT1m+IFXnE2VRq6ZM32fXG\r nf4Dc22P2w8cPlIGRXw46nfVSyteqnmcejuDBztC4Z6xJjvyW6/LAZ/6le2vP2zml6w+15zx1WcU\r uQ4yok4Gf5hNDznkPHn2ukFK1J+QWj1HO6f8apP5HsOtu405LQtRP/jCO8yJZXBeCEA8V730O+M2\r Q1nMvtHV6VRPk6kJZ4w71n9gIqvE2Le+sQVCX5t0BQ8JHBATU7CHdi30euE66NbMHUrI07GI2S9p\r OI/srBT55tc/Lxd87ixDyABIGSAdkDTio30B9AZBxBTg2ms+ayFImCUIof29QdgyFkuwF170jc/i\r yBno3XeWr9H7OOD449g00F2m7A249v3/fFpxQnICwCe1Rygfs3eZG6/SIRmLg+fqb++nZds2V5wH\r yOwTKc+1PDOQZLXQEqEOFEVCxn2Q1gGDcttKMJDCEZXt7WAgIy6hXByZ4zplR32TZKbDBItS3a3S\r tvRhqxMGMkdAyHwgHg/teJwyiBxQJBIP5WxL1+h8KE+7WJSUTf6kJtlk6SCdcd9v+xowYyubTBtR\r u3pNygc3JVitMOtFoYjic+TRlxsn4m0nr8OmT9zP8CMusXZq1r5n1jeYCwf3FVY2q0hyFNHkFvQx\r QtDY1CpVb/9RCssPcLn3aCce1hcNWQwI18F+5bbyWfNtcaTOiGdc+5S3qweICwUvPqYgGljRIXZ7\r 83en2Ax7v098z+TylKV9xF74PcKdBoQDayuQ63t3fUaR7uvWZ4gFx/gzfmArjkHGIGL0GNY/PbAg\r YRkB9ADRV0rBYKtvfbJySnx0ZgwnEAfaogUAmbwTK9rBblaE3e/cdbhCh1sG5vYZquVmadN+7SHT\r LjBCE3QchIsf+64ccd0rtikU18TEFjGYPXv9w71/ICalE04wYkJbHO0rHlEOucnuhf1b8vNzpLro\r BLPc8jJU4/lZVNa9cY88cVWBPtfvmsPHkrEzpaFqjax8+TZrnzq8p0/8vlbWvHKbLHvuZnuHmGaz\r 0JP7ZgMre996MPufesl9SkTONYLi40DMso5n6tf2+8BslnUiXIMtZhGt0gZcSXciwup1/GMF6yza\r YBdQJg2m57A8L0+IeLZ4KKauqYKrdyQSjFXz4KvFdr5+o6z4aIl8+4oz5eZffDWxWDAQjalTJxii\r 5wh5AIvrdgehzPe+e5mFEBLyFixYJr/93d9lyhRvc1+BusEiKxAICBPecjlHW10Jh5d97WMkIADW\r WOvXb7FtbPcGZYNKBNPfALsVYX3325eZGIsFhZmFLj81sBceA15oFNVELOieq7/JLAUSnrd5VfKh\r d184iFiivmJFQveBGMgV0F11H7vweRWZ9FHOB1uE2KNBlwwdASNzNTcNUTkTlZGfM0pSapdKfQMy\r Vj2tf7jLzt65TDIH49Ja2+gmuqKum+p6XvPOavsYcPdAHC4GvUeo4wf373W9HpsrPWIWWihpm7at\r NfkxM+twPh5ibYWyF79BrFto0jTiMhBcru0tnrxniAczQBADsmjEV4j/WJuS0B9ZuymySjmEcYed\r LZtXzE3sQTFo4CBJH3K4ibjiZRf/53s66z/O8lhQhgJ08SPfNrEJIistZOXYNAruC7cd1n8FRC1s\r EgXhoB8uyko1RFe9YpbN1hG50MTQGRfJvHu+YBwTil9awGKJ8UGBFc//xkROANZVZj2liLu4Za1s\r WDZf2pUQtSvWTe1olQM+8XVpam61fU3oCggcty4saEP/AcIPIW1Ftyp1+myrPnrJ9BPGbSgnh57C\r x2OqDD/8Iq+nRIF+EWZpf6uWzdJ21spA5U5BnPuffZNxLYjHUKLDFeAkkDIQQ8YlYjmIG88TpTrP\r ok/7Glm7cqnsrF5vs/329k4pyCuQQdO/JCOOvNSsBNl9kUkL+ho/jpBRx3/NvPfiwBMlO77DcC3y\r wX2X21jA/xjvj2fMDANPxuhJ4Eaw3kJMhYWWOVfU54BV1pBDzpd37vykbbELUca3FMTePCeMmm7v\r B+D7cjHTTusfgA+turXvmpjPxlIEOX3K9PnM0+9mio7PLQnLx/ySUfocXCIQK66gYw6X8RqDWyRE\r P9K35kX5cOEiGTG0VO74/Xd0YhXVjcHbbzvHERAzYiEOiMHexFhBhPXVaz8n2dlZJgbDoop6QSS2\r rwv/Bmo9dBHUDf245dd/NcKBaCz44CI/WGxxnx/nosKiogJ56F/Py/BhZebna0+AGKtv3yKZNduJ\r mGKY/wK6vDwg/vp7Bz+vv10KJhMHl/igCsCHGEU80IMPrWsDPbkPZtahhiPY6Ijy4gfn8RBqe0Nr\r PFHezuMo8S0pn3Km9OnTR9M6++zoNBNQTEFTP/p7ok6oZyGPUkPksYTZxexLkiJb3n9c++9xJxpO\r ALyupze++1AkHtK0/uYP2M/EYEOmf95WEmuhqHyyHhwH8nTNsY8UYgUSHHb4FxImu16e55kiq1/9\r g80A+dBBwIjVeH7JNv1g9TEedOtWva4EbL3W9PdRWVXVlXho+PbtZ8mgA0+VYr2e5esx+xdHyNhT\r bzB5fGiTmXZW8SCNehlWa4OQ0D9BPEBynENRyyyW1ek2647Kg0iZ/cM5kQMyZeZOvnMbsxQZHWJI\r HYu5cWf80MpgILDyzX9KI0pde7YoyJVINVZI6TjlWs78oa2JoNGPnvyxfPTEj2Xz+/8xhE+bgIvD\r /Bnggdj1FcnD1yFh8nqUtYOPLxTTS7U9+sMK9G2a3l/7BKEeryHAKnjba0YrBQ4F/1JbFz6r73Wh\r PpOjZe3rd5kCm2fD+Fj+0SIpKB0hGempNibT01KlsLBQz31oZda9hXsWxFjfj1yZ+PPLwAuCRnEj\r 8uatp9pzxmR4v0981xYWQsTDs97v1G8b8UD0yDdlT03PsUbG3dB4mrKTPvcnJSLnKlHva8gfJ5+I\r sxBR0h7l+IPYIUlg3RCr7fOUUxx57NW2o2IoR0ibjGGuQxovCxCTjNwiG+9W1sZjPPR6/MF9YJmJ\r h91BA/vIXb//luQW9VQMg5BB8vE4YYB4vDtQlpXnF3/hbEO8gQsBQlvM5F+b5R6K9wYo4MP1gnls\r nBuJA/noILDE2lMf/1sI17vnr/+2cE/A/bH6PoB/GXuBPvu0RoYX+d/DG+8mTcImTTjQXI4DWDG5\r 00SssPI9L6w610sFW3MA53uIf+yEQXJQ2aAj36KeJsHMnZAd7kKZcFC2onq7jJh+vm3vGqCpuUVW\r rVJuaC3+8PXRKWIx5KIHynPy+Dg9L7SFbuRFGTz5k1Gelw/nbb2ChigpEV2VT/+crRcJ50FSyfaS\r 9dB5FA4+UKpXvi64V1k7+88mAtCzWiZWXtMQjqlfus/iiKxWvXKbWawgp7Y+Wh1/Fqa01XRm2RTJ\r zGCRIIIBbQMDh+3RQjFNP/ONQTJeERXx9pZGaWttkrdvO11O+sUas7YK5RY/9h3bn7xkDBZMnocv\r KwjZ4V97XhE0JtLoASAes+2xYp3kIiZR5KvEQZEINQPSdsLhSmiDECose+omWaqEAALADoq79Pm2\r KxFO02eRkZomOXn5UrNphRGLQCiwfApt444eaymIwFu3nmZlbGxFgMUeyN/22Y6BcxnuXBFiFAAi\r CSfEDQSiQmjeghWxB4LCBACrJRaeYjIMZ3LKLRv93vQoKp8oZf1zZd37z5qrGe540KCBkjXx8xpL\r MRFfW2OdrccBWGwLJxJEW+OUUM/U5w3RwIijpbHWVpDTjvuhophfa79TbkCVoHmd0qD3y/vH+g+x\r pCF3crQcprOY/UJEtq2eo89kDaeMiKxWYkVbYXz1j8YaSvosffecw3iFvTr8O/JrE3duA1Pt+UZ4\r iAOJBYZRWUI3SPFrMKFa9vBl+lz6yzVfOktSs3pHXIFgBMQfgLzuK8B7g8rKGlM+QzwC8o3rLu75\r y2M9kP+eIIixTjxhRqJfgUDc9of7u6T/fBdeIXrqSv4vAEex39jhsnDhcvO0uzdY8OEyWxcCgGH2\r CmWF/gLDi0xAt6SB5fV2IkCsrW7F6kPndUDA1nMaotG1IHElKtmF+ksb9htBcnB1OWL5IcTckH0M\r UI56C55vsnudxSJO2Zk6QEpLS6S4yAkYHxWWL2xAU7zhoUQd2oSFrlj4tAzE3t7yUnWW/YSwd3cp\r Lq7JM6IT+uBxkBMz/kAc0HuwojqU6d5vyrHXhSYMsYL0tiuSggvo4eMq6h8EBFNg8lCes581/o2s\r bLgH/Zt3z+dlzCnfsnL9plxgSAuldgYbhChUP8n2pSIvfGe0fOK3FYkV2hAvPPKefpvOTGhTD9Z2\r oPAFIeIhlzSAXgPjApS9XIe9zI14rJhlfpqsPwoQDkRxcBLme8oIB8g3Rji6gSnE9fAuuEXVoFL3\r k9SifW3v6LA1CikDJpvhAcgeQsEYIA4XMf7MHxlxoB04BJ4d92bd0iNbZ9q8MzNHjfLCwfa7tMd1\r A2FgEsR+3DWr3zWihfkr0H/cEUZoeO0QlEEHfULGKUeETmXc6d/T9lJMAc96BtbzfPTEjbJ1/r+E\r PcxTU5SA6PVyc/OU2/qBHVyfZ8QJnjv3gpgSbqSK/d2poIDuCVEZXCBEi7HOpGzFc7+IiLaW07Jj\r lIggWsXM2d3O+PPctgoi4rsn2ngadbgREc7jAoWQf3Rl5uIkKkcmZs6cRweDEgeODk64bo1vWmbl\r aHMEelfqsJ1CmXEfnAsGKMnvwkPXhxwsO+beqVxBrvzh51fJN66/VGbNRsfRu74gTjzixASOoLS0\r XwJh9wZYTnEe4hGQOwQjtIGVF/DjG31jqL1BvC+BMITwwANcnB/SeOoFzjrzuH1C9vsKV33lM8Zx\r vvkWRgx7BjhKRHYWt989QHpbm2zeoU3zPruADZUIepw08FxetEV6wJSY6xIWDa6ocK+nQEaOrwEJ\r dUFkJi7QNBvLuAsNQFndwd25D35joZ3r5bCA0AevlyUvVQerE42sSZfK6NGjJS83y1dn6/na2lrB\r m2fW8r9S2MQOOM4DfGBbI5b2tiEOPtjtGvZLOc9jlbrV0TTKc821hYihLQvtVfkCulRMRTVsqNtk\r 59iX2ttLtkl5uAnio469WopRLhooQUGxaWW8Dn/0YdpXHjFlLggDncJBp3+TEtIRKYgrKipkzu1n\r yWFXPW5iPoB9sXFnPuPapxNtQizQYww/4lJLc0A4OCAc+HEC2NUPdyPUA/mh+8JyihrkoeMwpKjQ\r nXAgekG8FDVvB6bL5I0740f2MYCwE3oszWiTDtleV23IFSsu1sxgpmqO/5RgwEWYQl4ROXXIAzHh\r GgYT8uqlr9mB7yocQ+LqHG4x5COK2l8JEPVDn3ZVKNc8eLwsevRbcuiVj+qzbLV2md3TPwgD5Ylz\r eziWxGgCAkQTrAEZcdSlRtjWr2evEzG3O0xsxp70da1DKTHjAoitK/oR+82ytR1wtSB840aeUW5E\r y4865koL2X2QeyeOyLFGicMH/4hmzpoHJ1J+yPlm/suYwJyY7ZYBDCcow/V5FxCCWn0mVk6vz6QI\r L77EQzk4Frhed25YY3kQEZswYa2lv3Y/OoYhIhC4NbPuMm4bB48YSWCu7WVCWT9qXvi6rNeJ3fmf\r mK7XKTKk7r6jGAm9AxxEWsyiCKRIvYwMnzDtCUD6gXgEePChZ6Wpqdk2g/rgg6VKYLCg2zscqe3g\r VgUIHM3ZZ/mi0XCNkB/SBx20nzzzrHPpHwdc8JlPWMgOhHuDHymxDP3drRIdQIneobOQ9Pyh0t6p\r L4rBkABeYBSN5yczo1z9jZ32hOetWJR8AJjumvJc8/kobfOXaNU5ABJmBs+gQXmerYPRrqVHGHQh\r 9LxkGI97Od92NTHzjxTimJ9i6ZPIi/JbiidKUctqqd6GD3xFqHo06kDRLkvfYZNkR/VGnWWusEVr\r WsEWcoFw+KCTCnKOmNuSKI8QF9rIvYvLJ5nCnBXrJeOPj5XzkJkYHxLuKDRTr7ncfCsxU0ZRaWXt\r 2dJuijlhxDySmShrPLhnl1Njukc5SicJGLb7IAGsubDx73vQebL+5d+YGWymflS1O3bIuPJiSRns\r SITtWzua62X6tc9Yfdpk0yOMAAZMONEW9XFfiCNZTY9ewxe0ed/wc+aL6GaZ4nXNa3fojPgoaW3a\r aUphusgqaBa6oZSGI0G8hN6CmTHXtLFQXGaIH70R4q0KJehDDjnXzrOIr0FnakxA6GFBQb595Jwb\r deyVJt6iT3A8KMMRUaE4pz0U4vklI01nhCsd0vGDSQ5KcqzSBk85x/NLhttMHNfyvC8UzCy4G374\r F5STOtmskYB5f7lYTr55jREe+kIaCMSE/kBEmPWT3vr67VJnejLXx+Xl5cmwC/5pddicjL1PGG88\r J54nbaI7ZBLBvXDviNiIUAa908ADT9WJAJwinnOPdM+9+x+vROQKGTLN1+xgTp6Z28eIgS32pCFt\r BFEU3Lor4PW56nfK98PeHoOnnqvvaaNZ5a1QQmPuUbSQVVVgnQgbhvUxE2V0S9Ns8WnYssGvgT+t\r ubaLJ+t1GEu0iWQCBbsZlkSQ8cHP5b05c2TUyCFy5RXnS0ami51RaHu4pVelM0gZURRWeohvsKKi\r zuTJ+1vIgdJ6dxCIB0h90aIVSoxSzSSXfFZ5k4/7D0x79watrTrGc7PtetRHmb18+Vpb3NddmR4W\r HlZX1cqwYR+PMj0nJ1t+/Zu/2cr6vYnf6ANmxytXbdg7BwI0t/NGw+sHYqMhDr3ldYFkgelD3C1w\r AJCOQyijc5Igw9QR1WiO2pz7sA2j/IQ0KJGJ1/HfeBg/l2ID3EZodCCucDRKmiKe72mOCNFP/LKM\r HjVccrJZ/e5QW1Uhq577uYwY4YvQOLYueNLEI+b4kXrWkv5ZO/E2PU55yvg+0F6OGWo4Hw+ZiRFC\r MDB7bNlRaWaeTojsKhZaXI8Dz9cZIGkFiIe5yLB0VEb/QAzY6+M4EoXt6JOuk/l/+6JxNRQbNMgX\r X7UoJ4q/oaqqKiXsSw3xdLQ0yvSvQjwo4fuCY1mDfsMzU0yMRx7ILeQxG84uZpMiTWkWCG7jew8q\r ERyq5Y5WQny6zaQhBrg3MfESSFBni8YpKIK0zcS0PlZAnMOTLvnMc1h8OfvmYww5Z2VmJgY55Qvz\r C5SAHmbnQNJFwyYrsXbRV3tro4mgOJYo0oYj4UBPBdeyuyN/0GhXnuux5PEf21qcFu0DAFe0vxKF\r /lqO2TQKde4HTiV6HAbn/EWJtBIwwN6Tcj0gac7vN/1MSW2tkeaWDpzM6j2lyqFfRyyFJdsL8tbv\r fMtTDArWvPYn40Y4zA+aFuI58qAhvBBoE1VpGnEaHOHYk78pS/793YQeEVPqj/7zPVPckx6ghGbE\r zC8ZJ1IffYdwIowx40Q15G+MtsMzXPnCb+wcBRFfYphglciL8lF4Y+JLubo178lA5eAhGH6eiVCq\r jXPcyFAeFzO46GETKiAo1XMW/ELmvzdXiUe5XPHFMyVH3y8wZswwQ+AcEN3dibLgQsJsOsAqRYxe\r b8+wUpEt5UDsiLVCHdaOhfw4h7MngFBQHgjiKhwdAoH7CPkhfeSRH68yPWyjuy9tsuoe2CsHAhww\r JF+qW+IKKRBUFGVgBLCopxO/sdOe8IyCzmrZXOkP6LgjjpKKFl+YxOyPDWQohyNDAD1I/gDfM5yZ\r feA+UJ4XDMYRXkDIyTAg/gRyjfLcDLhUZ4sjFKnOMfkpLi0wD2UG6XuIBE5B60RcCEda2aGSUbdI\r du3cIelpfh8NTS3SULVKhh9yjnRkFprIgsVl7pYj2Q/fr13j2h6miiAJ+opYDuUf/UiW73ovIX/d\r 63cbB6IZ1g4fGMrwHEXGXobyEKWn3CeSxpntsbc0nACrszXT6+sfnAciHBAJ7lMw9cXHGIvFrJj+\r 5Rf2kfXvP+tKVoWOzjYZcuSVsuGNv8iMb7guhgPiAbIgjpM+ZrOcgaMrHX+s5bOaHPEWzgVxKJme\r nWdmscyMcaEy6oRrtBgmv4+ZCWeAXJ3VMy7igJkwM2lEQDwnVvBvU6KAKa2b4eLaYq1k1C6Rmtpa\r vXqKpKdnyyHfeEH6YiGmaQhFxYfPmENHCAHvjXzGAXoCVr6j21qtSJmV0iDLQFTix6a5j0mzEnPG\r FveB/J+Z+fCZF+k7mmpl1r15r3HV7A0DQeEaHymxGTLt02apRZ9xSkneQRfcqs/lFZnzB98pL69x\r pbz/0v3KibUrQhLJzMqWtow+xpnhBfmIb75inAp9HzL1k6azwb2IGyPMknFnfF85sfuMMPOscNuy\r /u1/2LvhebMVMNZLmCfbyn99cXAirDBnK2LWyGARhXNGdEJwJVpNx/BQWfH8zRbyznnfjIFN7z2s\r z3Ki+bCDs2xtrLM1M1yHegDcLnHbglgjYQvkpKsTCnaauTFcJ+MfgsjB2iE4EEp88ORvpF+fPLnj\r 11+Xz138KdmwYas2p2NQZ/N33/OYvPTS2zZ7353ZK8iYGXXgOED8cCMhj3B3AKcChDIgXuLsZAiw\r 1waLC/fVpDfsFcJCPTgj2qLNQIxIhyOkAzfycUBZWYk88OAzJsJjb/Y9wZ/vekRKS/vunQPpbGw1\r mf++QTQ69gZa7L2F0apmhVfmY2uvmbx4/fApACJ2CG16mDcQB4qAI8Hu5z3s7RwzHV8LkWZrCzwP\r 1xlYfoGAmfWwZiP0hcPaCXE9hk84VPr17yOtbZ2i/5KVjoXSNln70i1Ss+BhGTT5bGs3tEHYhTDo\r OZA0yJo8yvQdjRsIj3u9GPHQv+0bF9pME1k8bkuQa8O5mBuWmOLc6utfln5c+JhCfMPMnPwiW3SV\r LEPIjJI8fD2hvMesOTXNn439adiQBdfiK9KB+l1NMuf3p8nh38TxJWUkIh5JKyvaYnEXBIMZL4Xg\r OuAqEBcxi2RGjqiJ2SZlWH1OXWT3bMIFYIkEYtfpp6UBuA3y1r35N2sPzoGJRqnms8ht4UPfsDYo\r g08kdCA8RQBne0v++lmpWurnQboQIQjJrF8eY/nEbbKi5W1xoSJEngMmwYjLQPQc5OOsEKs2iBve\r kXEiiUlrRna+1ae9Jf9RTgYxlQKThv3Pcv0InApIkGcAQYFwsFf+kd9yzmK8loMrgcB8+OwfbI0L\r tgyp+u6nX3yHjP/Et3XsvmntQkRx1R7iiEBRwLMuA07EORCxBYpwHy2K0Okf8cCNIMLCWIE95inM\r PZVOONHM0M2RoQKLRfP1+4T7NIGg1pt+1ROmF7MLaJq/Az9zq3kPII9JCtwtExjOk8fzhAskjksd\r A/JGHiqrX3G9nbVl34S+PR33lOWA0LBFATrALY99SYaWD5A//OpaOfE01xng44oDQvLN6y5OiGNA\r uHviQnBi2B3ie5/vDnCKCFAucAh+rfcER4hAyN8bBA5m5szJtv8IEOoSBkIS0sDHRTyAT5x6lKTp\r xHTpPrh3/+4NX5YVK9btmQO579F5smNHhRTm5kpDuj8Me5H+H0EUs6Bbrg2YAMSjtAYtdUkzyJTM\r YuMAKA+HAdsf3LeTZx42dSDhljnHzHe9LT445xA0bYMtNuiiI56HLoDZOGkWvcGy4yCQfTvI27by\r dfPwGerHuY8Qb8weLkMydCbU1CD19cjWtbj+tLY2S0Fao+TBQhf4NUK9BPehB6IaTZjrcMuDGCgS\r ycgukuD+3cv6PREiHy6fdr4RDBAJO/E1VK2Wskmuc0G3YiEPVkMQFV5TMU/F1TXKR2aJ8TKsMEZP\r gf8mZNTr3/yr6STY4AfA0oK1BMwQ0+oW6/1h4OBE8/BPf19yhiLCwKrKiQcLGSE+bO2KuIEFdlgA\r cTlMTFkoV1Q2wWajiNMM+SvhGKocg8ntFemDtBDvwHF4N3U86KyX5+B7cxxuIjdW56PbQXkPd7Nx\r zgPaHua+KFr3szZoYMghn5Ktr/1OdtbXGxLEjHf41FNl+/Y64wrgMvB0u339fBt3GXlFNmMuKj/A\r iMTgqefYuGQPbsRchcrtMl5AXsyKIRZ9R+mEQicAbHA07vQbovQMadb2IPr9x840U1UW46EvWfvG\r vbLlgyfNEGLsKd/QsocZMQFGHnWZTW4gJk4Ej5bmysWyZcHT0rirTlhQn9ePRYVHy5rHvioTLvq7\r EUHSKMx5fqwDMiKreXgXxtfWsBkXaZmjzJGjrZ8aON64E54v7wHuAIs+CBp6HXyM4dgRgstCWHQi\r 7PLIYEcPgqn6pnceMHNtxGzl0z5j4zqu62AM4pWYcccYwn8WuxqiHwG8zBB9D6/KQB2HcB5Yqw2Y\r eLKdM4jaYg0K3ytjl8kW3F72qn/Ils3r5Q83Xy0nn+FeuwFm5XAOAOEHC5Ym9vLYExeCqIny5eUD\r baEgSvAhQwZa3t44kTgnEOKEHPiwmqKcyp7qB6AMBIKQ9R5Yg3H/pEMYrhPSHPQ1uEX5v8Jttz8g\r +OXaFz3I40++smcO5MLT3P59faXLcwPQeYdkLA6e2/s5YEr/pNNEPmxXnqeYshVi0VJfbWsFaAMR\r DdC9NZz/GQYzCFckjJCkHUAyD4sPEC/1GNhtTbvsg8DKyBA2ZfmoIrNHa4f8bvGN2dOlpKSEHGnD\r PUZmunQqclq3cbMsm/13yWuIfHJZPR6xhlE6Hidcr7N1SuFt1YlH1/PMtFEoNytBHXHkZZaPTmHk\r MVdEZaL29Q+X2Zanf4Qc9RX0JWo3ygcJI6pD+aw5+qG/LaOOvSZad+PEg7UdcGMU4ONqbu4wo4EM\r pVXbcHu+bYmJoyD0AL66apTjMM+1imicePj6BBTJYZdCFLIASA/uAQBZApizhjyABYUgIbiF9rYm\r K4e/rg1v328cB2IiNqsyrkDbg8sJps1wEpVv3C6ZOm3nfiD0re1t0mfI/oYkg9VU2aTTZdJFf9QZ\r /4+krWG7cQtz/nCuLHvmZkPsS5/6mSmHUeJumvuoEvNnbTOjnVuX2+x98/zHGcSWv+a1uxRJXmT1\r 2O+e+wXZjj/7hzL8yC8a0QNqVrxlfQ8cCgBnkpFbkCAmcCVLNb7sbxcqsXKEyLsq6DNAXv/TF2XA\r zCuM0ATrLV/78pqlP3z4G8JKd/JwyIhuhrHEniPGkWjaW3PXJIg7sfYiC04EY5Dlz/wsKiO2duT9\r +76iY0bT2g5WdHAgcLBONLwc78rqaBrDAkLywribdtlDNvasvB784YcLXQh7qvOMGc/sH0J/E9+O\r /jHms4pKTS+Tufxeqdm2Ve698wbJKfLxFIcwkwcwdw3p11+fpwi6dy4ExE05HCoC7M9BXpj57w44\r 9+ab7xtSD+VCnPpjI11M4Bz2BoGzQKfy3nuLEnVDSNtAvM067evHBbim51vZl/5WV9ftmQPJTmmX\r ex98RnJ1Fi2xvdF5/w6JiA+KCDzGILGIQoh4XmFHlWypdsSTXryf6zq0PsQE7oMFYMxYyWveXqGc\r RqnNOrCI8esgx12r+QMTgxok6YjXZ/pJZEwY0srFVC43eS1xU8RqyCBnRlky7hif+eGaIypPmLSk\r YqaPBdc7UqIzocymDbJr104rY6yzPnlmbRmttZI9DPmycx+hLSyPNOKzuahvmITyTOAW/Bpd78Us\r VTTkudAPjAjCeg/+0Nd4WynG/mONtfn9f1sfkYPzcTJr87J+oOTM1WeJZ2CexSbt10BFNIB/uCmC\r m4opl9yrGUok170gNbVKGBTS9FZYu1E0aLQse+VuRYz4BVJEVFhinAGEJ6xjALn3GTZV+1Rmoh4X\r Ybk+A84D4NpwK8jWh+rsmQmDO+rz1d2IiuAWNGmw4a1/yMGf/YMixxtNj8CB4nbAhOMNkWOaWjr+\r GCUSxbLk/svMGqa5sVk/Cj4LkQE6Ex6miBRRKQs8lz5xk9RXuwgVBMbzRYdRPu08axvubdiMz0ph\r 2XgZdOAppmMon/YpC8sOPl05yZPM8gp9AhMSAAs2XHdsfPdftkB0q3IQLMBDSYxrkkMuu8/G8nrl\r Rnj/KJA3zPmnrJ39F+NC91dituTxG6WjaqGkNmzRD7VWUrX72bmZcvgld8iEix+Qhh21zm3oMwKM\r iBrxxSXJF0x/A2eHd2Az29Z87sfGgQIcKOOJCRtj1vrz9n3GqcB18LhQYCNyRKSXlpltprp5fDva\r BnvVsOgSDo2JCOuqeL9UZLU5l2HSgB8tfGY11WxUbmWjWVIBZiigQG+wEER8xdhlx0u4QBYm2vce\r g106GSpYe7/MnfueHH/MVDlsxhRDpL3BY/9+SYqK8mXz5kpzu4FF06mnHKkz5965kMBlECL+evW1\r d013EhA2CJXzvUHQV7AuY/78JXL44b4dONxCsJ5CLLUv1lg8j3CdJ558VQ6ZOjHBdcTbo0zIxxHi\r ETP3zWR4b8A+KQ//63nzCfYFvdae4LHHXtwzARkyvNwU6a36YY4eNly2s27FEEyAKGZBt1wwQAKI\r e3pSv2qZ82FS/yHpBZIZ7TDoLhcwJ91g4ivECmb2qQi0vblecHPO+V2bl0hBZDHiyDke6nU0ngz9\r qF3PKm0lXoMnmiiIAY94CTkyohSug5VPkyK33BLlBvSct0mYZmnieE1FVtyeXSJFA0ZLadZ2/cC3\r SWtruymfOCq2bJLMbe9K3piTvG7UP3M9onFXQir3gT5D/4YefrGl/VrJfuuP/icJBP3to4Smdu18\r 7b8Osngdbcd9Cb0rpRNOtlk/SktzeMedR2WQSbMBFMQDzoOQxWluNUZJXzeQre1DbDHpXa/IjTl8\r e5vv09DS0iEVy2bLMT9aZIShs73FFPGYqxrx0NIgF5CnRi3NrDdPERHiIlyNAKtfuc04L8xJo4Lm\r NBIlL4jMlNSK5BH97NqKN+BFJuLgfL4iQ2bcw2ZepONlk6x6+Q86w/Z1J5vn/8eQevW8h2TnLhdf\r pXamSvHg8UoNd0pj/U4T3bHzI/c+fOYXZPDkM6V0/2NkiBKHsEgQboRFmyD5auUa2JERcRIcWNVH\r rxr3QRrPxxvmPGgECOJTqoh85NGXypgTrjHRF+1xrR2bcGsusvixH5gPKt7npIvuMCIFN5IVcSjE\r gdHTz5G5T+HO3XxBSl5+vrTkDDNz5gX3X2U6GcSfcDRMfDiG6b0sU24CE2C23EXsBmHBoACdGAQH\r QoIuDUMDey863rkI+UZE9HvAEzQGBHBQ6VkFSkBytAy7Rj5vXB5x3NjP/tl0WyxLWZwwLvnP98xP\r lo9NsXUki//9PRl13NX6HpVrT0u3tUODtQ7nAb5FFh0ipgIQc0L4eK82ziPIXfxbee/dd2RwWYl8\r //ovyLHHH27IdLZyFqyLiAN7Z0A8AFytT5jgHi4o35tIKqRByp///JkJwgFCXbx4pZmthrzeYOfO\r esnLy5UhQwYkEHy/vkWC40HaPOaYQ6OSewbqhfoo01mbwmMiHcJAOEK6o73Dwo8D6O/Nt/xFSkr6\r yJe/5OLG3QF+sfZIQIBgiTVwYLnUNoGsLKmQiERRTyd+Y6c94Rl9Umtkc1W1xVnVXTgUB20pCfGV\r 7TQYibQAnOmB1NjS1HQeGrfQBqj2Bw4ENWlIh7woTsjMD7cJzEohBCCgoPvAzw4WP+yFwGw+NyFK\r Cm051+FxOBidBRmyVcKgH0NNS76U5e4ySx/9sqW5pc3utLm5STKq3pHcUScZosDFenpOkQyecm6i\r fec+UiLuAyIRiEby+h5yP56/ZtYfzbtv4n65mpXD4qpcZ3KHSbY+R9yLu9WL19UfYY0GVlfIpFmw\r Bkc05NALuhAP9B6INQYrIm+przN9BrsQ9kmrUm5rh+BFnLl8fmGR5OYXSmdGgelo8N8VrLwQWxUp\r oUbOT9qQlD5XEN7YU75lOgRWryNSBOBIALpZr3Fk+IhvIBKmG9M2CNFZYNmEFRtm38ywsW4afsRF\r dq01r/3ZZrjcLefGTzlKNsx7RlpaW0X5Q0nVWbROfZVgfULfw5mK+M6w2TYEs/KjV0wJXrnkFZtp\r I44CofKOCHm3AyYer5zIOKvDAVcCZ8w5Fp7u0rELMUX0t+yZXylSVGT1+l/1vtJsAjTlC/ruDj7N\r LO+wPKtc8rIse/qXts8Gnd7/7B8aEW5X7gWx26r/fEsJYINk6rkOfcXl0z4tE8//nSLVchl1/NVG\r MCac8xMLWT8CoTAiotzdprmPyOZ5j5ouhvvh4bKXCkp2gDK2F4kSC94PVlOICc16Td8BnCL3jbcB\r jCTgsBBvsdCUb4ANnOg0ehD2Guk3dqb5uiqbdLbrQ3BnA2jfcWXTsG2DEoZa6a9cCQRnhY5FFhWG\r MoxJiAh5EHcfs/q6ih1xZr57gyxYsED6FufJtVd8Sj7zueTseHdcyPsffGTrGyAYIF0QMzP43a0L\r wXz37LOVk1WgLMgbx4Z4oAVB7wlJ//KXdyfESoihQPDBay39/28QfCAQ2dmZJj4eNarc2g3th75w\r dM//vwLPix0QsUTbmx4EK7N9JiBZBWXS2O47xjkkIomXDXhMf3uU87y1y5NOxjo6OhWh+aZEeEtF\r dMGHiCkkeZjHQlR26UdVWOaO/ziaa7eYeWGSaISwO+L1A+Ti3IvmaycgHAxYkAzEgz0nQAiJeorw\r PR6Z82o6tIdClQ+Ifm3+8HnbvCht8ExJ2TrHWFgWDqWnUzZFqqq2Sf+WJZIx7Djrf14/vUa6m/ey\r 3zVlhin34W33ci9GGLm25ilRRBwG8jQnkHofiXOUt+frBwv8QDbeb82zsi66giNBbs3x4YPXypiT\r r7dzoQyWO6y/gSND0frajyeZuW7hiCOkYt6D0tTcbgSkXRFLWmOFfPjkzba3ua/zwBfVT+iJEiVf\r FAZyKh4+1Zz3DTkUN+yzfCMiffaIKngPcBIQB5AaSAviAUJcxyJAkBkIXIFzcAGY6kI4gvfcdW9o\r OZ1hIz4bMPEkIzIs2Fvw3J9sF8uw8VJH40456tr7zafZ2hd+JU0763Tm3G7eYeE2hh3+OSNG/cfM\r 0PALxj04sfAFgrgjgRPiWnZgXqrcjZcbLmNP+poMUgJBeuiMC43ItTc32OJExKXLn/uNcn1zlOhU\r yISzfigjjrjYPA9g1gxs+eApQ9j7n/0jKcpskBWz/yGdrW3GfWRkZcrM782TlcppFSgRW/7Mzfac\r 0RmhC2Er4Jd/cIARaIgerlEgKJve+5c9W/aqYXJmTi61pivcP58gIpUfvWjEA4st251RwYiI3j/7\r 4DMZ4V3ZONFJlU1QdDKS03eYbR6GCM62HFBAHMx4DJtRQZwWPXK9jbkmnbjRDhPC7OKB9s0DJhHQ\r G8KnHHE8/8J9wG2lzrleli1dqggrTf78u+t0MpEvlRXbjDAcfPA4Q54fLV0tY0bHvIYrjB830soA\r cXHUunWbekW25mVW26IORCB4yQVB98a1dAfOB+RPHNFjbm6OxWfPnrvPi/54r9QBmc+f/5FtdhW4\r LNqPi7HWrN1knEC47scB8+ctlvcXLJNjovvYHWCivM8EJL2gXDoVUfl6XiAKLQh5IZlMe06U1iBu\r fZVWMEIyC9x6AASDzgxLjExldZmtmqUImdoeOgAQJc7x8lgnAtLkOl1CynoYR/r40LFdAfuVa5YT\r BYiIO3brYx8THwhhVr72I6rfW3vY6rNTW0Ptep3Zue0/Cxvzx54o7RvfMBEW26eCtLKyMmTTpi2S\r v2Oe5Iw+2TiW0GZX7oNrxO8BZB5EV56GYzJZvxIsyoU6mOticUUZDpSRm+Y/IoMPOU+fnbdJPn+Y\r hPIMMF1G94HIwUSEnNUyT13bV2fJd5uOY8O7DyhhfVPGnfljLTNCEWCOrH3tDmltaYWW2er01obt\r csjVTyeIB2sq2EYVBTFtQizgHDArLdf+kI4Dcnp2o+N9Qjy0WdPjYGqNuIWNnjLyik3PsB5OQwkD\r M2CIB0rnuXdfbEiSRaZBbIReAREQyBIrn7oVsyRd350yCcqDdEpnWpase+6nUr/pfRl8xJeVGzk5\r QSiA5785SpHpa9r2F03BDXHavn6BIX48JEA4WOOC8cCOjYuMUAVlePwIYihm7qOOvdyJyvTPaDvv\r Gkew6uXbTaaPzgdiQv/hgDbP+7cS0Btlx+InZHtdnamR8TiGj6YW5W5xwRL6wTPYptchhNOYeslf\r jTijA6vm+vpOea6E6KKY+Bgx1jQAFxTnRADOM4Hge8uLxgaWYeadVzkJ1pLA5THpYh8RmmJdzcZ3\r 7reyKM/RaWLqy1VydLyRX37Ip43rGK7PHOKB8nzdG3+1SYQVVAhEBOA9syCV73bFW/+UrLQOuf2W\r r8rxpxxjhOG+fzxpoiaAmf748dEeQt0AxB84lDhxQJneG8INBAfEGScc77y70LaW3R1QJiD1wBE0\r NDRKWZn7Ynvu+Tdk6hSdBO8DxNu6+x7fiTCI6Hg85AeC0djQZNvr8n3vy1qTfYHauh3y+BOvSmFh\r vpxycsRJ7gYYn3uFjoZWKc1qsO1d9wT+7qMR0B00e3ppXZSA64+srxQQX3GemZpZX2k8yFw54hZX\r mSwi1DxL6k8y1EgspAwH9vskMd8lzeC1DD0wr2zQjwHlOSuEISLkWxv2aLq2Rxx58ZYPnzJuYpBt\r FMUpX9FedvpvdJZRLkVFSuwUWhTZ5uZmytKly6Xm+WuUe5hrnAeoDNERSlDqdu97b+H2dfONnSfN\r Ne0cfbKEuxVZ9dLvzb6e7UU9Pzpn7rWtS1Kx4CkzGiDDxQzePsrn6Vc/aZs+kUb2DdiGW1pmhyLK\r opKhRo9gQeBCmto6pF+pz1DQheA91ZWjTjywhkKPNeqYr5glEGCEUwGug9kzEwZEVohecCtue6oo\r 4PsJZJiZU2wcCUgSCyVk+JlK9EHSIF1ui3MgxxUv/t4WlmKBNOGcGy0/PStLWpXLaEeElZEpfUZM\r kqN+NF+O+c02aXzha/LYxWnyyEWpMvvnx8jrvzxW2KRpv2O/KOf8dqmc/t1/y1m/WiBHXPIbOeyz\r P5fpl94lM695WKZ++kaZfPo1Mv1T18uRX/+PHHXDq3LuvZ1dDghb66J7ZdFdn9T2U+xY8m/tvxKS\r SZ//g8z8xtN2n4gIn7lupBKtV42zPOGmD2TEMZfJps1bpVVZjzY4T33m+TrrBta/9Q/jlux56DNI\r zcqx58L4hRNZO/tuE0nybHk25PF8SWCptnneI9aOjQ2FKuU40Je4AtzzWGgLJ4IokrEAcUF8hWdc\r Jh8U6zfmSLPCI0FT06992lyq2O6NSnDM3DdYYAEa5BaX2foQfH1BkOGGUZbHxyqleZcsWkShXvnq\r jdK3ON8WCp74CV/rAXz2wtMMyXIwUydkPUdvwDk2aQqAaGZ3s3WQfyA4AHtwAOef5w4SaWt3wLlA\r PCBSU6dOTJQ/dNqe99noDqFe6Oe7SsCA0H7ID/f1cbp4D4sIP/wwrMXbPaR0ti4EF+wW8oonGwEB\r Csa5fNBfcwQW9XTiN3Y6QaM0b5QslwVrlO1X6J9fKM0DfDERMmDcOMTXfiC2YmaP24zCaN8KsBfE\r hFXTyZk6YZjBRyIn8vTDI4SABJ9XtqhJkab7wTpcq0VrNJihdnb6PutR/e66D3eYeLrFd+rMsXDQ\r eCN4sOnJsn7N1jk3yurVq2XHjga714yMFMnMzFQkUCgZI042xa/3tXv//Xo8M88nD+R+v8mvQ55z\r ZanGfWDOywY/vmBQEb7eq5vMel3+cLddftjnjCijsJ5z+znmEJFzXkZs1jp4irucp6G3bj1VDv+q\r L/SjwJu/PVkOnjRV5jxxu+0vjlAoIz1FRg0fLvtd+rwsm32fEo+hToS1Qv221UagEUWhDAcwocb6\r yYiLIjgAc9w1ivTYvY6BiK5k3et/MeIDkQERA3GkSQ/RlUz5wp91pvumPoc7deY7QyqXviozrvE9\r DRb+lPY6ZeOGjbaGhbWIrE7OLxkmlRtXmqiRRXkZmalKNHjmDnCO7H+ekp5rrlogYo27kvsf7A54\r f9lKrJBbA3AMO2L1aHdw2VAdFy6uwtIKBTdKewDiAgeybemL9goyMtOkod6/O0Si5eXlMvmHa+3+\r +wydbK77eTboTEDs4dlg/suiSAgwzw/iABEJ7wFi8sZvT5Gxp3zb2kYEB+BWn/NG2JVgYNjSghm3\r PkOIB98H723pkz+RmV9/3oi0vTDO20QEC7gHbQ922u6rXOhydCOIS3U8Up8y79z5KRl1/LX6Dtkv\r fbrMufOTcujl/9JT+rZgEzUfDhODhJzq2fremuTiTx8n133LdwGMwx9uf0CuuvICi4M844i/OwTk\r Gsqg70C3sDu4484H5StX4B26K0CkdqcbCH2gDAg+xEN5TISxxtoXiN9PiHe/R54p4y7kP/7EK3Lm\r GXh9+L9Ddt5kmwB3tDrh2h0kv5zdQH3dfEnNzbCjB/Al+89uoOs5iEcf7BEVMjPD6lJAQ/1HbMXX\r w+zDdu/Tv8z8yGmixndtWmQKdEd8ZBFqKoqH0M55AVMqM5Mhn8GMeMYJCq3oTJsZkMbNzTZ5Vt/r\r xuO2OjqKF0ZuQkCYWyI/P17WEXzmjBtlePlQKS7ItQecm5WtyKBZKiqqpLQRd8lKIPSPej0PAg2j\r A4MAZNNdykfn1rx2pzTWbjbug+zRx38tEgl4Of7YzIn9GRqqV9uOeCueu8Weg7Xn/zoDLrP9SiqX\r vmJbzs695/NdiId+04ZE1n4IW4sbfQdDKtXVsq1ivRLSYdoXJgdwH68Z8gVptTU3SN1a/3hzS0ca\r EoLjAyAerFtALMK6DZxQzr3r82bJhSUOSBHCAYAsP2LGbSmRQ770F7M2QjyGnDx96T0yNG2NvPmt\r Ujtqa2tk5446aW1pUeStCFzr7FR2v2LDcsGRs5J8SVUumOHY3NwmzY1thrCbm9qlvqZKOaN10lhX\r KR1N2yVDL0r5cIR0bl5G4sjJTZeWpiapU/YfEQD6L9rjaNGjXdvdvGaNle3Xr4+sfeFmJeTnGWfy\r 2tf7ytoXfyo717xir44vpFnr4BOW8uRt2LjB7h+T4oL+g6TyrTvt2QTiUbHoRQtRkh/FanYFiDDP\r l1XtgROBSMz82rOymU2kAG0clz6sa4FDAXhHLTvDNtO8z9lazDkR3s0bvznJ3MIHCJxIubnjFxNf\r IfKyjamUwJsFZDQmx5zwNeOA8weM02/vbTnsikdtjNqgisqw8HFA64eyZu06OXD/4XLIYY7MugM6\r igBxZNsbxBEvsKftW2kjEI/QXtizfHecCxCQfCAeIR7g5VfmRLG9A/XRoQBhbUgIf38bUgxJ7OMe\r 8hcs2DvHsK+AmIxxuGaNm13vDsL3uE+QFiH/3oBXb78e6QqxvNoOT+wsdrvl+orlpgcB0fjiQf2A\r 2sNgQXwVLWLUaua23eK04QjSwdN+AHrGPgx3zob8njwQXpD5M7D5UJgdVenMNQzwUDdxjSgO0THR\r jxKJLQue0DMgV8rg4JF9saP+6Hnq5B7zSxk7dqwp5vDci96Ah71kyRJpftn34ght9x7yrz962CZb\r IQ8ipZHVynGwMAzlqJ0ArLjXsTY0XPnCr83J3ZiTvmnn8nWmP/bk660s7bN96eHXPivVq96UnRs+\r 1GffZtxVVMA8tcJ14XRv4rVzZEtltRTks4cKBAR56U4pal1j4rj+Y48x4jF0+udl5LE+62IrVfYq\r oQKL95zz6EwQD4jMmtf+aMgOf0xHfvtVWf3qnWZWazNqRX7U43p9Bw6R4QcfKWmbXpS3byiV9S/d\r LCvv/6xig5dk8eKPZO78D6VS+1dVVS0122qVYNdIq+k+FOkrrsnJTFGk3Cltisw7tUGc1DdiFNCm\r s18lJqAjnfhLlhIY5jd62/YRcZ+0YfNjfZHoASHsTY1KcPRoa2lXQqVELJsNq5ygZOWkW5hNxyNo\r 0nYgKNu1bx2NDXYOOzXSgdCktXVIuh5Ug+i1RnmZ2rHlT90oL90wVlbde54c+eOFktOy0V73woeu\r lwETT7DnNf7MH5jIjx0Xfc9wkccvz+tBRIZMO9/EXgAebn2NkijH8iPn/uASI4LSqQ+LRZOMKRNn\r KbfCwkPS6HOCS3heMs41aT+vf+Qba/RMqfroZT+vzwzX7+4Gf7lNMpA6IMqiro13Lbfzpavlg/nz\r JDO1Qw6dvJ8h07AFbRwuv+x8Q9LxIyDT7sC5AMQPPHBsok53CMgfCO1l2YTX/V/1VicA50J96hJv\r bXV8tifi0xsEAhnqhfCgA13M+9LLvhlfyA97hXwccNHnfF0Ye6XvCf4rAqLfhALDYl8hWXbmoORq\r yb65+YlTmH8CTbUb9NczkZsDzbuq3PpK8/nbudkVzw7xUM+Sr0cIPV+/WI2jqLYVsalp/4+9twCs\r 4uj6/09IQhI8uLt70VK8QkuF+lN3d3/qLdTd3d3dHWihhQJFirt7IASihPCfz5k99+693OB93uf9\r vf8vbHZ2d3Z27+7sOXN01AaCBwmjoxqt3EjYHSfnkdYPnRvTjhOtmZ+dj2HlpC80xfzySZ9pnbpd\r j/MMJKjPPz3HlZeltJXKmZmSnp6qRKhSpQyd1GjS5CmS8010rgxb0F/7VxLscx8c11g56XO3Gds2\r swoC0ppgEG/uRnZ6z3pcD2kq9APvnuU3g324UPoNv8z+9n5Z5ZgQaohmg66W1VO/k1aH3eQO+ePM\r 4cEIFAJSkLNC05YQhZ/qKDLOTRC5vz8jrsMRE/e+IDrla3qDNDYNVChcivgI08tjxzDmAVHzhCpJ\r arY7QBaNes1JUpfKihGPSb0qW+WL81Nk/vd3yZgnBjmJ4w75dtgBMn3C77Ji5VrJ25TvpIyNsnrN\r BkfAi/XJ8cmhCSHlChcr63Y6ui5Jbl9B0VYpcmsYAeln6M5pOPy5NdCf7FrZoq2kqBqKuKE6XQ6X\r 5vufJTWad5JG7XtL7Tq1pF7dmtKofh1p3LCe1HPbySneUJ+a5N51SYrkO8Jf4JbNjBxcc35GFX+t\r EpiPuz5LibvB1IDpJDnRhn3ce4qrmOYWV5RC9wfmkqIPvEQWzFsgX1xcU0qW/yHF09+Waq36Rpgt\r 62ruOWMXoT8gVezniLoxEVLPwESKi/L0fZCOH8M570DVUg6cwzZzsLDOmmPOD74/GhMB9bsdp5Hq\r mlPLgT6KK++kNy9WOwg/GLUlAzZ+Oy+JXFlEpJcpW06WT/Sq1Mnv+kSamyc+KXNmTpO69WrKx2/d\r LVdec852CbYRaRY8krZHpKlrhP2JJ99WF9kRpUSmG+OIEGe35lxcXO1YIlAPUMfOTU1N1WlgrY2d\r lUSeeMJLGnZe/Dp8b7Zm/97Afr18brBHH2cm09KxQxsIwA4CqjTpL5s1tXsA/8UpfMn9jeyiEGy4\r VbfMNTLir8m62bRWTVlTwedcyl01xxHkVurNVMGNfJVIartJmvuKD5iyt33U1g7M0FDXOtp3PdKV\r /TpsA/Fr9S1HZeO2MZjj9ql12M5arAnxfF1/rp2n267MNfC8qtNpiPrJE1TFcRLTkVbD7sHqhiPP\r WaNiqDD3eTdCnuZG67lqNyhyFAKHhGbNGkut494J6vrI7SaaRt1vs1444lk3mr/Ule03llHpgzTk\r KU6yQg2Q7kaQ5ELSITNPUM9lUqiHNVW3Lz/iyte647TBU/b1Zn17nyMANwrZWgnkijIPdw/uL1Oi\r VnKSH3mfYCSayXjuazJl2nTJzfMzomWkl3VElelVz1SmAEj7TVQ3NhfVrTspAjsOzMV08qznf8+U\r q47GJpfRUTy6/2LXxzIqV5eNa1Zo1mM6aIojrsWIEw6M/rELbC7YrOopQHJkTFGOj0hKRiVJLimS\r jNQSDUhDdcV801UqVpB2bVpKrRNel+Qa7SRvzg/Lxzx1Yl10760Ou07KOUmv6j6xeu+txfl4CMia\r hW7w4tYlGxZKcvVYbxq8BXHjDaN43reytUIDmfva8Y54rHdMLktqVqsq5SpWlOUrvB2Q35tctlxJ\r Qe6mMqnu9/HbAdIIgMHBSGAovAt+fSq/s1yq1uFtcwbrOo0bSUZnx+QcwccuAushiwOqPwYvPMNR\r Dw+So18s9M/fMXbeC3EsvFM86UgHz7NrfsDleoxJ23TKZ4UnE6gyaXDGV3eqNxoxNQA1Iv3G20NE\r Rj82WMtV3aCLc3HKaDnYSb7uXDQBk9680PXZU90R2t3qpJECqVp2o8z47mH3GzfLs49cLb+PR7L3\r RDxMPMMIE1QiwsljVRriias/b7xbbztyt3aRHlAVUTbbBoi/jzDsOnZf4XXYPrIjMNUtk00BOz83\r N08DFh93zOWKy0/dpv1PP/tJjj7KbNW7j4kTZ0iXHv9SqWbEz0yclxj0vZ2GN4QFoEfHYzv7jHmA\r WUsCsciNxn3+JW9PAF4dRF8MNUbZtiP7WceWjXCyrJ/PS/TBdWxj+1C3RFfGOwSvH1w3VX3F+cF5\r 4bL7o/9qdzpCt1PKlpeNZAl2ZRhKRPUVqquP1G3bfqKQ19X9l9Sr30DKuuEu6g+YiPvpMnvuQikY\r fqmexflN+l2os/TRzpKx70Tb1hW1/BXYx4fs56cWr3u248E5TBOrzMPtw+7RIsQ8fD3RSY9gHmwz\r wY9Cj5cJ9NJJmtMK//7RjwxSV9CmAy6UGoPudQRcxVEFRvUtW4o1RgYgXaye/oMyD1DkmCiEDOaB\r gbRmu4Pk73uabsM8YBKsk5wMkLdupW4nOc5Qxi3FxaSKwdEB5uqJL8kFM6tWkvr1q0tKeroUOubR\r qGFtOfC8+6VDxw5uRJ8ha7M3Sq9rfpDj3yiRg57OkfIH3r1k1IuXysh7BkpucVrd/R9fJwc8kS31\r D7lFqnY50b3TkTLCHRv77Cm6nv7lA7JippNe3UWT3PuH8aRXrSvpmcGc/G7ZuGq2TPt0mC6cwzJr\r yp+SvS5L2lw/Q3rfv1KOfmWz9H5wlaR3OE3y8rZIk0E3y+H3T5fDHllY5rg3tkqDBg2VKVTNrCHt\r 2raU9u1aSflKFVQiQTJJTnMDGnc5pBF+OxJLMkzV7YOHrly0SFYOf0RmvnKcrB1+l6TPeU2S0yvI\r 2jl41flbbXP4TVHm7d4Rkgj2RtzRqcP3XblBZ83ky7GS4s2uH6HKwsWXFrCPkNnX9wuYDRmXgTqS\r UIeGHFq7gQi2EdKh4O5LupOsOd77j2fZ+bTnVBXMIIheTZDniFeucoORMso8Djp0oBqfwwZrCCRp\r RsIwQsyI/403v9AyxJQlHtQlLsPKnujivbStFGLHx479O0YaYX/lyhUTtm/w7frz7VzbjjLDxJJP\r GDAPu46189DDr+m6c+DWaynl7fjff8/R9Z5in30YzDsm9uv273OXGEjlsiaIx8J3Gf83itB2qIg3\r ymED0Xm6UeqaubrG04rcV1SzuBDAyEg7nPtbuHGVKwYNsdbFlyOENoQM95FzHLdS1FbYPtYvcg/D\r UW5GRhhyabl8dVx3GW1rY769UJmF+TVYb1oz30lFs9TYS+4mgghzls/w9YO6rFxBtjBycxu47ZKh\r ttLBT8u+vQeo/WCLG1Jq4LurS3Ttmq+8r/6CX5/nVFk6/gPNpcTxpgMv8e0H10B11cyNEP01/bXs\r WHibCP7Ifi3Zcb8LHTaZUYkinv/zE2r4bHX4zVoTmG1l5td3udFliWMGhwcMIUlmTx6lDATnJegG\r rCQvL0/jTBi5Mkf30rHvafn7y9Nl4iunyoSnD5ZvLkmTaW+fJ38+NlAWLlqio2djHjAGJAyYxeYC\r xxxcmdH21i1udOqYbVrZDGnWqIFUyCgvaallnWSSIkc+vVJaH3GzLF66VipUrSdHXfuydLtruYz/\r 4T0ZN26cdLzwM2UcNdr0l3mf3LAewl60Nb1B/5uHC0uNtv0DhrG/jLh7oKyZ4VU1A9yxnhe/ret2\r x9zuGOgR2oYtFWu3UGZp27U7DNJ6LJxj5/EoYSpfXlZX14DEise/vkWjzmf99p5M+fQelYy7DF0g\r MJJK3c+XadNnS0nLk+SgpzZK48YN3Si4RLaUbJWyjmlUqVJJyrp3i4qMZ8SQjq8SKSU/J0ey1qyV\r VUuWyrg/xsqs96+VWZ/cLAvfPU2Zd6WGnVRCgYmw5v006X+ekGsO43vrw27QYFNTZ8FEiMXR6YQd\r 2A9DIZiVb069tZg8LOhX2Qv/lOUTHRF3x1Bfsbu4IEeTLmIY1+kDtD+6xa2ZH2VLMXnK3Lkjbpdq\r 1SrLE3dfpMzDECbUlOfPR9UdC7LHAohzPMGNR/fu7SPHUFGC7t0Tx2dQjyC+sNRB+6QrKa19QD3Q\r qlWTyLmcxzl2rDTVWWmwdmxteOTR13Uducd+scf3BMSe6LvJ9nnwEmGXGEiqROcs3xV0rbpWqkAN\r HEocQfhjpZ8oKiXDr3UOED2cpEZc1kzgQ8f2SJJK9ToGVSCFvq0IYVX4cpSZOClknp+q1Sa7yWzc\r Q3W/HLOZ1Ly+3p+j58aVSdNBRlO8VDBA1+1ytKoICHZDWiIduNYP/tm5y//6RJgXA4Nyw16eQSS1\r OV3aH3mbtGzdUsqim3CEET3stL9nyd8vHS1Nep2obeARVqURakPfni38ww5Def4IfN69V4se16PU\r E1n464s6DStlphRV1QEbetxHpBPUGFSX4sJcnYXOw9s9IA4wD0aaGNo14FFro49f50Zy5SXV9S6I\r O9iUlS0rXu6pbqBzHmsvzSpvkrGPHqgDBnOT3eKkCDpkUX6xEkU4EAboLa7MPmMe/JzqVStKalqG\r tGnVUho07ywH3vST1DzqOanZ70qpf8C/5bDnC2T0kyfI6Nev1ziMAffMkdnzFstHp5eRmm0GRBjH\r pBdO3oi0Uant4EwIuzINxyhgGCPu9hNdGdE3hmCAce4JaAtGcsRTy3UNE/l56L4RZtLOMZHOJz8s\r i0e+LD9ez8Ri05WxwEhmfnGPzP7g6uxudyzS7ZaH3aYSSo8bx8vgZ/Okbr06+ryQRCrWqC1bXX/a\r 4voSnxkSCU+cu2e9fPES+fHaRjLpKdd3f7rS7UFpJOrWHrxSZSjYR5ial3eodkj3IoyJ5K6dr4yk\r gevLpO7nRI7RF7ztzknlnY903+1UbY9z97vyW5VCYCasWx56g665JpclC8LKqd/I8m+uldmzZkq/\r Pl3kt3E+X1gYEF4IsBFfYxIGUp8DjlsdpITSYMR23329k4FJJfGgHiox2gwzpurVM7ch5GFQn7ky\r ypfPiNwP54XPGZBAbbY92D3Er+PvY2/Gg3Ro7+de2p531y4xEE0xooXIn1IQHAtWjE6zN9NlRepU\r 9wnjPKGEiEVTtuPRoSnG3XllNJDQwW3kYDz3G8EahMquTphxEB2M5GHeHRjwUGFxClNhEnGOFLJ2\r JmnbA3sDB60dLbMZVV9VqtPaMREeZJLGSyjzUFdjX90vkYL70E51jOM0355bNjgpJAtvm/TGUnvQ\r PVKzpmeOublFkp6eIutWL5Vprx0nTQZcJHW7Hav5ojiP1qxN/pMWhL2N+pyrRxbr3ODBbwiuz6hP\r K7Ow0rXf5t/Mr+7UlNxznPSBzWPuN/c66QMG4tshhTyAeYx65CA3Mr3ZjfRv1X2oOYgur1Wrlo56\r 8Q6CF4JJY8bLfDeSnTN1pvw1caLq9BkwQOhgJIyYYRBulxI+GEqKq4MqpnrVKlKlYqZUqlRR9h/Q\r T2rXrieNDrtTNjc/Qbr8e5zM/vM7WTdvrCPKA6R+zxM0+A8c/3qJVKzZXEbciwQxQhkHRHjhDw+t\r hnHU63dBRZU2HDGHcfx6/8F63oCbR0SYRmlQu9ZeBEzkgGFjIswkLJUMun+GZu+d+iFSoMgxrxZK\r cWrlKh+d7hj6R//OauPOIXbk++tbasxIr3uWS9MmTaRWjbrS+ZRnpc+5L0qlKtWkrtvXt39fqVyj\r utRtWF/S3fPk9fBLeF8zJk6SWZ8PlbEPDJCiKS/Jyr+/U6cG1LoY1TGoo24kcSWR4vQb3LAJoMVu\r 4tOc0Ee8Xpw+rmpod5GCDas0kSLznRi4rnqtuXZQZc368k63J+iLbl/O1E9l+fIVUqdWdbn6khPk\r wP2D/FgBIJQQyTDhjB/9sw9vRwMOFr338zbWeDz40Ktan9TuO4JdE9g1Tw+8k8LHEoEpdcnMa7Df\r APzv2DkGEnxapcLa3NH97A4spmRC6HfEY9cYSMm2Eoj/ge7vdn7pOCeSG8hQCYj50KBBhwq1vb7N\r j2xAknrtsGZ/WkUCB+0arOl8FH0nDA74tdvWdO2urIn13DYjIMvPw6jJ13cdmrQgWuY0ayfa5ub8\r jT5K3pVhHqjaVH21YJx6h5G2g+vxL3JesPCPaUORYMgltHG599TCJlJSvo40PO5Fady4jkoiBW70\r zXAxd+MmWfI2o7gZ6qJLm769qIqNv+wjwA3pw48U2QmI+3hYGu7nJR6VPg653pX9a6Yp1AgaROY2\r OA0XTDWc0zYVHMjPBcOA0eDk4OEZD4SDOSXSBz6oe0sKvRWbngFjwOmIZatjFgSg4oJKtlBcZxl+\r IIykpTvGUrJVyqUmS83qdWXANV9K9X5XSEm1dnLgExskq9EpUuXQx1U/DzPAs4j+Qhn8cGNb9Tga\r 4CQPiPBXVzWQOp0OVYaQM/P7JR86KaR8w+41jXHM/eEplThAv+t/UCb0Pw2YSDwjQSLpcPzdMstt\r z3SLSSMrZ4+rBtPY9+TbZ7M9/bOhykQ63TpPDeczv3/SidfNZeDDq2Rj2UayOvMA6f/gGskr11wa\r Db5d9r1hhNRq2EBVhsr03ftBOlkwe66Mf3SwfHW2GyCt/FKyZv+mC6hcv70OnlBz4QbOgAm7Cf2G\r 9Os+g6+PUarSsIsbmE1hU3NbwXx0w9Xt5aQQP7eIaJYDMjGTyZhjWR8dI5vyCyS1zFa54epTJM9J\r oxDCeAZh2xzDCM1c4PE452y8C73O/sQTBquqKhF6BPsXmx12B7Br20g/bKQ34p0IxJkYUeeeKcer\r gnaG4Ceyg8Sv49ux/YasVX7q8F0Fc5mAH3/yttZE2CUGklwQO7FU6XCdxxAqYghlpAF81KkoUfZ1\r krwnh1uXEIugyRP9fox8HlEi5w+GFrffDpEyhCJR4qibIJW4n3qDH4nknMTjKqvkw0l6YtB2qMwc\r 0Uy2Q5kMqnX3cR3e3S9ZZHPcB5Wm+l9/jr8vrpSkM78xpWuVBp3UOQB//Ab7OqIYUQO535pRUxod\r 84K0btlCR/HsBYsWLZasH67VlNe05dtk5e0fzO8ByparIpPevliaD7ra19Dri8z9/qGI6o+EjxEE\r 9wcDQV2F1NEikD6aOwmDYwDbiE/J7pjNV3dJ475IOrSvu9z2OeqAwAJM+iBEiDcKgQpjC+6tjjBw\r rGKNepJRoZIkpZSXgy9/Wxod9ZB0G7ZAls30v6n/DcOVWSDhoGJU5hEQ186nPanlkU7SgHFAbEc9\r iiODkzreLHES1HUy58Nrc6Z9+0wDtk3igHEww6CXNgYEfey/B4kYSWv322rvM0Q+dtIHj7f/TT4w\r 8JV/JbUsX7RyKUyE382z4BkRRT7tE4IuR6o6j2M8xwHueZKklO0mJ78pTY8cKofd9bu+Iz58FhTG\r MPwJo3+X+Z/fKnM/u1XGOOmEd7Bx+TRVZwEyHqDKAszBj0fizK+wjeBQcrgGfqL2ZDIoHDw0NkT7\r DUG4NWSrW/NbkPzJCp375Ykyb948aVCnmuzbra302LdLhPANPPBsXRsg3vfc+6ISSspkKo6HqaGY\r x8PSfiSCEfVWLWO95kqDMY54ZvHjTz6wsDQQ6Q74TdYG9itjJtzDztpBWrf2bvHWTvzantuo0QQp\r izCToWHyxOlSrVaIDuwCOnRoqe+MRJWlYZcYSE6uG1HiQL9dBC83diWpxZulQlqK6vzZRwQxncuk\r EEC6c/oGwYUebsP9x43UlzkTsHYd0q+C3cE+9498UGT8ZE9yWnk1ELO/YpASpWbr/TUZnc4CSC0a\r CNoIMxEipNXrypVJFMj+ul2OdSOsv2NsHxxP4lEG52KgZ84PPFrItspvtXZZ+bVjlOVqSbVj3nFM\r tY6Ud4Q1L4/U6Y44rFwlORPflPUf/yvSpkabu0fv9dakZn9UOp/6rCsG13V3oEGDB1/rCIYf4TXq\r 4z5ElT78fZJu20sfbpcDOu+WKn1Q3bfhjzlG4xgLbxppA+DiSRk9uHpU1WjqRpuBStMBRqItpJZR\r N9Nkgi/cpbFvVK1cSRrUrS37HHmN1B94lRz2ZLbMnjVd4z1G3jdQ22OB6NEu+bLCzMPKShQdgUTl\r gsoqtVwlZQyFS/9c9OFpZaRK+yMq9br6cynIXhmROKJqKv1h7nEwDv/vQzwjyWy8j0ofM/jdbuEZ\r 9LjoHXn93Dr1F4x8RY64Y/hsGKIxESbRmv3NQ8pEOp78iCwd95E+LyQ1GAgL9WaP+0EOfGC+7Hv9\r COnYo6tKhUVxn3Sye1TTXj5GVn1xgdpGkELs+enAwRWTUzLcs0z1WR7cDux2qDvVzddtkwHCbEjd\r zn1TZgcMBSmkSbUtGlBbqUKaPPfYNfLcc0Pl7Xe/jhDE4T+9EjOqhuD23q+zEsqKFctHCHAi0AZZ\r sbcH2gnnqTIbyva8sawuDIDZCsum+sDC0mDncT9Wfva59yO/kX1W3hGef95nDbAJqUxdRxvA2unT\r 26vt2rbxE3FN/3uWu8/oN7o7wN6zvWBCf0c7idSkIsHJ0jrTzsHX3Zzig+n8Q3CMo7xP44wKhhoE\r ofkRs+uMwTwS7N8YTMLEhrbkykbr/B+/aG13wI/Qg/1um0y8PqDJEeyiPD+i0gaAr+OvRNnv4x+q\r J8qkLVkx6XPHbJrLir8+dfe5VpmCqqQ4gfNpL9QOs85hm8Dugfpq+cTPAruCPx5ekJCanvWldLvo\r EzdyqC1btmyVvPwiJ+5ulKlTp8rqd8g4Sl2R5gddoWUYgSZCjPwOh0gRBnaA++t2BMetGvNPI33M\r UenjZid93KNrZUIOJM/D7rFs/IdOCtysZYVrgG2YR5sht8mUe5rJtFfPlK35xTqa1ffqmAZMBNXV\r 1qISSUtKlkqVK0uzJo2kSr8rJanpIVKl9xXKlAhyIwOtJ3BDlbgRJ1K5YWdNSlka88DeAeP+8Iwy\r Kk30vOgtmf/VnWv+eP36RiZ1TPuEaV7viTAOpNnQw9kxqLqry14ETKTRft6FmLaxjxBbhEqrUa+T\r lKlMePkcGfPusJa9T749holkNunmntVQjc8gYSMejTy33leQOcE9d563q7fo9zekYMMKaXTReGnm\r pJKjX90q7bp2kSq1a6s0wjvNyVonC2fNkr+ePVxmvHacLH2hpzJ59cRCAp09QlWfpF8H2NRqBiph\r JH2+YfW60oGVJzTr3eBn3ZzfZOqfY6Qob6M8ff9lcuAhA9RbifknbCTNvVrZYMSSiZtA/HGD1TOC\r nwiWGNHaeP4FT6BLkwho0+pCrJmDnH1hxlIa+vb1GTeoD2EP39/O2kHsHNriPCQDu274+laP9Ssv\r +aSZbdr7hLW7i6ZNfEoTJtZKhJ1iIGPciAB99qIgN4uBF61/fSEh+jbIk2rpnguWz0iTMSuqxNo/\r 6vi5z4uZRCZoiAylHo7RqCuvL0cJJuvQwn6KDkyNCUFn/mkM56iZcLllrgi8vWo46YPK+VkLtJ6d\r Hy6zVHdSBP79lJnAidxcFeu113unnkkglHUJziPxIbPUVXESCPurOKLYqPfZKg346sZwfMwL7TJD\r YlK5mtLhjFclvWxZbZFgoc3uS541d54sfn2wG63jPeOlq3Xz/9AJssLSB/80ZYlbcpZN0USLzLYY\r Oe7WqYGER4eY5ZgHBMD/buDW7j82FFJtMwGWSh/BcUaYqfPel7G31pVFCxbqPgNKISKlYSTkOKvv\r CFG16jWlz8PrpPa/XpXWR94mHY6/zzGmT5WA0SLEDIIE8yCrLindNyyepMctFTpqqjDzYP8Xl9bU\r /RDa+Z/euKGwqKQGzAIgdeCBtc/pTloLoDnOEoGbSLTsDhK1w7KbqFC7uTJAmCHSSJujbtUMvT/d\r hgOFyPGOiSwa/ZaMfmdYy/6n3b44zER4pgt/fdWt+2syRJ4v89Wzv3734yLPnTT65Nay6PWC+kOk\r 990rpNs1P0mXfXtGCEPhpk2yYc1amTMnsIW5/gATIeUJMSGorTQ2xN0ZfXnWV3fqPvv9vvuUkX3J\r 1jvzF8md+q7u79S+mRswRg3fQ2+7WNOSA4h1otE5x3v06KBEk+lp8XRKBM4vjcGA1q39CJ1rbNqU\r F7nW9jyjqOOJfpQBgO1dh7oMmKlrqiswduwUXYMwAygNdl4iFG/xdiMj8LQ3+a9pTjpMkrYdfKzI\r nqBiRZ8Feu5cH/waj51iIB26+bD2nUPoy3FFPLAKCwvVC2ddbr4exfWPg2r/CKAuvXqq64hBskK2\r vf3Dlz0oQBB90XfQYJ/7x6Q/ZMlNTeeH+wpMTqPtuE1T71RvS7Rm0A4HtKwbWqYN1ismfaEuvIBJ\r gSD62D+0vvtHA5ynZbc03Pc0YVIhRtMwj+wlkyVnieXx8XU8HBOq204WjHxeZ0wkRmXe+C+lWfNW\r UqNxO404TU8rK8WFm2XWrDky+i637++3dZ7zZgdcoXpka4d7wLOM8tzvH9SYmplfDJWqzfHFt+uR\r QuQAWTt3lDJSdNRR24eP90DiqN/tBMd8ng5l5hWZ8WBbqbn2W5kzY5asXuntUUgcZu9A8iiTXEY6\r du4gjQbfJB2GLZaMLmcL810gWTC/BRlz63U/Rhb//rbU7Xq0npe3ZoESsNWuDtP0GvPAmwomAfEM\r Mw/UVgNuGi5tHfOY+PxJ+QWSURnvJLN1mNRRXJCrDhD+t4Xgf+o2u/8x7OH1YJKA50Dg4oF3jJfv\r rmupUtWhD83R5zTyzWENB5x2+8owE8F+EWYoE9+6zA0eKml9tgGMhdQmPF/AeyCLb5kyKVL//DEq\r mTRr6wZNVasqkchbv16+PjdJxj80QJZ/dq4seLarahFg0Cr1u99Yt/NRyjyY192Yy+xvH9D2i/56\r UnKXjJeVixfJ5588KkNvv1TuuucFPQYggtOm+7gwQzxxJcEhqdsh2hjJTfUUD4h9IgaUCBMm+Om1\r /bW2yurVlkQyFtwfsU/UM4LOurTMvMDuP8wQmR6XuUGsjZ3tHOG2wmt7BkSOgzmz5qvb/OKlq3R7\r T2FqsXnzt42/ATvFQMLoVmPHqa3tmbDKzc2VgoISSWJygwAWfBS2f+BVRH0Md7gL22OtVL9j0B5/\r INZBMdjWfbrp/rqFEbrqXgPix8Q3lO1fzTb7S74jXJwXaUxXvgwzKCnZrEwM113m/MCADrPDxZHg\r O2pq/aBdfYxutcGN/FmYN5pJenSnW6CzWo/6dp5b1jvJo2n/i6TJgIulKgkHHWqf9L60O+sdqVUt\r 0zHeIimb6l/RJsd8/3Ij0pVfXaT2kBYHX6PtAP5Oee8qLeNbz5wP+172hR3Wa/08rLNjWG3UlXLi\r G+drpLDei96Xr0dhyZg3VFVltg+Z+5lsyCuUqVOnxTAMJFKQlJIszVs201QmjBBJ5kd7VF3yB5MM\r eeIEgYNYoZ5h0iTQqO+Z7rc8reVOJz+s0kY88zj4vumautyYR7PO/Wf/dv8gqd5xSEbbo2/TkTgT\r QJkUAlLSyyvBVAQ/Mfob/4ewm/cBE2nS7yyZ8q5PgHnIQ7Plt/sPUoma58HzGvHmsNowC9lSkMcz\r 41lWb9lH/njqeGUizCnPPOzND7xEshzjUHsIzIOAQsdQmh14qT7rfU5z78Jdw6LVUzqcKxvX+fkm\r sGYEr1+WOqkYA/iMlw6T5Z+erQM05g/hXNTFf79/lZSr2shJKv1U9bk1P0tGvnqLbC0oUKN9h66d\r lACecfqQGNXInDl+lMsjgsDeNsz3jXgYMe7Vq1NCg3mUOHvEZNAIgXv4bZTrWyGiHDZAhwEB7x0Q\r U2MiRtRLg9U595xjI/f00cc/yC03+9T0/vzE91Ya7Lfbun498viJrFu/QSZNmCrj/5oh7Tu10Tnh\r 9wZsbpCRpUSk7zQDufGG83S9cWM0KeK22PbrQAKBTpVPT5Ge7b26igycwNs/3EFXwSZ8CnsO4Q7o\r W/RkOvrHFiv6MnmvjEBzINmNjvC+Urh9pAxnf3rV+r4eJ7u1bz16HgZ2M56To4u5MigzxzR1UF9R\r UxGcyp8yZVCXJEnt9oMjk0VlNtrHBwXa9RRW9kxEi07k1MmbuJ/kNGl3+svSoU1LDbjjJamxs6hY\r 5k4aLkmLPpOSlYGtx9Wf871P0Y4vP5HxLQ+90W37qUs5TrR551Oe1oyrpGsn8WKrw/G04sIi3/27\r kbQ6FFuIOMllmDQLcm8VjX9cRr90vmxas0IKHFPFQG6AmTRu1FilmC2tT5GuTupIP+kXdfEESAwQ\r qZaHXKPEBZUKEwnN/Oq+4KpejVWpfntJZYIoxzB4VoBzOYbBnDnIUd3AVFru03/213cc3LL1kJul\r Qa+TVMWzadW8yEidOAQFP4SL2IX+22D3tpP3V656Q+l40gNOqvA5jnBPHvWQTxMDE8HuMe+nZ6T/\r rX+Um/H5XVt5du2OvVM9zniueGblLJ+uz7TF4Gv1sua8wMb8n57S8sLfXpENTmKuieHcvQP67eEP\r zZLGrVpJhcxMPa/EvXfsJIUbcmTNsuWyeM5cWfzxWTLn7VOkePkY185AlTz8DI/uW6nfQaY86b/B\r zz5+RFKSk3Wu8WrVqsg+ndvIo48x0PJ46IFrYlQ9eFuFYykMRphXrcqSRo3qBHtjsZnJ+x2oZ+k/\r 4gERhphfdukp2qYR5dLwwYffRe6Ndu0+PCNIDOqY+od6SCwmNXjGtXOdoLRrYD8CSxYuky3uN590\r ks9NllbWR9nvKTyd9JJTIuw0AyH7KvhrVlxD2/39SbJhwwbVjZckJUdmVfP5r6ISCGohA0Zq3ybM\r xKcyUegPCV3MFSNMwC38Q21kwE04PbOe92t39XyA1P5axpAHYpgIxaAMvBrNrZ0UwlwZGB3rdTs+\r xniu5wX/2AdjwXUXwzmqq0W/v6bBWN7l1dfy62gJMK8HbrveY8qBtmt0kBqnfSNNuhyobr6MU4q3\r bJVNm/J1UqJF35DDijac1NLpcKnV8VCpULO5uwefGyf4GXp89rf3aplUI9g9/GyPwKuuGvc7T331\r 8bTiOvjqZ726n/z61s2yfv162ZJSopllMZAjfTRp1ExaDLlNFqxcE0meqMFj7hhzY+euni89L3pH\r 98/+/hGp7pjHotFMm9pXJc0mAy7wI+NKNXUE3WLQ5Vp3/aKJyiiQNlT90qa/ENNBed+Tbp/901Pn\r toRxmLEcGPMA6VXcaMx++P8WcLs7ecv9b/xJJr9DTjPPRH7F0O6ATWTiG5e4ZzlSjn1tcxIMBQbQ\r YtAVkr14kpa7nfuKkDEXF3fQPEi3r6os93wBDidFuet1/g6cTWD6CyZ8J8ltTpH9H1onbffZR6rX\r qyslaTi5OIEnmeShIisXLpKslStlzvvnyao3fGAm10GNtf7n22TFwgVy2dVnyyFDDpLXX71bXn3t\r U1mXlS3t4qaI7dixlXz6+c8Rwoxd5KZbHg+OxgLiW8+NvmfO9EHI8TjwgF66ph5Ty5ZGgInNCHs1\r lZajimO1nHRCO5TtHllvD3eE3HaZFpc1980aZrKrhvTwdVnXrl1dXn35I6lQsZx07Rmlf+XLpwel\r PYPlxFq3PnE6k51mIAf096NDg+/z8T0/tB0UC5zYSt6nzErlZNyaajpXNQfVkG7zocNItH6SpKZX\r dn/dhvtfFNgtYqghRFu3Q0uwn7mr2SCQ0JgSieB0Gk63f+2sX9xf7B8HaX0Qw4R0l7uHcpk6PSvB\r gxtXkDyRtBQHyrIJH8UYz/19+iUva6FjHIjTjpE5JoL9o3Gfs6RR33N0VEZVq0sZf/nMJt11Id8V\r 8GosbVXX1F2bvUnTpzM1gO6HwjusW5sly153v8PtLcrNlsr12suS399QnfMc1Tv781njIQPxRp2H\r 7YO5PRTusBlACRwkZUm3896WNa/0dKOmuZptlwSGPCPrKJ07Ommq4yk6VznSBeoOULfLEDXKtnQj\r 3Ao1m8rXVzL9rh7SkW/j3qcrsQLo8/EqWjbBG9XXTP9F9xvzYM3yx1P/0uMwibHvDmtJdoHG/c7c\r hnmUlLjRpl4ruOAuwj+lvbPsNnaygU4nPyTjX2YqAJF+jomMftTPCz7gRuJCvLqhf1CG0Wa6fjjt\r 41uVGaAanvfT0/pMSRU078cnvCrLvR+kc8rcAm7nlJlXvZLry22G3KquvIUNjpRmp7wjzZs1k0yy\r L5dNkxI30kW9Rf+YN2OmTJw4UbLGPS9zPr5Bxj1ykCyaO1vKZ1aWhnW8gfxkN0Im6WHT0GyAEELD\r rTdfqNsQfoikxTaE8c23v0akBT+KjwVSjLVJPZZE9ZYsXamxGdRlwirW/fp5T6d4lJSU6P0Y4QZh\r Yl4awsdIkR4+x9pJdL3tYXVoet7xY8j4kCLNmvu4FtpFZRd2U95TYPvBSy4RdpqB9OjnEyDuEDEf\r AVlUi7WDlc/wHJEJ96lj7ru+vFbLuPL6ObVBkpSt5Ofp8E0GBDvYMiiNDPZVqNFU5/1gu1Ld9sK8\r H0DTubuKGJGZmS8seXhY2V3BrdIr19LMs0yshGeJD0YUqdf9eFk27gNq+fpu8aQ1SYOrKjfo6EZe\r f6oEsnT8hzq3BcZhD9++B/Xr6SjNL3+q2midW1u7vlaSdD//XWlz+RipVKWqZGSU1REfKcyzs7Nl\r wYIFMvbOlrLi8yBqvUyyI+DXa84hf77Iqqnfag4wchCRUmKO+uMDUt3/KX2u/lHaaJqSJI1a3zLm\r bpk2dbqsXrtOJ0cizQgeVuDA/feXupe7TukanvbxzRHpIwyuCUFqc9Rtbu3nJQfsM6BWSUor74jh\r o1peO+s3ZRjTIGSOaEHgsIEU5axRJjH/s5s3wTcxnm8jeejPRsHHlXcO1AwvexN73PZOnNTtnBfk\r 1/sHabn31Z+rJAKzaHv0UM0yHC7jZFCtxX76nPte950OcihXbzNAOpzwgDJ91FfKSNxgwE/45fqX\r kwaRQpiYavZ3D2mZYzhFbG32L+l55XBp1saNeAuLpEx6mhS5+1Zikp8vG1ev9kGlbiHp/MEH7SdZ\r GyzLhIcF2sUT98GH9JGhjgEYg+jerV1kQibDuHE+39aMGfMj9cKwNk11BFFNZOw+9ZQjlMhS9977\r XtR9d9z5bAzRN5g3FZHuHIdJ/TKcGJjtMwBri2swjTKw86PX2fFLp65dZ/p0BuEin3zygwZQzluw\r XI+PGeMznu8og+6ugpxewbh1G+w0A9kxYh8CW/vWznYSSJGm2YaDh+sgLvttggl9/Adzfvgq5HPa\r JOmVarOh236/AULPPn8+S0HOKp0rHWYB1i8YSy2tg896bhB1DhEFYSaixaCMxLEJryu3SZnYD8rL\r J37iVkmOiZzgq3KKgbqrZsqSP95U91pATqBGfc6Rqk26uuN2vxTJuvuCJmhE+vDXDuZuxzVXz3av\r xR0gSGvV1O807qPr9ZOk3Wmv6ssklhN7yKaNubJ+/Qa33iiLn99Pmg9kLhFa0AvpGoM+DAoJhCSJ\r Lc3zyv3H5RkVH6qrpc91kTWjH5eZM2dK0dZiKZNSRqdVTXfiIxMo9bphpGSc8qNPZ+HQcvB1EelD\r Z7tzhMiYxYzPPePAzRjGQcwHWP3398ocwJbCXKlS30lzDto53f1A2A66a5KqYigTgV0496d1hSVl\r K8A82A+UefifFyBSKBVWfcc19y5267o7cQLMwJhpm2OGasAhTBjw7FSyc8SeZ1a742DNMwdz7nLm\r cypZI5FMeMXnU4NJTHz9YnWnhvnAUMiqy3tF8sh0krENFmAizQddJeuzVkmri3+XbqfeLy17HC71\r GzSQJMdICh2hLXB9zwgL8kmzZn6qBgOqKUOUiHpAEP+aOCNCMKlrU7cajEG0CQLm4gk451Ln7Xe+\r imFOpQHmctON5+l5lLenxiLSHeJ/3rnHSbL7rexj2R64v4suPCFSj/ONofl7L408J8ZWx4iee+kz\r yXTSU9uOrSNMFKcbgNYAzN/BdLQ7i65ByvhE0wrvMgOpVbFcUNoRktR91/3XyFbzhNDcTQ6kKzeY\r 4Ty5LG27yu6/phtR+G3/J0qIo/AMgASKlL1LId5YzA3uj2sKBrePzTLJZbXM/ggT0bJbuTUeV3Yc\r +0dd3FldmZkHc1ZMjxxj8fdCu0kaeU7WXaQPDSQc/apsWDJRddC+PvDnNel/gSPqE9wHPVylAzL7\r Bofsj/vr17U6DFbmt2n1PMdkJkivy76Q5q2cZFTBvweeal7uJpk5e478NrSNzHnSMzAD0pR3JHDP\r wTGRaMr2JPnuugZSvmZTyVz7rUybPlP1nEWbSxyz3+reWRmpW6emNGnaVBqf+q6moPB35GEEpcG+\r J+vawCgW6WPjitmuzq16Dkyk7j5HyIDbfpd5P5NF2KurCjd6YyIMwWwdVRp2jKixalSQxV8OG1SV\r UTSY+9Mz0u5Yzzzy13lj/Y7gf+l/B3b5XrZzAokeiXmZ+eV9SvSpBoMwozpzmodVWUwTzbzpMI68\r rCUy6e2r1LgO/v7wRk1Qia0qLCkuG/+JMiEYzMJfX1YphGXuD4+qJMJF1+XkS3GVDtL91kVSo0ZN\r qVK5sqSnp4uTSyLE5eH7npcVy1dFCD2EFMIeJvzh8sAB7ntwsH3bYwKTpyTOFMs1IKwQamYARLII\r XyMMIteZNbC04waO0x7t1q1bM8IQ2L+9c6mHtASsjdj6O98rJo7/W7JyCqRHp6YyMC7xpMEkkB1N\r R7uzMNo9M0FKk11mILjlRrCD343Yh/0DvUvZwCvA5j2PMaAH7Wwpyos0mYb6ig3dERB4OxgcUCIb\r HK/WzD1MVybJW777QOyE/LULtewJMnm1mJCG8/REj6Auq2xH9GEyeF9tWh11GMD+oXXs3OAcW2Ac\r 7MOITnwHgYOVG3ZxBLGL1qCOvwd3Dcc8GNWRUgUVVnYgfWhb2pyvBzinQc+TZeXkL5QpJldvL80v\r GC516tTRarxARhwawZ6bJ8kV3P4Vv+t5pHDRKHyHLZsLZM6392uL/CcxIq66U5/sLZMn/y35hZul\r fHqqpJVPde/NMc+KFaV8twulqPkJUly4kVMi0gfMY8HIF3WEWqF2C5n97YNe+nCVZgRqK2J9IEYm\r lVRp7Ge1RCUIZn/3qOrjYR6oq4CqsYLRM0bzX98c1vDAu7wKkClce13u5+2GeWRUradlvWgCsDfx\r kf957PK9lVIZxsC8M+vm/Smt3XOc8clQrYs95I8nj3MMxksT458+NqfL2c/Lsj8/UCbT/ri7dCZC\r yjCICrWaK5OY8u41ESmES+Idx3ZRfrY6aBBACJBCTNVFqhPd7zpjhc5nS5MhD0qnTp0ks2pV10BZ\r VWOBV1/+RB564AXJ25Ad7IkyBpMoDFddcZoS2BudVMB+G2GHgfoJXH7ZqUqg4wk425bSHc+v0uYL\r J6qbyHI7f9UqBjWlSwTU21nGYTBDuiHcBtPwhj737eJdJ1GB444aIF26d9RyGOHnuTfRL4imX5/A\r kL4bDKQ46M/xv9pt265gjQGdKUaLk1MlKaNaxH2XCkwmQz3PSDiXk+x2kmRrKBuvByVbwkVfQJ/P\r WqWZoEq5ao1d2bdBVC7lzCY9ghfmz/NSCEW/DcEvKSnykkgwTScMwef40Sp6pi/6DWI/2Lf499cd\r A5qsC1lrmRNED9C2Lr5M5PmCkc9q8KDf54hi9nK3YoPMu25kt2CsMgxyX23OC6L09R79Kc0v/l2a\r Nm2iNhG0gzw5uv2Cv3+Tqe9eKsXLftdoc6YS5d7HPHWUz4Ol8DPKZS5+W+cUZ7pX+Hx+gRNRnQSS\r WamatDrro4iUAcPjok33v0Q9vlBdNRlwXiTXUe32B2vgHgzDbB/VmvfS+1Qm4hiCAcMsjMLnQvP7\r UL90OumhiOqK43+8O6wlv6dKo86qqun77299ZYftMQ/2bLv3vxO7dK+lVIQBL/7de7x1Pf9V+fP5\r M3XOE8B+JJKFYz+phDq27bF3RgzqBMriAYcUQtbqvz+4wUmJQ1QKgbFsdddDBck7mPvD4xGmwvvn\r fIB6i3K1ZvtpmQpIN3XO/E3637dS2rXzKkpAP/3uhzHSeb8z5Yevfo6oseKJK2D7ldc+VdUVxJDt\r MKFm29Q1RsTj2wCff/FL5DyOJ6qTnl5Wfvjxdz3Ws2dHqVWrupZLy4vFgi3DrsmyI1xzzZm65hyI\r vJ3D9nHHDkqYXTiMcX9MlMeffl+aNa0v+3TroOeHf7Ot4xnH3mIkeGKBvAQ5xnaZgWzNSJV9qsem\r NEncu5OUgeA9lOJGIrlJpDDxqcd9BDrn+IW/iEkV65C3xbelBEbhtgPCqdBNtv1iRJw06UR0U5fZ\r B/OzFuv+9CoQG8c4mvaQvDWIYHYuK182JkLEOeWKtduo4ZzRMrEfJDhMr4w9xs4NznEL/1BfsY/Y\r DzLuVnQjOuwfGs0d1PdIUtUVc34QPGj7APfvq/r6JKPbtHKOMpGc5dOkxaCrHVHeL3KcZZ3UkcZN\r m0qliuV1pOdbwid8vvz57HGStnG2zvOBnQMmorEfer4brfy7uowfP95JLyWaJQBWUK1qplSpWk16\r 3LFU1s39PSJxtA0YSUpaeSc5dY2MREnGSGs4DzAFLoFjJnHEMw5FkAkXKYPb4DhlGEbLwVfHqK5U\r j++I46q/f9QfltmkqxSsD4vk9ms92Ird878HO33vpVTqfNpjymSZl71izabKiAmsHPvcKXocg/qk\r V84qaLDvCTpQgUGwLzdrUUQKwbUbZoAta8ZnQ6XFwVfrfrIza7yIA55a9AGACkvVWA4kF0W1Fb1B\r /300uXictDziVmnWroNUqumZ/qLZ8+TIY66Ur78drQTeiKFNzWpA/WLEFqM5hvUw1qxZp7YEm1qZ\r 6O4wOA9V0a+/TVC7Ctegfjxom3oPPPiKphihDnVLk0I4NmrUX9o+dRO1GY/x4320O+BagHaQfmIj\r 4bfFxPFTZPzUBbLvPs2lx77bBgfaeaWdvzdQuZIPv0gUtLlLDCQ326sTRv62/Zu1boQNBMK2dUuh\r 5G8tpyKxokz0skWbfK76vNXzhOyedrJGoIe/GNcho4zD4Mq6maTeWxjRQTj6fN280e5DIXcTEeZI\r FNSwtrSof/jHfwyMVkaCqNXuEFk+8WOtiqss7epChWBh3mf2LXISyOoZP6m9YtGoV2TJ2He1Bn+M\r 4VRt0s1JH8/JghHPhCLu9Yq6thVBkZvz1rn7H6OJEye+SfRqUC+o1uuyz6XaoY9Kh6Nukjq1a0py\r arIUFm/V3FRZGzbJilWrJXfBb1K0apLM+drPP87JC57uKhnuo9rkJA7UXoCMuS1btpTuty9yjOMO\r qdqit44slXm46yF1zP3pCV1DLCA0TCfLGrsHICOseV5xizCBFJ1a14m/88e5encpg+CgfZ7UIQ4B\r RlK2XGVVXf1Geo5b/Ij21wcOjnhcpWduGzTGdVj2Cqyx3Vn2AnaqqVIqlUlJlbWzf3fP8jZZOt5J\r vg4wiXEvnKXPfNWsP9JzZn63pNs5L8uU965VZkEqGSaxInsvmQKQIrDf9bthuObPgmE0O+AyN/jo\r o4wGRkJ2BsphNVZm4y6SUrZcRJW1NoizsptdVZQp9evXk2at2+lABTz5yMsyacpsx0hGyeuvf6qD\r oDARREJhBA2BJm2JBQbGw6LDM9J9PwsDJnTrLRdqHAhINCI3BtazBxm/PYGvoPbFxG+C+oD7oi4L\r DMr2J4IdgyHab+zatZ08+dTbofNirzfuj7/k0SffdWOuErnovGOk535dY65h6qpEsHqsE00BvKsg\r vx1YlMCmsssSyM7BP4ycnBwbdDokyZZCT6xI6mcoGxjQSaBoj9DyVvnFiGsYbp8SZF9WA3pQ5l+5\r ms1UCmG7cqOu7jiJEwkOJICR86gctME2cGUNHtSyY2B12qrhPG/9Eqnf7V8ayaun+hp+zR+3EPfB\r 0siJ5zU1xoR5M871BubwNRxMAiH2g0hfPKSqYkQP6vhf6xb3nzT22IKYgpbgPl/FH5/z/YOOkP/q\r pJI+snx1jmMI5d1HWt915nT3wh1jctWwfY14eLDM+/4+qVOvrhQv/llWf36eLFu2VFY75qLqL1en\r RvWq0rFjR6lxzmiNVEeNAYhsXzbBEyPAJF/YPQx6Ow7o4GEa+euX6b6w9LH8ry90jX0L4KpLHYia\r 2TsAjGTIM1mSUyiquqrRuq+Oqgfdl2huB39lu/5ugwbCy55gL7a1U6fHVWoz5CY1koP63Y5RKQTG\r u3CUj8LGLjLxk/sboIpCnWVSCI4MZABAnbVo9JvS+vAbVc2IdEGm5Iq1m8vKv79XaQSmw3nq0uuk\r TaCqK4ea7YhJos+21+M5y6ZpH9TEig55dQ6Wuse9Js1dP27d2RO4JNdBH3r0dfl1zDR57qVP5Kpr\r yN7rgf0UIgnRv+vu5+XuO3ywaRgQbwgyhHJmMC96GAsWLI1ICNShTVN9xWO//aIxGhD30iQQDPJg\r 0EH7aV0Wm7wKyaQ0UI/fYsQdycMYGsfCDGHkz6PljIvvl40b82KCAwF1S4O1DazekiXYfPcMJLCk\r u/E847H7DGQnejlTuNprYCY6opA5cXOuV4ExF7e3WYQbS5KiHFJSeFKqiBDhYE/0gP+rlnoy+nq9\r erkq9X2AnCuXdczKd2InKayY4ZpK0EawD0M1tg8LHvQIDOS6I1ion+RnCcSv3s/GRvvTdR92FA87\r B3DE/UtO1ayzRJ6zaPzHAveytWr0dZA0kVQuhRtXqRqLzMKcb6jZdpD7iPvrdL2tDr1e2l45Udpe\r PUW6Hn+XesHAPHjm3Ne6ddmyasVyGfP8qTLzj88ky23DOFJSktUVMSOjvFQ5fYSmncfOASACXK2e\r I0YAewgLEgdMBIaxaNTrKj30ueZrGXnf/pJeua4eIz0JDIFRbc0OB2uZfFUqfTjYr2B/mJHUrFRm\r 8ZT3rpc2eFoFqFy/nayZ+nOwBfzZ0Sexi+BEW/5J7OF1duq0uEp4ZcE4YBLTMag7tHNMYuKbl+s+\r mEDZjXOXE+ypU9kqM5khf716gb6rck6KhyF4ZsEcLf2lIGe1lK/eSLcBUgmGc74j+oipsTDKZ7lt\r 1La46C8j7Y8DUkmtDodqXyUxaXU34Gl0wSg54OLnRRP/uBHmkmVr5L33v5OFi1fLb8P97HekLh8d\r uO+eesrhOo9QmHhCLN//4Dsts/+0U31MRxjUgckYYyCUwGIlwuA49hbiK8zwHibGYWCQB7i0Usfq\r 0b7FeSRC+FXF3ycgE/Dvv/4p9z7wihx67GVy+qmHyZGHJPayCsMYj60Ttb2n4NmXhl1mINdceoau\r 01PCHNo9HntCwbpKWrEUhGwuBSUpbjTt4zp85HmSFG5Y6aqHH60v+wBCED7mEZUagjPdNnpZyuTd\r ycP24YAE4iWTpMi0tMmBOoV9bLNokbIrVHHSyqq/v9VN0plzBVKDJKWkSGUi0LUqe6PnK9wKAzqJ\r 47KXTFL1Vfbiif6o+6P3rIsb17gPZuvWYpVAmjliTebbauTAirSFK/JYNZ6XrUD0bpLaPvxshrqp\r f2Z8MVQlhHJVGzup4X7H/JiH2klc3c+XVq1aaTp4J/26e/LviXK+Y9j5+fmuQyQFAYlbnLheUbre\r 5kdvRODPH/60Iwx+VGnSBmorRp4rJn/leFyyMhHQYL9TnHT0hB6D2JAqg/tLr1hdiZAlRjSQXobb\r N5VV++CYMZK5s6Y1TE7z7slIH6a6qtGeeSY8OF8fwa5it0/02LR6vsz+7vEdLtTbBrt57Z06LVQB\r hrDsr8+13PaYocpMsCPN/fFJv88xkx+fPK8uSShJN8NxBggrpvh50XlnuADDTEzaYF8lx8RxevHv\r 2XtpUYY5mBqrjPu2rEyiTz9xl/++mMdfjwcDHgZ3KR3OkEOe9aqlrXkbpUKlSrJ+wyY566J75N83\r PqajcAsgXLRoufbV+LgGcytlmlmbkTAMiCkSiBFViL3ljgrDjmNX6dChhW7viBCHGQdLaUkYDWFq\r CeIZ1Pg/J8lt974id93zlJoKbrjmdOnUJeqEYLCsuxYDY1JMvHoua51PerspUFHvKbj/NXHTeYDd\r lkDql7PGEnVxJw2UJElajcaSlBZw7Nx1kSj0SMJEelcCeAIdQOvQEd06vnpwPl4kMW25MnM1+/ow\r Dte5XFnncXbHIu3rOb6TAxI6MiMeUkjFOm0jaduJal867oOgfgB/qrrtMnkO6qsqDRyRd/uY9nXb\r BIpEhX8vme5jIvaDOUqW/Pmu1O9xgjvi69h9YUBH6ija5FMWZM37IxojQy23anfMPa4ekskijdGo\r 3dlP9k8bG2ocLFWrVtXRFKM83oCZnQoKN7uPcaukpKZI9WrVpdZ+PjMoiDCOId6GYYGClR3zYrTJ\r yDI8JeysL++Wye9cpcTGJoZSycNtk9KeETHbpDaBGcz6+gF3g/5G8Lxq1O9sZSQVa7eU6uVlPvp4\r YxqJEHlvuwL/yHYLxjSmfnKT/HxXd5n05pU7XEY9Nqh0ZrKb97LDU0IV6nU5MiKFLPnDz72BK+4S\r nq1j0ipdVJDFW4uLNLElkh8xIjAEa8aYB9KFSR4+EDGqxmK6BMpAvbEccwDWh0iNY+qtLMcwpn9y\r i2oCsOetnc1+/zCwiQx+Jk8a1qsrdWvXlhUr18qDD70q51x8j2MgWyRrlZ8+AGDTCMOIJqoViLhJ\r LAaINBKIlaljk0eFESbmZiAH2/PECoNZ+0i0OGly4pgUwLXD59k2Ete9D74qC5evk/uGXhCxM5cG\r 84hKS/NhEfabJwRJJ/GoBNWC/F6TJydOQbKr4G1NCyLgw9hlBtK/l9f3/TVm+xy6cSXH+XIWakxB\r q/q1ZXOeYzjuLtSdNoBNLwphSKtocR9OMglUWMH/ELSC/jNiTpn5D0zFQ9JEmxuDeS8ABExTuEcY\r gKsZKrPonB+uqKnbV8zUMpILOYMoQ9D1uizuXCujviopdpLH0kmu7F8mwYOkgtC6Cl+3VvtDZOHI\r 54PEiT77bq7GqXA4Wnfc8yeq8bxq816aFnvZuPd9S0EVRnHMQc3EUuwq4tk6WBMZTvrqcPZ7Ur9u\r Xd1md+Bxq5IH2zWqV5ctme3UdhOBOwDz4MPPbNYz4saLzcpGl0gl6qHj6lA+9rUtavNYMPIlJUa0\r DdPYUrBJCQyj2dUzfMDaluJClUJgGoxoylVroHWZaW9tnjS1dxKWPgz+yC6AE3b5JA9jHL/c1UOZ\r wvSP75XCrGj+oe0hZ9G8CDOZ8NpZe42R7Gx1GAfqQkDiSZgJiRfJ1ksjMIQZ40Y2bH7wlU7a9iqg\r inVaqeTRxkkoMBsYhGcWXhKZ/NblOv1zRI3ljpEaR5kMaiy3APXMcmX6N4Mlg3nt2RzqzJGu4H5a\r 9HXtXyTNLx0rjf/1omRWqSJ169WTZSuy5I8//5ZzL71XPvjoB0l2TO6FYJa9MFDdeKO36LS38TAb\r CGsItjGUMOKJu52zrdwQBeewgLVuZA4zGzgglrGEEW/vSE8pI/c9+Jp88MVvctShfeTJR6+Xbj1j\r 8w0mgl2zSqBqs99s0eJpgcHbVFrxaWD2NnaZgRxw2AFy7b99CoREsI6eVLRR8pKSlYGkMZ2tTi2K\r 11WUgVhWWIzm6ZX8zIOcX7ZyrYAY8sct1qghsu2Paf4sKKQrwzyUgVBeu0AlHzZI4hhlAMG5kbJb\r uQvigeU33IPPy1GmsXEFbnbeNdiOBad4uI0qDb0bL0vBeiaiikKvyX+3kLq9Sf8LVX1VtUl3NzIb\r FVJfBZXcf9Ktc22YyMaV06XjSZaR1NfLmvt7xHUYKJMLjrFM+/gGyd6wSVKZkMrtgU2T1wpg+6hY\r sZy0Ov8HVSmgWgB4XjFdLYwBXTbpUwApLcIEAvVVaobrvFu3KuOAiFRwxIWAQtDswEuUqTJJFMBp\r oFz1Rso0AKNgG/ka+p56+3wkEtQtieB/pf+7Q9hj2A1A6Gd9+2iEcRRkJZ5caGexavKv2s5fb56/\r VxjJdquGDiL5ZS+apMzEbCEAZoJNZBrMolt/vRlVc7l92e6deekiVo2V5d5v9tK/Zemf72t7vG+Y\r DMlCrV9Uxb3cgUFGBSdNVqzbTlWwG5eTsypJpROCVpsPuk7toGEa0PLwW6Wck/ptzvQKnU6XrjdO\r l3YdO0nNOvVkffYmeeaFj+Skc1z/bNNcRvxgHl4eMARmFSwNHG/btpmukRKMAIcB82A/axaIPetE\r KhtA3UqVKmgdCPXUINV5okA7g7GiSRP+lpmzFsot97wkfbu3luOOGiht2vlvZ2fANbcH5jcBnTr5\r jOfxqq3dRWZmML9OHHZLhcU0iqXD92RceEmJAfILciUlnRtwx2JceIkLSdIoaQ9/bjQHloH9jhQr\r gfVlXdx/Rv9sed05O7ZEPLBY1LDugGdWsMv++KYou0L56k0lV6UQUpi01chbmA8fw8ZljokE144y\r IX8/lRswAkhS9RVBb3U6H6HqK+Il/DnBNULnob5iqVjffWgY0PWIVlR45uGNiclpFSTLMRJ/vp4u\r 9XucpIZ9clkB5v8AWsP9aTrgIvfR9lMDOckQOceQVjZZel38geYdg8EyXS9o3O8cZSIGGzUifZgt\r hDWZWbmGqScgMlWb93aEyDEXxwTQlRMXAqFCuthcsFGZBtOp2m2UbC7UfWY8X5svTac6qQMgfbQ6\r 1KcsB6Fb3zF2qXIsIO4Q+slvXb3HjCMeK//6WRnJjC/u3JaJgF247+1WDQ5C6Ce95ScYK1PWJzFt\r d4xjHI6ZEGQIk8jKlaYwAs8s+quXHMzBCJ0yE/eOqdv17JfU4UUljtm/OkbRX5KSUzQzNf3Epwfy\r 56VXqSs1HcNAkq1Yz7vGAtRW2a7Pm7eWutpzkvs/4/Pbgxxtrp7bT3+te9p30v36KWrLq+ykkqVL\r V8nPv4yVU869Q24f+qzce8/LkuZICcQcV14jrPGTR3H8mWff0zXp2G1fPDif/XaMNdlzE4G6TIRF\r HQh0+7i09Ikw/e+ZcsvQp+X625+Qps0bykN3XCzFboAdZgil5eAKw2JK7DxzY7btbt283YQ8WcAk\r kT0FqVsSYbcYiKF3k+BlBZ0njAkz58jWohKduY60GPiXK3jBWh+1lb8pnxfLN4I3hwfbbrG2bR3A\r E0XUXdSHCeHh5UruOkypCVCRFBfgmYWay0e8Rwi1NhAl27lr50fmKQHMVaHGd1fPsvpG4C+uYAIe\r D3REvs3CHB/b4hGtC2Ac0X3BOtQeI38kDw4Rh0FBj0aryOR3LnV/HSNydVFnzf7m3kgTfIDkvsKg\r PXX6VJ2QysCcHpmVq0hucYZ+0OZwABb+9rISAz5+rlVc6GeKIx3Kbw8cqAQF6QMiCFoddoPbN0A+\r vyhTKtRqqoyAUStMw261SpOuEdftpeM+EuJeYBq12jIvfWA8d1JHWGU13ZWZUTBrpiMkugeEfnxp\r 2IkqiQBBRzr4eVhXJfT/JBYMf00mvH7Of4SJWMBfp5MfkbWBTQRmAHhvJnmsYSZBh3rdjlVmwj4W\r sGLSV7Jx1VwpWLfUDQCO97NHbvX9CY0CtkxSoACYi9lBCEC1AYaHd3ShzzHbJZKvgQBX0u3M+Y40\r Owx+UDHxI9zi/qfX7iR9h86WOvVqS916DWTt2g1yx90vyM23PyWnOmYycdwUGT16ohJzvIUSZaId\r fEjfCIFlbfN/hMH5HAvXK23OdeoaYcbFFYTPDWP0yDFy67Bn5NPv/nBj52S585aLZND+PaVTV38e\r bUUdAGKZXyIYgwCca4GUBouHsSlo95YEUqWKV5nFY48YyLdf/xCUEiM53ds4KlUkCp1UIuKns9UO\r EjWmW2dPDEdAQwTWg22/L389ea8ccVQinyTlqjb0bsLuHAITkXyoaVHw/IlpT8tJkrt6nhutp6v9\r Y2MwV3vFWq1U+kCi8WTcLbQblM19N3vpZC2TR2vD4onunvAW8bWAlewv6iuy9iIFmBSh9xG6L00P\r MfMXKVsu00egc3Zwr2QctqzDGCVbHnqTP+4WnUDLYfyzfsa6FIweATLSy0qlyv7jwaDZpL+fV8IA\r AeDDh5HU6eRnNqP91swH4QgErrswivm/PBfYeET2u+IzlTwAUgggoBOGg/oKyXDBr6/q3bU58maZ\r ++NTUq1VXyVgAOM552nU+dSfI2qs6q19Di8N/twe/M/eLUDI5/30rEoHhdnRHE3/JFZNGiGjHz+k\r dCayk79lu9XcwQ4n3q/PuFK9NppzDBjjUGnEMYvW3frPr9asp+4rWL9MMtyAi/cGeN9Mm9tkwLm6\r D+bT5YznIrYw1JnsI4iUb9skZoDTRXJKmmZcXqPzzZCLLV8wsLc+wr9fM7YDpBH6e4VaLWTTmjkx\r gYjQhrk/PiZdnTTS6JgnpEKlClKhfAUlxgsWLJc7HnhNnn/pE/n+q5+lrKOlFSvG0pI+fbposkSI\r LWC9UvNdxQLib3WijCDxU8ZgbYQ5UXQ2hvEbbnlSylfpInc+/KbmAbzn1vPkjtsulLzCaH/mOmQe\r tjiSnX75cQj/tqXL/KyczZpG51vZGzD35XjsEQPxCP3ooJiWHIxSCvzDyissCCSAqA0Erw4D4rGe\r 6whkxIAOYp6nVtB/tp9yhmMYlDKqNhKCEf0BgguDwKKA6HraHJyooB2/zd/ytZp7KSZSxc8wWLFe\r e0kuG3RKTvElD7dRLrN+ZGPTKid1aSn4Q/u6ePsHebhI4a4qrAV/qprMV9UzFKivWBj5lymbISv/\r /trt9cetFnN+rHOSB8TdkiUqXIVUx6BRXxmSSIUcoFi2SNt/z9aJvGa5kaDZfHA9ZlTIR409ynTb\r BRuiQUgQDGwegLnVzUgKoWnU7yx1CzW7RuGGVbq/9WH/1uh0vMlsbAUjR32FjUTVVxjPg2NrZ4/a\r xnhexkktpSL603YLy//6UmZ9/VCw9Z/DhoVzSmciYA9/FyB+BlsTKMzzzBHGsXbO6Ig0ghrLB7F6\r F9/y1ckdh2Q4VGZ8fpfU73G8Mg8CC2Ewfzx1bMBMvKoLhtS479mS5r5tjfFy59JPGESVbCl0g4co\r Ma/WwvdJsjMA+psfyLkBkZNCaA/3dzwUQfBpqvs6302Wu2+t2/0s6d6zhzRv2UKqVM2UDTl58u57\r 38i9j70vx5xwvdx2x7MyJpQpA6+q8HzeEO2yqd4eGAbE15iIEeTSJAIM1uTNApzDwsROZ5xzu5x0\r yvUy7N7X5cmnXpWrrjxX7rjhHLn1xnPVQE67Zl8BbHcJvKr2FmyO9L2NxE9iNxnIoAH7SNOWsTn+\r o3BMYEsZqeQYFmykTLlUnVSKzgVMvWTbFEjaZsCArsdcDwoT1gjCu1wZGwEgwR5xJTEVXBtMIAVs\r HhDfM42hAFdwGzaFbWo5H3th1Yn/2FIEg7P78YvZP/KctJFWoaYaFXFHxf5RBfuHNaDw53jGQb4u\r NpNi833pX1KvjFHvKkf59ePRjyzUVNa80aq20vKcURH1lVXJX7dIvruqohPny7iPeKuUhFRY5dIr\r yOppP6htB+ZjqgQCvACechjkzf6xYMTzugYQC1RUIHvxZN0mGrnOPkfIIidhLB79ZuQe6GwwiJlf\r P+Dq9Yuow2Z8YZNZefVVoz6nqvrK2rWo9Q0Lt52FbhuEnsnuAOI99WNvO/qfAExkygfX7BET2W4V\r d3BLkbctthlys0oZmU26+dxiDjAO9qVkVNJU7TCVGZ/fqfsAI39jFrxL0hD1vPh93aZt3j/54XLX\r zI9IrQAJxaQUoIMRV5++Xb/nSW5wtK/WDUsgfP3zfn5SWutUAwb/66rqTJo+z1W1Fr11gFNuyNvS\r /IKfpUGDBkGQm2u7fi0ZOLCHjB0zRVVbN9z8hNxy29Pyy4gJUqtaZWnYsI5OJQuMgMfDGAf6/igT\r 2RacT94sMPyH39y1npITz7hdfvrxd0l10saDd1+i7rh3Db1YeuxnQcUeJiHEg+vl5fu4mO0hfO97\r y76xM8Cemgi7xUAGHjxQjjgiGtyVCGWSo1x+c9lqEQnE4gB08igHuok3fHnyTBS67zoBoI66xy3h\r clALMVkPuZEq85ZT9u67vr3y1X3sR4Uazdwqep4HJ1opKbDTbBWy+ObY3OdaJ3ROsAuY/YOZFBnF\r E4GOaoc8Qh7R80jfXibFGzRJaY9qSkHbWs3XVebhyqitcAeuqnYQwPGkyEhMkeB5kCwPkEMHhAXP\r 5JqdpWa7QeiFpFyNJl5n7U4z6UNzlflmFEYISG0fRsW6rVUaYeIo8iA1OeAiKe/am/PDE+oBxELO\r L/O8A437nOHuabOXUoJrNG7SbD69AbUVfYBpcTmENAi2bE6cdiJ8j7sDiPbYF46X4iBH0v8Ulv7x\r mcz+7rF/jIm0O3aoMC8LzAEDOrYls4MQV4Rtr1nH3ssXB/EizH+DBIE00uIQb4Q32yJq11VTfEZk\r 2oC5RAdAicenm9xghNQm3CV9jAEKUy2EmQeo6iQQXNy9+jXJSYU20OCrTHKDzkyVtOn7uU7KB1vm\r fyHFW0tkc1GRNHLM4cZrTpE3X7tbbr/xbDnxhEPkyadfkyJ37KFHX5AHH39XPv/4e1nmiDeEOuqm\r G0VGRrqsWp0l6elpUqOG/zYh1vGMhBxV5114p7zyxlcyeMj5cvi/rnCfU4kcd/wgeeTeS+WNV++U\r fbpHnQfC4F2FJYSJk2bGMASL7dgbMK+ppntJldW0iU+GuWJF2L67mwwkjF4Noh+hJ9muQ6QVKUGw\r xgvzGIH6Y2mVvN1Dc2AFhNkTdg8frR7dNsTTcPuTv26JemKB9Cok2wsqWqVgM7YByu5ugzqqynFl\r Ag1JnY4b8Kbl0yQHF163P3KmO8H/Rr+kkNMrOE6eKAi+JlbUPR5WHxsLYj5beDbxMUXsH+wNTiE4\r sBoqLHTKbp+3dUSPe7VV2P4RjKL1eJJeA+nDPmlMIDVa9pBBj+SpK6V+vG7f4t/fDGp4ZDbqGjGC\r 2qgRvTVMoumA890oc0SEMdZqP0j63/CLjkZRb2RUqulGoguUQQAI1jonaeGpw4iWWyNTLFIHSfew\r O2B8RX2FBAKmf3qHtD7sOi2rm7BDJHNAGPo7dx8Q69nfPixZM7YfsPWfwtzvn1RVWqnYid9bWhXe\r w4alfvrXzEbeoyhsB1kw8hXJaHFwXSb7og0kio2unwLsUrzfdXMD24argI2iIHuFv5774z23fLwI\r +7ADwlgAfalivbbRgaODSkR6sh+0AL79mi37axodHUaWSRYmPvMHfR8vyl2vKl0cWxrse4ruz536\r vqxdu1YaNaorBwzoIhdf6ucQ6dC5rdx1h5cAHrjvKvnq/cekdu2q8ub7P8rBh58nn3w2XH78ZayM\r HuFzWhkwhuOlVVBQKJMnz1LC/uzTb8urb36tEgb2DJYBg8+VTRs3ad3P331Er3PYIb1k8EE9pXb9\r utuVXFqGouCpt0/n1jH1k4O4uB2BWUjBvvv6GC6TRP4MpvoFHTt6h6AGDeI9WncP5lEb76q82wwE\r d1CwenU0UtRQ7Ea/GzZHR5/pyZ6wRIMIXQ+wyDaHSGCR21+YY3p3VyfobJG1Qbf9Tgx/pqtPSa8c\r TCDlpJCqPm6DyHKfxt0jzKwiDQftKbEPduG+6zewhbgRReQ8W7vfWZAjySl4UDjppWyGEu/KmkWY\r 6rTFoofdaG292j9IK49xkp1k3PUMJoCrj/0jHO1NzAewWozq17mRGB8WIzI+rDCypn+t6dmBpTHp\r fOqz6gFjyIobAcJUiDI3zxk/C6NItmMC2FMgJI37niXNB13picr8P7UuI1UznCN1MA0xxlndDqQX\r 1B9FOp+JR6vDr9P8StXbBioPR+QA7aSklXPPKTpT5T8BiPXcH7Ydgf5PYulf75QuhewhVkzGhiay\r aZWPVUBdiOSQXqW2DhDoWMsmfKpMhWM5juHAeEytWFJSrGUYw8wv7pIlY9+T9MDuR/+tVL99hGlA\r 6A1kMVjv+knk23PXYeBE4KpKvK4/ar46B3ornpg6587WLW4/kki0z5sKC+/GPL5vd2TNmjVSsXyq\r XHzOEXL66UdFCHF8NPrAg/vJQQf0lNNOOkiOHjJIXnzlXTfy/1vOuODuCFNgSa/YWZ578WMZdNh5\r 8vZ738lJp94gdz34uowaNcExthK59JIz5ZKLzpCvPnhMXnvlTnng3svloEMHBlfZOcxKkPDRUKsW\r zkWJJbl4TJnio8sZKAIz6DdtWl+aN9/WtKAmhD1EQZCEMpZ+7okEEjS0KX/bIJ7kMlulvDvM6Lec\r eygrVoe9Hvx5FoXu2/H7tkVA1CPH3Tqmvl97ws886lGbgrre6uEknRzHI1LQ+rpyy+bcbCfq++hz\r D1dw/30glN+MAdtuIY0JYj/AXkFKE9qtEsy+5xF7MsbznKDdsO2H31BSXOSkmL80NiSjSn1Vz1Vq\r EBKHXdv20TFHCB9WuPWo94ofMdioIblmRz2PjxYbBxHurYfcFrk1VhlVPVFAP13ZEQVQzY0E8bzC\r doOEQedBxbFyyrcR99xqLftIsSP6RkRgJBCj/A0r1FgOUsvFuk3CLKyeESqbojZmkBGPBLt2BRBp\r P/XxfxfWTvvzH5NCbDDS8tBrpXBjlj732d8+otHn6+aN1WPNDrhEGQVMP62Cj5VQLyv3nsJODEwi\r hiqSGQwBAyEYjjpXuBvQ+XgCoP5ksMQAzsd5Jal31ryfHtcBS/WW/r0DGAcBrda3Ffp9Bkvw4xg0\r IYXkf3O6ZGdnO4YwQHruFzsZU6JodIIIL7viTLnw/OPl2y9ekAfvukpWrPL9zRgDzKVB/VpyzFGH\r aP4oUv0cc/SB8sIT18n9d1+uywP3XiEDB/Xbq6omw6pVux57hPtyGNWrVYnYecKYP3/P50Y3xhGs\r IthtBmJuXXNmLpQe9b2R1FC8NVkKg9Ev+kFDOALVQBxHWuVokEpZCyK0G43ccMxY3Zfdn/TKddxH\r Eg3XL9gYtaEo0XNr5hrRXx6cFNOS2x+Zp8TtJ427HSYHVtQ+E5zn6us6tHhjN6ms2/kcWJFjBiu7\r tfvPqAwj5lZGHPpG/HFURDARNstVa+hG5BXcB4qbYLSOjyPB4O09a+zu+Ju3Zp6UCbyuyABAab+L\r 3tBt3HZZUCskJZd1DCD2neFSbSnXg0spCGJEctqc76UINaa7BQ8bCAxqKkaiCneeqkgc8dGMxiEQ\r /5GS7h0ekGIY5ZJyA4IGGvX2kx+ZinMLzyGM0D3tLiDSs799NNj678L6hWO3L4Xs5u9nZkg91/Uz\r iH31Vn38gRBIvT77u0e0XL6Wj4rm3WAHNOmDd8ZMm6ip7FaSy6ZH+gMgzxvQtEXuuzEbm/UP8+4j\r 9xYek+vcYApEiFPQcth7C9jRDcumatqiBfPmyVpyZLlrhA3jFlQXj4ULl8WkWm/XobWqnliMMbz7\r 9gNy2OA+cuF5x8oF5xwjt9xwjkaJJ6dtm6TRkOsYDZIPHllcf312rHonEcI2D1NBGbDD/BNYuXJb\r ururSHUMFZASP4zdZiCHDeolDQMDzfr1sSH/VZI3ug7iGUdeQYnUrBZrnKVsRvQI6ERWx5XD1SOI\r acNvYKwnRTpnoEKyKPbI9LmuXvnAXTbSgK7447cjmzHwxzeu8EnKFNvUcbt8Nf1jRvIo/An2l7nP\r WTMq81PwAnfUV3CMtHZE748NBC8vtYEExwGJExmJAQyL+MPb8ahRE5WAH3mWqxzVQRtmf3NfJIgQ\r JovUQfZgDKv2kUMw1jvmQdQ4DMHiPmBYOh2xA8RlrSM0a2d7rzBGsKisIADMDWIwdVa9rj7qHVQv\r J/NRecFIkEQMeWu8iiLZAk9B6PfvCcxG89+IRb+9u30pBOzgOSQ6XKlua1Ut4Q3Hu0LyN0O6Mnv3\r 7Ou17rE+KSlZ38WqqT8EgYcDNIYkjOJAFQlDyZo7Rm2OSDiewTiJJeg7OMogZcQGE7rBoSP+SM7k\r aiN6nVxwdtfYEE1TgD3OwPdFKhX2FbtBTNny1aUwP18aNaglgwd2jVHZxAfVGcjmCyDelq7dJpkq\r DVGiW/pDt6jwNWvWKyOx6O/SEG4JIzep5cMMJT/fOyzsbcRH5+8OrI341O67zUC69OwiJ55wsJYn\r /Dk15umsLSwnRQEDAdkbc3UdiaeIYNuXkxLkx9rmWGSTgt+Ify6qQlIkSZrraMaGoqN0Q1DWFalL\r Qh+K67HMgQ7KpJaNOSsKv5cEivFAFWbn+DV/E7dSLWJEd3DXxQ0ZrxeM6JxiXl7xZ5tOmANRLy2R\r ud/couvioi0+A69bUhozwVW0hTJOYqBdPMdAVNXnR4jmjkkKGFwuORYeZcL4iCqHaLAgQVRt2l0Z\r zprZvymzQPXG3BIGCNOmlbM1IZ/pyTGgZznGw6WRZGp3PET3V2rg1WfFgYpsb4HR/dLxbwVb/+8i\r +qY9UDdtWEzAq+s386MG2zCqtD00s1ygwkSFxffCO1EJJJA+2CabtqkcGawxYPEMyTGcoH8A4kBQ\r YaEGYyHzL8A+iIoSd3eP6N1mB9JIIlSu38H1m3Uq2TB42pSzUY45en+1b4ASRwgg4GYHIc1IInB8\r w4aNOnkUU9kmAlJAaZJMadjZWf/C8Sjby5u1t7C9+Ul2FTYRl9ldDLvNQEChI1TFCZhb2ZJNMcQ9\r Lc2PzC15IrCZCH1AoZH3JDW0RcFejvm1X6KrIp25MEmjzaNwB4PjpCfxsH2s/UG/8mW1fyjY9ldD\r zYQ6Cfdg3a8n2OI+ktAkU3hfAVRQaiCnri5WJUnVQJWCzLfMue7VRRwMIdhEbZTEAwwf1nKSNNzv\r TLdKUumjejiI0IE07eEXzIRRMXBtINHU2efIQNXmPj416Nt7cAiuaR5XOrJ0i/1Gy5m0corP5Mrz\r WecI06bVc6VGy746dwSqPLLuImGY9JEfJJmEmMFQwDo3ijVUax5ipg6crwg/gz0Ao/t1s7edTOi/\r CUvGv7FjY/ouPg/iowwluLyHADMo0MBdDOmf6ZoZCgESCwGjYZg6K4/pExyqOMJu94OzB0zEbk8H\r I26bJS/LG4+pwwDFSybY86ISih/keXtIRpV6Xr0V+ebct+zawPV90Qv7S4UKaXLo/lHbRxmt58E8\r GTZnhsFmNzQweVRp6Nq1bYwk0779jvNc7Sz69Yu11/zTyM3dvpS1K7C2TJVl2CMGAixTRnKSD9VL\r KbNViiX2IjYpe6wNJFYmAD7xYWivFRPsAmovcPD5rvjv07nHIsl1vCpBOYygpchKG4hAky86qBEy\r tmpMPSWsbrtgwyrX310hdCy8sX7BOMlZOlkyndRBqhQ/v4eHPQlsEz7/FRvhhij7bVwt8RDDGEzk\r ux3To+4rxAOLRACQ33Dwz+I/3tA4Fz5e7hOvK4BRH1hameyFE3TNh4+LtEkfBEoCT0QGqAGWa1Zv\r 2VtjPoyooN5Cpw7WL5igKi0qwnSQVtCtmwqseivPAC39uBnSAfNN+B/1fwe4Fu9QjQV28FziD5s6\r sWJD75ARlhZylnliawlN+aaQGlIDY7o1VjFgJrxHXNLxmrIxIkyF6ZVNNWZSrM7/42A55rB7qKdV\r GDE3S9bs+RpwWLJNDFCSFP1+p8yeO0UuPvdIGTAodvBkSDSxE7Mb7iywlZibLNJItWqJaMf/DmRk\r JHCD302Y7SM+J9YeMZAhB/eUlkFEetPy6z3zKHEvOqlcTADbhmz/QvzUs1qKdJxw/1G3wh1BT+AP\r bYTP9uW8LK9Dx87AArzB2RHZSHVfiJ7tS0zvqYhpNwy3P3Soimbi9bs0iNGBWf0Sw59Img9F5BrR\r BtUIGWqf3Fwx9+KKqr5yo3PybRXkrAw1E/19MHWM6Da5DMD9UdtzwI3WTrOPHZQ4kZdZHUGSIw+k\r yYc4hGHnVXOMw5JGFm/26iYjICHhM/xzPNyOSoGXl7tJvw5ADE6CM/YKtpbsuSvj/1ZsXOmD78KD\r luKCWGmkbHk/2Ru5y3h/Nu00KHLfD1K6fz8eTMsM8N6DqeAggUNFGHgphpGaXkmWjnvPlcjCELab\r Rt95fvYymfN9bHoZO7pmrR+ANm3pv+tdQevWO3+OucnWrBlkzfhfitQEKVt2F6kpyfoeyI4cxh4x\r kP0G9Jajjx6k5ZXLlsqWrW5km1SiapxQCib1xGIzJQ3u5UfL4Uh1j9AJ4XJ4tyJ2h24FlDNG+vAH\r 4qqzkWif+xCqmTHOb0eqaHW2bH+0jFdKPDzT8sc9fAoTAzMIRhCu5jZsQqpKdZkcxm2rmiwK+6iN\r 0fmU2FGYNwsoLgkCOYN9GrwYGNlJtx6BO8yIE0ZRxjF4y5qsNgh3DOJAoGU8c1jx1xfBPCSMYkOO\r Bg6mT8cdOcxMqjaLVVNZ57OI9Qp1o9mQY5/NnmPr1r2nD/6vwG48n03LTVXrnn1KqsbdqBG8Tf9A\r VYsNMpZAACR4XM5xpLB8ceYenB5MP02/1/cYvq9QmSJ9i4nfQOkDrcRY9901snLlQrnjpgtk3boo\r I9tZVKoUb3/dFvEEl6DC/xdQmnPBrmDBwqh2IIw9YiBgc7HvSMuWLJOqZQuViZSkZerERYYtWseR\r 3hDTsOltjcBtC0i1Vogu4boU1dAS3hcqB/sje8KHDFbfrSwYkRGQAY+RmBND7UdiONyuqOuuqC3A\r w2/bX11v81vddmiXDzAMno07gMExfIYRbEWCpsxTgmdvqkVD5UAFhdszqOiYlFVBXRWP9SGffqKP\r FaE2za03DFONmHpMk2SGgNsnoBkWUy2aF1fhhm2DUvcazKbyfwRxr1/BjJDRA74QiceKYfWx4D3a\r t7tNdgC+A9dUODlqomsD1GPYN2KxbW0YTfynsjbLSx/EfcQbcncGO2O0ttn7atTwksfuxGb8N6J2\r 7W09MXcVGwNHqHjsMQMBm4O+V6E4SyqnoYNn6lK/D1hnsFFLGOFUBzGI60DhTV92jCqUaymmRkzv\r QxljcIQ8cihaR/W5gYunJ4wcYy71kFtuuEkHotPjdjkwgZUnrP7YtjUMMce3YSxxiDnMRun1UV0p\r SqmSUcVPc0uMSQTuZVk6mAihDb/AEHDFBJoePwQ/p4uHjUoBsQelgej9MOLb3JvQmJv/4/Cpfjxw\r aTZPt00r57rX7t97PNMHSCvkP8OLLh4wDqRXjbmKU0nGwPVHJhfz2bMZZIT6XxzIRefh+3r+8kmS\r lpos991+me61KWx3BaXN7REPEikyg+E/gfA8JHn5None7iM+dX1paNZsz/NhlSsXooUh7DEDObBv\r p8gN5uVtUgkko8xmt9ZdivQgctOIaxRRghuDRMQv0T6IXSmEEkTosq7DFV052EQ2KBNmFKF6xGUY\r wmeDpPghvoNnQqH9FOOqBbKIlmIQ2TRpRTcCsBHsKG1/HEqh/xEVlaksFO5BQSQMiVv0MCJP8kSF\r 3ZZrj2hmECbWYc+7+IZNsrFRsEXDb/cG/n9EsYvPKZIJ2wH1lQEjuxnRTQoOg5iN/KzFkpHpBx8E\r ufL+ubxPLeKZjOsAWjag/owF/cL3DTz0EoFgV5OSwfr3j5CCggLJWr9G9uneUUj50aB+6fmdzJU3\r DKa8Dat3LRV7IixfvjoSNwIs1mNvYP26KK0rl5Eu69ZvkHnzoi7AY/+MVVnvCPvEpYKfPmO+LFkS\r nYJhb2JxKe3uMQM54NADNOQfzJnjRjKuf1RNyY/07QrQq4CamWtmxEXTQefwCF6u1nLlHX4XVt8M\r o3TcyEk7OjvuuNuM2mNij0XSOOj1QkvMdhQq5utu6vh9kYLu98UwYn9tggoJ98Ui8nG4laUvKY2B\r 2IyP6+b9HmnapC9FSDUXRXjDl00SMcAomOMdmLG1SoOOOl+6gXlBEsGio0kt/k/Bscig9H8H9tYy\r AsnDPOzMnhWGfUswdTLvxrx+h83u3Rmj590zz70BRkEqdlOFFhdujAS7AmxsgCDfKIMiQ2+gOnUX\r 0+u5fkw6ExxhbMK0WbNmub68RaWP3Lz8hF5WxHWEEQ7OAxMmTJP+/bqpagpvIjLubg9Erhu25wpr\r nkk2o2CHDhbfsnOomllZli6NEubOnX1apJ2FuS+bizK2ofiYlNJUT7sKmHCiedH32ldlNo/6yatV\r AkkJrOibHH+IiV50u4lu3ga+eiwS7QvvVGIXruTL4b8gQqRjVw6+ZOlKQOSYKyQajQHqRFU2bEWl\r Bp1XpFRordA6DqXsNqTE5ZSKhSORQYdSLyy3Lu9E/a3rZ2uzpj7ctNZnW/Xw9ZEcbM4OQ5VGPpgK\r 9QSLGd7tFjMyo7ps5kwxwzmwUWnZCrFeLBuWxM7eFjtedfeIGs0usLdhjPH/NezE8yLvFbC0MQbe\r E+n48bAyN+1Gfc9w0gmZBJZH+gzeVXwhGwMjfGrA6GMYkbuP3GASN9RaSKTEgoQdNsgbt37BWO1P\r 8QiPdwhuhVmteO1ATZhYtmyqXHLF6VLeEeq///YeUmHMnr1ImUY844jHmjXr1KUXKWVHdXd0HNAW\r i0W1M/Ph9s7jNyaSkMCcuYslzf3OnYFdI34+kF69ol5vdp2//op1cNldbN5cnNCWsle+qsMP6hlJ\r KUBaE/Lw49FjSIl7MH60s23Pj+6JOxbZjN1PVDWIGgIdgipxLQQIH4zWSMXoGz4hKPu4lDgExzat\r iRJiTQsSEO/o9LzWIGsrB4hshvdHy1lIB267xeB/+x3AHWaKXaDZgR2IKQkjXvoo3LxZtpb1hmrc\r fy1dezgbL9HvyakZwvSzBJH5+UYgEpX1d+Vl+RGNMQOa5k4r1W6pU/2CDcumaRyMGdFxmzYVRZgw\r gIq1W2hUMwi7ioJoQOfeR4zK7v8QSFUSm9wzitw1C5UZFGSvjMRULRr1htpKUFfxXXE+sT6VG3TQ\r vpJrg4PyVTW9e5iJWLwJHlmW1YDcWSaZFGQvd5JFH2Eedo6zGIgPsS+Ae9n08dFOElioSQ/37dFx\r u8F/a9f6frQ9xmB5psI5seIBowrDtxXfg2MRzg011zGBRHOy7wxaKP0M04Odh2XjLW3Sp72FRLm6\r 9soVe+/fW4491rvz5uTkSGGhkzBCz31ryfYfjD8aX4dt2xcqR1buXwxRsLrAlSOb4f2JQWZZ8yIx\r F1qwbVBiLGzUFsm7VQqIQt8GcbcVu+m3TOUA2GP2i1R89h1s20AkOoA9U8L7rWCRVyv5FNq/aTns\r QmlODKgZCPAzdRYfOwxEZ5xzx0g7YiCYkOA/5viwPFbVW/RWd1CIEs/NjKQ26rVRJ5KLdQ1NseHA\r vNygSjBnBchfH3h+7SWEMx//tyKlQnmp2+WIYGvvQFOQBPOrZAR2K2aSBLxX3hnvg3eKmzfvrWKd\r lvp+1bkkcH9GbbV23hjJX7dU+wUMhXcZDkpkUAHCTIW5dQzpVRxTcoM+3M/D8UfW37kPGAkqrFWr\r Vklu7hr5+sPH9RgwFUqYSdhIu7SRPahePVOlA1Baeg/OLyrarG2zsM2sg23aJHAcCNJ6JML28k6F\r 7xF1GpqZosDza29h5nZSxu8pWofmMzHsta/KHtvKNWtl2YoVbvQb2Cccsjf4zLGGGIlhB4i1EcQh\r KWhnO1U45g+HKwVlXfFnaxCJTTlcLw5xh4iPiK/N3OdRRI9WadRNdfzk19oW0XpZOiMhqT32cyOx\r bT01+KiRJjJde3bWlpXjJPvXu7WMi2N6WqqqEDFmE/VORRgItidGhyUhbzg+aEs7Aaq3DOwR6ZW0\r bMTAEhGSkA+ipIwh7scv/PVVjZC3USrEyaLMgZVhOtXKy/yaQUqTzCZd3TGfytuy8GZkRg2pewMQ\r 5rKV/zkby95A8wMvkAo1dz1IbmewaupP0rDXiYFEEc2fBnIX/amK8mymEoYAuvdau9NgdcdeO+s3\r WTvnd32X9J3V035SjyuDdQH6yYYgHghVVY2AQSClmuSbvcQn5LR5/MNMhDLSEDaQ9dO+lnnzfPDj\r gIP6Sp8+XZSo44o7JphKNhGo8+BDrwZbUXz08Q+6DjOe0gCRN0JPHMiMGdumliEJYhi0yz3uCEgK\r kyb7LNV4euEQEDs/e+nMxxBmQiZ5GFo5At+kiVcl/xZIWrbeEywNDOh16vxDKiyAa7Z1ppyNm2Ie\r RUrIwwdEkx7GIo4eeYR2JjwegGPbZlsNznArszNvD6qmCddz5ajfOwdiF2wk5rpouaX8sW0B08Q+\r Yikaqjb1iQoTQQ3SwURS8bAEi+sXjZet2fNk85SlZvHeAADEpUlEQVSXZPXw+2XGn19Katkymsqk\r sHizFDtCgI0hm5kNHciOmuakDSQK7Bs6M2EAPl4kBJhIdHKuCmpwZz4QRpmMUEGlBh01sR0w6QMg\r DfkgSv+zTD0FozE1CMzHmEZWrjQ1GwhzPCjciRsWeVVFeHKivQEIc4P9jg+2/juRXtGCWXcRpfQj\r QDYBsM5JkLwjmLh6HYbO2bB2eXlLM2POEQQF4mmF+isnsF016nO69gVTQYYlDe0jbgGk2wH0qfAc\r IWTzDTMNL6UmaV9kEIMEtP67qyQvL9d9r4UR6YOpIyCcEOrvvg8SiYYQmZHvz78TZtmF0HKuEd94\r 24EhEYMpjW6EGQ2Iz1KbCNDEzp2iwbJ4fBl2hrmVBjsXG4XZUZhhEeyNhIrFwYRUFeKi0MFeYyCH\r D+olTZpFP4AYXhr3FsKqp20z9O4OfPsFGgToy6T6ML2uETwPfzz811aWCj7YVHj/eC8HhfdXru8N\r VsywZohnjFafNTmnLO8UYI6E+LgYzcLrYMZ7nQskfFG3kZxWQcpVqi5rPr9AFn1zu/z+1g0y9a8f\r ZdPK6U468e0xiKQ743m03kk0WxZ8rxJI4aa1OhqkSWY+BHZNc7nMYLa54JoQ9nhXzJwlU3QuE1NJ\r oc8mYWK1Fr1i5nGo1+1oXZvUUavDQduMrzzRIkdWf5VegE3QxTzYexsVq/uP6v8SyGcGVk37Rdd4\r WdXucLAsGv22zigJyOeGhEFGAVNLMhir3/04HQjYoIKU65oLLRhMsJ7+2VDtC7aEQd+xpKkGGIVJ\r JKRop6vZ7ISZldJl5arlkppaRr56/1GVPiDSpnsPE+wwzC0XNVV8HzOEz40fuRuoQ3xGOP/V3kyA\r mKitWMYR87EnBPO6G0zaSARjJKX91l3B1One3vuP2UBAtz49InaQeBQWeUIezsVjiJUadvwAPVy9\r UqpabAHMA4IJYrL1JjjPGE08IOCRYMW486KJE5Mi0keleu31o4itHHtidB50x1QWuk4dOswcIJFk\r ig7kpcqaa7YHf72U2W/K9OcOkbVrVsvqNVmyKeRmmJKeLEmbt0S8sYrd6AOHBuwZfPyAZIqM+NYF\r kgmjUj7qnGVT1Q5io0qIAYyX7fBIs7ojGhhZmSCKwDDHBYMjIlPeu06mfwpBiY4ywbRPPKEyiQVi\r RRkClDXH30duMFPgxpXbetnsLaDGyqhVegzB/ySaH3zZXrd/kO+q5SFXablWu/11Pf+X5x2z3zcy\r xS3vwTzqsuaQLbdfhOkTK2Lqqhlf3KNrkz4AfYT6M7+8JzLQYE1/4Rj9Kj5gkIGL74PRduitrQ+/\r Vaa/eYbkbNwoTIo28OAoMzL7BWjRIuo+DCDAGelpEUI8cAcEs7SRvu0nPiMrK7vUemHMnrNImQ4u\r roBztnceNINswWFmFi7n5Sf2+gwDQ72hYcM6kfPD7QCb92TR4j23Ja50kpJKTwncjPcaAwHqPupp\r lyewATbmbJIqqYUxkd2RmJBt1E7bQbTJAH684RMoemi0rdZLikRdb5t3KxYQ0bSKoehpTWECAS89\r 4AgwE+GugAl0/DzoSCTjnPSC0Tj8o5LUAwv7B0tm4+4R28x3V2XKd1dWkakzZknW2nWyMbdQXafD\r ZzMPSIl7pcyPYD6ydO75Xw9TtQW2E9K3txpyW1zwpGd+bQJ1lTFNPG3qdTs2UGNFP2jUcUxXi+eW\r qi4ChlCv2zHSoNfJug3Yx/tF0rB9BogUkseqv78P9niEU47nZycOXtpdoMZqNeiGYOu/C8TL7G37\r x6xvHpLUcn7wZGzeggkX//6OtBh0mTIEvKkAUw/zrsJ9ygYDOElQt+Wh1+naGEa7o4c56ebHyCDD\r Mw9L2R6V0G2bfhbNOOCvxDwyMu99N7peIjWrV5GrLjlV9wPUTaaCAvXqRmcvBfc/8LIeg4AmIuC2\r H8SvwzACHG4jUT1g+1sGzIw4k50FNhUGdmHYtctlxGZmSAS7djzDiAfznoBGjsnsKZat8A5GzYIJ\r BMPYqwwkOaWMFFtPDXkj5BW4EcQWYj+CrulWiaa3jUG4F8cgeoCIWLajqQ92AXHtF26MioZhhNNy\r lAabOyN70QRdEt16mdTYzoFnVjxjQ520JX+jMpGstwbJD/+uJ6Pu20++vzoaT0Hb6mzl3lzZjBSV\r Ogz333O1nHnmMZIaPHrqlrh6WVlZkv/jlaoyq9XhEN0fVusZAbHRo7nyblg8WZaN/1g/fn8skCAc\r M7GyoWDjalf3E1nyxzvBHs8karWPVV2hsmp3zFA9Vr28zDepBIM9x6o7plKU650uLN5gb4JRftXW\r u8b4/2k0GXjWXpc+wpj+yTD3zG93kuAwJ+lcrvuY4Aub39pp3+cjCfIeSMMPo7f3Nc9JK2wrQ4Ax\r uHpIJS0OuVqZyHQnhdIP2h4VlTqbDDhf16Bul6NlyRjfH5Busd8xBUG9rsdEbCElq8ZK1qzhMn/+\r Ag2sO2hANzlkcOxgA6IZZgRhEFwYJqbxhJUgPzuXNUv8XOIAg3bTOAIZ35aB/dgYEt1Pafg1aOuv\r iTMi04Hb+eaJ1b//jtVlVtckC7PnTJzkXeBte8ZMb/yfkiBuZlcxfZqXVhOlRNmrDGTwgdF4kDDg\r JXklaXG2CBBLasOpQ3YHqeWjUao2FwFgCk2P8PVC5YiLZ1JE+iDYEYNixMAbD3c608AajInw8YUT\r ERqYVQ2gwsp0kgjrcJZeQ0pGRRn37DEyYdKkMA+OoEHt2o6wpkhaRqo88+gN8vknz8jff34k0yd8\r Ktdc4whR3Rry1jsPypbgJ6U4ho5hMXfTRsdsKnpm4BYkIAMfdWEwsRAwl+aiPKZCHSAVareUrLl/\r aOBZzYB5qAThjlkKb/Tn7Y4ZJv1vGq7EiON4jJnksXa29+SBiCF5UGdtrjSFYeAVVqv9gaFAQ//D\r w+k29hYY5Tfsfkaw9T+PtCpVpM2QW/a69BHG6qk/BSVR+wfP3uwY2SvnZyCJ8L4sPY1NJ4ztw09v\r 299Jgytk0ltXuEHCp+oWzPnKeBxjYHZCizZfMOIF3YeGAUcIm/+jRuuBEWlkxhfD3GDGS7nzPjxP\r 33b1alXk6ktPlLPOPj6GMEMQjZAnIugHDPQqYewgpRF8w+bAGGxG4TCYlpYobgIVace3FUufwsBg\r H75e9JzEMMLeZZ82UiVu6ttYT6ztw+ouWODn3zEbxz6Besm2jRnuTubieBBEWNqT2KsMpFtvbweJ\r TxOVUras+ElWt6WIKTEzEDrCHZMgcdewORSPQTCbMaSwL3pCuM6uEeTBfUNoy5RN325yP/uJMBGz\r gWAwLM1FGQM66c1VhZWUpOswRg5tIiNvbyTjnztWUssmS3JqsmMSTsJw5bLpqbpsLvhbzjr3aPnu\r yxfkm8+fl6bNm6qxjPkRGjXzTPLTz3+W6jWqybzpX+k9woSS3LJ69WrZNMZ7tbQZcpsaMtcGU+Pi\r fVW/x78iakebEMpGnguGv6AMNXeNf44WMMZkURAKCJJG5ruLUQZb3PO35H1VGnZUVRaSR7gPUJd9\r WbNGKVNZ+ufHun/9vO0Tgj0Fo/3GA04Ptv5n0eaIof8I84BRI3UAmDOY/slQtX/ALEzqAEgis79+\r QBr1OUOmf3aXq7OfqiiBTgjm0HDfk6TzqY87RuLzRKkai3ZcH8F5RN3AXfdhm6Vmm4Faz1Sfa2YO\r j8RDmfSx5vV+snTpck0AmrVunVxz3fnyznvf6LHSEG8UJhIchjNqtB/AxUsF3bv7uWcg7hnp6dsc\r NzRqVFdWr1kXQ3B3JBEwuieeo7Q2wwjXyc7OiTAb9pOKZXvMJwyrZ88hP0g5b+lZ7Dp704j+40/e\r TpkIe5WBAMgDsQimyQIZaalSITWxO1lynOfSDlVbcdAo8FLgo8K3G0kSwNUJpBDmQ4cYlq8Zncpy\r A95QCYA+l/pIHykZVaSIkbsbTevEUAmuig0EyYN5xTcvHSVT3jhHfrqxoVuiomEZ9+wsoy6R5WN+\r e09ys//SBdAh6CQ85y5dCHqMxeOPeB3/ux/9KBdfdEKEXOdtytN4HAIlVQJx9xz2ApvxmRsVOgZA\r 2gsIgAFPnLaOmEBwUEeBTcEERUpkSkqUyNTtfISOVKd9OlQN6XW6HqUzFUKkshdP8RJLIHkA6m5a\r s0Dadus/H8IWRtWW+zmmEg1c3NuAYLc98nap231wsOd/Bv+E4TweMJK2jpGgxmqrDNwzEphL9oxv\r 1jc74CLdl9msp9o/6L+8K1AhcMtGVWVgigFAn8ADr1inZvaMAskUry8CUud8/2jUUB58CnjpVQ9y\r XFWrVd+NohdI/qZcPfzOy3fLhx99Ly+89JEeNxx4gPcSrF+/tvwxZnIMIYaYPvTwa7qmXviYYfiI\r qOdj/fq1tG6ievOc9FEzSOPOcUbwI0cmjirnOEbqjh1aanoU2uzatV1wNDHsmqxnzV4oW0KJJ4my\r D0/+tj1YO0uCHFo4EID4uUvC19tT5OYXSOPG8Wn4PfY6AxlySC9pEOdehp4SNUWqI7KGSPrwPUA8\r iQ4TROIdAPNzhJlBIqRX9sZ2XH9RYWkEtjsPBrE94LlE/ezFf0WyCuP3nkiFhdqKeZ5/vqWFTHzl\r ZPn7u6djUmcXFfjngQcKjKNg4yT5/qsX5fMvvPulgQn/6bAwEvLcmK7TMPSOZ7TT3HD9uU4aPFg6\r wmSCt0yGgL8f6SnVa9WTTCc1bQmuz8ePAR1sXDEros5i//oF472u2xEV85iDmUBsYAYwD94DDIFt\r U22wbaCuzcSYVqmGI1Be8lj42+uqxjIm1+5YbCMjdTrb9CC31ub8aJr4vQmYSOeTn5Ia7fcN9vxn\r 0XzQJdLykCv/MdVV7Y6H6Dp7YVS1ivoqe9FkHSSAOaM+Ul9pmAwqSN6ZvQu87Br1OU2N57xf4kE4\r zrs120f/G36WhSNfiqivkFaJOyElDjEdjft7ewgDJgNehTO/GCrz3j9P1mevlnLlM+T0kw9zDKWm\r HH/cwZK7IVqXfm6R1SQd/P6HbQcVNjcIdfc/8Gwth4H6he+BZVQgpcSDc/Fc7NWrs9ZjOz4pYTzw\r SAoTZwzp8aqpMGiTBbRq2VjTjtg26q20sokCjLeFXdOy+Jpq7O+pcyLtmVF/UmAX2RsozRi/1xlI\r 9z49ZMiQA7QMOYfP4hWUvyVVdaWG4vzY6HRDPFPYMazLu3PLJEv56l6Pa0FtOwO8T4DN2OeN8zsH\r mEeVhl6FVaVRV6ms0se2GH57a5n61hmqkkI9xTqsnmJBynj+6WHKPOgMdJZ4EZTZxcJ64Tatm8q0\r wMgFht52sa7tOJPgP/LozVreUrhZ1qxcKtNfOVG9sMJ2ECSQas17qcdVWqVaYpM8kZbEmAKAcDCS\r hLmsmOzVDSaxwExqtx+ko9Oc5TN1JOvVJf0lrXItZQ6V6rV1BGtojDTCyJgy+6Z97EfJlgYefbtN\r ybq3AfHufs7bUq3NjqOI9yZaHXattBx89T/GPGAI1Zr3VDfeqs09gzT11bIJn0mDXifp+0EdhSRC\r gCeSCMwFZs9SsVYLZSKov1BP/XrfAco4eO8N9ztF26QvND/o8kgWA/oBTATQjxaOfEHLq/7+1kkr\r rh+06i+pKWWkfMECWTBrrNSpVUuaN60nZ5x5jNb77POfYyLJ6efnnn1MhGjGfwukNunmRv52/PZb\r vTQVBqocvoVhbmB1ysmHy5/jtp2fhpkImQfkscffjHw367NzXLvbfsscZ7H8W1ybBeP4tOnR7zAe\r 0DUj9naOwWsVdmxATwR7Jh3at4i0b27Fa7P2PBh3xYo1eu/xz96w1xkIwMvA0UhH7ILmt5ZIWklu\r ZM4BYAFGEKuCkAGXeb53Fp514IXl9f+0ZUirGGv8xlC8PeSsmO5GZtH8+iZ9oL4q2ph4pjzceKPM\r o0vEA8ursFxnu7OjjLyjnYwY1laN3oyWbMRUo3I1ZRSmnjIV1RmnHxnpxKxx+bNtgwU6MWKi0zRo\r EOt8wMdiHTQtraxcdNGJ8ucfb+t28eYSWTxjksjUV3TbABGY9dW9smj0GzIddVZg5DSCAOHAiI50\r pqopRzzIyUXQo0kfJFBESiFtO0wZ2wdpSgwwDiQPYxyct3Tcp6rGslgRsGbmb04qrKkGXEACxn8K\r EPGe53/oRsunBXv+WbQ45AppduBF/xjzCAM33jZDbgzUWLHqq9V/vLq+9eFe3VmuRmNlGssdczGG\r v9F9L0gsMBH6QJ3Oh0ndrj44dPHvb7t3SIxHRd0OJ8H0NpD+2ofaHOmlWs104Jbln54vE545QpYv\r X6LM4/Xnb5NxE6LZYonmPujAaByUqazuve9F6dZtWxXRBx95F3C+jzBBNoT33x4MrK679ixdh4EN\r 4p13v5aeQfQ25xx1pB8EJ8K48dPklVc/DbY8Dh3cdxsX4zD6uTbDRDh8b6xLU5eFEaYD1la4Ddu3\r arW33SbyNttVTJo0Q+lsaQP7f4aBpGBTSHJEqERjFViKtqZE0iQAtRckQFoQDb6zyA/mGEdsNtUL\r 6qvCOKK/fcnGs6KNy/1c4wZUVMwJUjaOGRnCXli/3dtDpr5zoUx563wZedc+Muah6IgC6QKQZgTj\r N4xjydKf5ZfhY2M6BbBt6xgH7L9vpGwg0An88cckOXhQb/ltVDT/ltWNb7dD147y688varnY/dw5\r s+bKihGP6rb+fMfkUWMZM44yjqjkkVo+MyKdqUqruEg6nnCfMgRvBznc1e8nvz9xrMz/5QWVAsl0\r 7KUL3w5SBjA11u+PHxtRY7GvxwWvydSPbtM64cR0pBf/pwAxxxW148n3S0q5Hfvi7w4qN2klnU97\r TFocfPk/yjzCxnODZ9zejdcYycRPH8hsfcQNum/puI+VadjT1jacFEmMDmv6AFLl8gmfaj+gXK/7\r sbJi4pcaTNp04AW63xvV+8u8n58OWvJY/PubOkBZNWeMBrbWqF5NXnzieuk9oJc8eN81Ogii377+\r xucxc3tsyNkkTz39juznBkpM7BQ/Cr7rDu+STEZcBk2JYIMpvgfK8d8FYB8MhnrR7ycxQe/UqZVc\r e82Zymw4z9ojD5Wduz2Er085HFm+I4TPtd8EbM1gEbRr61X2pUkNu4JpU71UNTDwdovHP8JAjjmi\r vxqsgunSneTBDIVlpAzuQDtA4S5IICCjqid4Wwo3RUZEEbjL5a7xDyAtNMtZabBrYxi3r4m5MtLj\r XHmT8lfL+KcPlOkfXC4zP7lCpr13iWOY/hiSBgsw1RRAwsCmYS+eBT2o5awxWCe0js86/uOgY2Dk\r wwOFzKDxOWrsg8QHnrrWwXr221cGH9pPHH/Xn5eTs1HmPBQY4pPKqBoLAmD5r4AlV4Q4mD4doNLC\r jRfAPCibJAJgGFUadZIFI1+WlY4QcYxzYBIDbh6uRM2YCefse8KNq2Z8PNQxHXO5dtd2x41x2Gx4\r /xQg6q0P+7cMunuqNOzzr2DvniO9WjXpcNI90vvyb6Slkz7+E5IHMEYSZhomfcz75MYNzNNBnjcc\r HloOvkaN7LwzjjcdcK5KHjCKOT88KSPvdcR/6o+6re24Y8sc02E7HKvTuN85snr6LzqYow8BYopS\r VwyXpR+eJYvnTlevvbdfHioDDx4gd7h+fd0NDyvxpo/GS9KHuMERqhn6MkkI7dsA9g2h0i1xA1Vj\r AGGQeoP+//wLH+gxk0LiwTFrL8pkEtOqb78bFRyPws4tDXbMVEzA7vWtt7/S9c6osOyc+PZsPT6w\r fZh6bW9gpZNmeBLQmkT4RxhIh66d5K1X7pBmTesrsWJuqfSs8ZJWJmrk9ios/5LCMQgRJH5/DvEH\r gm1HwcPzq5sNpHwNz40LNxB4Ezo3NLoFSB+onpR5OOSu9cbpzct+l8mvnyVjnzhExjx+kIx57AAZ\r /9qpEaM3KimYBHYNFqSMErewjldP4alhL986A/7k8aBD0NnpzLfdelHCjs/H9ttvXvJYmmAUw3Vw\r YeQDuvOu54K9IrVrVJF69WrqO4HnzV+4UGbc20Kq1YsGE8JEAHN8qFty+LG5JVxHpYsQ84CZtIvk\r WJoiTfqfo6oQA4zI7B/GTKY6wpbRfFAtuwzG9DFPn6JSrCVXBDnLYiXEfwIQ+PbH3qvSQqdTHlIG\r sDuo2amPdDr1Edn/lj+lzeE3/kcYh5fqSpc+2hx1q+6b9et7let1P0Zmf/uo9gGOk0EZ9RWYP+Il\r HTTBRIjdImcW88Pw8rGXgIgxfcZw3UZiXfjry8KUAQw+UGGB1dN/kmXLl6sbeeNGdeSBOy+RAQf5\r 2JDhro+uXzM68k0c5gY3Bhs0kT+K49hHwiCoLXvDRo3p4FuKH2SBn38Zo+sLzv+XtsFi310Y4XPt\r W8NZJRFOOvHQoORRqVLpc7vHg28x7DnJvey7nel1S4MxDNoLr2G2wIIHwwxrdzF6VOLAaMM/wkBA\r z769VBxFfUXkPvMaVy+f7D2P3L7wZE1h76ltpIidhTKEre5DWCB5Qf6e3NCkTztCxbptJG/dEimf\r M0kmvXG2zPjwapn56U0yf9yXEemiSmbViERh0gWMggW1lHlO5QfleOjUmu5ls9hHk6hD04k5zvqb\r b3+Ve+71qicD55xw0rWRc+vXi42Wx5DOsWeefU/XYZfBU047Sq5zInjtujUl1f2ugvxCmTdvvsx4\r vK9UrNdWCcGCkS/p2n54RJ3liAYMgAXgfQPDCDMPYyZLxr6vhnDKYOWU73WEa8Z49jMiNmaCUben\r k0LGvXCO7jPJo3bnQyO2kMg87P8wIPZIC60OvUYZAMyEpfngsyWtWjQrQBgV6tWXtsfeFKnb7czX\r pdXgq/5jEsesbx6JTF2LCtCYho+98dIH9pD5TvrAI5LjKyd/I20CZl8hmPvGJJc6nQ7VTARIGSwr\r p3yrDKNNsK3qKvcuTdLwtg+/XaleO3WTBtljn9VcVpUrlZP9+3WRdTnRfE8jfh0vk51ksWLlWvnV\r DYZSnTQRBv2fCZrow0YkDXghHTlkf1Vf2bcSD1RfwL61RAifW7Fi+Ujd0aNLn8CK+7FvLydnU8x2\r Itjc5dR55NHXt2F2b7/zdVDaPmyq3fhnYbB7OPoob78prd6u4K+JMyOuwonwjzEQsE/H5hpUCBnK\r Wp/rRu25siXwGw/Pfx0Nvtu6/ey8NkSNgd8ZzodVTj2xYiuXD9J1xCOtaKVUmPmMFE15TfL/el6m\r fvu0bCnwLrnoFM1TCuFpU9Y6KcmLdT+GYcAs6BR0PvS2Vo4HL5hjLNbpEtWzfaxRT21OMOnMxRee\r oMdpI9FIY+ABZ8nFF524zTHqv/fpLzL4kD5SyzERnlIZ92fR/IWy/oeh0rBVVw0UZG6I+b88q+co\r cYD4B1KHMQH02onUWBNeu0ij1/3sg0gaI2Tml/fpMQiPT63hXXYBBOuvVy+SjBaDauWt9pIfUsjw\r u3wwWgXH3EFy2XQ3KIi+5/8EjJmwdDn1ZTnglnERJhFe+l07Utofc3ek7n+KcRiIXWIiqBnu2Zqd\r Kkb6OPIWZejTf3m9cpMB5+jxVdN+1uO8D4YYlAHbzHm+3xWfaB0YhzGS6Z/dEdk2IJEakDwsEHXS\r nY1lzZo1UrdODXnt2Zul/8BeEWJN3z3heC+ZnnjCYO2n9E3DHU5qNkL7w4+JpzbgOOorJNX474jt\r li09U7RvLdy+gX12LvOH77uvj5ZPpFK66+7nta7Vtza5j6++jj6DeDz22BsRaQgnmXPPOdYxDa+6\r 2pSbt80AsDScccZRurZvOry2e+J5EDOD/TDR791VbHaj/4MOip0/Jox/lIEUJ/nROgNZNaZvNENo\r mLjHEno/5t0R3DnBaWb01XxYsU0pSFJXdku2FC71RrEyBVlSZsKjMv2Nc2XmB+fLpE9vkT8njpfl\r q1fI2g3rZN2GbBVmWDD4FRVsUY+Rn79/TvKL/tYlXjVFB7IPY8gRA7Vc2svjGAsv3BgJwUjxsM7J\r Ym2HYZ0HfSdRtPaxAc5hdMcMa4xCWKyDgSuvOE3Ou+BEZSKtWjfRdwPmz5vtmMZzkjvuJanSOCrC\r R9RVIUKhaizHELTsGEFYjYXKihiHNbN+C6SMAdLv39/rMRwpuBxSBvX/ePIEJVwwmeyFk2SfY69f\r MtIxDrOPwGTwyFoxybsM4921JdGc+v8hhBlKePlPM4wwpn1yR4T4wwiaDjx3G+mj/fF3yuwP/521\r 1X1hxlQiTCCQNE36sG8QFVY4X5tKhe7D4DxcuE0SRUK1pV7Xo2XJe6fL2FvryuIlSyW1bKq899od\r 7r1XiskkS/897thBUqGCt989cN/VujbcdsuF2m/pyziLhL+BlU5iAezLWrdBR/jUC4Pt2bMX6jqe\r 8IeBhE8dW7whOjEVuuXmC4KSZ1BmAOc+Dj/M99dEuM0dt/xXBOTxHEw6OOxQzktAuOIQvvfWrX1f\r szZgSEYPTF395FPe63JPMMVJhzwJS5OSCMlDb7vY97J/AATjtGvTVH4f9Zd27JycXKlfNVkK0+pI\r SloF99y2qPSBxxST0DCSID4Bzyc6NdssicuO97mFcv66xVJuy1opm1FR52CuWGajVEgukNm/vSYb\r 5v8iKx2x27hymqz960tZM/0XR7B9B0zC1zhAcX6xI0zuLt27xNM2NTlFjdxFhZOlQkaqTJq2IPLC\r wli0aLmODOwFZ2dvlFmzFuj+RNGbH3z4XcTIxXE8Tw4N6X4B+2mPY1wTI+DXboQTvr51cZgPLods\r h6/H+c2bNdB9HMNgaSOYjz76QWrXqibtO7SUCROmy/4Du0v2xjxZ7z7G7OVzpcSNOgqWjZcN836X\r ik16SfnqjWXRqNfVjbdGm4GqB0dnDmNgP2XqkD5m9d/fS9P9L1RmMe0TT4yIhEatgoqwzeHM854k\r i0a/JY37niFT3v13QPySNHlf62Pvqrx45AsFGTWbp7Q/9nb58/mzpEm/Mx0hK6uqzrQKVV05VtXx\r fxnTPkatdIt+D16yu11T5P/1+qXS7/rvlCkgMbbrPmDxt/ceVQcvMJjCuOdOD5wZvK2C83hnLLyv\r Rb+/LZPeuly6n/eqnj/DMZP1C/9S5jHy3oH6PlBXma3Dq7KSZNPXF0h+Xq6sXL1aKlYoL8cfub9c\r dtXZ2peB9WGC/tq2aabxF2++9aVGZ9sxBkOQ1DNdf7WBUbjvw3SYmRBvxMGH9JX77n8p5jjgvDKO\r aGevz5HTTxui30H4+zCQHh5PL9RsBCrmBjEUieoS1EvKEBgN3zdpTxLVSwTq2/ds5xKjhQ2F39I+\r sF+UhjfcuVwXtG/n7bp2bdqAyHNvRgfQhCRKfrgreMnRnV/cQPQM9/w6d46GOITxj0ogcNrBB/VQ\r 5mE8ds6caOQ08QIgHL9ROW2zJOXMl2Sd2dshxJxTpMjt3yxlpUDSSjZIStE62TL/K9k872vJWThG\r sia+I0nrp+vczfP++EjdiDF2k+a8TGFxZKRdplyqLmGULZ8qyenJQnbbH75/Rfbt1UXy8ibK2298\r Jkcfe4hcdOEJQc1Y8FIh1jaCIUIVicBedjz+dfwhkXqs6VAEMMWDEQUjGz4EElSGJ7kBGPlIZ0Ab\r TLFpIxCD2UEYfbEe7jqCoW+fLlqf/bgk1mtQV047dYgGXTHDYm4ezCTb/f48WfqOTzyoKiy32PwQ\r MA+Aeot0J6iwlv31uaq18MJRY7obAfe46C1NwFe7wyA9B4mCkSvMwKSQEXcPDAgY9pWRss95b6Rb\r QCHR0BBJvLPm//CU7vv/EYsyScnKPFIDN/mfh+0nR7/oXb1NjTXijWENSe1D+dd7DnCMwD9fm1HT\r pA8r1+5wSKSOIbNpD1Vf8c4NNgXAlDubyuxXj5OFCxfIkiXLHBGrK0ce1lf69O+h9ZjC1aQICOh9\r 9/h5SuiDHTq0iJEwvnSDJfovffSmG88L9kZxznm3qdoL8O2Fzw3jtFN9mhjqPPBgbNwTYD/LpZec\r rPeBsZ11dHgWC2wuAEbC76Eu9xiW/uPBwA2gqrr5Jh+Z768h8t773+rafsv2cPTRPp8Z9wvsmraO\r jzq3XFh7goIg6eSZZ/r4n3igWv9HGQjo3mdf+eX7ZyOvpEKFDFk96SNZPfEDWT9nuKyc8K6sm/WT\r ZP39nqyd8q4smPCprJzzm6yc+LasnvCqpC39WtKXfCVJ8z+XvBlumfKebJzygawa944s+PUFWThz\r iqxyo/A1Wetk3fq1biS9QfI3F0muW9SuvsXxIMfBCoqZIZyPzYn5eZsjy/iRb0XUUdgzzNX27dfu\r kqULl8oppx8lTzz5dsK5keNhHZIRgJXjYalJyKVjx/snmKnMZv+CwRAL0i/OjQ73xQb1a2seHdPb\r hmGddJ99Wut1uIbNEWDHAHEkfAQN69WQG288X2rXriYpjqhgnNy6pUR12Msf7xJRYzHnuSF39QJl\r AORHIpMujATM/elpqdPRfxSLx7wnS9xo1qu3fGQ6hAqnhbAthP0Dbh4hI+87WCrWbi51W3XPmu4Y\r R9MBZ+sxPLDaOIlk5qd3absga+7YoPR/EzDWdu6ZGFoMujRgBJ7wf3l5Q3XhzcyQ2aixhjy7Wo9v\r KS7Ud4C9hEFWmHFYee5PT0USKprxvE6nwW6wV1NaH3FTVP3lUPTTVZKTvV7Wr8+WtPSykuoGZ+ed\r eZRMnblQznLEhwHO9GBWO/Da658JU61C+GfOnC8T/ooGE4IjAnUQNIMo8csu9ZHvhpdfvMP36aAf\r xxPwu+95Qdu2OixXXB6dY8TAfr4jzn/0sTe0PtJ+v37buqxiHwGcAyPh91Cf77M0BgZQXwFUVQT2\r cQ6gnWuuPjOyvSN8+aVXF+JsAEzisrWBbzm83hP89ENi25Nh5cqsf56BgF4D+8jBgZpm06Z8SU9J\r lgrp6ZIRBL4QN4EnkyEkdMjilStl0YoVsmLNSsnasFbWbcqRLMck1mVv0rlH3OBLmQIoUDXUFsnP\r dZzR7aRdJIvUtGRdHzy4rzzx1O0yccIHEXtGm05Rt7pwQrPZ85fKvEUrtHPZCKU0xB/jnNJeYOdO\r rfU4YrMBT454/Pu62Lw+HTtG51I2cI2wgf3lVz4JSh6IzHRc6jGiix+l0HlhFGDBklVyyy0Xykdv\r 3Sd16tVUYxxgis+Zs2bJjGHNJPery3QfsxLyjiyRJbEyLQ66TCrXb6dl7CFVm/VQwk/UejN3DMkC\r CcakEGaOpA2TQiwuhKlxIYytjn+g2rrp3xcUbFgtA28ZLr8M8/EorY++RZaO/VDLpOtYvyBxfqP/\r 17H4j/cizAMJDrUTDGDD0mnKBCg3HXCODDj99sWvnpbZ0mJBZn39oDIV0uvbd2aMg55ANl5jHOHv\r 0EDKkzIpfnS7cNTrMv7W+rJs2TI3gMtW1dK7r96pg7FN+ZvlsMH9tK8TqxTGsDufVfsc/e+rr3+N\r 2AdA/LdTrWZvqVo1mrGb4ywGvr14As5I3wgzaxaYWDxQfeEGzPlXXXm6toUUoqryOJB3jutau9Rl\r +fGn32PuJx5IIJbDi3bJl2Vt+PO2vVYimFtx/EDSYDTInsUxgcSyJxg3YZrUqxM7JXEYvNd/1AbC\r ozE9HbrOC84+Qr77cYwbqTji715cgSP26YEqCeJP/ITGUDhpYXORL6cEdgpUUVscx7AlzZ2X7BgR\r y5Yt2EJSJNXxo9SyKUJCwn69e8gbzw+Vf51wuJx2yhB54bk7NNXA0cccJNVrJX4oJGyzF8F9I2oP\r GNBDjXEmVdjvCePxJ96S778fpTYGzmHNyCBR3SpVKupzqVWzml6LOhB6RM74QCo62ELuwdVDcnnf\r ibzhEQft0IbdF/7f4eOffvazY65Jeox6Z51zi+qVAefyofL7MBxOnTZXDYH1GtWTLu2byw8/jdHp\r cnn6RZuLJW/TRrWNpGRNl3pN20mljseoNMJSs+1AXZNniZQx2EOYZ7tS4D2F7nzBL89LW0fwFox4\r WWM72h87VNbNHy9/f3izDLx5uIx74WzHdHpKh+PvUoJIm9XaHpgy5rGjipsPurwMOZ2mvHejNOh5\r nM4Lz5wlaRWq6WySeI1R/r+COd8/qcwBjH74KLV1AJ7bIfdPUwY97oUz5V/3Dl854o1h9XCD7n/j\r j8ooSKvf44JXZeHIV5RBwDhg7tSBCeHN9cuwXtL3Wu+0EPG4iuMmuW8OlDm/vS0rVqzUb+4yN8iq\r XbOKXHHNudpviUE679zjtD9ecNEweclJDYBjeAnBFPhOvvx6hNx5hx+YAI4P//lVXXMcN/Nwn6bc\r uVMrNSRTB2kDG0cYuMryrdv3RT6nPn22Jbx9+nSRzz7/RQkh3yDfBN9vou/WvmuOcV2jbczSF76/\r eHAPy5au0rqotrGPsg9w3pIlK3T/jmD3FLajsI/1xElOOnfPw+gA6x49dj2+JAxsQnff+6JcfdUZ\r pf4+tDL/EQnE0K13T7nykhM0U+ywYZdI/bo1pAQbhVsIbINX6A25zsqafSVupFLkJApUUSmOGELQ\r tkbDRhQpqVvlycdulEvOO1FHPxqP8e0L0r13N009EB7BbA/2YnkBdBKwbNlq3c++0kCHNpHZQNkm\r fYkHI5HwtTi3NFdFRkbUSZRZkzZOPf0GZQSMbHjR4XvY3zGHOwMbSHg/sOsDGOSSJSsjI7++B+zn\r xPSB0qRxXUnPcFzZvYd8x+xXrl4r8xYukpGv3yST7mwjyz+I5hVi8qHMRvvo6LW4cJOULZepai+k\r kMzGXaTnpe8pASM5X6O+p2u5atPuEYkEg+5vD/ogLVQww+9CWukv9XudmjL+5Qu0XKlu64g9ZMOi\r yUr40ipWU3fhTYH77//rmP0t6VA8wZ3x6V3S++rPtPzBqUly+BO+v424e4AcdOcEmT5hVG1UV33/\r /a0+b8o8W54h/KDVoddGpI+yFX0QLkzdMWwtl4ZlT+4jo38fK6tWrZHmjoAeevB+rp+kyxtvPhTU\r cKPXcVP1G2LhWzTUdAOnN1+/V9Wv4N67r9S1wYiV5b461EkxYdCPGbARH8J3c0tgVwgDokfSRPuG\r Te0Thqms8EjkW6At/03AGrYFx+z3WF3K8d9VGDYLIbmp7nBSFzAJxM4j8/aOYHYUwLWBfb+smckR\r LAjiRMIS3O7ik49/DEql4533vv5nGQg/Lv4BX3nd+XLgQfvJDTdeKMNuOV+ee/Z2efiBa6R/v65y\r 0/Xny51DL5aLzj9W7r/7Mrnt5gt0mtZnn75FXnnpTnn5xbvk+WeHyctOsvhr1DsR2wUMo03rxjIk\r SIAWfrF0tg4dWuq2PfTtgXqMTOxF2WQvnNsu8H6IR/hlhu0Rixev2Ob3A+YowAvDQB0L/omH5YOy\r Dyu+PVwJkSo+//xn9cYIdx7ux6LU2Y8a66OPf9BtA+0xm9vXXz4jl11xT7BXpEat6nKXGxnef/91\r jhmkqyME3xZ3k5+zVhYvnONGdktk3qvHyYL3zpfMLUuleNVkN2K9w0khPn3M3J+eUeIExjx1YmQU\r u2LiV5JctpwyBWDqK1RcwzGoO0mF8qiHj9Ry2TIl2dhDTGUz54enpb6TRAiIWzfPp/9GN79+4Z4n\r j/tvBoS/5WBPcHkeeF+BX+7sL93Pf03KVa0n313fTplEwzZdZk9+9zpVV6EiJA7HykYiycabXrmW\r MuJqQdZeUD6II8HzKmzryH9jf5k5rKlMnfy3TtFQo1oV6dG9rbz2+gPbpOQBfEP2HRnuuud5XTM1\r qxFkQ7hM/NOAA86KTAgFOE4/5luw7yLRN009nENsQHX9v720FgYDM7KEc5z6tt5eShH7PdhJqEs5\r 0fUNxhpqu2+JjBKAAW34nJ1JYWJ2lO++9xPAce3w2tAkkFLwTNtTWDr7c872mZJBeCZHJJRx46f+\r syosYKIWy3h3QVRZti9nU74cedRB0qNnZ80x8+STt0rvPt2lfIXyctIpQ6Rf/x7Sc999pEvX9tKp\r c2vp0LGVdN6njVvaSvWa0bQlYNEiz31pl47DGpB7nwhTXP64Nh3FjiUCdV56+WN1i7NpIanPyypf\r LqPUc2mX39Wsmf/4KINEHYz7wyuEc+jEk6fM0k4W3zYfOkna2G/PDOZmdgtAp8F1mGN4dhHNG24H\r 21JhQaHu41726Xac3HrzhXqMZ/PxJz8qE9LJdNy9cE3qsq7gnhszriUnbZV27Vu4d9FJNm3cKKuz\r NsgWN3LaumWrvsONy/6WwmUTpGj5BKnZ70ppsO8Jsnq6Y2h1WjtpobEylPbH3aGECpdfmMrWLcU6\r Hwhl1F8zv3xABtz4g4x7AakmSXpc+KqMefpkLXc4+eH0mR/emJdRq0Vqk35nyNzvn9RYkHpdh0jW\r 3DFSmLNGg+iIxN6wZKrGjfy/hhWTvpWm+5+r5emf3CEtDrtGkpPLKsOt1XagxqIgqcEIep9y++zP\r bx3YEmmP5zvS1SEeqtt5L8mohw6X9Mx6un/uD09pZojG7pl+fXk9ZTDYr5b99YVKhsT6VHTvcO1L\r A2Xljw/JwgULdH79NPd9FhZvlm8+flSyc4ukbZumatsz0K+PPeYglTb4bmzwQ9k8rL7+5lcZ6kbl\r qKsMAw88WwntYtfXca9lkGXnAsr2bZND6hQnfV/tGEEYRlTpv/R36ib65kkDZMetzST3D++xeKB2\r evqZdwX3e7yvSCHPOVyLtsP3GAa/AxU010HDwKRVlSqVl/LlM/R7fv2NL0o9NwwkENrgO/X36b9R\r 7CFoM4w2mHoL+rUz7W4PN9zwsCxdvkYeeQi3ew+YRtnAu4tZFe9/4OV/XoWFf7chN9enMSD4B/BQ\r eAHgoguibrLh/TuLESN9h+A8O5c16hmwvUjRMD759Cf9IPDOsLaY9YwXsr37YmTEiIPjpB6hLktp\r oD0WvFQYySQSOznfvFc4zvaoUbFGY/bZJFJjx06RevX8rGsGRhCkyUakZ/+jD18fEa3r1Kkhi5es\r 1Pvgw+Aadh+0x2hp7J9/y7nn/ksaN6qnBOH1l4ZJwwaeQOPEgEqxoHCzLFq6xklci2X680fK6Otq\r SkaJf8d4WkHIIFYk74MwzfziPsleNEmaDjxPVk75QaUNDOJelTVCJRLKA28hlsSnf+97+x/lRtzl\r 1V09L35Ts/0u/O0Nqd/jWNmcmy0bFvucYpUbtJcCx1D+XwG/F8mjTmfv1Tb2yRMdob9NJ92CefA8\r YQaoophCGOYx+u1hLdfM/DWyHzVi3+u/03fBtLI8d1NdQQAo977ma1k19ScNHkQNyXWLp74p614b\r LKP+HC8LFi2UrIKNcokj2Icf1lduvuEC+WnUZO27YTUMRJV9ieIaYBhDQ3N2hMv0a7ZnzvQ2Aogh\r 7cTDGARBfW+9fq+Ww8B114gn/Z1U8LQXj1+CTNgsEEYIfGnSAIGL3AuBj1zf7oF9ie7RQAp3w6CD\r 9nPfTe0Yb7Tbb9t2/pJEMAmElC/AvlELGrTfZ/di0s6egJT1rR0TD8M8QwGpZFau+g94YWHAMpiO\r jonrd4RpoQe9MxjQ3xvJsHfYAy0oLNIyncQ61Y5Qp3b1yPmseVndu0UnrbF1PHh5do3eQUpqrpub\r 6wOT4kE7LNQBpd0fhB3Yces88eCFYggnRUK4Dp4x+QUF0qN7e70eWZJvDz4AcLr74Mh0ChgZhvXF\r k91+Pq7wdJ3denWTLz58VM4/91g5/bTDpV6DOpp1GRpSVLRV1q3Pkez162TuV3fLvNdPlFYNMpUB\r VG7QQUgfDjHDjZR5MRYMf9FJEH9EVFm4+VJGBQOzqNGmnwy4ZYTaQ2jjX29v1f15WUvVM2v19OEy\r 86sHpW63I1WdtXCE9/VPr1RDNq7YcR/7bweMA5jqju2el72nZdK8hJmHMolThyrzgOke/+YW3Y/d\r o8sZT2u5ckOvXkVqUwnDPdM27nzawDvL5k7Pnv6tFIx7VlatWiV/TZ6iOdMqZlaSHz55Uho1qS8N\r GzeIEKtVq9ZKbffNxIMBmzETcJcrM3K+8QYf1wHLCRNfUn2wTbwV30SgoYqAfcQ0hZHoWyQo0b4t\r RuV2vXhwLYgkYBIrJPlEsSLAvlOm3OU8Fn6b2TUSwQZpzFluDGeVI7gG2hx2R+nnG4w+AGgTMEcY\r uw9ga3UGcFLJngBtDSrrE+ISR4a9RY3G/OMMJMy1TK0Tht2IvSRDovQe24d/aEgQgLZQCwHa3llY\r Xc4nxiLswss+RNntgbqM+A3MYxD+XfEIJ1rbXj07nojRQPjxIEPs5/jGIJrWUDbVi52cXzkueyjt\r Io4C3gUpJKwzcoz2wtflWMeuHeXkEw+Ts844Rq6/9nTXkS+UOnVraG9KT0+RzY6brFm33o2YVsnw\r 12+RGS8dJxm5c5SIQbgq1GquZbx+AGWIGEANQ7n5gZfIB6ckRRgKTAQc93qRfHV5A8lds0i9ibYU\r 5ilhzWzcWerve4Ksmuw9klBpEdCIhPO/DeT7mv3dE8o4+P0Qen6jMZJPz8uUNkNuijAPpI0j7xw+\r e1TAPIY8vUrPgXmglmp64EX6dWQvnqznELMDs8Ye8tFpSTptcJ9rvpJV4z+UBk1by4RnT5Rpoz5V\r grHFvdPMzMry8Tv3S+/9e2vaDEA/gIC9/4F/3sD2sY5P7WHSBxIBkjJ9NhGs78Xnf7tt2NMqddA+\r 32CibwUGE3aTxbspUT2SjALsJPRxRux8O/Gu84D7IWM29Zhyl7nHaRNX4e2N9E36OOTgPnrPgDZY\r 7J52VgIBnGPnhn+XtW021MY74dG1IzwfhBiQRSQMm7KXQbENNP9xBmKzfAHc90CYCBIoZAiPnNH9\r 7woQP3HHs3w1tGWEkU5gD5/1jkA9zqcTWwR4Xl6+7rM0AonAeSzYKQD1bYmHdQAM3wbqTZnipYFE\r 4Hi4AxrYh66VnEGUKwb5hQzsMzUXEgnP/4svfRpuEM8k4mHXRT0GkErYZn/rtq3caDFJbrnhbDnl\r lCFSt24ddcNWDzo3ity0cZPkbMiW31++QvLGPy9L3jld1v9wq1Su20bmO4kBhoIKy5hIRmYddUft\r cuZTup+RNoQTJgJDIQYBSeTrKxtL4dyf1oVH5ynp5aVWp0NUvQXSKlaX2h0H/a9Sac396TmdqKvl\r Id4TKiyFoFbiGfS+6jOp3eEgGfvsaZIzf3ThgJt+lj/e8cwDFWB+9gohdQzMg2eKYwMDelRTpIux\r Z84Utv1u+FnmfX2XjLu9uaz54yUZ+eRpsiknxxFKdw/NGsjN150rxxx9gPToG51QCKJFICzf1eWX\r bRugt//AnnrMiBvl8y/4V0TqwGkjDI4bIIQDDjw7cq5h5C+v+bXrc9giEn1TfPt88xyjzltve2kk\r HgxOkXi4Lu2Frx8P7gMHAeqxWCoT1HZslwbsFuZZaeeG6++M9AHsnES/F9i947IPSqu3K1gWDN4t\r +h3gEGRYunRVZBK7f9yITgRnrVreR3+jG9EgVrLgloroS8Aa24CHZUQMMcr27yxGj/5Lfyjn0Q5r\r PAfIaUXZjE1cZ3ttIwYiJnbq5KO4OY8pL2mTzlPa+ZxncRuAUR/1WrRovE2MR6L7oD6eFqURcmuP\r 65BiGXWU4fPPf4n8Ztq1ugbOQUwngAt/9vMuHKr2F2Btsl+Ne29+oXl68F7jGG2xv1rVyvr7Rv8+\r Ua/FfkYip55yuJRNS3cMfLMM6NNJlixzI+CsDV437ioVOYZSWFQs2e79b9q0URPsrZ3ylaQkl5HU\r TQtk/fJ5UrPjobLwV593iXxbGNiRMOZ8/7gs+eN9NarTmKY9OdYRRrd8e0vvjOTCrA2tj70znRH3\r qEeO1JTlTKO7dOxHsmrK9xqYSAqP/3ZsWjVPlk34Qprtf666JvN7Fv76ujIOHBFgJAt/fU0Of3yB\r xtlg/6jduO2GTue8Xh7ma8yDpI7fXddKGvc/S5nHBCfRpWRU1DL1SFG/yD3b3BXTJL18JZnx7hVS\r uOh3jSJfvXiOxl5VzqykRPOKS0+STvu0k0suPUUJFQOUX34Zq+8exw/m3qZshNj6n42Q2QYYx8eN\r eS9mXxgMZtLTyuoxCGH3wEgdBtew9lEpJ8oQS/v0YdKeL1+xRk48IVYFY6AdbBFdnPS/eXOxngNB\r T3RvgGvn5RfKcccN0m2uQ56p8PcVD+iE5aKiHt+PMTO2S7tWPOwc+55VRdevm8yYOV9aNPcaB2Dr\r +O9+d3DskZeoCmvY0Ev9DgcGDAZU5S++/LGW/3EJxFxogT0MYGk1wlgTJBkERqh3BYkM6RjD7bo8\r dLAjLs3LsOAezqU++6wdW8eDOvYiAfWwHzRpkviFhu8DRmqSSzxsknzas99lLn2G8P1Rrl49M+b5\r ffLRY7q2ax7gRonh4+XLl9Ntjv/y0ysyZ040ZQlgP20C2qcu10OiwbuEcnp6WenSvbOcc87x8uzT\r t8vZZx3jRpud5frrznLSiw/eLHbMZNXqNZKbv1Hm//mJTPjmRSmz7HeZ98qJkpnp22cEDiB4g+6e\r KOsWTJARcZIIBPaIZ1ZIfpFUJsssx455aYN8fmFNJba4+bY49ConjbwoCwKJBJC6478JTLo148v7\r pUKtZtKk/5m6b9RDQ5QQmHRlae293cdJIacmSd2W3bOaH3Nv5TDzSKtYQ766oqFO4qWShzuWnlnX\r zzCICixgIiXT3pIN41+TcU+fINnL58iK1VnK/FNSkrWvDr35XJUW1qz3c10YLLszBNUMy2FY3+K4\r HbvTlY8PjM/x9QH7H338zYg6CDtBonrA+it9NR60Y/fK4A+DdyJYG6jYunXzdkGQSJ1kdbkfbDMv\r vPhhzHVKg8VtUNfa4Jzw9s7Mgf54ghx5FjSJqy7tAVOr0/aO7m1nwNd3/fXn6vs2GL1GyxPO3feP\r MxAQJpT2APEKAvxg20dH2xNcfJGfihRXXGvXHjJlojVBmMgngr0Euy8jzmxvzzZj5+F+SKAT9SGw\r eDslQvg+cM0N207CoA27l/CzDINrv/jSR1qmDgxpZCiBInps1Fj2cXJttg3og38ePlaOOHyAXmui\r kxDffc9HI9M28S3EkHB++Dz86bGx8JxJCvftd79Jx/YtHPM4Wk49+XAZ/eubTlpKl2svO1lOOnGw\r pKSWkbT0VM0mkLS12FH0LTJz6p+yNnuNjHv7Gvnr5bOlJGumlGxYJCX562XqW5c5xpAjeeuWxqiz\r sIlAFDuceK9sLlO+Ginga1SQxUc+5+fCn/iGj5douv95Uq/n8ZEYEUseCHAFXjDSq0b+kyD9CveO\r SqpKw47S5ojrdf8Mt2/6p3dJn2u/0Ol8qQOz9BKXI/5umyBBmAWpXpBCYB7/egtyj/3ofJ33A3fd\r Px47VpkA6ipmGGzQ7UgZ9+BA2TjmGZk1Z66sWLlG3buLAn7KqnLVSvLp+w/JpVecJT9898I2KXbC\r fcfyU/HezeMqEeEnbUnXwM6XCGYbebAUAzZ4+BH/juz7igf3wLXtGwH23YeBFMC3Qf4t1EuoixPV\r M9g3b9/V+ecdr9cx9VdpsO+aulzP6rJtv2Fn4j+uuOI0XXMPnMf3l8j+ceABPoaHkIA9Bc4OIL1s\r asRlF5gEgiftn+Ois6j+RxhIGGSlBNgUDGSVBfbCDKURy9JgLnImacBI7GXSlrVvL3F7QPXFOeH6\r rDHAIcqXBoIN8QQjWHBH9x//e0GYqYRh98KonjokQbRgKgOT1VAHqQ8mFn8cwyUTTdk1cRAIXz+z\r SqVI0rirXOf9PfQ7TcVA7h989+1+DBwjtYHdP8f4fXw87NunWydp1aKx/DX6benTq5vUr1dH51rh\r Hkk9U5C7Wba47YKsRTL29Stl4R9vytyfnpQ5Pz+jo+ZDH5mj7X5+US0lpnhnQTx1ZO22Wx7+b3nm\r yKSGMz/w0sg+pz8mn5xbWY+XLZ8pmY33kfnDX5Llf30lm/O8bQy3Ykb9JGUs2VIsS51E9E9hzczf\r ZJ6ThBb8+rpkVK2n92zeZwQFjnrkaE0W2fboW5SxfH2V977D3kM9mOeav7/Lg1kwMdQXl3qplu1F\r v7+rjKVWh4N03o/pHw+VSo4xwTwWvnma5I9/Ucbeu5+smDZClqxwDNa6hRNz2rZpLAMH9pCHHrxW\r mjWuL1k5+frOsE1CoCjzLnmH9k6R6sPZHaZOnROpC4ywsQ1jqlipQmRfGFYfaevf/z5Ht+PrsY+k\r gzsC9ex7Qz0etq0aIL78Dgz/fMOoy5h0bXv2CNpsGbizklkCukVy00S/x4AB3WyM1GOx38p6Z6QP\r EI5ABzZlbevW3j5sNhbL6sugdU+xZMUa7R4wL6MfNv8KQDMRpiv/EQYSfpl4JQEjNAAXVIO51gEL\r 5NtZeII8PuJpxA9nH4BYArNFhIlfIpBjh3uMJ/Ls69XLR6cnQljNE/6NpSGeycRfz0Bb1H3l1U+0\r Dp0o3l2PEQPzRE+bNlfroBILt8U+836hvH59zjbShBnbARNOWcdnH37oJm20CXlocAxbyB+hhHW8\r c67Nx8N9E3nMs4FA3XPXFXLzdWfKFZedIueceYxmS052komm0y+brASleHOJpLoymP3lHfLZmclS\r rWiBVEgu1FE5gLjivjr8zgEaJ3G82y5JLl8NpoE0gkoLUJ99TLRUt8vh7gMo0dE+Ee2AGJQyySlS\r v8cxkr34b1ky9kNVdS1yzG53ARNY/Mf7yrAo12jdV5rtf74QCGnR30zfSywLOcL6XP2p1oNRkMr+\r sEfnKZNZOu5Tvf+G+50sA27/oxypTH6+vae2RQ4xmOvsbx5WqczUVvkTX5PNk16TyU8NkaVLlmh6\r dUaOm7eIpg866qgDNOPssUcfJIcd3Fd+/uFl2ZiTK/fec1Xk3Ydh74817z48Xzj7eMe860UhQysw\r 6QIizTw48YiPC4kHyQ7DwLZh0kgYXJ/75hvh/sgblygNPKCeEXUWAmUTqa8IkgPWNu2+8eYXUq5c\r hu4vDajswMSJMyLfDs/mwAN6aZn2eGY7A4v/sPrGKJ57/gNdE1sCaBOQlmVP8bqTtmAK5Mcz+hJ2\r 057vmCjxH4Z/3IgOwoZybsmMSvH7ACNcI7xMBrOrBiE4/wn/OkRfGpyS8ym3aeNHdM+/8KES1vAE\r LYnAPXGcc3mB3BO/o0mT+jH7SoP9xvDvTAT77agL/Gxo3uAd3zZ1rC4L3iAEQ/FyMXgbSLiIPpl7\r HDiw5zZtcT/3ug+TXEQYxSHq+XkFkXvE0I5NAy84pJEZsxZEottxdSQCmA6bkZGmz5rr0D6GPVJ0\r 81yOPXaQGllxf+QY9416bvqMeWqwZATYtl1LOeyw/jJ37hK53jGuTe4e+u7XRVq1bCIHuY9t+rR5\r arhMKiapJqPuMrIue4Mb0W6RlDLJMnf4K7Jm5BM67WrW7y/I769c4a6CuscnB/z29oFuiJwkA864\r fXGTI4ZWZh8GePbV6XSI1Gg7QKo166Gj/3I1msi8n55RIg9xJ6swHw/qJUDmWgzcTMREfMmqab/I\r 6ul+7pI1bp2zYpaUq9pAM+SWcVLNlqICyWzUSYMacSfGCA6oP+n1y2XZuE+ctDBImh1wvlRx9WAc\r TJyFay3qKibSYt+E504uWDtvQsrhjy2Qqk266v3jRYUKC0bE9sLfXpOe570kmenFmtIkd+FYycvd\r JKvXrFGXU8aKPP+q1SrL+WccJldffZZjAF3de+kh/fp0lSbNGkrDhnV09Ppa4GhhfYx3iwMIwXlL\r l6zUfQzqGMlDHDmOvYH+kpaWpo4v1tc4zqyYFmmO+iXcD+34oYf0lZtuOl+3jRAa+g48I3I+1zr6\r uCtj8moZ+M65b/p6375dI84hYeDeHx707Ah9ent7JNfld3PvLD/9/IcassO/JQyjKRznufO9sY9n\r HG5rR7Doc2D1w2tri+fGNuuDD/YZq/cEtzmmDiPC/Tic8QLax/s9/8JhmtvL8B+RQIwQA9KKgPC+\r 0rAzdeKBRxDgXDvfODjlXpE5j7f/Eu1ccmHZC+OBWnv2MrcH6tm1S4PdB+68tL092G8C1CUdQ3zw\r 0623XKgJFsMIt8v5N17vU2JQxi35qmsf0G3APqKCzYiOlEL6CQCDs2dB8kXmnCY6Pdw+xydMmKbM\r CRUiHZs2eQ4QCLbxfgGkn4fZ/T5umnz0wWOS6xjGGacfJYc4ovL5Bw/qB7g1pYxO8gWQSjYXbZEk\r xy9TncSyOmu9fHNDe1mzZpGkuTqotD4+vYws+P5uSS/vpLE/npOnj0xqiEtr/9Nvn4/EAj46M0Ml\r kvULJ+non+SMbY68Seb//Lwbwd8hc755VKZ/eqfWBdVb7ictBl2iajDUScxR0urQq6TNkBtU5dRs\r //M0fUrTgeco8ylf3aezgWGoXYPl07uUmPe+9gvpdcWHyjjIqvvRGekqceC2jJEcjLxjv3z2tT7u\r 3nSkjOmf36OG863FBXLoBQ/I6o/O1e21s36Vxo0ay8w3z5VRL10pRYUFsilno+RsylOpzj06nZWy\r r5M2SI455LjDJS2jnN4H7+TbIM04Eisw1STHeKeUw/EYZJCAQIdBHVQ6DPyMATBwgLht3fy3vm/y\r 0SX6XpA+rksQewE4z6QTyiCRtMIxGylzfVyIE4HgZfsW7TdZu6WB43YO4JkgScQzujAwNlu7PEcW\r 26atnXXf5Txg58av5wZaG2JTwPbuaWdxT9A2Nqt4eyxMevbsRerCH8Z/RAIBjFbx/8agzIugg9no\r mLLtoyuwNnz+xXDZN85vfHuwzosPOHNomATAYq6qXIsXRKR1oihaA/X3dx8H5+J9wIdGJ+Ce7SML\r 32s87LdYHa5HLpxE+lk6Bi6y5N0x98hE7ds+fhf14zsOHxMfC95fGzfmqS93vBTENqoqRm38DlR9\r 4edOGZUFnQi9K8b0fEfcu3drr3V4BthLGAxMmz5X99mCmG/BTFUyK0lTJ7FhdLvk4pMi98759h6Y\r tZLsqfz+xx65Qf59wyMaNV+SlCwvvXinSh9NXXsVK1aSs844UqZMmS0bc/J0P6Of4pKtjiA4alm8\r VdJcn3cDJSkKLMNFjuCiBoOQj31naGbOmBekXeceOS17H5tW98BrlGGYVOIenKZFIbgO11/WRLzj\r 8kpwYv6GVbJw+Euyac1CWTHxa1k353dZ4ySRNbNGOQlltMz57jHZuGymBvXlLJ8pJYW5klGtodTr\r fpRKO0TV4122YelUlTZw0W3Q6wTp7qQHpuxlwqzxz56cv3rmqNS2x92VihSyaclkGXNPL1k04Rtl\r kBVqNZL5Y76QJUuXSorjDuzLzs52vzdPCgpxSPDP/KorTnW/u6xceumpUi2zohx4UG9N2w949kgN\r Roh4D7jZ887HO8bvbQLPRN4n+zaTEdv1BwsOhEje98DL8uord2s/pb59x6B+4wPl048f1zLv+Iab\r H5NXX45OBGbXtr7Ldnw/xvU3LH2g7rLtMDjGtQ3YKBJ9X9RDysd78Tc3QGJK52lOyg2fa8ARhEHU\r lVecrseR5F559VPN77U9oL4a5EbuXMvui+tZ8CXbSOl8EzuCPUv7LuPXNgjD7su2vYM9wTMvfKAu\r uk8/eYs67gCeGXMrrVmzXkaN/kvefufrGGP9f4yBhOMbjHGEX34iZgJ+cOcZN94Z+PO9HYSyLXhc\r WMJCu9b2mAewlwUwGkIcOc+YhzGT0sC5q1evUw8GDHbEqYz+fVLCc+xaqJRYE+OBM0DLFl79YeDe\r qQv4+IkKxSBo9wk4zixvaWmput/OsTqsYVJMr8uHMuSIAXLRJXdGUiRw/C0nplt9xNk/xk6Wgw70\r elwICHMuY1jnHmifSHgYNs8GER81B4wKRsOkVjwvjlGXVN38Lu6JxHLMl0A7fAR0XuJMkMiWL1+j\r 6pOKlSqqioxUOENvPEemzfTzszRqXFdOP2WIGnHz3EfueIq2CWMhBqXIMRaklrQM5opJlpyNG2Xm\r uF/S5jmCPO+bu6V68TJpiDF/2QRZOf5j+ePVq2Xpj4/Ihj9fleQqjaVicqFUa9lHanQ+XNVRtTsd\r IlWbdpOajiFUb903whhQfZFA0m/3lyrlU6R8433VRTd37SJlGOPcQqJHzoU5wDRQba0f+fC63x44\r NGPFn+/JpqwFqcUbl8qS0a/L3x8NlUVjPpDi4kJJd/fPCDB7+SIpyM9TxpGamiwFeZulruvTbdo0\r d8/hcElOSZHXnrtFGjZpKLe60foHH30vRx11oEqDgP4KoU5EwJnzmtE77wk1FU4gPOPZThJloILz\r htVlGzdZ3i9L1WpVZNCg3pHj5v1HP7dvPNznbR/t4xLK4Cx8HHfZbl3a6j671/g2AMfiGQ956OLr\r AdLLo5LNdAwWhsD9jxw5wdXd1hvqHUckYR6Aa6DCNebBvdt3EQ+jU1yffsizMduHnbczzCOsvqIN\r zrNrcv/YZ7gGbVKPJLUnn3SYHt8TnHjiNdLDfZsnn3yYOkrg1o16nPLy5avlgw+/lwkTY2ePTHJi\r ZpSd/IMgj4yJWxjCbDpHe1BkhbWXdOnld8tTT9ys5XCdncWwO55zHevChOdCMBkF7GybqGMsF5S1\r x9qYR2ntWEoVmxmMcwyJzuE4ncTiT0Ci+wdIGHhZcQ8wJwh6/IdEx+f+YEh4hsV/bOH7gVhDnGnX\r 6nAc7zibt2G42+ajCB83oNrDHsO9w4QYFeHuzP3h2stEV2T7xchvDgj2/GwN+K12n+jMa7h75zjb\r pMAgr9Gnn/0kBw3sLg8/7g3cpKu/+pIT5eeRE+WWoU8qY+vXp4vst28nfQc4aDB9DEzFmAvbySlJ\r stlJLWVTy6jhPozy6RWlTMU6krN6geTnea9BZs9k0q+0smn6O1KSUxFaJCk5SUdkMHLyHpUkpUru\r xmwpl5HupIJCx7iY7CxJR3GGzMpVndS3WplcsmsvNWWL1iGIr7CwRJkFKjqYHmW81ch+DGilRs2q\r 0qp5I0lxH/fxRw2Qth3abPM8kTBxmOAsu7I9X0Ad27YysG1gbTErJXEH9t5AuE64X1XK7CnXOImS\r fdQnIaelwAB4AZokwcRP1/z7IVV1hXHr7U/KncP8nCfcD9JHfB1gfcUQvx0GTjE2J/muAFUtjje0\r TbZrmxe9NCC9hNOp2z2xpvdBl3YE3Ixtwiw7N7w2wHhRKzNgs/nfdxekqL/YDSLPcdIS6YzIGoI0\r h9MA14Hptu1wpAZohsH39B+BpgsPQDpkQKc1QlQ9SBkCwvOPh+vsLGxUYZ09fH7Pnh20zbAb8fZA\r pKrB7sU+rO3dG6M+G/kB6hoSTa8JwszDkKh9Ai7p1KecfLimnadTxecO4v7waCOlgyHcFvdjHliL\r Fvsoc34XajbAcZgH+ygPDO7f2gj/HpgH18Owz/FwAsiZsxZE3r25HXIudVc7JkMde0/MlW0fCszD\r km9CdGAe7EeFBfMgLoW6vffbRz78bLhkrc+W7Kw/VE/+qxsk3PfQq3LAwB5y59BLZOgt50tfx1Rg\r HL16d5H69WpKEiov1/uRUpgCmSUvWK/PWidrF06TIsc8cE9g2ew+okI3+s/O3qBJBpcvJdp5uWS5\r uqtWrpJ169e5Dy1PNhdskGTXbkFBgSPeW50E4V2VmXGz0C20v8IxjxTHWMo4JlFcVOgkiWK9doFj\r FCmOsZVjGmbHPDgn3x0rV76cnOYkjHPOPFptckMG93H7MjTgc/W62FgN1MToxxmM8f7J5wZ45jw/\r wDMnStqkQXuXHD/s0H66bTpw3o0RRHtP9s7oP2GClpTaQXLWj428Q46HmQf7ONfiL7o6KSORXYMR\r PzTA7rc020f42jvCrjAP+rBdO5xBYnvMw+qjQidrBcDtF9d6wL1Wrx6lB9sDaWSA/T7TDNg2Egcw\r LzWbu2NPsHrlWh1sXHn5aSp16L7VPuYNJsW3G3bnNfzHGAidMkx8rGxuu+F9cMAw0FnuCixIh8Af\r QGeHgwLTj9oHYtcsDfFEnbb4COx+7aOKB8eBtY8IiKsrmW/Dk04ZwvVtKQ2kZiENO/MDAOoiuodB\r e4yK7T7xTIuHGU2PCibiYsR65dX3aRlwLsc5nzK/+5XXPg2ORo+zH2C/MXAMIIIDO98+NCb5QVIx\r JrI+O0dHe0YYUJPYuUOOGBh5HuQ7YkQNY6cuH5eJ0NY2o1WIzrMvfSw3DX0aMUFGDH9d9++/f09Z\r vGy1Rtvu65jJTdefrS6fLBdd8C8l0M1aNlJmgyWFZau7INcgJctmJ706QUGKlTmUqFokv3Cz2l62\r lCRppD3HERgwZG9x449CxxiQUhwr0bacjKH7tmC7CUBaFxgHgZYwDhhKwwZ11HY0dsSraqc4+ugD\r nGSTIaeedpQwp4s9K96BERdS3KBOxHbF+zd3Vns21ndxuSZTNupFwPPlGNHZACmdbWuX42PGTtFt\r zmfNcQPt817sOiB8HHCfeECizo2/7zDwlsLtl0Sj0IdEdeJhz2JvgPsyGAPeUdsQ0vXrN2g9HFC4\r Hzw2w+ou3uWOgPoKSQfg8QVwXwa8A9rlHWGbsHvaG7/7Hifl8f5qOukWrQUw2odmgsmjEgUq/sds\r IIARj3Wqn34eI13cCCTstovuu2OQf4mHZQ9/xIg/IwRpZ4GEYcFOPJjmzRvGtIlKjY9sR+68GIpR\r e+GGx4eJbYX6tGXEM9xJwuD3Qgi5Piqn091oZEcOAZzTvXsH2ZCzURmFXSMMrgdx5T4wdqEuwoZg\r +cUMnEeHq+Y6BAQX9RG/JXy/jF5wcOB82qSLQMg7dWylxzG0kxYfOwXXY/TIR2XeOPw2A228/Oon\r kdxjLMa4KeflFag0wuRhGOS5v48++kHjS8495zi1c/BcWZigiPYoMwUy87nTBlHPh7pRMob9Cx3B\r Rx1Kh7/u2rO1Ll5o/QaeoVOhfvj+I3p/qECIiKbMxwajRKJCbXTnPS/qAAWpuFrVKvLGa/dqzNDx\r R/aXWXOXyuoVq1QHjDSByok29DNyBci/sQCSR9pBjlMkSO/ii06Q/Z0kxHOEYWDzyV7PBGB15Tgn\r JVx95Zly3HEHS6vWTWX5srWOqGdJ/77d5LWX75JHH7lexo37W6bOXKjegxMmTJeXX7xD+wj9kedB\r mahwvPHoayz8Rvaz5pkA6vI8WVOXycROPcWrPawOgFExAqW/8H0CjmNc5Xvid9FPcOs8+iivnjWm\r wXOlfY63bdtcdekG6rCNTcD65UknHhpJVmpgPwZb7h1Xcjz5aDMM6sQTTe4x/jtJBKLKkXxKg7VN\r WxDOr78ZuVPt8m1Y5nHqs3BP3DttljZZVTzoH+a9iN2JNe+NKXhPdM/L7gUthrW9M/e3PZCA8h7X\r J5A+UTmjHSCNCao06N+iRSvkuusfVhVtPP5jEgggyM1go+fwj58/PzqH+A+OsRi2R+BLAzn+DWGC\r DxiZ1Q3Si+xM26QuAJZNGJsDU21y75wfDoQMg47IYtfgHpBE6JR0iESgTVRAPXt01PMs7iQRaMdc\r MKlDAFU8YDBk50WPbRH04fbMOIroDSACBCsauAeM5Tw7zuP+CouKIimxw8+P4wfuv688+/z7aggF\r 4d/O6AYwYRc2L8DzISiSD8G2rU+wj21GYEhLPH9mW0OlRR0mH4Kg4eVidbHHvPT8MO38Nev4+bRN\r InniqbdVzdKk+cH6e6jPMRYGBuzjOMuZF9wp7dx9HXb4AXLddec5xnSJvPv2Q/LOWw85xvSYfPTe\r 4/KeKw8ZPEDatGgqgw/pLw/df51c4xhC185tXP+qKeXLlZc77nxel1df+1zVhK++eKdeb8Gc7zXV\r y0svfyh33vWMvPDCB1LLPZ8RP70SkQwHH3ah/s7RoydqihnKZ5x1k943x3m2SNRPut/FMRakNRgE\r dXgm2L+oC7759lfdR4bs8HspDOU8QjJnHzE/gPo4ZPRwgxra/3vqHB2JhoN8Yc4cA0iUgwafv81U\r tOCgA/fTtrF9ANzADXaPDAYgYgZrd3uwd78z4PsrDfpsggEeZQY61q79hu3BpBUDv4nf69/XzkWJ\r mwRo36XZjQnyBbQH/r/27gR+u2rcH/8OoUwVIUMdwjFEnRyEimbNMpRUpFAUoYHmSUlJSJo5opRK\r g6ThaTCdio5KScisHw1KGUoq//1e9/dzP+vZ3dP3eR4N/D/3637tvdde815rXWtd17WulfqaG/jM\r p75YrrTsYqrJCtRkzd4Pqw/n/AzCfSZEB4WvG273vnarhW1Qv5sE8Y9vZ1auAWiM3PDso3HSTXcQ\r 6vfdxjppvvjTYXJCIgwKxx+kgTAcVx9oVSNpWxX42Nmn0vXLjTCTfAMbwiqo9uO99OrOin9d13/q\r L/6wFup8Jd9B/NXv8VIJ5AJxsMEF3t/VNlorpORDWO6udfr2nigDgsTEfLdz+z4IiMHIP+/rwcCq\r JEBc6rxC6sSuW3F9ux3E5a8GXv3fq3OiPROWk0vddfc9LUHZtrh341W317UDmbZZ5ABtvlJW76ye\r qDLnGyQvtOawdlI/qWMbADdtV7fsy+XgMGVU3kH1l3rwrgurwQzgqbekJ55uv3z9G99X2IgIHJiI\r ECTXfUQYZYS725WLk/TqOADRRljHwemgaTNByjoOo/x13+U5dTAq/nwffnAaTI6ZEwpM8hDyccC+\r yu7zfLegTgP7iuLL3ML88/1Xc0fbjq+6/JTmqU97UhlHtGNjzw03/KH5WLvKP6Ct90G4T1cg6STd\r +6j91W5pcIHKmw56cV3aPwUsA4T4s/pInElzGBLuc/9zSr8zgcEuu1st6QchRhXFYQ+MKwxrUHmv\r ofjrLFhIZgSDIG6b/XRKjT3ha1AHJsz0zsCr3HWZE8Y19whOjswEeTGgpfyIh+dAuO43qtPxHvGw\r PE7jF0c6qPcPa2e/0nEeBLxh/feXFdhXz7iwuEc4/64tN2j+3+9uKKuRQR2cm93u4eUG3P2xZrLy\r QDzIpqRpEHvK01cofuRdWQ89ZNcy2P39jsv7YfK/8/bL7vV8x1++31z0neOK+XIQjwE0K5uU7cjD\r 9igC5wykKQcQuqsPfSDu8oJ4KOfNt9xa+ky+hT0W0tl+O+fJ9+LyLuWQfuon1zq9wI7yLvHwvb5/\r 2Y/KfU0IgJ+vnHpe8/12heI7e7bRrPstQiD9sTephXcRQTm+f902u5hd4jEd1NqIsPzyww0fSl+5\r co/NFw3MYBLiUSNxutbPyRPWK+T9nOL2lnistsormoe3EzxanbgWp57W42ZQZjjyqJ7p9ntjnvuW\r gIAGHcR2jg4T5L0KqxtSOst0IC4DoUE88XGjIucoTjtoIQ1gFISjw514/A3qZsNYWvVgWyONj/8M\r eOLQ0OrydeEdv674nYhVF3W+1U9YOd14t9xig767MIM6HDeyg4TdYbvNykotR3OCgaD+PtJccWpA\r BHHkPXjvOdoiwpCJ4K+796foUOfNvcEYyKjsHzJAccc2k4b7rklvgzPUZePPn2mG2v2xj3lU/x2c\r d+7RJc3Lvndis0WbHwTbCiVEJf+HPWLJMogO+/NDjdX16f+xcgmv/NhMWFMhNOrRTF/63W+FoGAx\r eWegSB2qGzND7gst+Lg+i4iqtTiUz+ZZSF9xteoNIRIHv1hZNRAJp1iGbVLnyYTDe/tBsMfEAWbL\r iJjyJD3Ie5CmurR3wb2/slCg6IJqNFtP2HUhsjWEha62IaOik0D4ug3U6L7L6iHuK0xtwhyEDKAJ\r H01CoHo+HWT10UVkVUFYgHMDdp8jR694xX/1NVNpj5FPWelQ3x+usTrPfcvCgs3fsVsRBEI+UAYP\r qO/rD4sXZ6CejoFFKxAaWY66pL0jPo1d/KztEo6Ksz4sZRiSL1f8YZoWedYpEu8o8IvlEoE+IDCZ\r UdRIeoHB8wXtDHxUGokzqP16pyMT0EVuIt+pX+DHUnX7dpaHwOlI8z36xc3tf555Tjo/l3z3yv5J\r k1YhVEZjrNL71EfgGZJW8pn85Tn5YfqCYK/Wu6fAQAZSfy9aXwStvis25fUG5ZaQ0+ITD3ew5yhG\r +JIH74StNccCbaU25WATmk6UcgxDyqx9qOcgdQI/vfbXzbPb789v6kk98GN397YfeGsRNH9gu/2b\r dacGbAP+o+afrx9H0qFJRcEg9VfD3hvtDEspaWRvDXTrvn7upgPcUneIh4EF8beat1eA3OOWm2bK\r LbvxiH/3PQ9p9tx9q+IWrL3uVs127fehLpu+ffY537kXYci3JDgmE3MuhtXppBA++e8i3wG7xoQw\r GBUGCJprk+eB9rvNezeeyvNkez9MEgdpZwbJi83Myp7xa04R9tV55xxV2ODavb7nW5DpHHn0SYVF\r Ogz3qRYWLPC43g5xMGy699fgXM2yMkDkPcw//yPLHoA8TwJaD4jIc9uBwsAtPg1ZWmmsZleTIOme\r d/4lRVsoebaKWqpd5YjXSmoQMQAfA5sL+0Q4oHGRY2K7oMniT5vG6oOW0NXtcpL2Uhfio5WjQwkD\r GRAC+TWo3PyHnoVaLC2nusX0C7g+tR34dCjaOIgIofhmm+9SNEHiR+MFadAuYqCS+RLv/NWAOOp4\r aQeR1RBSevadmYe4c0omkgFKWTbYYPXSoREEbJXFn7N688HtN2se087uCfT5sTJitDEDCyJhf8yb\r NnhNc8P1fyimMMQhTjNBeXLPvzr64x//VIgeP76LkywRKLMuLC1p5P/1dhXEPRAmZc3/pnaCY5Z+\r wolnF7YphQZnf0uXBdNbb+2FX2nFl5X2qO6827fNG6UFq+FXvmKpYt+M+xbvXL8Yn7SngOBX/SGm\r WEzahDTNTK0SHzLV5lLne7VEdP03rla0GpWZm3KECHlO+4K0FWw/pktAGYN8GxDP5u/cvdmyJR7O\r 1/HuW9/5fvPhvd5T4g2e8ezXlNWUeKTz/m33LyuhmMgITMS0LefVBM9avGdLrIYSqgPfDRjrrPM4\r CuMIQfJ9zBe+2u9fWHErT1leGIZ6klHj7La9KPM2792k1Nck+fzsZ3tWtmP0UTj5knfhEw+OCmgn\r dX3PLnZpifoy7WTQ6Y3GD+MXNWv7hBznQP5xZ7UXDpu5p85r7fWP+56AKHQqp77XKVQQ4jHoPYxT\r uR0E8W705jUL6yQzfzO3+vQ/2kn1hqFRiA0aS1WaNlRK5U8nHyXYMkgQUFGRBeXQedKRU8bAM3ed\r yyrF81//cvtQv3tNqakGg+JdvCWaVHaZdDGQ24dhFlX7cZ86J+Q1S/9FG486Skfwjlot4gHczzzr\r W0XYTHvMe3nB4ohdLG7RmnLvOyMeBqBTTju/2bAdGOXXc/z4f6GdcRmIDDwGIGl5r15CPEIYaJBg\r 1yHq1JCpVeKpmyHvtGNvI5myGYR2aAkSFXIDNOKBoJKtiN/fZEB+3NfEA7BlavmK3e/igKdNTQiu\r +fEvWwK3SuH5M5+efP/9rrtLXbpXB4TesFg7AQhRsarTbldd+RXFCsKT2lmx8totnLLn+yIe/CtP\r NoCZ4HQHfc8UAliZVZc2hqnf9Cf1ZxVn85i8BoT9OTyKyZiXvfLNzQXnHt1stNFaJX274bUheQqw\r 86ghe5/vaKUXW1qQNuYKyrve67dpPjSAvSVv4s+3SR0MAzMsaZtgsFUng2BcMJOXxnbb9mRIUFu4\r HgVlrwkJbgcDodTQjRGTmFivhedRksh4qH5SbrAxWHvO+zkB9tUFbR993XqrlD0fve/0yyKjcu75\r ccd/raiO1/s/Zt77Co+47wkI1IXPvewoQO3WvYf4mRSJN8s98WFRAFYOTR6DuzTYmIkZ52HwQXUM\r Np5yLoLGt8bqy5VZdTpGF+K36vEu78UDw4ii9/U/cN9NQ/y1HxgUb/ZlYGdl0KOm94LnzxT0iQuB\r cMU6tGfA7K/+RjRv4gecz0xYnwYff2ed853+jJJbl0Dwf/AndyzmGKSR+Hwn7wyCVi7OQECgXvLy\r DQtR4i//Tx9yXNkoue66K5ZvYQkuHOIhvac+tXewGNmEq3cGiJxzL118eelJl8wsdSmP6tFmy6Rn\r NZj8+yOyeeevfGQHBi5xyx8iAMyh3HjTH8vkYZF2wA7RSL14ZjnXakBc7BEZ7L0L4ZDHxds6jb0q\r 5dn3I0eUeyuh1du2KKzy8C9uO6Kpc9N8w8ayEdW+JCB78J3JlaymA8QjNpasOp/y9BWbu+64vM86\r sgqw2kK8AvWfekmZ5DfELHj9+u8v8ib55Nd1wQUe07dSEShDl1iIj/9BYLIED79+P4x4UKVfbtkX\r l3vpDItzFNjyesXLl5p6mlXgng2Bk0AdqDv1lCuNrq5ZFBp6eT+nWLVdpVP92b4lnLgNNK/Yz7Mi\r Z0GCqr32W8P37AEhefT9Q0BkQoXV94973KP77JT6vVllBjduPnTeTYJumDpuxCPv/O9uZ4d5Nwwa\r Lz8ZnH1MDU+nEhcMi4NffuRBxxaHRkK113M3nOf4c60xKI3ar6v06vJC4qzNEiAgXX9mcCe0syHm\r 3sE7M92YVQB+uKXj8fOIRz6iNDxunudtB0ADiXuD2/Oft3h/YOHGHxadhopvTMGBu3pKJ3lSu2Li\r 78wzv1lWIb+97obmxUs/r7CmsKpe9pIXFuJBTZmMwQxQ2bH1PnHQh0pYs2f7LJIvxERckAEqA1PZ\r XX77HeVePRokTTasqE5rV0vy1v1bgfqWqXuzfCwj5UI8Lm7btrr0zm535Vd36pCbtGL2ZKGFFiju\r 6omMIYTDfgzEQXrSotWmLAiMgVfZc5yB8nsnDiq2MUuBRQkhHuKymRTBW6BdEWGfmOUKl5UHUCC4\r 5+9XlkkSiB8rjmpxwA3Uf77tIOIB9t0gWsp1Xfs9fatBxCPtWFye0zY81+CHu8HPO/7G4Zx2csMv\r Yv66KTt804E0mdgB7auWn0wHySsZDI0t7cakJxsTKehkk638mgBkT9XsQlxHt99G+6IksNpqryzf\r wZ43ykLYWIxK1gpOVru9J63XhPxh9w8BSSNwzb2B4zOHHV82G9XvVaaBwT3MDhsLD9oAb6AyQ0jc\r oIHroNzEW78bBDaVxGXzIKqtKpOfDB60hgadg+7jp3EnjewLGVYm/nTmhEsag/LpOeWIhU7+B/nb\r +r37Fp57nqH26+r0SFfxueKrP/JRL252n1K55FazCrAFdUYrrWOPPaOfZ3WkDIgHGFQdVFU0bqb8\r uJIZYLFZJTlMitwIP1mZ/A1E/C6/3IuL8FIYRMA7hISJ7hAPqC2qUkcUXhm1h2e28WA9ha32zGe/\r psQln+QUG7Z1Jy2rnwyo4b9L95b23gBu1m4jpPiVSxhpMNvPOjG/4tcRDz3shD5h0Kbf8IZVyyoW\r W/Pmm28r+wdYPE2bEpbM7U9tPqVx5te/Vd5ZPYT1YuA1eGnDka/lO6bdYJVFkybfEvhFxBZ/5qJF\r FsgAJDkZQpVBX74f+vAXNTf+/ltldhpNMCb4642AqXMyvTPOuLDkM3KQGsmf1RBIl7n3t1UTk0Df\r pOp9W0vQb2wJYMrj34XVtNUTAktZIPK2YZDflLG7G35SKIuTB1kJ8G0H5Ws6iLov4hHIpzYNiX9O\r iQcYRx3oxSoxGYcyXH7FNe2KZ9lytbKa5eColnggaD3bgCYRCMhD+lpo9zkObpf1geUSIBaBxgIa\r +/6dXeXThU2DluDZS0HbADSAfJSkNw7ZqUvIFBgIucmbq30Lw2AjlEbBX8KA+2GQx7xPGiGEw+AI\r 07zXyLugadUtM1PzNXQwfsTjTxvp/HOPLjzuQH7sTgaDqPOjrRrVTwYVfmjsiMtfeWgYgefaH9mF\r b242RmCYTp5rIEzCeUedFJZY8rXl2R9vmZA5z2bt0sNa8vze92xcwthXQThNtiFvBPcmGxtsuF2z\r yaY79fNctxXaYMCqgX0D3jHv8olPfbG8P+nkc/vfGagk86NsWemwQ6VOse9omSm/fEHCOhBKfAZ1\r YHbFLJu/KDMkTNQ7+YfkN7uLxQ/ixbbCXjTAG6RjTNOMNPHxh3hYeWD5/eIX15V8kWXkYDhIGaUX\r DbMzzvxGUV2uwV/yEFaPQf7CDpEBfpmlQaBp+QlXb87rgmYSP9og+LaxdjEdhMU7DupBPZGP5X52\r EIsMGZuwX0GcUBujhLjPKfbZ+9Ay+GuzNqFS8kAgTBCsPiKrDXrEgwq1qQHGV2+svt8ISCxOgsEO\r 0uChvnd8aqCRpMFOBx/d/3P9sJlx6DDczF5idM7zpEg+dOTELc5RjclGKO/5Txio77vgnve5H3aA\r vncOaXLFm3fN0bM1uHdhRWLArSGvM6ZMuSQMI3c1EaHNpNxYEmbhS7zg2cWSL1VWBBOsyOp6YZfL\r c/KVqzRihVcbCPHTceInHdbffTqV56uuOLXcg+U2YgH8HPzpY/vh4saiMe0+m/GiOmoQspS3yllo\r wcc2L33pC8tpfCEwg/7yTWAeGYIBl+lrbLtAulRQaVypr3zLOj+1Gz/+4s/kKvI7/vjh170/1ps6\r r82I2J0O/AETMwx6Emq/pi2vcMDMS8oB3Fde7R3NBVNEgILIscf1VpU53gAQwLAxhU34R7cDf+6D\r w47oneXNvd4MN0hzkaAY6yZlA4R6HMStXoQ56uiZhj9rsBlXn58RAisvk2plAv/5doGVz6QwwckR\r FoTvQAW4BrYumFDNLXy4TdfUY9NN12v+1BIOigAOhjPJoVGZM1Nq/KVdwfa0sfQqrDXvH3n/sLAA\r L1ajRNmiCeTvw3fvX7jEc5qrp06+g9lhY/3jHuejP6U/+/PxXcVpiW9lEbdchyH5sBSXj7AM/IUz\r gBushsUhfl1GOBCHstpwhh+d+APP3iethIOkXUNH426lJb4nPH7BvlZR7Vf+1EfthjDJW+1mBecs\r ZA0M2wbvG8xio1mTuAjcY64EocbSquPjL/fKhOBwM1Bi6+DFe8/NYIsVZCe0jspd3SWsP3d+uXt2\r 74p94t6fsN/peXmf+pe281q4EVZToSSHs4/DasXmKuWjzkk2QBlAHrAuaxmSeqZmnnzTrLqr7Wzq\r C/uFaux87XusMN/Q7Js/30OdyQt3V/WQ+mLmhMbgG9+4Wl+V1zvsKu+VJ22BwJshUkREOzKpQdAY\r MOQXmBhBOFLHNXbYfvO+G6J/2eU/Kqq58gXqjEA3iiPBxm/5YFnFJKw8KUN3YBWenOFrX/tGyUfK\r rB5qpEzqnh/9krIAf12/oA2axefbgrTk561v7cl5uqBtRrGBf35pUkIdxygIEyLln7Jy32D91ct3\r RgDHQVh1kPi618Cz1WrXfXaxwiqblzXEsxZ7avOMZz6tTJAQDrK6X/7qunbCeWE5Z6eGCUyPfeWr\r ICDWHg+9/wiID+yIRKql7lWmawZ4yP3CCy/Yl48EabCTIntCXIVNAw6Sft6Niz8f3xUv3YAijOeY\r 3hgGZeI3nV9ndQ64wd5MfRBPNnFLM+ECz3V+E7e/JTbigUga2Lt+5YWlTUQCIcdDJiP4fTt7rv05\r sGaxZ67SHHXkXiUOFoOt3OQp38u1S5AMdptsumOz+DNmNW3NLAwtHrNx9pHIBrAydT6WksVl+W4F\r YuCUzrbbH1AIlLr1DK7+3JIP6dhtrjyE69mJTxNpw412KILmDHJWG5859EvFr8PDxBHDhYTe4sJW\r IJ9R7q+d+c3m/PMvKXnKn/aZ8KlzBEg4f3GIS7msRk6cknF4x+/1N9xcBKTKmQGVu3pkO4w/2mLq\r 0TvPysuPdHPoFoF36r4MvC3xSPvm3zsru6x++AvqfqCerL6cGEnbzer/kM98qWgndomHVWgt45DO\r IOIB3lHAMFgpxyFtna+6ysz+HMinOk1ZyXhG9UfEuwiYq4lPwg5DPRDLF//TGZyF8ec/4ePuO//3\r gL1aXdSqu4kjV5MA7TyIu9We82/mFFaMT154oWaNdnLkqGOmkIwRj3jkw8smzgsv/N4sqrtkY4yx\r 9ohGViA9rdb7jYUFtfVKDQ/yMaC+X3P13iwBNPju+ReTQBrCms25+jBU/up33OoONQzxi03BxEPk\r Ktw1LPFqlMMgbBCz2MI6oyHWfwcBi4m/Oo/1fRC3XMOzTz3XYPb8jHZmSAhLk8TgC3Ue4a9/urRf\r Jo1OOc1U6nKmE2qk0hbHh/d8T3mu2V5va5fP3mOPxdSMsLV1YYg7rNMO7O6TXtyBW50PQl6oWQIG\r 3Te+YdWy4TB499Z79zutq/RoYDELIj75sIJwXom6wyvmr/5bKWBvpW6Tl4SHJ7QDfX1oGnf+sQpi\r 5bn2bzCElN+KIu+tSsBmTzAweycvjDsK4w/csaxgn723KVf+pK1M8Qcf2umg4m4nf1RfKRlYsdT+\r IMRDfvJnQbv+JoE80PSJP88HfHS7qbcz4R32m28XWaH+MA5YYCnTJDBBQxSlV2OS8PKUMg66x8ad\r DhKujssEJtaua/fYOpsT7NPGp20t8tQnFuvoJtRkfq9tJ1qUZuyh6hoNRcRnIuwrrL6/3X8rEKhn\r Frn392FH3QNBYu4nxbLtDIqQiJZU4sTvE+8666xQ2Gk333xrWQXUaQ2D99gUZh20MFoyXtyEPe30\r C8qHl89BPF7+DGhg1sWHZ2w9y/dB6XuOunDCgh3LiOIg/zpg3aiTbtev9GnViDswaNT5UHdmIwSk\r VP3EY+ZLjZTQWScG/q0smU0noAPvzH6f9Z9rzKJq6Zpvn84iTbNQqycsCn7yp3FEddQ94XMIWfLN\r HbKJK8+JE8tKnSzzsiWbN2+8QxkElQMLCuQDy0vnWn3K6B+WpL+4Fh2y4RQLTFjCbvsCMos2KCkf\r Dapo+9lBT8hOEK1OsbtAGHGEALjnX/ugnGCVwo0GoOtqbf68W2CBx/TDxcICto7Vzp1//3uZtXpf\r txl5ofkICOaqr3lHc2y70rEBMJB3NrJqVV35UT8hHmBlZSLw0Y98oDwH3nfbmjzme3dBjRlB1Q6p\r OiNc+ucgvxQGtLvMyvmRHi5DvnkXJhPixEJzfkzC8O9aq6gPA3/qy/k1CRt36t45gXAURq0+AuZr\r PGM5dtWb5wSrrLxZWUO8f5u3lM2DxqbfX39TWe1/9WsXltVHbWHaStbkE5egt/qwWdp7Jlz+cv8S\r kHxA1/r+c23njwEzHSQVW9/X/idFTwXxsMIbTVhX0JmsatZf/zXFrTt4DgM/TEaw128ZqMGb4aw6\r JaC0Iaze9V5D3DqYzpzOHTaT9Ach+c0Ag3USmUO3swY6ZOJHgLBkun7dG8BdE3fSqv1S07S345h2\r 8KYxpU4RZrMXs8YIJzVOA7vBBpTRTIYKrrjY9EkZk7Z9DLGE6jsjHiAf/txqXXvpcxMWhLPy8w2y\r ESqDFX/+BlsDqxVj9nqkbkB+rSj22/f9fXcrB4P+uNkwOQl1W1os4rVCsKJi5dTgiD3gfAfECCEy\r OOAry5+6EMa9smZSAQgL4sFYJk0k7oUwtZ3/hhtvmUXOkbDUgW2OZHUgIFCnIlq3rXPbQfh5S6xT\r CP1BB36wtCWCeOZQWAfoEg8ryS8ff2Axw6N+TLr+t23/++7zvilfPfBLwwebk6YVKxD5ztpCDW7K\r TrYkzvxpUaVcXVDCEGbGjIuKeY2wujbY4DX9TcM15IeJHLCB04oQxAHe534YrNJpE9o0K8/aG+AY\r WFH/ve2Lg9T3u5CWb5A4cBWED+q45ybxsPP8vHa1zyTO7393Q/tNFivEg3q9g+BMhK+6uscBCOyd\r uvW2v0w9mWSpZfIdLK37eQUCDHXlwx33pTNLo6NzTKZgaZ8BAOp7qAnKpOjF8ZTSQMUlDg3afozM\r djITrNMaBn4MODQ7aEqI14BNIGw2xV6RBjMsLu7eG3j++Mc/l/KnA4Ug1eA/7/1pxLgG3XTw0c3k\r aWTxFzVBIEysO5u65MeKhfAbNHQDuQ5KjgLSYNPsfDuhW0LB7AE3pkHUZz2Tc0+465AjqzV1S0PJ\r QI39hf0H0rY6yDfWiWzGs1FL/YCr2XfMyQRMg0hn3fXe06463lLCMl/D6KO4DEwsAhtoEBjfGyFK\r 2yHXeNSj52sePnXcMXfh1AW1WWZuyIQs9VnCxR/Gc1eWtBUz/VNOOa9skPMMtAuldXNbnxQCqGoi\r GFiEIRhJS9m6RIO7etcGPFMmyHtzQbvjwxMXnkzJTnPtZp8Pb1OItPSVQ56ZWamJB4ON5E1WHfwh\r aPCOLfco5tVrv/YFeK+enTYI4j3iqBPLZs0aykH2FNakNiZ//Eunhn5O9qRc3oMw6ZddJB5/9SNc\r hOyeBxEP8E674A9R91yD+zjU+15qImQ1DpMQj/32O7LZeeeecUVlka5vbCIWxD1IvucUrBxbRzyu\r Jf6rvWbZItc64OP/U7Qv2b3Spnuyjpkgz+spjKhp/cOV6RYqvXff/wREdnRwA529AxEmMuLFJosP\r rUJd6/uE7TaEcegJ02euMNJIaWW4N8D811LP66dTpzcM/Ji5iVPDxlax7EsaMCwO7w2Uz372f5SG\r 5HnhhRcqG7+WavMxCOLyT0eqYUe/WWENdSveCNLNYhE7M7x0xMC9gSi2gLxHBA0gdSPmjwDXbFu9\r 8cea6MorLVM0oNp2NeWzp0OObXVTO1tOvAjP2i3x4Nd3TNzi1WEcn0lzjnvqEKIUwKyJmSAwR8Es\r hbD8akd33P63/iCsA7hnb8omvD+230d+f9xOGhzVS8spgm/puQI/2oM6M1jEmKeZv2v+kHP7bTC0\r UslgEj9WoeJW957l0yDJOGROtEx+tZvkA/FgpNF+ELPuP/+5d859zGQkHn5Z833rJuuUDYpYfdy8\r W6CNI30pYSg23HP3PYWVkzq2qpGH4764f98v+B7qgD/wjn/7SD79qZ2LW0CBxKrFe/kEExAbB/Nc\r g5Vk8Xr3tClbcWmTdR4C70AbjWFOaY1iXUF2WPOvTvidZGDeu/UzKN8hHtPFJZdcWdhz0s4qoyYe\r tXugfOPyOQ5YzDg7hn7twxHK325XjlTVsd5MDhhrrWFPzw+v/ll7F+G5zZ/6r3urkofev0J08HFo\r AYGls9kErNfOrgJ82ODwqaNSQViVO30YsmYKzXy0976nZ7bBkhvybhIYmOu8GOTybJY/Kp/eGRS8\r 9/fs4CSDVNwGIe781zDIDQJ/LMS6ItjBoHLW9ndAWgYF9VQDG0hjJ1A1uEUAblMftzrvtLwMsvYW\r gHClE7czXdcctwveYSG5Js26U5nZUrdl96h+74+Xm/MTzBiV77//u8cGcE+bzNVM3eDtOFcESTyp\r 79yrK3GyjJt710H/pE/ugp0Z98SpXROMuievCsiv5MeJh4m/Bv+pG+XJe+4pu/D09KMRhZ0I3MUZ\r k/iwx56HFDYUxYat371h6Qni4td34L/G+z6wX/9dYLLF7SMdthXbYwTA4qvLbpNmt1zAv3ipHSuL\r DbnxN8i/VX7RumrfYV/O+u17u7W7iJ9on9WgImxlOAqGykEwIZouyD627RyINQ7y3/0ms4Mo5pjk\r XdT2HUJzZXj3lm8qciTm+WtYSdN+nQmTUqsTBIQQXc08AFYgQCAWtkdWFZlZuOo4ucePzgwFdEwr\r hukgKr3rr79amRFLkwzE3g0yEEREp6s7QtIbBEQC5It/18yUsJiEh2FxcI//hMVjJkx3Pyhcwvgj\r NlCnPSgMX3kPKVs9OAR1nuQF62uFlgh0VyLg263/pm37RF/YmOyo47f/gYaPeM0C863BAPrqlugY\r zOv43Zt9kyEgbJ5Tn+nEnpMOISmI9ytTNrmsgLDlmIr44he/WjpkDiYysCBImf1D7v3FW+c39Uf1\r msCRlhLFi19PudOQwrJyz/4U7SmstJ/97Nd9y7tWIV86/sxml523LJMN6fmG2ExJM+n5RsqQvCU/\r NKsctuWd8iBKwojrKU99YhkcaxYQ8/dv3XyXIp9jxDDgj1UIZmqkVcMkgMn2o4/au/QJYcmNqD53\r BzX56h4TDVYJw2QSNnmy5vvotn1lFZt6HwSzZHWKNUiNPG3hV7/6XRumZ/W5i/gRp3tg0BJb0tiB\r DTgMNk5SEiF8Z1In4Q3qow6ZGobUzTCiMMhdmKQ7J2Dqx+rjV+2Ke801li8cCG0Pm52Ch42yNZxQ\r yArAj3/y6/ZJPyM81yLF0tPohPt9BQIHf3KnUlFQN756xpB772t3wqf4nx7+UQYWHy1p4tUDtgV0\r ZyyjIHzicc1f/JB3w+B9fUWU+Md+inmGLuIXC8yqoo5/UFrdNPhJBxvm38BOOEwrSb1o4E5W7Po/\r +cRPlJlt8KIXPac/cKQOgqSvfnPvYKRdd96iOfHkc5rVVn9n/wAoIAtD3BOPPAzqgISckLzxI37h\r DYDZR5T3V7Urph0+dGDxk07K5Hni5q/bBrMaJgt5flsvhOFkdjYMes8UiJWWe3sewOFb4rQPAzEW\r L+UH2oDMwEibjTXu/vKTvAM3ZfdXx9gKdihnxcFdemGTKWfCGiRWX3PLZufdD272bOOkCh0IY2ZK\r jTv+QXqIBzak1UN2879nm31L2t265z+mdcTjClbSo3Z2yytLAMLEpMcg2KWdOPkl7K2fHRo3DPEH\r aT/qHrrl6ELehMlucMcfBN2TEceh1ryaFNIel8dJENVdZID1gQM+um0hGjQqTXiwSLuwF6xnokio\r rD5cs/rokY4HxAqEQDN8Sch9PUMddg912EkhfL2x0OwnjT9Xs6L6uU6zi1583yvaJjkXJHGI2x9G\r xVH7M1umMfWnP/21L5wfFJYbBYBHPOIRZZZeL60HhUk+wYATlh3Y45DVVEBrymBOzoDVJk7CbtpM\r NtfV8VuJZOaMr/r0RRcpbp86+Nhmw422L/r9CCL4Xv4GKhBGXTErYbOiDXjxC/GvU8n/vC1x0sh1\r sLxzEBQevFk4P+I0s5dX7xOPPMsnVtPFF/+grFrMNrkjxgYzncpzPTOmxROzFzoXwk7mQaAqr/FL\r 1sK/e4M04kImc+ONtxQBOmGlfFBDRVy0L/6TN5D/1KW4T/7KjDKYWzGE5ekdOQ5NHeGsEBMedtrl\r ky3hPa6Ub7OpfTfyhOfudEDfRp5rqF/1F46AtLAF7RFBUGiR1UhbEm/6CZh0DLNOGz/xL+x3v3fl\r vfISIE5WkAZ+MqEohIxaeYhXXfhnfODmOp3xQhjf2VkhWJDPe+4zmjXXfFWfqE0nHuUNUUCMyDqD\r QcRiOvGPAtVdeMESz+6fJIpdSBZDcYlM0Mo/MCm67ba/VLvRjWc0Pa0+TKCMMVrf/XCg1DDIThp/\r 7v1V4qB7nTzWXeuw04FBY5NN1mlOOXVG2QkufhCXBuqaxkbYVBuQGwRhsCdcr7jimlk6VDpv4h0E\r 7knbwEeTizosrZdRYblbikaDq8agMJ6pcxIusxibNMUxKH7EI/INQGgIEbEW8bGz9wDSQQ1C2Fji\r NYCxNUUTqtspDFTcrr7m583D531YGUQ8GyR0KuxNRC7ntAjrbzBByEJQ/GnDtRXXLLnkc0u6tMRc\r kya/SdvVQOpqpaQNGeyVnyxO/t27ekdmYuNdZtTMPniPeATkGdHkSlyPbGd5t7fEQ2eMaXx7BbyT\r tmsgnyEavj/+vPcIPeLh3mBKAQHb9tTTzi/EQ9uq41FOGmm77rRFqTfv0hbly0qIaZc6DCDm3FJH\r iddBVoP8g/rFesOqwg4u36rN76i+Ih7hvnjsGcUIojIPm2lbITlUzDeRn0xa/Bdd9MmlngbB+3zv\r jA9m3NTQ0x6GoRac8+eUQnuOGGg0wRCv/I4T3AeD9n0gRnXYbp6SxpyC6u6MdsJCkUKfLZsUDzuh\r yOo+9vHPF/YrSxo1WGqYKROx6rDaoLqLiFiBeO5NVB8wBMQHVolpHPiTBiD82Ri50/ijfbLV1h/u\r z5L4p4XDJPF0YHatETDXIA6NOh3N9ZZbbu0TFoQh+RsG73x4M17hEaZFF31K2V2LfxsNmlHxeAfK\r KT9mra4wLGzyHn/Ar2cC/u6qAsxkabwlXPz7D8pb0oBs9pIXG42YlyYIDXQEnRa7xb24IWWzInEA\r VMDPKiu/vJ+uazqQOtvmAx9t9pw6cTGdLIoAnmnu0HxDfG5tVwTcpLXea1cqcWVFAlRpDUjiqmei\r /Ll37d77Y1nU7Jhrf/abYoWgNq2NeBjQlDfhEY2XvuSFpW0mrkCe5IG2i/ZLpV1ehU0c6tw5DdiH\r /ApjYrHGGss1K664zCzxqTMWhA14O37w7VOuvbbg3YzzLylEd9Cqw98KI/EJk/wNGsjIX7JqU2Z7\r ClLHVs6jEH+Ih71XrO4OAn/6nUOU5MM3k69TTzuvXeHe3KZz73YKyqLuhHfNd0bgbXC1y34Y4QHj\r jLd13RLaB95R/Z50Z7h85Buoy1yD7jMk73OKlac2Dj7nOYuVPo/tevElVxR18rPO+nZZQdcwOVG+\r n/28x8Z/2EMf004Q7Ey3+kBAYg+rt2J5wBAQyIcGm73Y3kE8VKaPaVDNfWau+ciOR60/+KSQpo2F\r ZjpYAOIEceWAqwyqwwbXGvLPn3jZYLJU9RziYQaF1TQsnqTDP4GlMGYJZtzcdc7sx6iRcAF1XooB\r CBd3/26adRhXaQ3zC9z8v942PIOUTmhz2tln9w7mqcGfb4T14cyBfCt/G9x23PkT7TJ65u71QGfK\r eebCMDGC16/J7tESEfVq5Vmb0683FBocV1717c1nj9q7CH1D6EAn/U07QzZIn/bVC8v5Id6Jm7kS\r 7Cnxe5bPGsl7/vaiIAxddyvGGr6ddiTepJU0EFgmUKiXypP6/8THP1TiYSaewoJNh1h1ISzK52ow\r CN6xxe7NkUedVGbp5InYPFkBgT03hM60puIG2BYrtnXN7eMH7lDaixVEBjvuXWID3j3+8Y8r7Vs7\r w65MOxJ2FPIt+DOrf+ESPXtjg8CdhpC45SPtUj6Hsa5AGurIH/I9f9tONLp7LgZBuHyvxKHMuReX\r bz8JJtl13n2W1iCiPV1k4+CT2gnkbS2heGLb3k1I9QuTLsoIxpkalCm+csp5LdGYp3n8Qo9t/vJX\r Kw2TQ8SD35mrD5jnH3+/cibz636GijRbxr7IcxpzKnTYPcT/dGEVgqIKmzgO+Njnygwjz7nq2LQT\r JoEwBPURpqYRigdbgHroMAgbMJ9OrhI3wsmaf1rDIIhoJc81uA1ChKTkJwbAcYNB4sVOodJJU8VG\r QSYiItitodzgWzHRbcYZt1Pa2eTl/3dyua/hPYJhQ1sgvIFR+tLGm1beug0Ewpt8fPmks5uPf2yH\r WfIgPJMjZDLcfRPxgs2CZqmADfPXv97RP6shnZx8pFbFhbxDiLCVEp9BfcZ5F5eZHzf+0gaknfx4\r V98H8dsFfwcd9Pnm1pbAWjkESQOwIayAEPAupM1vHTZIXrow+bH6rJG8Mb1hpTAK8gzC1PeD0K0T\r IF9EUEeF8U4fpcrcLUfeD8NpbVtcd92VSjmx5LRpkzhxqC/GH6mrzw4cl23ilG8edJ9hkNvsYL55\r X1iGfWzW+R89f9uO72me8IQFmk02Wrs5op1w5ByfwEbT7T6wafO+bT/aPj2kecLjF25u+oP9HogG\r pQHHbsxKQB5QKxCUfbsdPtZXrTML0BnqGWH3vp4tMwlgsJ0unGDGBAdhsZPoNDTmISDx01awk5pO\r ftIbBYOyQQ7P1RkB1D0zi/JnGkM6w+Lizp8Gf3Gbdv3stMHkqwtaPkxoeG/2zj+VU4RsWBhEg+0o\r 5rZt0BOG32H+uZVv8+qXlmWw76Dx+VbC5LsF7v3x2Ndbb+ViaZTg30Brv4cOoy66YQxu3BESz+7F\r r3Nhb2IN0mR65fKb9MME7mlfISIM55kxhpXlOyAC2F3KbOOfMvlbWXivTDSqHvOY+Ysqq7D5q9cu\r 8k6esPXcy4P4n7jwgiVuz6nP1K2rgc55NM59x2bhTx5q/4G9PLTUjv/yWcXUvToSnj+rLUQv2nDe\r mWzUUP4XLrVesdcVFrDvTbPp3BkXlXwPGryEs3LuIqup2lJ2DeHkzRWkVd934Z04hVEH2oYrtWdt\r e1AYsJvd4M7/Ku1AL7z685wxw38UmB0iQMY2AxwQrEsTCnF99nNfafM3mdyjC3JAKx/lEx77j9an\r 8YSM0cZhbGDmgHI20Zwgso+Fn/j4st9pwYWoYP+trN7ZbTv99AuK7KoGOeUBB362bQu3tavzBZsb\r bjRZsPpAPO69+oDRa7n7AfXRlvlQGs0uu32qf69R5F7nCTZ72+v6jXM6cMiThhG7M+GPSkcaViMb\r vmmNErfnSdKo9yjgzwsXTBqHpWadZh1uVBxYJnaZxw+V0yCrjS4MGgTWBOJJC9wPSof/oz/7lXIf\r v+B+0AAEVie0kKy+2BQK8p2dU27JX0NcOW0QIQEHZAG/VqxWKU6tlE97SdI+gq3evWE/X/7e4/Wa\r FOQUPyu8tKWUV5hFn96zRCqcfGYG6ttQVY5cJKZRVl7p5UUonzLVoE1lgIak5cqvwUM+pVPXJ8gP\r 4utfZGI/P7c5/ZSDm/Pb+qzre+99Divxqee4BYnD+zNOO2SW99rKGWf2jPd1w4H66h5M5Squd225\r wb3yC9JLPdb1Wd93kXfyoJ49u3dl0mZQmKDLikkbsNoVrtsmBkFa2Gq13yhFmDQMqpth+HJLjGpo\r E1at4hA/FWFQLs85P6SWDc4J9p7qK/fcdVdZfVDnRqSsopi46WLFdjKIpZmTCB/6UFwWhMOkYVai\r EVhVP6BYWIEGk8ay866fLGaoa7dh94CN0t1JPQkSj4+Zj5zGayczoRPhZdIi1JxEWFjnEzzX91Y9\r 27bLxmGIX+CfOiMzFUHi72JQejTJogM/LBzttpgd50c94KmTMwwLY2AyaGl8NmgRjD7kIfMU8xfD\r Ot1LlnlT872Lj+/XM1CNZAkUm8u564PC8o+Q/PaXM8rqDhBMbMKUk82f/fZ5X3Nm2xZ0DAPjsLwH\r ZpdWLAs87jHNVT/8aXPG177Zlvk5ZRVpn8ekYMTRgVs0XqxsQfohFBCW5DA45uB3v7+xsAch4UBO\r 0mG5/+73NxU516gy+j7yY+c58Je6ki/twkA2CL4lW0mJ29G7iKc6H5Ze3WYDfrVb7XdQOLN/Mqnk\r rb4a/GLiaBCSXv0+Yev2NQzdPRryYiUu3CThByFxDgrfdZvdNIbB6mPXto/M1xKlR833iGbB9nup\r d+ZssHypj3cH/VNO+kQp9/FfPqdd3S/S/OKXEa4jHrS07r36+PoZhz6wWFjBoYefULRygAG8LD81\r itzjKUZFkSAwZpTZR4q/6aAX/6XtcrlnqdeyOQ2TnSodzezSqXV03LGlxqXRi7PHdtGY8+yem39Y\r ZsPiilAz/u3EzTO4DgrLLWHMjh1y48CqOq5B4Sxx7S2IeXIDU/jeXdZUEFbI5Zf3zI2rq513emdZ\r OhuUu6q+8M63v6F0HMSATS0sJpp3Vn+IkTohTDdg1mm6x5q5+JIf9M9dxxfnT9moGB96yK7N3Xfd\r XXYL02zCXln0mas0K7TvlWHBBR57L800g7r4ECX3ZoLSwipLXQa/aQfRK6/8aTkFUHoLP3Ghkj4Y\r qLUPkwvh/VOPrv71/hZIG9lxp4OKbTHyGRaO+aXRlzrQJpXRs5WMsq295quKO79dIBzKq74i9BVe\r eieceFZhWxm4sFC6SJ6wdIQxeaKt+POf/7bfJgfBkbn1BEQcrggR/vugcNKiHuud++71+BPOKv1y\r GJIG9t71LUHNM6irQXXThUE1R/WSGyWcetfGWGIgvJ8EgwTnbONZrXr2vYIQD5MtfW5uwL6PMtTf\r 84/mrvaPDWeSsO7aKxSZYFeOtf4bViuTHhZ5Wd594sJPbv5wsyN0rb5oXc007x7Yqb7H7ls9MFcg\r ZrIZ7CCNie0jA1Pt1r2Hww47odmyXVpPF45yXGftWW35dK+0ONKBuukOQvzg1UcmUbuT29Snxw0C\r Hj2ZAT/CgXsmOFjPNLMYh6Tnar8Ifjb+67B0+YuguQ6bmfSgcOkM/AH+O4G+MKNmWAiMjU3xIx7w\r 7D7C9GFx8HPc8Wc2P776jFnCBlhmOog8Y5M55/v1b3xf2Uux44fe3j/LZFhdzE2kbhi2M9BRhrDC\r I29RTwZ7xC3noCRPqXuwerEJchD4iwzkwAO2L22u/mb61VrrbtUc+uldB5ZXm7BKTZiAX2feYFsM\r CpdyDYK4mKLPirFGN5y4WXVG9K0KF3/moq3b4J3mwvJPUwt7xrkkzhjnbiKCJTMorzWYeFm+9dNt\r N9qkCaOBHcF3DMTuuw1WN+7CgB37XmnDdXusn5lJsdO962d2YfWxyxT7yprhke0qhMaciQ1tPxyG\r 7oD/zfP/pzn9jAuaj338C+2q+1nNFT/I5mJkiLwPOZ011GXfO7FoxT4gCQjUFRrNHUij6d5TVSQE\r Cup300E6TsK7Qu4HXceBP5VN/bYbH2igGuqouPB4CQrrcFA/j8sLf/HPWmxUXIeFM5DEkB8kbFhh\r g8J5/4YNPtCc8/Ujyky+TrO+DoJvDvnu9bN7e0GGsbYCwtbN37Fb851vfqHISsiulNM9A3HJQw0s\r L/Fa7e6735Flty4evL0bCD8QrD6+MkJpNqkefDf/Gj+48idF7vXr3/yu7OjFNqDEQKPn+hv+UDZz\r /eIX1zVbvetNxb88pb2Ly4bLDN4hGlATlC6UCeEwa84hXjXhgMcttEyRnYyKYxBSZ+PCLbnkf5Zd\r 6/Eb92HhsOpiEsRECOvZigk3oRfWnprBxCP1lWsgnJ3+u7XfM/kYhrz3faLVmPi8I7foHuM7DtS2\r s0fJ9465pDqP457nBI9oJ0jWC9hXj3zkw9tV0zPayeevymSusBDb/NV4U7vS3uY9GzebvWPX5qc/\r /W3bZ5dovnfpj9o3VsnRvJqVgLy57VPHfoGm1gNMC6uGLMc0eTnzuP2gOkfNRtFQllqyt7FwwXap\r Xy9VaS7lmNnpIOYRzA7Fl+VwGlv3qpPW6Q6C91QDE5drfa/zMOqXMg6CwYpfmhTYUWZYNG5ifTd5\r Gha+m2+NCS8bIYmWVxf2GnD3T73Lw7LL9g6FGgTuO2y3Wd+cecJZVf7kp78sdqLsW3jv1j3rxzX4\r sxp77gvWLiwonYqbDpb35RyOX15XyrHIkx5fZlY1aMpZpUqfH+wUkws2gED+DQoRFoKJh/bGBMnG\r U8LNldvv4bxyhICZdAJQplL+9Oe/NJddfk3bya4qBg2x3WwqY37eio3cA9uO6q/9Ee/aYv0ymD39\r aT0tNUe5OoDpkIN36Q2Wb31taUPZtf+/F11R2Fi6q7ZNBZMfYQfVOdMtW75rz3LvPSurQVhb79/2\r o4UFdcbpPQLThXoqhgVfu1LJA6RtKtOwyQIIG9T7Qep4BkE4iiYUEYRbeeWXFzfniLjKJ4I0CN4r\r W/z51/d1Ox+Gs876VknTpsQXL/2C0sbUsT+Ix7n909G6wrqy8RhwFpwrD8In/uS9BrdJ0xiFaF4B\r lV0E+exz/rd56lOeWDgB9n10VwvHH3tAc+rp5zcnn3J+85rVXtH2L5aco3kVtd1ZQ5385YPK2AEP\r 2BUImFFZ0kNNpevGUd9TAf7Y/jPPWh7XiIbha2d+q1lzjd4O9G5jHOU2Ct1wTt4zW4HafVxc3gfx\r Tz1QZxwX3jvsK5pYtd/EOSpc3sUvZHY8bPbkm2E/RYuq/objwC/Dim98/ar9MFZheOXJDz+TrEpA\r GKZIrr7654VFstceW5dOXnfcui6AOrTBrV6t1TDbxk+uecpWJnnu1q17HY9AM1CHNgpSFY0l4tT1\r MIinVtUd5n++R7+42WWnLfps3y6SN4oLbIt186t+t97qzf3BogZ/Bg75xharMUn+Iem5Rvklz+PA\r H0LOJEcdZjrhofarvBRm1lzjVVMu/DkUa7ixxhqf/vSxzdbtxCjtXL1E9he3YK+23ZpYIGCjLAJP\r Bw9pVx+Ge3pTVtsmmFSfTWZYTuhi9dWWbfbZ+73NW962U9vOb2kJ6RItwbm0/a6mU2K5976PjTZc\r s/niMftNPT2AVyCgGGYCEOrtuV6F1PfMNMc/nHf+Jfc6vW4SSPdHP/pF26F7566b7RNmpnHmqlFI\r 2+pglO0fEE8d3s5gbmZq/tyZPrHiqsvQhZkzzaCEA88GOibDE/+gOLjllLhuWcRlFjrINL5wLN1i\r D5k9Jb9l1t6+O/a4rzX/aAlYN011kwkAmMVTQuBu5nx8G1++XRfc3/2uNxXjdTTV5DPfN9+cLMry\r m0DZ+0FC90A4QlAElNDf3pfUk1XNpu0qBQuLsNSeHXES7uuACL0y42vbYEYTCRCK7I1QH+LyDQD7\r o7bqLK2T27L/8Y9/KnH78+/vFEXh5dvzIAhvJaXswJ9yiFuZuee6ymrvaF7VlvPII/Ys5nq6EBeN\r Gwc4QWRw3F3F8aj55yt7oXJWfA3+2Luyqz8q6ilL2uWocli5scF29dXX9tPNCsTzKPCTdNgHw36i\r 2szNOwojs55jcW+Qe6ScwqS9uFo1pF9jsS233ODjqAfhpS/tHSVgtm8/EJM9ddwmbtpdTUwmFcyP\r gzi146wG2EGzMiazUt/dVcJ87UTn0wfvXMacC7/x/bYtrd184dgZzfzzPa6dUCAc9yYe2pdVLM5Q\r 8IBegQBz2/vvt225ryu+bmz1/WZv37WYsQjqd9NBZh5JM/GMu44Df8Cvk+gMRglfY1RcdZpB/WzH\r 7iCBZVCHd1VGGksIiIY+Km1+DaIE9/X3GAfaOVu8e69ZhOHSzyoG7JhmhXgUCMEvnPHZci+f9jCk\r rAaVgz55TNGyiuB9XHkGIflK5wfPVjBYQWRZjFGamRt8bUo0iC255HOaRz9q/nJIFWInPNaWzkq9\r uauJNgrUSE0KstJIXgaVR37tKrayGVfelM2sF7H8TjtIUtO1mspxx+PCB7W/us4mCa8OrSjNjvnv\r uQ+XeQA/CATr1EmDbMuxyIToBsyuteBhEFfiSDuu2/N0Vh611hVlF6vV7oqqjpvQH4GZTv8ZBYSw\r TIDae9MZq3T7SnxPE1JHMXRB/kb7ilbWjPMuaVcfSzXHHX9u87SnPmHKCu+9CYiVfj0hhAc8Aak/\r dC1Irit/1g8/0z8wUjdMY2UcEld9ha5b0qvvR6GOx6zc+ePuzz7nO0WmUZtQGYY6DsCOyYE+waR5\r IeB32lsg3Lj0IfWeNO2B6J2fPJqt5fTHBac2N3oG/t0b+I84dPfmHW9/Q3EfBP7IUpyhwSS1mWIG\r xOT95ltubf77xUsUTR74/BdOL8e9ep/B+IEEedYRUx9rrfmq/sZWyLcw4bDiNZDaI7Xvfkc1r25X\r oINMyNSwQQ5Lpf5eNbCD/qttB6O+ubyl7mp/iW9UWH6syhywxV8dpnc/nniAyZGVJwUNcsWk6f2o\r 9KHrR3mwwGrbcinjuLhqJF5hu+0+boPSHtZHpgusK22H5AIBWXXVV5bjhp+48EJFKaNrbdd+m9/9\r 9sLmLZvuWLYF3H4HhYYftURn3ua2P/E7eNd5WNE1+HpAQ6XjFwLKmhlr3RHqe/43fsvMQ/4RDx9r\r 9mDRNivET504DcaVqQzIDvZJIJw8s5VEkOie2Q2n1qWxpUyD4D3Ej5lwwqmjceED/tKBsHdSvzAq\r vHf1QCye2PYa1TG8C/EAz/75Rhopojrqm/E/45yjyvWee3rzHywxyDdZ77Url1m/PPL3uXZV6t57\r /4c+/EVln4T7E0+cddfwPxvqDjtQ+q9YbuNyBa1HHs3yantayhPQ2MN+Ys5k1ZVfUeprGPGQjr8y\r OspX3F15BcLh+xtI63RqJB712N0AyR2GhYX4CfHIZkL/meHHEw/+7fkh1M+kyzt/96MQtpW6AGGU\r x3kpiR+4/fwXo4+5rVGnnf6QNOrd63XaUBOtOQHBuXaTHSTztpMLrHtmUoxHXeIBRx2xZ1Gbtzqh\r wPPtb/+oecITHtMSj1vat7MSjcCkbhAe8CsQwDdnhhpsfnI2RT5IPlD0tsFHxRONZdRJGtgwfPyg\r Y5oPvP8t/TiSZp6HXceh9u9Dk2O4h+nGx7Q2llIdvnYbFz5+6mV3MCqsDhJTIPkO6od5C3sGsrLJ\r u0HAwqgty6aTMdBoJzZB46TAgmPPCfsIsDOoL9b14t4M3smCzDp4romme+eLkwFkQABsO6yowN4N\r HdAMrxaKw5+njPlhX5kl10icrtKq21Ldtup32Fi/amfdtMRGCc1rCAcpMzVV8oLEKy2rGN9qFPir\r 66GGuLwblh/pWiH+v/93Y1/mVIMG3U03ISaTEY9R98PyEERlmL+csyKcwU8ZEsckcQU16+prZ36j\r CN+78eSbAuOMO2y/WZGd1UcDzAke2a4+6EtZCTxk3ocVNini+tCHPqS58+/33gDo2OmP7b9t2Th5\r 2ukXtO3iyc1vfnN9c8l3L2/bK/9OHpx19bFGOyZ87auDJ3QPCgICdrLGyFj9UeoPXrvX99B9ng7C\r D60bB9QNpc5HfT8K3XiY42BhNhsO5XlUBw1shJuVlzw8b4PgfQaW2mxEzRYbFb5GXc8aqUF6HAjJ\r zSprcxriqSHO7obDURCe2q1B/CMf3qa4EYIbRLosO/V+1VXXtu7/WQaaIHVn13s0q25sJzC0pbAH\r ArM4hxUFwwbcwCxePYufbIhdMOkEef/Vr32jCKnf0q4eJql/mw+p/fKbtsPUCTdHE9PGqr/1MOR7\r J0/2wNAajAZfMCpPdXkgfoVfeunntQTW/prRG/0SR52XQfej4gBWi98/tSG2W3ZtPd+i3g8yDnW6\r afPj3CDucwMfbuPabYo7YxVi74fJD5Vwh4YNwq1/uKi0r4WfvHyzxurLNn/+8zzNtT/7efODK3/c\r vv1H85B57i6m3GsC8u0Ljxm6H+YBrYVV4/fX39S84Pk9AWtmDGYRtQkCxeaW+1obpPs8HXx56myS\r b3/n+0V7RDwaBWOCrMumkaTTTpoOP/wmPvsDonNvoHNgUN6Pis/u+DoeVzNj9WIl8IY3TGb5l3Va\r Mgxx8E+wDtf+7NdF+2tUPpRdGLzpmOP/4rFfLW7qhJVRs9FBYBmWOQ0ztO9fdnXzspe+qITx1xns\r DYAYeqy/8zAIa0Pa5pu9rsx0sYz8ESGDabTzEJNL/+/q5pWvaL8vQnzPPX3bVywA0KffaKO1Snxc\r X9CuaLTDV7T+Wdrlbhe5g6XkyT97G/ItnGZIF3+ZZZZs6+SM5k1vWqO4+9s5HRZWuxRtzj73O+WA\r KWER33XXWWFsWdUJQaqVUL0/AhA6rCOqwty9l+dh8B2FFR+/7tm9ArIHigTaxeKLL1rcBkE6XaS8\r iK8VifKNKlfiSFscdu86Clbim2y8Tr9cdf1wy7f4/DGnN2usMdocfY1j2vpJHsQJ6ix16xqNx4wL\r ELc5BVNK62+0Q2FdGeoRBRqB87Q/E1D13F0ZOBOffIQZqNtu+2vzpg3Watvj6c2Pf5Kja++cCjMz\r 5Oteu1I5zncYHjQrEPAhQr3r+7ohUUvD/4baD3Sfp4PuKgTrpjbzkbgZBNxl5y1mydMoxJ+VBxtK\r 2DAGMG7eQe7Hxdf1b8Zt0Ja3aDiNiifhr/rhtcUeEH/CavzPfvZi5dCi6dSfGV3OJgFxkWP5jzoL\r ZRCSb2wtAyWiycy6HbRXX3lv66LjIL7ft4M8lU+rW0t+8oVt228a2F9j1p166a5cukg547/ec6Ps\r AUWBTx30oaIerG4TbjpgIQCv28oTBsWTfMC4NPg1O8fCvPyKa4rJfew/3wrL2CY0GBVPnR7wG7eZ\r 95MJy6NtFSS8wUpZ2b1ad52ZmyYHIWZKhEt4K9KatcuUCOUBLOTZQfp9kOdBZpdoXdYHoc0JIjgP\r AcESU7ZHP2q+5s9T36qGMeXuO39Q2twTF3l1c8GMo5oddzm87aO3Ntde+8t21fHXIkc1gQoI2y/+\r znF9UcAgPKgISD5EkOf6Iw7zE3Sfp4NxrCysELM1s3AzgknTquOrr6BsZeY0Zd5hXHz8QOIZdj8q\r nrxn5bVekWT5Py78pw7+YmG9BMzQ5BS469uV5JOe9IT+gDoJQTJDzwyum37y5T0zJGd//Yix+RuF\r lFmcQdmz0XYixhOPPPrkcrZDTmS0gZPpErPYO+64s+w8R6gpVsgTlU4rFJjdPAUpayB+8pyYPvfO\r 3hmD/ihruV34Fqlf8THdvtSSPevLCJRJ0bjvJP1BqPNgVdw1JFmj/m7u7USnNs0t8bufzuY7M37E\r geKBVaeJUDBzY2qvX0+CWu6R8N3xB7eCxhkk/drPnILgnLVdK2K9ap55H1bkiL6dA9BsDO2CEonT\r Bs/8+reak06eUSZfn/7MKc3Tn75wc9nlrFkgOmLskQME55CDdy6nTo7Cg4qAQGb4kFUAHPzpY4vg\r FeqP1f1wtV2t6WLPvQ5t43pXYYV0zweprxnQIG7jUMcB3XjjZsAadyRnN476XuOibJC4RyF+sNVq\r w4v5BpN0ikHpCAfC1vejwJ/OGtP34mVmo9Z04QbqP3G7TlLWByLkXzvCz0agIO1KGZXJjJKNLsQM\r 2yJtb5LyJn5+U3eBmbIZM5nPoBMNa2C31rIjSPrixUIct78n3yj5qMMHeZ93k6JuB1CHP+5LZzZv\r 3nCNqafRqNNOnDXyPu/YNPvQ1Nn0s5PvYXhEu/pAIgz31gvRppo5/M8KttGY66GMdMl3f9Astuii\r zdfPuqS59me/KPavHvKQv7Xjgphmrj6Y3vn1L2ZMPQ3Hg0YGEugk4Z2aeZmN2M15x+1/67vrFD6Y\r Z/c2I+bEtNqu1nSReNda69XNl088a6DWhSt/OrI0dPxJ0uJHWDM0bCe8ejIQboG4mAln4C+2pgYh\r 6frL03XX3dD8+Ce/KPGRIyC2609wcE3isPfAqkredA7fQBk12HFlG/Q+Zco1g33qbhC4k5VA8bfy\r Zs3ZZx7e/ybyCcprBRF5gHgf1s7QqDUu+6pN+oeOIcS1OvH9ieQ/f8fqfuELpxcFBrNXMhVyB2X1\r HuF0+JRyWmks8pQnFhacsvMz7puoE99O/Ygv7QXEYUMe0yYw6pja5FubchU217wHEx7q6sPAnzDx\r X4ev48zzKPCjPPU17YBtMwc55V3veNzJWVeD5B7iTRtM3jxTOiDfAuysTTZZp9zPKVZfc8vmJ1Nm\r SQz3Vgq0rXqah+2KuO2bNWgTzjj7yNJ32VizCrz99nuaJV/0zOYb37y4HEcwzzz3sPzeYmbYi751\r 7EQKBQ86AuLD56MBtgIzxdxtGjPQgTMtnjUl6HOqmKVdKkSD9Bdmuug1yktb4rF8v9EMusqfkwyZ\r g/A8SVr8mPURVoZ4iE9eIXGHZTEqTu8Mks5SeN3rVi42ixKGkNr9uDrwzp8/gnGrkLvuvrvsGQDu\r hOsxz5BvMgjYWgSa/OQvD5BrCAmDiINMaATyRJ1V+o6cfeZzVi8zLO7Cs9/kHaGmOG+ZMkWyUjsg\r uyLuTmnk/4M7frwoLyQ/3mMH1OYa5gZS90kj+TOQ3zmlMBHBtfYsP/JJscGkAa/+b1OaYHY7O2tF\r e+DPakHcoyDdpNclHP4BszT2oIh7WJyIM9YWJQPoxuOZtlzss40jHpCwaeP670orLVOExc7JyL6P\r URAu4bvXpz39yWUvjPaRwT9WcyeBOBKuKyy3WZkwvu4Dhx1+QrkXbm4Rj73b+I9qx7jwH7RTdUPR\r w9hfyy+CfffepllhhZcWM+4XXfyD5kM7vL2dIFzYPl/QTlR+18w/3zzN3+60nplJPHbdeYtm/TdO\r djLig46FBT6KymOPB6gvsovDvV4u10tIH7decs7uyYXQlYX03GbOnuI+yG0SjIuLYDr7GyaJs/bH\r xHS0arh1T5wbhToe95ENcJs0L74D1N8ibmC2zeAhzaHazySggEAt9kvHHtBnVSZfrlDfB3GzN8Rq\r C3/YrJoSgA2KYQ/VyEABMSMC3JkHWWyxRco58TVLKW2wTp87NpxVZfIRv0kj7tNhT4EwP2zbCrlI\r niHxxfBj0pukvrtx5Bp4Vp5xtuGg3tOVuGJk1D1wny4LzJV6rslk8la/m47Mo4ucVfKZQ4+fpV7F\r 293fUQvS5way54PgnOpEyIXV4iC5x0v++wXNdy86vtwv/pw12vvjmq3fe0Cz6KIsDZ/a3HbbTYUt\r XJt4pzzjpNBJ96k86FYgYIbD1HI6mM5rlmMmduhhx/fdzZIyi+IWthI4ubDupNMBc+/nX/DdwlbQ\r eDIDqxspod2aa76qP1vhx0zFGRPjkPgSJ7C9ZLb/3e9d2bx6Sr2Wv6Q/CvEnPuwscX6/7WC0XNZ7\r 7Up9S7Pej4or79Ub4sHcePJHaYAa7rj69N5fHBkQ80eMXr7MUsUAoOdjjzujsJ7krZ71DQOV3/Dr\r zdIXf+bTmndttXcxOpi6FBeCoBwMG8KPrvl5IciEogwoAnVtcfAnX+Xa/h0R4BRJlnpvuMHO3aao\r 2yq/ne/gFL+1115hlvp0L07twr6MwHsTHbNbeYOEUz9YjVZI8l7qaCq+cdD2nX3NRpR4hRUv5PrK\r Vy7dr9dxdZv2wc4Xo5Py4TlxyZ97O6zH7bJOXAh0vglwY5BQ3Nx++9vrCwuPivQo8Jt4XCHm/AHx\r YX/KOyu5DTaY/Nzxeoww8Vp+ud7EMTa3aCZS5+aPbLH2f0HH2vOc4C2b7thc1hJXQDgynXn4vIOJ\r B6LyjfP/p6zQteu//OWvzfXX39ZcdvlP2/p8dDth+Unrflvz19tnnmVDlvblLx04Uuuqi9HS2Acw\r ttt2034D0TA+st+R5b6e4XH3QYO4B3PycVdsl4X2oNQNt746EtUyts4PsyrdPIyCzhP/VHLh6U97\r 8ixlSnqTgF+DEv929nuOFknej4rLe1BvypVnYchVQPwgzjqfXQiPDVX76w6O4VeL04l28TdJednS\r YiCwNvORcOtvuN0sncRKFIsElCkadIOAnYR1YzAhPMamcV4+tmK9ox5/HVJHYMNa2H+Q+sZKSTkB\r q9U7dURAWscxKeRF+LRxe1zEn7iSFj/jIG8JF2WKun5oNvWe5yk79EehjgsST+1msIdwGEYh8XXj\r ZQEgqxYTBqAE4/S/SXHwwV/s14+2R8uyi9hs408e4t8m3EnqdhJgXdk/lMEa8YiMatBuc/j0p3Yq\r bdVhUlu9Z5/mbW99XTuhskfpP5oDP35cu1q6te372LQzV9YOOhtUxlF4ULKwgppFBWlEPnb98eKO\r DeHMEEd9Bl2/0wGB1MUXM+g2q2rvJNdJ0PVrD4KzlenIE+LX+Tagjfv45BDvfc/G/XgH1RNMkj88\r buqK4sB2YgSyW4/TqVt+ofYfN4h7zFBkv8906rMLcdUrGyq6NvEhICH2OcIYpDtudpY6jPXdPBuw\r pZOBO2nObt6DE086u525/66sOF74wmeXwVfc3XgZIWWSf9LvAbQNqSAnrpTFd/f9uaf+cx2FhA/4\r j2Xa+t24eALsRod3Je2oiIvTuR710QV/v+vudoWwzFTI8UhfE75ux7l3TLK9THW58652mxt4xJTW\r VZd1NQw2u151xanlftXXbNGcfuqn2nZ3WUuEzmpO/+r5ze23/6V5ylMWKis8Qncmesj8GFicLh7U\r BATqj1vzHM87/+Jyyh/UfuqNekH9frqwmWulFWc19+Ee6mf3ScfgP6mQChviLZUQLnHXRIQK5bBd\r 3l3odAT1yRueM/U+8SSfScOsmm75OLCCa7Y/CMoM061feTDYdg80insdX+q1VuWeG6DlZF8IhABM\r F2bR9cpkbsIsm2ICJG+IueNyyW5qQpJvmudR4De2syBtoo7L7NZueyyycXEmbajjinvXbVx8YPVn\r Vd4N56rdzrpSGr15cRDSphBeLCBxXXopwrREfx9KPW4k/dptbuBZ/7l68/Of986VmWSgplzxwx+c\r WiYvCOphh5/ULL30c5vvXWqv0m+bE758XttX5y3fNhpbVjNnnXlY0fqbLh6UMpAatSop3rkPqOM4\r 7AZP1TvPPrB7fHKzTuq8WdrWcUwXNGZ6Qrme7SgdS7qeI/PwbPWz1lqvKjuTo/47SZo2U6VMIAxZ\r iEbt/rLLf9Q3CugZQcCfHwaza/74Z95imZct2Y9bvfRqpNepJx34mEZIHIH4xReYFTLnMYzQdCGP\r 4vzoAUf3TaqoB+7RhpGGuvVM7dls2fNPr/1V0Tqr6212gL0nveQl99P5j9uzMwkQeJMFLDDacKlb\r B0JJI4dT+WZYXmQ33PzTtvMfBSsyG/cQy9j6sqolgwHhpS2dyy//cZm0jIsz/n0X6F69A2VzkFee\r R8EOcwPkLbfcWlT4k4Yr4X0mSJ7nhHgAGUfkU8zXAMKp3LQ7rTRzgJRB2QFk4+pkUtgwePJp5/c2\r C7b/SQjI5z+3T2F9Wz3tvc/hzQe337wltA8v8s7jvnROs9BCD29+89sb2rh6sT2pnYhu9OY1y0Rt\r dvCgJyA+Vj1QqGhsBwP5RRdfUVRCQYP155/frd+7T1HFBW7HfelrxWjc7IBQHREx0FElxlpx/kK9\r xP2fz59a7C3JA2Ky1FLPK6a1J9mLIL9kPOxFATaKPLN9c9ff7ypxpsMQQupgTgocBeHVEd64k/Pk\r l+Vb7v4gvhNPOqekEbdBqAdpqsszZlzULLDgY8sMPiAnMDjVfidBrajg+sY3rtafeUIGHPnX0dUF\r wvfDq68tp8t5Ntgi9NgSaQMPRChT8qdNZ/Cnv2+wjtYgN/XoWt+DOLJaUh9xHwVn4ht0mQdZhUJA\r OwirV/XmpMC6fQGW2bhBmV9pC+sP4khcdZzO+aecMEle+U+4LvGA2JLrPU+feAiXCUoIiQ3LNg7H\r zXvXqAVHoP6xAz/XDzun8C223GrvQjxqofkoOKJ2v4+8v9y/Y4u9ijruH/5wW7v6uLo5+JDj2v54\r Y/PidjXyi1/8pqw+Fmr7KA7D+ef2DmibHTzoCQhYghkENUB/54foQIiHD5wOptGmkdpn8OvqGfGI\r 39lBj4h8r8+XX2edFco1jZmeeJ7JIqSDeHBLHkYB8aCaauUUEL6mXOmkOn0a+CRlUW/y9LznPqOd\r PfXOGxeHsFf84Mdl413yN0leEUlhL7zwu8UImzAgHnUiX9xofNCkm0RQmjTFS+3YVR4ZOTTDF6eO\r Ll6Dp/L/bspgn3rxjHiwFZRd+MJngPZct41/JqRlgoM/nzTlX14CM1wGLDMYUUc94YSvFz/CJO/u\r aRs5P4Uw36r0+c9/VqmfScriND9pzTjv4hJu4ScuWDTr7Hy3UpdXcUmHLSx7qdSptj4KwvEXQia8\r Z+7gOVdcAPKKcVDGywaoOqujxCueG2/849SZJ7NHPMSb+/SjWImOW/dav5tbWGKJdQrhwANAPMYR\r ECvG8845qoxrVPUdyb3IIk9ofnTNr5rrrvtdc+6M/2sJ7lPLpNq+I9B3TjnpE9PSuuriX4KA6JAn\r nXxuXw6g0fqgOlEGCXDFJ7eRLqwsfoN0ykk63yAIe/PNtzUvf/mSJf26sddXDY3wk1VXaSWv44B4\r aNB1nkFYZRGv5TSLqc9avLc7eFx5vLMiYlI9sqHEf327gvDeMv6MMy4s9/PO+7DCBhsHu5mVy8Au\r vs8fc2oZLGhWYTUSQhL88uOv7rvfYxDy3hUxiaaaZ2VNx1566ecXomGVJt/ehXgAf6mfgD/vucmL\r 86Sd6+HZO8j7YX8nvNHAck+1/KKLriiE0rdDNJxbHbaWWWAG6uQHqNemLfrT+vI+5Qh7yt9GMmxO\r rCvsk3Go8x+7VOLFnsHvp7lkRWLypU75d6b22mu/ul8Hw8Bv8uif8NoUOV02FnpXX8dBHPaGUNM/\r 4siTCitU2HxrEA+5hzRsqAvbczpI+cgOXvCCZ5e4pQHSZ+wU4k8e3KeMcwtvf8duzffbtqsNZAUy\r Docfuls5s4Zs6PVv/EBzxGG7F424u++6q9l1jyPatozd/ZNyVg1QFqHezlr1nGDOGbQPEFDrNbh2\r 4cPW7tlXAAY3WlkBv2ZNswvhczIepGENulr2Jh/cBuV9EOTZSgQMSCCezMBtbiLaMcgryyRxG9iF\r NxiLk39xXfLdKwtBoqpoMBDXqLPWa4jPX1z+tL/w0wkgk/+AaqvVTsowKWITTTjA/xbe0brus0nu\r E5/8Qr/eXcE9ecINN95cjknN+0CZWUiOjr134+rRWdI2qEY4iT2ASBrgoxGEkKhnCHsuAy3wYz9N\r 8dv+wXekxw9YPfynfuNnUtTx5pumzSsvxM5bZHuTqL7yzy9FlsQfeGdyZ7WpHLXwexxykiBgs9kc\r F9R1lviUZbrC4MQD7mlyRfMOEKaoWgfagvRynVvYp43v6HbCkYF5sJLurNhhu7eViRls/d79mjNO\r P6S54oqftv336mbbHT7RTljuKfmPOO65bbsn3/vIPu/rOcwBHvRaWDV8YNpJmSn4uBlcnEeByAB+\r Of4lEO6asdcHH9XhZgfDdqp3tUPqK9SHZo1DN3yueMAGruwGjsZInc4oDCu7jmnAcRVXkEFoHMiY\r zLxZDADp1OimmfzO7reo8yjP4ohb6mvUPYx6Nwq1X5vqog7Krb4S/FsN17vQrQqoh8sz7TsKE1aI\r 3k8X4hOP768d+FZWGHZ/B1hg1HVTx718z9M897n/UQbSSdAL04OVEBZKVLuhLnOOLZgEBnHcBefK\r bLzR2v04uldt680bMhnU63fTQeIYdp/r2ed8pxw5Xb+b03GiC/GutPJmhV1lrKeyO25wXnnFZZpz\r z+7tgcOOPuYLX222bwnKNdf8sl2N3Nnst/9xzQ+uvKJYxzbOgUn01884dKSJmUnxL0VAoPtRuw0h\r qJ+33f6AWfaGwJw2jsSfU/3iBni15A1Jw+w0s9KTTj5nrPXTIPFlgExHC6hYzj//TLbGNdf8vAge\r J4G4xRuiYebLtli0wma3boSFhPfMonJt+iJ+oE6n/mazA+GZxWBCI2VL2wAEzhkeUXU2U8YSsHIy\r MMbfOGQlB4mfYN8MPGVIXO6VV16COS1jXba41SZNIPnIPdzyxz+1xGb0GRtBwmDh0N6C7t6Xbvww\r admSv5Qlz7la2anTme5zj3ikfXevUOcDEmZu4GHzvrAQjez3GAcWAX7zyxnNk5/8hNJOd9vjM+2q\r YpsiC6P6u+Y62zQ777hpMc//uc/39oUA4fpee2w99TRn+JcjIFB/cFpRBLhAQwh1htoOjxkewXt3\r sII5aSDdlYgrdknPCuisjTV+oJ7tTAIsGofiGOSxnPCBmXemtZP4Y8OnPs9gHOzOrs9PmJuQrxrd\r ujdwxA1R9a0MJPjg9eaxuQFxQb4RSB9Yo0WIIemREVgldFGHB88pZ74xxF/im1OIaxDRiBvU772z\r MqLp8+pXvXSqric/ez5typ4qbDhqxiwbiJdJGG1QOjYbPv/5zywrkUnLKg5IPutrkGftPPKk6aKO\r 014ah0xBypZrvZ+McB6BBCr6NpvOLTjzhnwMEJBJWFc//uFXixki2GW3g5sP7/WeohThLJL3bPPx\r ZuGF5yt1dNTRJzd3tO3VGIGFetCBHyxh5gb+JQmIxlEf6pLGMOreIIHAUGWdafpg5vvZRc4QoSNu\r c1Yabr2Lvj4XO416OpsNIWFZ3WRG2iH/j25XOTU0olhxnU7ZEDSDJnYCcwcOSwKz8tVfs2wZQAJx\r Oup3usI5m+IIAUHeaB6ts/YK5VnZQL7dG/AM7HTvoa63fzbYXbvqqp9OPc0K39cAel+BvGHZtp2n\r 7PZ/mAwtsMBj+uyn1B1ZD7lbWJyzU2cJQ45BuSDfA+p7q0ks1GDSdBJ/4gnihlhEED/T75ytPGii\r pZ2lT3RPG4X6fm6MCzXs99ilncAihQbjSYTmn2iJQGRTe+51WLvqXboQc9+XReXTTv9WO6FcrPnY\r gZ9v/nbnnUUgj8if9OWDSpi5hX8JLawuLKsJajP7ctUAuEe7xT13jcEVuwIRof7pXcLl/eyil/al\r ZWBJI8Rqeve7Niwb8JZ95dLl7PK8Sz7xqh3cFNbWOAhjVkwdWRz0+bn5G+AJRq/77fUlDQMwDYxJ\r gXWl3l772pUKS0yZPBPc2bTYK2Ov07vaFObqP2nd2RQHwjBE2Jsd98LSiEpZYMEFHlu0hnwb+VCm\r 3PMzp99sFKhJJi/df44L+GeArO6oo0/q17U62fYDby3qre6VXTvCoiMgjR/5KuEvvar4ue22vxRC\r k8FwEpBF0GgDfSdnmuc57dbVM1mfg5rIGZP+OCR8HU+u/oB9mo2U3pl45cyNSZGwuc9KX1/ceact\r ysTt7Zu/obwD+bdCocEHxhWTzLkFdq6cLmjVMQnhgNe0eT74UztNPfXKoX/fdNMfi1WIz/7P15uX\r vuQ5zQUXfLeog8Oa7YSLssqk32NS/EuuQAIDSWYKdcOp3aF+ppX1sf23K/dB1/900WuMPb305CNx\r 1vnK/ai8joPBIctaqOOCLu8YS8u19jMJuvEGMTEh37GZBNMpQzfu+pk11Ry3GmUIFm6d3ww9dkzv\r bPrlOntMplvG+wspr2tA/ZIFAysMK2QWDczG4eJ29fbBHTYv/mtW1dxA8lDnJ/f11Xdmgr92mwSD\r 4rR6HnZYWw9IoTDTW3lYPcYsTuKEnLBJqaFW9fa+7n91mLkB8UVoHrnHOCLymHZycN2vz+/LDNde\r 9z3NV087uNzbmb/dDp9q1l7rFe0q5MzmpK+cU9zfvtnrytEC0+mDk+JfmoD4QGbMYXXEmCDUspG6\r wZg9f/wTxxRLsUH3jILZQS+NHhFhxTfmR8SZK0SIXruRz0xn1tMlTq4G9d9ff1NZxmKfMbHyzalB\r qPY7CcRfY1TDJGClVotFBdNtxDVxqOvKrNgpi+Q63GjfPfOZTytaTJ7HIXHl/v5AyhJCmPxQudTe\r gkF5rcs4iGh4P7vEpI67mza5mFVP7R4Q5lohTIrI47rxJO7B1+mzrCDhu/fpKzkfyDvw/p9JPCBC\r c6yrSVYfTLdf/n8nV1qmPfa4PuxQKXKPRZ782GaZZV7YvHvrDxdTRdu+/61l9TjjnKNKmLmNf0kW\r VmC5Rni81FLPLc947BqFToXHHttV/FnuczcA0TX/8L6H9zcjYdNYRs/J8k/YXhxPKYJgKrsZNHod\r o8e6wuqSRxuYNAyzzfr9JFAOWkA2mjnRDmgXsYeDP/6d/72st0Gqnc264pvK0ymnzJhIxVL8ZWBa\r /r/7Z5OAfMun4zURaH7YvqI4wB1YCp1kw1vggBvl9jd4APVDg+wX24FXGsytrLvuiu0s+PvFX83+\r yLWG9oBlkfo0gKsL/vLPO/n2TN1V/LWfYf9u2Nq9dgMsBmeypH7k1zEAq6++XGFjJlz8Jyx/cf9V\r S0yd680sTdhZ3qub5GUS+H42T1IwSb3VacmjujeT90ze5mwUaWpH2GeTQDysQLylDWNjrzNPkk7S\r hLjx7+qQqGUmOE+ni4Tv3odA2NT6pg16e1/A+7yDOszcwiMftXRzVzvo+1aTsq8O+8xufZYbucer\r W0JKLglnn/Pt5tprf9t+v8Wa3fY4pNiDszGY4Pz442budZvbmD0VhgcR8PppTAQ6VRrKQ6eEcqCx\r aDRAxZZ+9a6795aGkEY1JzBzOuror5R7+z3EJ940UBofkLwQGtaN2kpoUpCdvPUt65b7Og0DejpG\r 3AlVpRcV30MPO6FcxyHKBoF4/a2wQJypM+7K7CS3uE0X6k+e5ZegU5zyHy2pwMwLENBBoIEkLE01\r cHJhkDKJN3UP2bU9CeqwNOMC2kmgDEFYJrUbtWErqsAeDu99U4TTPVZWwlmdWmG6V646rnEQB8ID\r wmYzoZ3j4vFPedxbZQSOvqUaLtykMFiLB9tDnKwnJ+5cIdf6XY6rng7CooXEFQsI8q0txmYdeM8t\r ZcqZP3MTq6yyeZm0aWkG4Ek0rg7Yb9tyJg70JlK9vUHaK67JBRde2bztrWs2V//oZ+WbgP4/OxZ2\r p4N/eQICS3eOtrS0z/2ZX/9WuYc0KNBZF1u0Z98q8F4HmBO8ffPXNXvt3duJnfTkww526oJJv36X\r PBCQmx1OB8JTP3SlHw5Mk4hT/LUtKqsP7u/acoPS8WYX8u4fhB1jkAvqHfvUQVPuSUFLBpRLWjrV\r c5/7jMKHzy7i7E/gx1nurpD6nH++e5+7nk178RvU7WASRKBOYyvxxTz6IIifH9ealQKUBsCqUhug\r LfjNb/7fvfI4XUiDTMDEJeklr4svzsr0TMKRvOU51+nsK7Kr3GBt5S9s3Ov4utfaz3QgjH9U1ut4\r EUz32lyv7cwse9yALKbeYDw3QONqhiMl2ntEdJL9Hru3E4RsgoYL27YetWvtfa1139ds+/4Nmt/9\r /qZyVK3jaF+/3srt+LVIYVn/M/EvLQOpUTcMqJ/ZKnrbpuuVe9TcUlljMljv/7HPlk039RnBaYxz\r gvAve/e9vHSvkLQGuU0HzGO8rDpwqg6fcw4CaRUW1RyWMRAfJP/AzUBptg3TlfOMQ+oIb/v5z1u8\r EBPP9WBhJprZd/0OUvbaf/1+FAbFNSie3LtCBNEzMU+7ElmoELUbb8RWmj7vv4a0sGNrK7ZxB8/1\r t88+oGH5nRQIx/JTYaGOR9kQRqwYhL9+NztpQZ0OpO8MSt81Kv/YmpQRoN4bMrdA42q3jsbVuMGX\r kdNvXvD5PnvQEc2HHrJruQdC81VWfnGz6NMXaVZd/Z1FC8sE0HHNRxz2z5dO/EvLQGroFOkc3ef/\r Wup5/XusCrxXPG/2pF64RDvjO/Bz/c1EgP9bxzU76KXfsxrsT3hup3Aau1k5Q3vSMvjlABuz0VqW\r Myl0EnGFrxzg/xvIpZ89DDpVjMiBtL411eFmBymjFRD2U9zuuOPOwpIJIoeCOa1fZQVn35P7eI5Q\r ucdn/10ZsH79m9+X09hSN0HCu8433yOKocGAmiqZkXf1PyufxKO+uIPJCJP2nvM+9/JCNuYgKGF6\r 5tJ7Vm8XXnjBspoZZwF3GHzLyEWAkcvcS7ubn7xz/+lDjiun1THuGL/+kwLhwEZUFt9Tm9K/atMt\r Sd/xBr266OWFHbN6UjMpQhjE61580k36ca/zFFYx686JI2q7cwshHlYeYfuMIx5WEN/+xjF9dqbx\r 4oD9ty33sMdeR7ar+oe2q6Rlmn33O7IoxRgnbFSe2/s9huHfhoCAwaMemHSWdIz63n+ffQ8v/sqh\r Qos9tZg7qc08sCiLD/+KdjCZXYh/348c1Sy33NL9fSIatCvhtKs8EfqanW6yyTrlhDyDwPbbbVbe\r 14PuJEgHclUX0UrDXuGG5WIDY+0HJt29PgqIB9tOBmxAPMSv7jOg4KtnoxvZhhlw/c3mBMqTqwHZ\r dckX/Wdbxw4fu64IiFnxzYCOLaaDOlc6MAAyf33dddc3DkBy5onyyDP3DIDQE7xfVrSWEP1eOv+v\r KG44A4PJFCzEEIfudXaRdqFesajUubIxNWJXuHLXgyzUxPWyy68pwmrhY83Yf1KIk5DcqoMw97dt\r +sKLm0zIRCKyFm7yYrc0dkueJxXI18B21X/AasLeorSruLNFt+yyL57FzT1/3fu5Bccvb7X1h0t9\r Ih7YVpOwfS773onF6gJEaJ7vwDLDj370q2bzzdYpGlcmgEwkvbIdjz550IemJbObE/zbsLACDQTS\r SJgx3/YDPf6igapms9g0FAGrQYDsoH7fjWt2cdrpFzQrrvDSotudBlzHnXzVu9PrvM5uo08ctLPM\r cmKUjrtNR4TNAZmFXehzA+IHabvHPshRxDYQrrvOisXdzFD9O0wLoU691Nf/HzORNgPf+vb3i5UA\r mwtr8EPWVQvpu1D3iMl069eKw2CS7+P70f6rvxnU329Wt9lT0YXE173PmetQpznIb30/tyDOVVbe\r rH+m+SQCc7jmqtP7KtFWHkhO+ju23y67HdHsuvOmzf+2BHGNtd5VJivOfCe3jZXq+wL/VisQQMHr\r WbuByUfmzi33QE01zwZ36oufOvjYZoVX9zSBuFuimzUlzOyAeWWmQsK6APH568waDpbWWmu+qjw7\r PIZZCst8g+/spp06iGHHnCfOvZb5eOdMivgHGxaxOGq3SYGFQQtFWH+rucAZJN7ZYaz+4dZb/1xU\r g5Uz3y517vuQE5AR1AYZ/9Wh3HU79mwVoU4MPGussXzf2mr8mgGD2Sr2iPMifFvu6lN7MvMX53Tb\r lNk/tVzhxGl2j/WaFYU8uLLV9LOf9WzBMYnjhEkrpMiopgvxJg1gFy4Wn71jsQCSJ+wdq0xIniDv\r 5ybIUpdfbuPG8U1WHpOo6sIJxx3Qtv1evmjDMYxYE48PbPeJZv/9ti5yjjXWflfhXlDvfUK72pyb\r csRJEHbcvxV8DA0t0Ih0sNwf84XTyz141riAvr5zt53gFuhs0eqaE/Qa8j8KoQCNG+TVffakeMYC\r kCeDfPxB8jld9E5wmxXi8jeDg+QDdPaYAI+/6YAGlbDMfgficMiWekCsAmkinIMQgbM81oNlff1X\r gjqyWgx6baZ3jGsNqrbKz3+3HoRR99hoENke90k1qmrYi8NyMRan9Aya+oR0k7/kAcsOKw9bjdtW\r 796wvV5aVinxOx0kDX+TO+lbOXPPu9yn/dqTVIelWi2c93MbL3np+mXFManMA/beY+tZbOCdO+Pi\r Nm8zicKOOx/S7LbLZoV1+ta37VxY7Hvv+Z7mnntmrlDuS/xbEhDQ0AxYAZ1pDQmcw5B7yFkEluQ7\r bL9ZOaOa6mM6sw9X+59daNAIhSVrGn/cA240l9IhvJO2e250wKebFxZGhTXbgYTnZvmf8kU11Swz\r bpD76abLGGOArVLvk0hcTperkbT4ibHMIPWVK7jPsz0oD3Qkryl/t0xYTwZpyIrC1hX1oW5qc+qB\r dwb11FdtSZgMxvvpArtKOhtvvHYhDO6lT3sp8XFzb4LlGivKvb0xvdzPLZYV2V3ahhm5d/YzuZIh\r YsG6J7tK+xGO7E+4uY3sModJVx87fejts7CfVlhpszZvM/co7bnXUc073/7awv349GeOKxYeDjl4\r l2aPtjxd80v3Ff5tCQhgA6WjQmZOQC5C5gA0bsA7s37mAT77uVPajnN9cYc03rkBMw5ESiOv40yn\r iZt7llGlHXezyNntEDkSWL104/AcLa2Am3/yk/s6z5PCrKubJtgIJT7lc2BOjbgHyR9C34W6q1lc\r nvOtXRGvPP8zgVVZp1vfB1hJYFY9CNlMCOqgFvJnf433rD076TFxs/Xkfk4ErPt95MgSBwE5uJdW\r VuHOD8/ADd77rskDwmEQnxPCkTTz7N4/aZnouKfO6sqUB/mdeyystNNYeZjbCPFAIieVeyAeH97r\r vVNPTbPhRjs0F5z32akn3/noltgvWcz1nPyVGUV7cu89ty5yywvP+9yUr/se/9YEBGqikcZkX4Sl\r 4ZPa2V79jtE6sJnrkIN3bg4/8sSidx1omIcfPtku7nHALqOpks6n88uDhs8N28Z95BfAvUbcpwsD\r sbDd8PIxKE7p+tf5GBR+OuiWBajJysOgd2CFoY7qjWoBFtcgVl2QsxhqSMvfjD33+TNmaJ+EAan7\r zh/qd4HNjjX+NLW5s0bkTzH8B8qTeu1uSLS3A7D0qIKn7IiVk+gg4bv1MgkokJBxaOsfmjoxU5nE\r ZRbsXtw2OAJzKHlP5Tn3ZB4Ix6THIneReFKGPA+7r/0zHZR7xxPI76SWrqeDmngYXCchHlu132yf\r vbfpW0Gg8fmlY/cv93D4EaxX3NMsv9xShVAfeNDnmz1336q0vx2njoS4f9A0/x+YR8Q3Yw94KAAA\r AABJRU5ErkJggg==\r ",
      id: "image3179"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, undefined);
};

_c = Avatar;
/* harmony default export */ __webpack_exports__["default"] = (Avatar);

var _c;

$RefreshReg$(_c, "Avatar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Container.js":
/*!*********************************!*\
  !*** ./components/Container.js ***!
  \*********************************/
/*! exports provided: siteTitle, profileName, description, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteTitle", function() { return siteTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profileName", function() { return profileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "description", function() { return description; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Head */ "./components/Head.js");
/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Header */ "./components/Header.js");
/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/Footer */ "./components/Footer.js");

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Container.js";

/**
 * Container
 * @description Main Container for the App
 * @author dtro-devuk @github:dtro-devuk.io
 */




const siteTitle = 'A simple Next 10, Tailwind CSS app deployed to GitHub Project pages';
const profileName = 'dtro-devuk';
const description = 'This demo shows a simple Next 10 app with routing deployed as static html to GitHub Pages.';

const Container = ({
  children
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    id: "container",
    className: "bg-gray-300",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Head__WEBPACK_IMPORTED_MODULE_2__["default"], {
      title: siteTitle,
      description: description
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Header__WEBPACK_IMPORTED_MODULE_3__["default"], {
      caption: siteTitle,
      author: profileName,
      description: description
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("main", {
      id: "main-content",
      role: "main",
      "aria-label": "main content area for the page",
      className: "flex-1 p-3 overflow-y-hidden justify-center \r mx-2 sm:my-12 sm:text-sm\r md:mx-8 \r leading-relaxed\r bg-white text-gray-700",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Footer__WEBPACK_IMPORTED_MODULE_4__["default"], {
      caption: siteTitle,
      author: profileName
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 19,
    columnNumber: 5
  }, undefined);
};

_c = Container;
/* harmony default export */ __webpack_exports__["default"] = (Container);
Container.propTypes = {
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node.isRequired
};

var _c;

$RefreshReg$(_c, "Container");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Footer.js":
/*!******************************!*\
  !*** ./components/Footer.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Footer.js";

/**
 * Site Footer Component
 * @description footer elements to be included here
 * @author dtro-devuk @github:dtro-devuk.io
 */


const Footer = ({
  caption,
  author
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("footer", {
    id: "main-footer",
    role: "contentinfo",
    "aria-label": "main footer content info",
    className: "w-full p-3\r flex flex-col items-center text-center \r bg-gray-800 ",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "text-white text-sm md:text-1xl lg:text-2xl p-3",
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        children: caption || ''
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 19,
        columnNumber: 9
      }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        children: ["Copyright ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
          dangerouslySetInnerHTML: {
            __html: '&copy;'
          }
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 21,
          columnNumber: 21
        }, undefined), ' ', /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          href: "https://www.github.com/dtro-devuk",
          className: " font-semibold\r text-yellow-600 dark:text-indigo-400 \r hover:text-yellow-200 dark:hover:text-pink-400",
          target: "_blank",
          rel: "noopener noreferrer",
          children: author
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 22,
          columnNumber: 11
        }, undefined), ' ', "2021"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 9
      }, undefined)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }, undefined)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, undefined);
};

_c = Footer;
/* harmony default export */ __webpack_exports__["default"] = (Footer);
Footer.propTypes = {
  caption: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Footer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Hamburger.js":
/*!*********************************!*\
  !*** ./components/Hamburger.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);



var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Hamburger.js";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Hamburger Toggle Button with animation
 * @description Toggle Burger button, open and close animations and aria support
 * @author dtro-devuk @github:dtro-devuk.io
 */


/**
 * Hamburger Toggle Button
 * With animated Open and Close, animations courtesy of Johnshu, see readme for attributions
 * @param {*} param0
 */

const Hamburger = (_ref) => {
  let {
    open,
    setOpen
  } = _ref,
      props = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref, ["open", "setOpen"]);

  const isOpen = open ? true : false;
  /**
   * Show/Hide the Menu
   */

  const handleToggleMenuClick = (event, open) => {
    if (event.ctrlKey || event.metaKey || event.shiftKey) {
      return; // let the browser deal with the click natively
    }

    event.preventDefault();
    setOpen(open);
  };

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("button", _objectSpread(_objectSpread({
    className: "hamburger--spring-r ".concat(open ? 'is-active' : '', "\n            h-10, w-10 fill-current\n            p-1 md:p-3 ml-3 mr-3 \n            lg:hidden lg:ml-0 lg:w-0 \n            text-gray-300 hover:text-yellow-500             \n            rounded\n            transform hover:scale-125 hover:bg-opacity-50 transition ease-out duration-500\n            focus:text-white\n            focus:outline-none"),
    id: "hamburger-btn",
    "aria-label": "Hamburger Menu Toggle Button",
    "aria-expanded": isOpen,
    "aria-controls": "{menuId}",
    type: "button",
    tabIndex: "0",
    onClick: event => handleToggleMenuClick(event, !open)
  }, props), {}, {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("span", {
      className: "hamburger-box",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("span", {
        className: "hamburger-inner rounded"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 52,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 51,
      columnNumber: 7
    }, undefined)
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 32,
    columnNumber: 5
  }, undefined);
};

_c = Hamburger;
Hamburger.propTypes = {
  open: prop_types__WEBPACK_IMPORTED_MODULE_4__["bool"].isRequired,
  setOpen: prop_types__WEBPACK_IMPORTED_MODULE_4__["func"].isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (Hamburger);

var _c;

$RefreshReg$(_c, "Hamburger");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/HamburgerMenu.js":
/*!*************************************!*\
  !*** ./components/HamburgerMenu.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\HamburgerMenu.js";

/**
 * Hamburger Menu
 * @description Opens and Close based on properties passed from the associated Hamburger Toggle Button, see Hamburger.js
 * @author dtro-devuk @github:dtro-devuk.io
 */




const HamburgerMenu = (_ref) => {
  let {
    open
  } = _ref,
      props = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, ["open"]);

  const isHidden = open ? true : false;
  const isOpen = open;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    "aria-hidden": !isHidden,
    className: "block mt-2 w-full lg:inline-flex lg:flex-grow lg:w-auto \n    ".concat(!isHidden ? 'hidden' : ''),
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "lg:translate-y-0\n            lg:inline-flex lg:flex-row lg:ml-auto lg:w-auto w-full \n            lg:items-center items-start flex flex-col lg:h-auto\n            transition ".concat(isOpen ? 'translate-y-0 ease-out duration-1000 transform ' : '-translate-y-full ease-in duration-1000 transform '),
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "/blog",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "block w-full\n             md:px-3 md:py-2 rounded md:text-lg\n            text-yellow-500 hover:text-white \n            lg:hover:bg-yellow-500 \n            active:text-white focus:outline-none\n            transform ".concat('hover:scale-x-90 transition ease-in-out duration-500'),
          children: "Blog"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 33,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 9
      }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "/about",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "block mt-1 w-full \n                md:px-3 md:py-2 rounded md:text-lg\n                text-yellow-400 hover:text-white \n                lg:hover:bg-yellow-500 \n                active:text-white focus:outline-none \n                transform ".concat('hover:scale-x-90 transition ease-in-out duration-500'),
          children: "About"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 46,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 45,
        columnNumber: 9
      }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "https://www.github.com/dtro-devuk",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "block mt-1 w-full \n                md:px-3 md:py-2 rounded md:text-lg\n                text-yellow-500 hover:text-white \n                lg:hover:bg-yellow-500 \n                active:text-white focus:outline-none\"\n                transform ".concat('hover:scale-x-90 transition ease-in-out duration-500'),
          target: "_blank",
          rel: "noopener noreferrer",
          children: "Github"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 59,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 58,
        columnNumber: 9
      }, undefined)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 7
    }, undefined)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 17,
    columnNumber: 5
  }, undefined);
};

_c = HamburgerMenu;
HamburgerMenu.propTypes = {
  open: prop_types__WEBPACK_IMPORTED_MODULE_4__["bool"].isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (HamburgerMenu);

var _c;

$RefreshReg$(_c, "HamburgerMenu");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Head.js":
/*!****************************!*\
  !*** ./components/Head.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Head.js";

/**
 * Head
 * @description Site Head modifications
 * @author dtro-devuk @github:dtro-devuk.io
 */




const Head = ({
  title,
  description
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_3___default.a, {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      charSet: "UTF-8"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
      children: title || ''
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      name: "description",
      content: description || ''
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      name: "viewport",
      content: "width=device-width, initial-scale=1 shrink-to-fit=no, user-scalable=0"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, undefined);
};

_c = Head;
/* harmony default export */ __webpack_exports__["default"] = (Head);
Head.propTypes = {
  title: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired,
  description: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Header.js":
/*!******************************!*\
  !*** ./components/Header.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Navbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Navbar */ "./components/Navbar.js");

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Header.js";

/**
 * Header Component
 * @description Site Header including the Navigation menu
 * @author dtro-devuk @github:dtro-devuk.io
 */



const Header = ({
  caption,
  author,
  description
}) => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("header", {
    id: "header",
    role: "banner",
    className: "sticky-header \r bg-gray-800\r text-center",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Navbar__WEBPACK_IMPORTED_MODULE_2__["default"], {
      author: author
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "px-4 pb-5 font-extrabold md:font-black\r text-lg md:text-3xl lg:text-4xl\r text-white ",
      children: caption || ''
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "bg-gray-300 w-full",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
        "aria-label": "Demo description",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h1", {
          className: "md:pt-5 font-bold text-gray-700 italic \r font-sans text-sm md:text-xl text-center",
          children: description
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 30,
          columnNumber: 11
        }, undefined)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 29,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, undefined);
};

_c = Header;
/* harmony default export */ __webpack_exports__["default"] = (Header);
Header.propTypes = {
  caption: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  author: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  description: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Header");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Navbar.js":
/*!******************************!*\
  !*** ./components/Navbar.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lib_hooks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/hooks.js */ "./lib/hooks.js");
/* harmony import */ var _components_Avatar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/Avatar */ "./components/Avatar.js");
/* harmony import */ var _components_Hamburger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/Hamburger */ "./components/Hamburger.js");
/* harmony import */ var _components_HamburgerMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/HamburgerMenu */ "./components/HamburgerMenu.js");



var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\components\\Navbar.js",
    _s = $RefreshSig$();

/**
 * Navigation Menu Bar Component
 * @description Horizontal Vertically expanding Navigation Menu with animations
 * @author dtro-devuk @github:dtro-devuk.io
 */







/**
 * Main Navigation Menu Bar (Horizontal)
 */

const NavBar = ({
  author
}) => {
  _s();

  const {
    0: open,
    1: setOpen
  } = Object(react__WEBPACK_IMPORTED_MODULE_3__["useState"])(false);
  const node = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(null);
  const menuId = 'mobile-menu';
  Object(_lib_hooks_js__WEBPACK_IMPORTED_MODULE_4__["useOnMouseClickOutsideNav"])(node, () => setOpen(false));
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      ref: node,
      className: "",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("nav", {
        id: "navbar",
        role: "navigation",
        className: "container mx-auto \r px-4 py-3\r flex items-center justify-between\r bg-gray-800 flex-wrap \r md:py-2",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
          className: "md:p-2",
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
            href: "/",
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
              className: "inline-flex items-center w-auto cursor-pointer focus:outline-none",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Avatar__WEBPACK_IMPORTED_MODULE_5__["default"], {
                className: "h-12 w-12 rounded-full md:mr-2 md:h-20 md:w-20\r border-4 border-white-200 \r transform hover:scale-125 hover:bg-opacity-50 transition ease-out duration-500"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 42,
                columnNumber: 17
              }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
                className: "p-3 font-bold italic\r text-xl md:text-3xl lg:text-4xl\r text-blue-400",
                children: author || ''
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 48,
                columnNumber: 17
              }, undefined)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 41,
              columnNumber: 15
            }, undefined)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 40,
            columnNumber: 13
          }, undefined)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 39,
          columnNumber: 11
        }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
          className: "block md:my-2 ml-auto md:w-auto",
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Hamburger__WEBPACK_IMPORTED_MODULE_6__["default"], {
            open: open,
            setOpen: setOpen,
            "aria-controls": menuId
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 59,
            columnNumber: 13
          }, undefined)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 58,
          columnNumber: 11
        }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_HamburgerMenu__WEBPACK_IMPORTED_MODULE_7__["default"], {
          open: open,
          setOpen: setOpen,
          id: menuId
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 61,
          columnNumber: 11
        }, undefined)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 7
    }, undefined)
  }, void 0, false);
};

_s(NavBar, "eo+ALe2yXdMitpGGRHVPwEDJmcQ=", false, function () {
  return [_lib_hooks_js__WEBPACK_IMPORTED_MODULE_4__["useOnMouseClickOutsideNav"]];
});

_c = NavBar;
/* harmony default export */ __webpack_exports__["default"] = (NavBar);
NavBar.propTypes = {
  author: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "NavBar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./lib/hooks.js":
/*!**********************!*\
  !*** ./lib/hooks.js ***!
  \**********************/
/*! exports provided: useOnMouseClickOutsideNav */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useOnMouseClickOutsideNav", function() { return useOnMouseClickOutsideNav; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var _s = $RefreshSig$();

/**
 * Hooks Functions
 * @description Main Global Site Hooks to included here
 * @author dtro-devuk @github:dtro-devuk.io
 */

/**
 * Use this to determine if the user clicked outside an element (e.g. Nav Bar Menu)
 * @param {*} ref
 * @param {*} handler
 */

const useOnMouseClickOutsideNav = (ref, handler) => {
  _s();

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    const listener = event => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }

      handler(event);
    };

    document.addEventListener('mousedown', listener);
    return () => {
      document.removeEventListener('mousedown', listener);
    };
  }, [ref, handler]);
};

_s(useOnMouseClickOutsideNav, "OD7bBpZva5O2jO+Puf00hKivP7c=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutProperties; });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-gh-pages-example%5Cpages%5Cindex.js!./":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-gh-pages-example%5Cpages%5Cindex.js ***!
  \**********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


      (window.__NEXT_P = window.__NEXT_P || []).push([
        "/",
        function () {
          return __webpack_require__(/*! ./pages/index.js */ "./pages/index.js");
        }
      ]);
    

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

const prefetched = {};

function prefetch(router, href, as, options) {
  if ( false || !router) return;
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options).catch(err => {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  const curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  const {
    target
  } = event.currentTarget;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  const {
    nodeName
  } = e.currentTarget;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow,
    locale,
    scroll
  }).then(success => {
    if (!success) return;

    if (scroll) {
      // FIXME: proper route announcing at Router level, not Link:
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    } // TypeScript trick for type-guarding:


    const requiredPropsGuard = {
      href: true
    };
    const requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(key => {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // TypeScript trick for type-guarding:

    const optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    const optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(key => {
      const valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    const hasWarned = _react.default.useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  const p = props.prefetch !== false;
  const router = (0, _router2.useRouter)();
  const pathname = router && router.pathname || '/';

  const {
    href,
    as
  } = _react.default.useMemo(() => {
    const [resolvedHref, resolvedAs] = (0, _router.resolveHref)(pathname, props.href, true);
    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]);

  let {
    children,
    replace,
    shallow,
    scroll,
    locale
  } = props; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react.default.createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  const child = _react.Children.only(children);

  const childRef = child && typeof child === 'object' && child.ref;
  const [setIntersectionRef, isVisible] = (0, _useIntersection.useIntersection)({
    rootMargin: '200px'
  });

  const setRef = _react.default.useCallback(el => {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  (0, _react.useEffect)(() => {
    const shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);
    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    const isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);
  const childProps = {
    ref: setRef,
    onClick: e => {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = e => {
    if (!(0, _router.isLocalURL)(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    const localeDomain = (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);
    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react.default.cloneElement(child, childProps);
}

_s(Link, "7cX92ILFgstKFyzTMH+g73G4t5k=");

_c = Link;
var _default = Link;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


const normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = void 0;

const requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  let start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function () {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

var _default = requestIdleCallback;
exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports.default = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js")); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


const MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  let entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  let resolver;
  const prom = new Promise(resolve => {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(value => (resolver(value), value)) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

const canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise((res, rej) => {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

const ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise((resolve, reject) => {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = () => reject(markAssetError(new Error("Failed to load script: ".concat(src)))); // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
}

function idleTimeout(ms, err) {
  return new Promise((_resolve, reject) => (0, _requestIdleCallback.default)(() => setTimeout(() => reject(err), ms)));
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  const onBuildManifest = new Promise(resolve => {
    // Mandatory because this is not concurrent safe:
    const cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = () => {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return Promise.race([onBuildManifest, idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')))]);
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute.default)(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(manifest => {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + encodeURI(entry));
    return {
      scripts: allFiles.filter(v => v.endsWith('.js')),
      css: allFiles.filter(v => v.endsWith('.css'))
    };
  });
}

function createRouteLoader(assetPrefix) {
  const entrypoints = new Map();
  const loadedScripts = new Map();
  const styleSheets = new Map();
  const routes = new Map();

  function maybeExecuteScript(src) {
    let prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    let prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(res => {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(text => ({
        href: href,
        content: text
      }));
    }).catch(err => {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },

    onEntrypoint(route, execute) {
      Promise.resolve(execute).then(fn => fn()).then(exports => ({
        component: exports && exports.default || exports,
        exports: exports
      }), err => ({
        error: err
      })).then(input => {
        const old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },

    loadRoute(route) {
      return withFuture(route, routes, async () => {
        try {
          const {
            scripts,
            css
          } = await getFilesForRoute(assetPrefix, route);
          const [, styles] = await Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);
          const entrypoint = await Promise.race([this.whenEntrypoint(route), idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route))))]);
          const res = Object.assign({
            styles
          }, entrypoint);
          return 'error' in entrypoint ? entrypoint : res;
        } catch (err) {
          return {
            error: err
          };
        }
      });
    },

    prefetch(route) {
      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      let cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script, 'script')) : [])).then(() => {
        (0, _requestIdleCallback.default)(() => this.loadRoute(route));
      }).catch( // swallow prefetch errors
      () => {});
    }

  };
}

var _default = createRouteLoader;
exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2.default;
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter.default;
/* global window */

const singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],

  ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }

}; // Create public properties and methods of the router in the singletonRouter

const urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady'];
const routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
const coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get() {
    return _router2.default.events;
  }

});
urlPropertyFields.forEach(field => {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get() {
      const router = getRouter();
      return router[field];
    }

  });
});
coreMethodFields.forEach(field => {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = (...args) => {
    const router = getRouter();
    return router[field](...args);
  };
});
routerEvents.forEach(event => {
  singletonRouter.ready(() => {
    _router2.default.events.on(event, (...args) => {
      const eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      const _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField](...args);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    const message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports.default = _default;

function useRouter() {
  _s();

  return _react.default.useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

const createRouter = (...args) => {
  singletonRouter.router = new _router2.default(...args);
  singletonRouter.readyCallbacks.forEach(cb => cb());
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  const _router = router;
  const instance = {};

  for (const property of urlPropertyFields) {
    if (typeof _router[property] === 'object') {
      instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

      continue;
    }

    instance[property] = _router[property];
  } // Events is a static property on the router, the router doesn't have to be initialized to use it


  instance.events = _router2.default.events;
  coreMethodFields.forEach(field => {
    instance[field] = (...args) => {
      return _router[field](...args);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js"));

const hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection({
  rootMargin,
  disabled
}) {
  const isDisabled = disabled || !hasIntersectionObserver;
  const unobserve = (0, _react.useRef)();
  const [visible, setVisible] = (0, _react.useState)(false);
  const setRef = (0, _react.useCallback)(el => {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {
        rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(() => {
    if (!hasIntersectionObserver) {
      if (!visible) (0, _requestIdleCallback.default)(() => setVisible(true));
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  const {
    id,
    observer,
    elements
  } = createObserver(options);
  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements.delete(element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers.delete(id);
    }
  };
}

const observers = new Map();

function createObserver(options) {
  const id = options.rootMargin || '';
  let instance = observers.get(id);

  if (instance) {
    return instance;
  }

  const elements = new Map();
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      const callback = elements.get(entry.target);
      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id,
    observer,
    elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.default = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react.default.createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const AmpStateContext = /*#__PURE__*/_react.default.createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isInAmpMode({
  ampFirst = false,
  hybrid = false,
  hasQuery = false
} = {}) {
  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react.default.useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const HeadManagerContext = /*#__PURE__*/_react.default.createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead(inAmpMode = false) {
  const head = [/*#__PURE__*/_react.default.createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react.default.createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react.default.Fragment) {
    return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild) => {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

const METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  const keys = new Set();
  const tags = new Set();
  const metaTypes = new Set();
  const metaCategories = {};
  return h => {
    let isUnique = true;
    let hasKey = false;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      hasKey = true;
      const key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (let i = 0, len = METATYPES.length; i < len; i++) {
          const metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            const category = h.props[metatype];
            const categories = metaCategories[metatype] || new Set();

            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce((list, headElement) => {
    const headElementChildren = _react.default.Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map((c, i) => {
    const key = c.key || i;

    if (false) {}

    return /*#__PURE__*/_react.default.cloneElement(c, {
      key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head({
  children
}) {
  const ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  const headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react.default.createElement(_sideEffect.default, {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = () => {};

var _default = Head;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  let detectedLocale; // first item will be empty string from splitting at first char

  const pathnameParts = pathname.split('/');
  (locales || []).some(locale => {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname,
    detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  const all = Object.create(null);
  return {
    on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },

    off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },

    emit(type, ...evts) {
      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(handler => {
        handler(...evts);
      });
    }

  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const RouterContext = /*#__PURE__*/_react.default.createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports.default = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


let detectDomainLocale;

if (false) {}

const basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) {}

  return false;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function pathNoQueryHash(path) {
  const queryIndex = path.indexOf('?');
  const hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = "/".concat(path);
  return path;
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    const locationOrigin = (0, _utils.getLocationOrigin)();
    const resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  let interpolatedRoute = '';
  const dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  const dynamicGroups = dynamicRegex.groups;
  const dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  const params = Object.keys(dynamicGroups);

  if (!params.every(param => {
    let value = dynamicMatches[param] || '';
    const {
      repeat,
      optional
    } = dynamicGroups[param]; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    let replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  const filteredQuery = {};
  Object.keys(query).forEach(key => {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  const base = new URL(currentPath, 'http://n');
  const urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    const finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    let interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
      const {
        result,
        params
      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  const origin = (0, _utils.getLocationOrigin)();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  let [resolvedHref, resolvedAs] = resolveHref(router.pathname, url, true);
  const origin = (0, _utils.getLocationOrigin)();
  const hrefHadOrigin = resolvedHref.startsWith(origin);
  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  const preparedAs = as ? stripOrigin(resolveHref(router.pathname, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

const manualScrollRestoration =  false && false;
const SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(res => {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(data => {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error("Failed to load static props");
        });
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

class Router {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  constructor(_pathname, _query, _as, {
    initialProps,
    pageLoader,
    App,
    wrapApp,
    Component,
    err,
    subscription,
    isFallback,
    locale,
    locales,
    defaultLocale,
    domainLocales
  }) {
    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;
    this.domainLocales = void 0;
    this.isReady = void 0;
    this._idx = 0;

    this.onPopState = e => {
      const state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        const {
          pathname,
          query
        } = this;
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(pathname),
          query
        }), (0, _utils.getURL)());
        return;
      }

      if (!state.__N) {
        return;
      }

      let forcedScroll;
      const {
        url,
        as,
        options,
        idx
      } = state;

      if (false) {}

      this._idx = idx;
      const {
        pathname
      } = (0, _parseRelativeUrl.parseRelativeUrl)(url); // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site

      if (this.isSsr && as === this.asPath && pathname === this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (this._bps && !this._bps(state)) {
        return;
      }

      this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && this._shallow,
        locale: options.locale || this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component,
        initial: true,
        props: initialProps,
        err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    const autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search);

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  reload() {
    window.location.reload();
  }
  /**
  * Go back in history
  */


  back() {
    window.history.back();
  }
  /**
  * Performs a `pushState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  push(url, as, options = {}) {
    if (false) {}

    ;
    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('pushState', url, as, options);
  }
  /**
  * Performs a `replaceState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  replace(url, as, options = {}) {
    ;
    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('replaceState', url, as, options);
  }

  async change(method, url, as, options, forcedScroll) {
    var _options$scroll;

    if (!isLocalURL(url)) {
      window.location.href = url;
      return false;
    } // for static pages with query params in the URL we delay
    // marking the router ready until after the query is updated


    if (options._h) {
      this.isReady = true;
    } // Default to scroll reset behavior unless explicitly specified to be
    // `false`! This makes the behavior between using `Router#push` and a
    // `<Link />` consistent.


    options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);
    let localeChange = options.locale !== this.locale;

    if (false) { var _this$locales; }

    if (!options._h) {
      this.isSsr = false;
    } // marking route changes as a navigation start entry


    if (_utils.ST) {
      performance.mark('routeChange');
    }

    const {
      shallow = false
    } = options;
    const routeProps = {
      shallow
    };

    if (this._inFlightRoute) {
      this.abortComponentLoad(this._inFlightRoute, routeProps);
    }

    as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
    this._inFlightRoute = as; // If the url change is only related to a hash change
    // We should not proceed. We should only change the state.
    // WARNING: `_h` is an internal option for handing Next.js client-side
    // hydration. Your app should _never_ use this property. It may change at
    // any time without notice.

    if (!options._h && this.onlyAHashChange(cleanedAs)) {
      this.asPath = cleanedAs;
      Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

      this.changeState(method, url, as, options);
      this.scrollToHash(cleanedAs);
      this.notify(this.components[this.route], null);
      Router.events.emit('hashChangeComplete', as, routeProps);
      return true;
    }

    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
    let {
      pathname,
      query
    } = parsed; // The build manifest needs to be loaded before auto-static dynamic pages
    // get their query parameters to allow ensuring they can be parsed properly
    // when rewritten to

    let pages, rewrites;

    try {
      pages = await this.pageLoader.getPageList();
      ({
        __rewrites: rewrites
      } = await (0, _routeLoader.getClientBuildManifest)());
    } catch (err) {
      // If we fail to resolve the page list or client-build manifest, we must
      // do a server-side transition:
      window.location.href = as;
      return false;
    }

    parsed = this._resolveHref(parsed, pages);

    if (parsed.pathname !== pathname) {
      pathname = parsed.pathname;
      url = (0, _utils.formatWithValidation)(parsed);
    } // url and as should always be prefixed with basePath by this
    // point by either next/link or router.push/replace so strip the
    // basePath from the pathname to match the pages dir 1-to-1


    pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
    // (not location.reload() but reload getInitialProps and other Next.js stuffs)
    // We also need to set the method = replaceState always
    // as this should not go into the history (That's how browsers work)
    // We should compare the new asPath to the current asPath, not the url

    if (!this.urlIsNew(cleanedAs) && !localeChange) {
      method = 'replaceState';
    }

    let route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // we need to resolve the as value using rewrites for dynamic SSG
    // pages to allow building the data URL correctly

    let resolvedAs = as;

    if ( true && as.startsWith('/')) {
      resolvedAs = (0, _resolveRewrites.default)(addBasePath(addLocale(delBasePath((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname), this.locale)), pages, rewrites, query, p => this._resolveHref({
        pathname: p
      }, pages).pathname, this.locales);

      if (resolvedAs !== as) {
        const potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
          pathname: (0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(resolvedAs) ? delBasePath(resolvedAs) : resolvedAs, this.locales).pathname
        }), pages, false).pathname); // if this directly matches a page we need to update the href to
        // allow the correct page chunk to be loaded

        if (pages.includes(potentialHref)) {
          route = potentialHref;
          pathname = potentialHref;
          parsed.pathname = pathname;
          url = (0, _utils.formatWithValidation)(parsed);
        }
      }
    }

    if (!isLocalURL(as)) {
      if (true) {
        throw new Error("Invalid href: \"".concat(url, "\" and as: \"").concat(as, "\", received relative href and external as") + "\nSee more info: https://err.sh/next.js/invalid-relative-url-external-as");
      }

      window.location.href = as;
      return false;
    }

    resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

    if ((0, _isDynamic.isDynamicRoute)(route)) {
      const parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
      const asPathname = parsedAs.pathname;
      const routeRegex = (0, _routeRegex.getRouteRegex)(route);
      const routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
      const shouldInterpolate = route === asPathname;
      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);

        if (missingParams.length > 0) {
          if (true) {
            console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
          }

          throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));
        }
      } else if (shouldInterpolate) {
        as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {
          pathname: interpolatedAs.result,
          query: omitParmsFromQuery(query, interpolatedAs.params)
        }));
      } else {
        // Merge params into `query`, overwriting any specified in search
        Object.assign(query, routeMatch);
      }
    }

    Router.events.emit('routeChangeStart', as, routeProps);

    try {
      let routeInfo = await this.getRouteInfo(route, pathname, query, addBasePath(addLocale(resolvedAs, this.locale)), routeProps);
      let {
        error,
        props,
        __N_SSG,
        __N_SSP
      } = routeInfo; // handle redirect on client-transition

      if ((__N_SSG || __N_SSP) && props) {
        if (props.pageProps && props.pageProps.__N_REDIRECT) {
          const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
          // client-navigation if it is falling back to hard navigation if
          // it's not

          if (destination.startsWith('/')) {
            const parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

            this._resolveHref(parsedHref, pages, false);

            if (pages.includes(parsedHref.pathname)) {
              const {
                url: newUrl,
                as: newAs
              } = prepareUrlAs(this, destination, destination);
              return this.change(method, newUrl, newAs, options);
            }
          }

          window.location.href = destination;
          return new Promise(() => {});
        } // handle SSG data 404


        if (props.notFound === SSG_DATA_NOT_FOUND) {
          let notFoundRoute;

          try {
            await this.fetchComponent('/404');
            notFoundRoute = '/404';
          } catch (_) {
            notFoundRoute = '/_error';
          }

          routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, {
            shallow: false
          });
        }
      }

      Router.events.emit('beforeHistoryChange', as, routeProps);
      this.changeState(method, url, as, options);

      if (true) {
        const appComp = this.components['/_app'].Component;
        window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
      }

      await this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (options.scroll ? {
        x: 0,
        y: 0
      } : null)).catch(e => {
        if (e.cancelled) error = error || e;else throw e;
      });

      if (error) {
        Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
        throw error;
      }

      if (false) {}

      Router.events.emit('routeChangeComplete', as, routeProps);
      return true;
    } catch (err) {
      if (err.cancelled) {
        return false;
      }

      throw err;
    }
  }

  changeState(method, url, as, options = {}) {
    if (true) {
      if (typeof window.history === 'undefined') {
        console.error("Warning: window.history is not available.");
        return;
      }

      if (typeof window.history[method] === 'undefined') {
        console.error("Warning: window.history.".concat(method, " is not available"));
        return;
      }
    }

    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
      this._shallow = options.shallow;
      window.history[method]({
        url,
        as,
        options,
        __N: true,
        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
      }, // Most browsers currently ignores this parameter, although they may use it in the future.
      // Passing the empty string here should be safe against future changes to the method.
      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
      '', as);
    }
  }

  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
    if (err.cancelled) {
      // bubble up cancellation errors
      throw err;
    }

    if ((0, _routeLoader.isAssetError)(err) || loadErrorFail) {
      Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
      //  1. Page doesn't exists
      //  2. Page does exist in a different zone
      //  3. Internal error while loading the page
      // So, doing a hard reload is the proper way to deal with this.

      window.location.href = as; // Changing the URL doesn't block executing the current code path.
      // So let's throw a cancellation error stop the routing logic.

      throw buildCancellationError();
    }

    try {
      let Component;
      let styleSheets;
      let props;

      if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {
        ;
        ({
          page: Component,
          styleSheets
        } = await this.fetchComponent('/_error'));
      }

      const routeInfo = {
        props,
        Component,
        styleSheets,
        err,
        error: err
      };

      if (!routeInfo.props) {
        try {
          routeInfo.props = await this.getInitialProps(Component, {
            err,
            pathname,
            query
          });
        } catch (gipErr) {
          console.error('Error in error page `getInitialProps`: ', gipErr);
          routeInfo.props = {};
        }
      }

      return routeInfo;
    } catch (routeInfoErr) {
      return this.handleRouteInfoError(routeInfoErr, pathname, query, as, routeProps, true);
    }
  }

  async getRouteInfo(route, pathname, query, as, routeProps) {
    try {
      const existingRouteInfo = this.components[route];

      if (routeProps.shallow && existingRouteInfo && this.route === route) {
        return existingRouteInfo;
      }

      const cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;
      const routeInfo = cachedRouteInfo ? cachedRouteInfo : await this.fetchComponent(route).then(res => ({
        Component: res.page,
        styleSheets: res.styleSheets,
        __N_SSG: res.mod.__N_SSG,
        __N_SSP: res.mod.__N_SSP
      }));
      const {
        Component,
        __N_SSG,
        __N_SSP
      } = routeInfo;

      if (true) {
        const {
          isValidElementType
        } = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

        if (!isValidElementType(Component)) {
          throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));
        }
      }

      let dataHref;

      if (__N_SSG || __N_SSP) {
        dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
          pathname,
          query
        }), delBasePath(as), __N_SSG, this.locale);
      }

      const props = await this._getData(() => __N_SSG ? this._getStaticData(dataHref) : __N_SSP ? this._getServerData(dataHref) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
      {
        pathname,
        query,
        asPath: as
      }));
      routeInfo.props = props;
      this.components[route] = routeInfo;
      return routeInfo;
    } catch (err) {
      return this.handleRouteInfoError(err, pathname, query, as, routeProps);
    }
  }

  set(route, pathname, query, as, data, resetScroll) {
    this.isFallback = false;
    this.route = route;
    this.pathname = pathname;
    this.query = query;
    this.asPath = as;
    return this.notify(data, resetScroll);
  }
  /**
  * Callback to execute before replacing router state
  * @param cb callback to be executed
  */


  beforePopState(cb) {
    this._bps = cb;
  }

  onlyAHashChange(as) {
    if (!this.asPath) return false;
    const [oldUrlNoHash, oldHash] = this.asPath.split('#');
    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same

    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
      return true;
    } // If the urls are change, there's more than a hash change


    if (oldUrlNoHash !== newUrlNoHash) {
      return false;
    } // If the hash has changed, then it's a hash only change.
    // This check is necessary to handle both the enter and
    // leave hash === '' cases. The identity case falls through
    // and is treated as a next reload.


    return oldHash !== newHash;
  }

  scrollToHash(as) {
    const [, hash] = as.split('#'); // Scroll to top if the hash is just `#` with no value

    if (hash === '') {
      window.scrollTo(0, 0);
      return;
    } // First we check if the element by id is found


    const idEl = document.getElementById(hash);

    if (idEl) {
      idEl.scrollIntoView();
      return;
    } // If there's no element with the id, we check the `name` property
    // To mirror browsers


    const nameEl = document.getElementsByName(hash)[0];

    if (nameEl) {
      nameEl.scrollIntoView();
    }
  }

  urlIsNew(asPath) {
    return this.asPath !== asPath;
  }

  _resolveHref(parsedHref, pages, applyBasePath = true) {
    const {
      pathname
    } = parsedHref;
    const cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

    if (cleanPathname === '/404' || cleanPathname === '/_error') {
      return parsedHref;
    } // handle resolving href for dynamic routes


    if (!pages.includes(cleanPathname)) {
      // eslint-disable-next-line array-callback-return
      pages.some(page => {
        if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
          parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
          return true;
        }
      });
    }

    parsedHref.pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(parsedHref.pathname);
    return parsedHref;
  }
  /**
  * Prefetch page code, you may wait for the data during page rendering.
  * This feature only works in production!
  * @param url the href of prefetched page
  * @param asPath the as path of the prefetched page
  */


  async prefetch(url, asPath = url, options = {}) {
    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
    let {
      pathname
    } = parsed;

    if (false) {}

    const pages = await this.pageLoader.getPageList();
    parsed = this._resolveHref(parsed, pages, false);

    if (parsed.pathname !== pathname) {
      pathname = parsed.pathname;
      url = (0, _utils.formatWithValidation)(parsed);
    } // Prefetch is not supported in development mode because it would trigger on-demand-entries


    if (true) {
      return;
    }

    const route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
    await Promise.all([this.pageLoader._isSsg(url).then(isSsg => {
      return isSsg ? this._getStaticData(this.pageLoader.getDataHref(url, asPath, true, typeof options.locale !== 'undefined' ? options.locale : this.locale)) : false;
    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);
  }

  async fetchComponent(route) {
    let cancelled = false;

    const cancel = this.clc = () => {
      cancelled = true;
    };

    const componentResult = await this.pageLoader.loadPage(route);

    if (cancelled) {
      const error = new Error("Abort fetching component for route: \"".concat(route, "\""));
      error.cancelled = true;
      throw error;
    }

    if (cancel === this.clc) {
      this.clc = null;
    }

    return componentResult;
  }

  _getData(fn) {
    let cancelled = false;

    const cancel = () => {
      cancelled = true;
    };

    this.clc = cancel;
    return fn().then(data => {
      if (cancel === this.clc) {
        this.clc = null;
      }

      if (cancelled) {
        const err = new Error('Loading initial props cancelled');
        err.cancelled = true;
        throw err;
      }

      return data;
    });
  }

  _getStaticData(dataHref) {
    const {
      href: cacheKey
    } = new URL(dataHref, window.location.href);

    if (false) {}

    return fetchNextData(dataHref, this.isSsr).then(data => {
      this.sdc[cacheKey] = data;
      return data;
    });
  }

  _getServerData(dataHref) {
    return fetchNextData(dataHref, this.isSsr);
  }

  getInitialProps(Component, ctx) {
    const {
      Component: App
    } = this.components['/_app'];

    const AppTree = this._wrapApp(App);

    ctx.AppTree = AppTree;
    return (0, _utils.loadGetInitialProps)(App, {
      AppTree,
      Component,
      router: this,
      ctx
    });
  }

  abortComponentLoad(as, routeProps) {
    if (this.clc) {
      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
      this.clc();
      this.clc = null;
    }
  }

  notify(data, resetScroll) {
    return this.sub(data, this.components['/_app'].Component, resetScroll);
  }

}

exports.default = Router;
Router.events = (0, _mitt.default)();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


const slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  let {
    auth,
    hostname
  } = urlObj;
  let protocol = urlObj.protocol || '';
  let pathname = urlObj.pathname || '';
  let hash = urlObj.hash || '';
  let query = urlObj.query || '';
  let host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  let search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route, ext = '') {
  const path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  const globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  const resolvedBase = base ? new URL(base, globalBase) : globalBase;
  const {
    pathname,
    searchParams,
    search,
    hash,
    href,
    origin
  } = new URL(url, resolvedBase);

  if (origin !== globalBase.origin) {
    throw new Error("invariant: invalid relative URL, router received ".concat(url));
  }

  return {
    pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search,
    hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports.default = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

const matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

const customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = (customRoute = false) => {
  return path => {
    const keys = [];
    const matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return (pathname, params) => {
      const res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        for (const key of keys) {
          // unnamed params should be removed as they
          // are not allowed to be used in the destination
          if (typeof key.name === 'number') {
            delete res.params[key.name];
          }
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.compileNonPath = compileNonPath;
exports.default = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function () {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function compileNonPath(value, params) {
  if (!value.includes(':')) {
    return value;
  }

  for (const key of Object.keys(params)) {
    if (value.includes(":".concat(key))) {
      value = value.replace(new RegExp(":".concat(key, "\\*"), 'g'), ":".concat(key, "--ESCAPED_PARAM_ASTERISKS")).replace(new RegExp(":".concat(key, "\\?"), 'g'), ":".concat(key, "--ESCAPED_PARAM_QUESTION")).replace(new RegExp(":".concat(key, "\\+"), 'g'), ":".concat(key, "--ESCAPED_PARAM_PLUS")).replace(new RegExp(":".concat(key, "(?!\\w)"), 'g'), "--ESCAPED_PARAM_COLON".concat(key));
    }
  }

  value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled
  // correctly

  return pathToRegexp.compile("/".concat(value), {
    validate: false
  })(params).substr(1);
}

function prepareDestination(destination, params, query, appendParamsToQuery) {
  let parsedDestination = {}; // clone query so we don't modify the original

  query = Object.assign({}, query);
  const hadLocale = query.__nextLocale;
  delete query.__nextLocale;
  delete query.__nextDefaultLocale;

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    const {
      pathname,
      searchParams,
      hash,
      hostname,
      port,
      protocol,
      search,
      href
    } = new URL(destination);
    parsedDestination = {
      pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash,
      protocol,
      hostname,
      port,
      search,
      href
    };
  }

  const destQuery = parsedDestination.query;
  const destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  const destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  const destPathParams = destPathParamKeys.map(key => key.name);
  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  let newUrl; // update any params in query values

  for (const [key, strOrArray] of Object.entries(destQuery)) {
    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = compileNonPath(value, params);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  let paramKeys = Object.keys(params); // remove internal param for i18n

  if (hadLocale) {
    paramKeys = paramKeys.filter(name => name !== 'nextInternalLocale');
  }

  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {
    for (const key of paramKeys) {
      if (!(key in destQuery)) {
        destQuery[key] = params[key];
      }
    }
  }

  try {
    newUrl = destinationCompiler(params);
    const [pathname, hash] = newUrl.split('#');
    parsedDestination.pathname = pathname;
    parsedDestination.hash = "".concat(hash ? '#' : '').concat(hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl,
    parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  const query = {};
  searchParams.forEach((value, key) => {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  const result = new URLSearchParams();
  Object.entries(urlQuery).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach(item => result.append(key, stringifyUrlQueryParam(item)));
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target, ...searchParamsList) {
  searchParamsList.forEach(searchParams => {
    Array.from(searchParams.keys()).forEach(key => target.delete(key));
    searchParams.forEach((value, key) => target.append(key, value));
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const customRouteMatcher = (0, _pathMatch.default)(true);

function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
  if (!pages.includes((0, _normalizeLocalePath.normalizeLocalePath)(asPath, locales).pathname)) {
    for (const rewrite of rewrites) {
      const matcher = customRouteMatcher(rewrite.source);
      const params = matcher(asPath);

      if (params) {
        if (!rewrite.destination) {
          // this is a proxied rewrite which isn't handled on the client
          break;
        }

        const destRes = (0, _prepareDestination.default)(rewrite.destination, params, query, true);
        asPath = destRes.parsedDestination.pathname;
        Object.assign(query, destRes.parsedDestination.query);
        const fsPathname = (0, _normalizeLocalePath.normalizeLocalePath)((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath), locales).pathname;

        if (pages.includes(fsPathname)) {
          asPath = fsPathname; // check if we now match a page as this means we are done
          // resolving the rewrites

          break;
        } // check if we match a dynamic-route, if so we break the rewrites chain


        const resolvedHref = resolveHref(fsPathname);

        if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
          asPath = fsPathname;
          break;
        }
      }
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  const {
    re,
    groups
  } = routeRegex;
  return pathname => {
    const routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    const decode = param => {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        const err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    const params = {};
    Object.keys(groups).forEach(slugName => {
      const g = groups[slugName];
      const m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(entry => decode(entry)) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  const optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  const repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat,
    optional
  };
}

function getRouteRegex(normalizedRoute) {
  const segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  const groups = {};
  let groupIndex = 1;
  const parameterizedRoute = segments.map(segment => {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      const {
        key,
        optional,
        repeat
      } = parseParameter(segment.slice(1, -1));
      groups[key] = {
        pos: groupIndex++,
        repeat,
        optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

const isServer = false;

class _default extends _react.Component {
  constructor(props) {
    super(props);
    this._hasHeadManager = void 0;

    this.emitChange = () => {
      if (this._hasHeadManager) {
        this.props.headManager.updateHead(this.props.reduceComponentsToState([...this.props.headManager.mountedInstances], this.props));
      }
    };

    this._hasHeadManager = this.props.headManager && this.props.headManager.mountedInstances;

    if (isServer && this._hasHeadManager) {
      this.props.headManager.mountedInstances.add(this);
      this.emitChange();
    }
  }

  componentDidMount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances.add(this);
    }

    this.emitChange();
  }

  componentDidUpdate() {
    this.emitChange();
  }

  componentWillUnmount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances.delete(this);
    }

    this.emitChange();
  }

  render() {
    return null;
  }

}

exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  let used = false;
  let result;
  return (...args) => {
    if (!used) {
      used = true;
      result = fn(...args);
    }

    return result;
  };
}

function getLocationOrigin() {
  const {
    protocol,
    hostname,
    port
  } = window.location;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  const {
    href
  } = window.location;
  const origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

async function loadGetInitialProps(App, ctx) {
  if (true) {
    var _App$prototype;

    if ((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps) {
      const message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
      throw new Error(message);
    }
  } // when called from _app `ctx` is nested in `ctx`


  const res = ctx.res || ctx.ctx && ctx.ctx.res;

  if (!App.getInitialProps) {
    if (ctx.ctx && ctx.Component) {
      // @ts-ignore pageProps default
      return {
        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
      };
    }

    return {};
  }

  const props = await App.getInitialProps(ctx);

  if (res && isResSent(res)) {
    return props;
  }

  if (!props) {
    const message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
    throw new Error(message);
  }

  if (true) {
    if (Object.keys(props).length === 0 && !ctx.ctx) {
      console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
    }
  }

  return props;
}

const urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(key => {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

const SP = typeof performance !== 'undefined';
exports.SP = SP;
const ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js")


/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Container */ "./components/Container.js");

var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-gh-pages-example\\pages\\index.js";


const Home = () => {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Container__WEBPACK_IMPORTED_MODULE_1__["default"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "divide-y divide-gray-200 align-text-top max-w-4xl mx-auto mb-16",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "md:pt-10 flex flex-col justify-center items-center mx-auto mb-16",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h1", {
          className: "pb-5 text-lg md:text-3xl text-center text-blue-800  font-bold leading-normal",
          children: "Next.js Static HTML app deployment to GitHub Project Pages Demo"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 8,
          columnNumber: 11
        }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
          className: "font-normal leading-normal sm:text-sm lg:leading-relaxed",
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
            children: ["Hi all, this is an demo of how we can deploy a Next.js v10 app, with Tailwind CSS styling to GitHub Project pages.", ' ']
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 16,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 20,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
            children: "GitHub Project pages can be hosted alongside specific GitHub projects / repositories. They can be documents or web pages."
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 21,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 25,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
            children: "The static Html pages here have been created in the GitHub repository, and have been pushed to a \"gh-pages\" branch and published."
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 26,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 30,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
            children: "This app was created with Next.js v10+ and Tailwind 2.0+ and exported to static HTML. Since the pages are statically generated at build time, they are very fast to render, despite still being reactive. The benefit being that they are optimized and do not require any server-side computation, giving a faster loading experience."
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 31,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 37,
            columnNumber: 13
          }, undefined), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
            children: "Further details of how this was done can be read in the README file, in the main project repository."
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 38,
            columnNumber: 13
          }, undefined)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 15,
          columnNumber: 11
        }, undefined)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 7,
        columnNumber: 9
      }, undefined)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 6,
      columnNumber: 7
    }, undefined)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 5,
    columnNumber: 5
  }, undefined);
};

_c = Home;
/* harmony default export */ __webpack_exports__["default"] = (Home);

var _c;

$RefreshReg$(_c, "Home");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-gh-pages-example%5Cpages%5Cindex.js!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BdmF0YXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ29udGFpbmVyLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9IYW1idXJnZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvSGFtYnVyZ2VyTWVudS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9IZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0hlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9OYXZiYXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9ob29rcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9saW5rLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvdXNlLWludGVyc2VjdGlvbi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9taXR0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1tYXRjaC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcHJlcGFyZS1kZXN0aW5hdGlvbi50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3NpZGUtZWZmZWN0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9zZXJ2ZXIvZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC5qcyJdLCJuYW1lcyI6WyJBdmF0YXIiLCJjbGFzc05hbWUiLCJzaXRlVGl0bGUiLCJwcm9maWxlTmFtZSIsImRlc2NyaXB0aW9uIiwiQ29udGFpbmVyIiwiY2hpbGRyZW4iLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJub2RlIiwiaXNSZXF1aXJlZCIsIkZvb3RlciIsImNhcHRpb24iLCJhdXRob3IiLCJfX2h0bWwiLCJzdHJpbmciLCJIYW1idXJnZXIiLCJvcGVuIiwic2V0T3BlbiIsInByb3BzIiwiaXNPcGVuIiwiaGFuZGxlVG9nZ2xlTWVudUNsaWNrIiwiZXZlbnQiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwicHJldmVudERlZmF1bHQiLCJib29sIiwiZnVuYyIsIkhhbWJ1cmdlck1lbnUiLCJpc0hpZGRlbiIsIkhlYWQiLCJ0aXRsZSIsIkhlYWRlciIsIk5hdkJhciIsInVzZVN0YXRlIiwidXNlUmVmIiwibWVudUlkIiwidXNlT25Nb3VzZUNsaWNrT3V0c2lkZU5hdiIsInJlZiIsImhhbmRsZXIiLCJ1c2VFZmZlY3QiLCJsaXN0ZW5lciIsImN1cnJlbnQiLCJjb250YWlucyIsInRhcmdldCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwcmVmZXRjaGVkIiwicm91dGVyIiwiZXJyIiwiY3VyTG9jYWxlIiwib3B0aW9ucyIsImhyZWYiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJzdWNjZXNzIiwiYXJncyIsImtleSIsImV4cGVjdGVkIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsImNyZWF0ZVByb3BFcnJvciIsImFjdHVhbCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJzaGFsbG93IiwicGFzc0hyZWYiLCJwcmVmZXRjaCIsImxvY2FsZSIsIm9wdGlvbmFsUHJvcHMiLCJ2YWxUeXBlIiwiaGFzV2FybmVkIiwiUmVhY3QiLCJjb25zb2xlIiwicCIsInBhdGhuYW1lIiwicmVzb2x2ZWRBcyIsImNoaWxkIiwiQ2hpbGRyZW4iLCJjaGlsZFJlZiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJlbCIsInNldEludGVyc2VjdGlvblJlZiIsInNob3VsZFByZWZldGNoIiwiaXNWaXNpYmxlIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsIm9uQ2xpY2siLCJsaW5rQ2xpY2tlZCIsInByaW9yaXR5IiwibG9jYWxlRG9tYWluIiwiTGluayIsInBhdGgiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInByb2Nlc3MiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsInN0YXJ0IiwiRGF0ZSIsInNldFRpbWVvdXQiLCJjYiIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIk1TX01BWF9JRExFX0RFTEFZIiwiZW50cnkiLCJtYXAiLCJQcm9taXNlIiwicHJvbSIsInJlc29sdmUiLCJyZXNvbHZlciIsImZ1dHVyZSIsImdlbmVyYXRvciIsInZhbHVlIiwibGluayIsIndpbmRvdyIsImNhblByZWZldGNoIiwiaGFzUHJlZmV0Y2giLCJyZXMiLCJBU1NFVF9MT0FEX0VSUk9SIiwiU3ltYm9sIiwic2NyaXB0IiwicmVqZWN0IiwibWFya0Fzc2V0RXJyb3IiLCJvbkJ1aWxkTWFuaWZlc3QiLCJpZGxlVGltZW91dCIsInNjcmlwdHMiLCJhc3NldFByZWZpeCIsImVuY29kZVVSSSIsImNzcyIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJtYW5pZmVzdCIsInJvdXRlIiwiYWxsRmlsZXMiLCJ2IiwiZW50cnlwb2ludHMiLCJsb2FkZWRTY3JpcHRzIiwic3R5bGVTaGVldHMiLCJyb3V0ZXMiLCJhcHBlbmRTY3JpcHQiLCJmZXRjaCIsInRleHQiLCJjb250ZW50Iiwid2hlbkVudHJ5cG9pbnQiLCJ3aXRoRnV0dXJlIiwib25FbnRyeXBvaW50IiwiZm4iLCJleHBvcnRzIiwiY29tcG9uZW50IiwiZXJyb3IiLCJpbnB1dCIsIm9sZCIsImxvYWRSb3V0ZSIsImdldEZpbGVzRm9yUm91dGUiLCJlbnRyeXBvaW50IiwiY24iLCJuYXZpZ2F0b3IiLCJvdXRwdXQiLCJwcmVmZXRjaFZpYURvbSIsImNyZWF0ZVJvdXRlTG9hZGVyIiwic2luZ2xldG9uUm91dGVyIiwicmVhZHlDYWxsYmFja3MiLCJyZWFkeSIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImdldCIsIlJvdXRlciIsImZpZWxkIiwiZ2V0Um91dGVyIiwiZXZlbnRGaWVsZCIsIl9zaW5nbGV0b25Sb3V0ZXIiLCJtZXNzYWdlIiwiUm91dGVyQ29udGV4dCIsImNyZWF0ZVJvdXRlciIsIl9yb3V0ZXIiLCJpbnN0YW5jZSIsIkFycmF5IiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJpc0Rpc2FibGVkIiwiZGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwic2V0VmlzaWJsZSIsImNyZWF0ZU9ic2VydmVyIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsIm9ic2VydmVycyIsImlkIiwiZW50cmllcyIsImNhbGxiYWNrIiwiQ29tcG9zZWRDb21wb25lbnQiLCJnZXRJbml0aWFsUHJvcHMiLCJXaXRoUm91dGVyV3JhcHBlciIsIm5hbWUiLCJBbXBTdGF0ZUNvbnRleHQiLCJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5IiwiaXNJbkFtcE1vZGUiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJpbkFtcE1vZGUiLCJoZWFkIiwibGlzdCIsImZyYWdtZW50TGlzdCIsIk1FVEFUWVBFUyIsImtleXMiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJpIiwibGVuIiwibWV0YXR5cGUiLCJjYXRlZ29yeSIsImNhdGVnb3JpZXMiLCJoZWFkRWxlbWVudHMiLCJoZWFkRWxlbWVudENoaWxkcmVuIiwiaGVhZEVsZW1lbnQiLCJkZWZhdWx0SGVhZCIsInVuaXF1ZSIsImMiLCJhbXBTdGF0ZSIsImhlYWRNYW5hZ2VyIiwicGF0aG5hbWVQYXJ0cyIsImxvY2FsZXMiLCJkZXRlY3RlZExvY2FsZSIsImFsbCIsIm9uIiwib2ZmIiwiZW1pdCIsImJhc2VQYXRoIiwiY2FuY2VsbGVkIiwicHJlZml4IiwicGF0aE5vUXVlcnlIYXNoIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsImFkZFBhdGhQcmVmaXgiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiaGFzQmFzZVBhdGgiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImR5bmFtaWNHcm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImFzUGF0aG5hbWUiLCJwYXJhbXMiLCJwYXJhbSIsInJlcGxhY2VkIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzdWx0IiwiZmlsdGVyZWRRdWVyeSIsInF1ZXJ5IiwiYmFzZSIsInVybEFzU3RyaW5nIiwiaXNMb2NhbFVSTCIsInJlc29sdmVBcyIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsInJlc29sdmVkSHJlZiIsIm9yaWdpbiIsInJlc29sdmVIcmVmIiwiaHJlZkhhZE9yaWdpbiIsImFzSGFkT3JpZ2luIiwic3RyaXBPcmlnaW4iLCJwcmVwYXJlZFVybCIsImFkZEJhc2VQYXRoIiwicHJlcGFyZWRBcyIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiY3JlZGVudGlhbHMiLCJhdHRlbXB0cyIsImZldGNoUmV0cnkiLCJkYXRhIiwibm90Rm91bmQiLCJpc1NlcnZlclJlbmRlciIsImNvbnN0cnVjdG9yIiwiYXNQYXRoIiwiY29tcG9uZW50cyIsInNkYyIsInN1YiIsImNsYyIsInBhZ2VMb2FkZXIiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsImlzRmFsbGJhY2siLCJfaW5GbGlnaHRSb3V0ZSIsIl9zaGFsbG93IiwiZGVmYXVsdExvY2FsZSIsImRvbWFpbkxvY2FsZXMiLCJpc1JlYWR5IiwiX2lkeCIsInN0YXRlIiwiaW5pdGlhbCIsIl9fTl9TU0ciLCJpbml0aWFsUHJvcHMiLCJfX05fU1NQIiwiQ29tcG9uZW50IiwiYXV0b0V4cG9ydER5bmFtaWMiLCJyZWxvYWQiLCJiYWNrIiwicHVzaCIsInByZXBhcmVVcmxBcyIsImxvY2FsZUNoYW5nZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJyb3V0ZVByb3BzIiwiYWRkTG9jYWxlIiwiZGVsQmFzZVBhdGgiLCJjbGVhbmVkQXMiLCJkZWxMb2NhbGUiLCJwYXJzZWQiLCJwYWdlcyIsIl9fcmV3cml0ZXMiLCJtZXRob2QiLCJwb3RlbnRpYWxIcmVmIiwicGFyc2VkQXMiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJvdXRlSW5mbyIsImRlc3RpbmF0aW9uIiwicGFyc2VkSHJlZiIsIm5vdEZvdW5kUm91dGUiLCJhcHBDb21wIiwiZm9yY2VkU2Nyb2xsIiwieCIsInkiLCJjaGFuZ2VTdGF0ZSIsIl9fTiIsImlkeCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJwYWdlIiwiZXhpc3RpbmdSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJyZXF1aXJlIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZGF0YUhyZWYiLCJzZXQiLCJiZWZvcmVQb3BTdGF0ZSIsIm9ubHlBSGFzaENoYW5nZSIsIm5ld0hhc2giLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwic2Nyb2xsVG9IYXNoIiwiaWRFbCIsIm5hbWVFbCIsInVybElzTmV3IiwiX3Jlc29sdmVIcmVmIiwiYXBwbHlCYXNlUGF0aCIsImNsZWFuUGF0aG5hbWUiLCJpc1NzZyIsImNhbmNlbCIsImNvbXBvbmVudFJlc3VsdCIsIl9nZXREYXRhIiwiX2dldFN0YXRpY0RhdGEiLCJmZXRjaE5leHREYXRhIiwiX2dldFNlcnZlckRhdGEiLCJBcHBUcmVlIiwiY3R4IiwiYWJvcnRDb21wb25lbnRMb2FkIiwibm90aWZ5Iiwic2xhc2hlZFByb3RvY29scyIsInByb3RvY29sIiwidXJsT2JqIiwiaG9zdCIsImF1dGgiLCJob3N0bmFtZSIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwic2VhcmNoIiwiZXh0IiwiVEVTVF9ST1VURSIsImdsb2JhbEJhc2UiLCJyZXNvbHZlZEJhc2UiLCJtYXRjaGVyT3B0aW9ucyIsInNlbnNpdGl2ZSIsImRlbGltaXRlciIsImN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMiLCJzdHJpY3QiLCJjdXN0b21Sb3V0ZSIsIm1hdGNoZXJSZWdleCIsInBhdGhUb1JlZ2V4cCIsIm1hdGNoZXIiLCJ2YWxpZGF0ZSIsInBhcnNlZERlc3RpbmF0aW9uIiwiaGFkTG9jYWxlIiwiZGVzdFF1ZXJ5IiwiZGVzdFBhdGgiLCJkZXN0UGF0aFBhcmFtS2V5cyIsImRlc3RQYXRoUGFyYW1zIiwiZGVzdGluYXRpb25Db21waWxlciIsInN0ck9yQXJyYXkiLCJjb21waWxlTm9uUGF0aCIsInBhcmFtS2V5cyIsImFwcGVuZFBhcmFtc1RvUXVlcnkiLCJuZXdVcmwiLCJzZWFyY2hQYXJhbXMiLCJpc05hTiIsIml0ZW0iLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwic2VhcmNoUGFyYW1zTGlzdCIsImN1c3RvbVJvdXRlTWF0Y2hlciIsInJld3JpdGUiLCJkZXN0UmVzIiwiZnNQYXRobmFtZSIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwibSIsInN0ciIsInNlZ21lbnRzIiwibm9ybWFsaXplZFJvdXRlIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsInBhcnNlUGFyYW1ldGVyIiwicG9zIiwiZXNjYXBlUmVnZXgiLCJpc1NlcnZlciIsIl9oYXNIZWFkTWFuYWdlciIsImVtaXRDaGFuZ2UiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwidXNlZCIsInBvcnQiLCJnZXRMb2NhdGlvbk9yaWdpbiIsIkFwcCIsImdldERpc3BsYXlOYW1lIiwicGFnZVByb3BzIiwibG9hZEdldEluaXRpYWxQcm9wcyIsImlzUmVzU2VudCIsInVybE9iamVjdEtleXMiLCJTUCIsIkhvbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1BLE1BQU0sR0FBRyxDQUFDO0FBQUVDO0FBQUYsQ0FBRCxLQUFtQjtBQUNoQyxzQkFDRTtBQUNFLFdBQU8sRUFBQyxLQURWO0FBRUUsTUFBRSxFQUFDLFNBRkw7QUFHRSxhQUFTLEVBQUVBLFNBSGI7QUFJRSxRQUFJLEVBQUMsTUFKUDtBQUtFLFdBQU8sRUFBQyx5QkFMVjtBQUFBLDRCQU9FO0FBQU8sUUFBRSxFQUFDLFdBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBUEYsZUFRRTtBQUFVLFFBQUUsRUFBQztBQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBUkYsZUFTRTtBQUFNLFFBQUUsRUFBQztBQUFUO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBVEYsZUFVRTtBQUNFLFdBQUssRUFBQyxXQURSO0FBRUUsWUFBTSxFQUFDLFdBRlQ7QUFHRSx5QkFBbUIsRUFBQyxNQUh0QjtBQUlFLFVBQUksRUFBQyw0bXJQQUpQO0FBcW5HRSxRQUFFLEVBQUM7QUFybkdMO0FBQUE7QUFBQTtB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QTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFx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QUMsdUZBQTJCO0FBQ3RELENBQUMsTUFBTSxFQUlOOzs7Ozs7Ozs7Ozs7O0FDbEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGVBQWU7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhNQUE4TTs7QUFFOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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dUJBdkJGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFSRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQURGO0FBMkNELENBNUNEOztLQUFNQSxJO0FBOENTQSxtRUFBZiIsImZpbGUiOiJzdGF0aWMvY2h1bmtzL3BhZ2VzL2luZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFByb2ZpbGUgQXZhdGFyIGFzIFNWR1xyXG4gKiBAZGVzY3JpcHRpb24gTWFpbiBTaXRlIEF2YXRhciBmb3IgcHJvZmlsZVxyXG4gKiBAYXV0aG9yIGR0cm8tZGV2dWsgQGdpdGh1YjpkdHJvLWRldnVrLmlvXHJcbiAqL1xyXG5cclxuY29uc3QgQXZhdGFyID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPHN2Z1xyXG4gICAgICB2ZXJzaW9uPVwiMS4xXCJcclxuICAgICAgaWQ9XCJzdmczMTY5XCJcclxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XHJcbiAgICAgIGZpbGw9XCJub25lXCJcclxuICAgICAgdmlld0JveD1cIjAgMCA1NDAuODQ1MDkgNTM5LjQ5Mjk4XCJcclxuICAgID5cclxuICAgICAgPHRpdGxlIGlkPVwidGl0bGUzNzQyXCI+ZHRyby1kZXZ1ayBhdmF0YXIgPC90aXRsZT5cclxuICAgICAgPG1ldGFkYXRhIGlkPVwibWV0YWRhdGEzMTc1XCI+PC9tZXRhZGF0YT5cclxuICAgICAgPGRlZnMgaWQ9XCJkZWZzMzE3M1wiIC8+XHJcbiAgICAgIDxpbWFnZVxyXG4gICAgICAgIHdpZHRoPVwiNTQwLjg0NTA5XCJcclxuICAgICAgICBoZWlnaHQ9XCI1MzkuNDkyOThcIlxyXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCJcclxuICAgICAgICBocmVmPVwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFaQUFBQUdQQ0FZQUFBQnlQNGFDQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hcclxuICBqd3Y4WVFVQUFBQUpjRWhaY3dBQUN1c0FBQXJyQVlLTERWb0FBQURiYVZSWWRGaE5URHBqYjIwdVlXUnZZbVV1ZUcxd0FBQUFBQUE4XHJcbiAgUDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QZzBLUEhnNlxyXG4gIGVHMXdiV1YwWVNCNGJXeHVjenA0UFNKaFpHOWlaVHB1Y3pwdFpYUmhMeUkrRFFvZ0lEeHlaR1k2VWtSR0lIaHRiRzV6T25Ka1pqMGlcclxuICBhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SWdMejROQ2p3dmVEcDRiWEJ0XHJcbiAgWlhSaFBnMEtQRDk0Y0dGamEyVjBJR1Z1WkQwaWNpSS9QaU1IZEZFQUFQNitTVVJCVkhoZTdMMEh3RzFYVlNlK3Z0Nzc2NzIvbDA0cVxyXG4gIENRR0JBQUZCSFVVSFJrZkZqbjBjeTk4WkhVV3hqSDEwSE5HeDkwSFVFVVpGQk5JZ0JOSklmY2w3eWV2MWUrWHJ2Zi9YYjYyMTJ5bjNcclxuICB1OTk3aVFHUzM3Mzc3TlgyUHZ1ZWU4NWVaNWV6VDgzUzNGTkxGR0ZwYVltZWV1bzVldXZiMzB2OTV3Wk1ta1V0VVEwSFEwMk5FWUtFXHJcbiAgWVdSNVJwcUFFZk1STFdTSmp1bVFUU3dIbUMvVUdWMm0wNi9TTVpMeVJyU1FHVnZtUzQ5SHp0N29qTDFuYy9ZQTgxbFJMQkIxNEpjV1xyXG4gIDUybHVySitKQlpOa1VGTkhEWjBiK08rc3QyemkxREVrNHdJVUNNVzBPQmVGNlVwTmloV1Z6N015UkhiVkpza1lYbUt5QWxTZDB3dUFcclxuICA1TExPWXhtMVE5N3NVaEpXbVNheTQycW9CQ1VLTHk3ZjF4SjBoZW9Db1loUytkTGlBczJPWEFSaEVvY2wyckMrZ3g1NThHOW8vZnJWXHJcbiAgSm50NUlIZ0J3L256QS9TZWIvdEpqZ2ROVW9Sd0lhU1ZlUFlDS2VCemxYR1d0MGpzbkM2bWdiaVNUdVVTUkdTMGg4bHpPcVdSbjBxY1xyXG4gIEhJQXd3N3NvS1IrQVBMTGxNa1l5ajNqRUlsUFNFZnB4ckZjYW1IWnBCRTZ2QXQyRno4RVE5QlVScFUydFJXSEJSQUl3TGdSU2YzOCtcclxuICBsOGpBZ29rOG5DQW9oT0tOQnMzWHBCYXlpSFFob1JkSjhJaUZXdDcwazFya0JFbitVY2diWnNLL0pZcjJINFdpOGt2SW1LVXNoL1NUXHJcbiAgdHpBa1l0NjRrQ2l5Q0RwL0xqRXJRZlJBc0ltbFFjUWJoS3llSVNXV1BHRWpBb05qdk1CWTN2aThYa0VSY2c1a2NYRkpuTWRpK1MyQVxyXG4gIHdCOWJRZEVCenNqY24rWVJNNkNObHlpcmN3Z25sY3Fkem1ndmNuSWcwam5hUS9NcXpDOHByK2trTXRvakxoTVE2U1dQMUZabHhwcXRcclxuICBiTjFHQ1E0T0p2T2lTQzhxM1g5a3dCQUYzeGZ4SjNlM2xJZVd3RUhUcHZzRXdMZ1FTTm0vZlZKNEEwOEdPRUZRQ01VYi8zc1FJbjBLXHJcbiAga3pzN0NVRWNFSVRwSjlaa21DUlBDNmtCaDB0QlVUNHZkcmdVWlBJb09oNzg5ZXJVbWtQcFVWWWtZdDY0a0xYek1EbmJ1SE5Ea3FpU1xyXG4gIFlYb2ZERjVVb0dOb0NUVS9VWG0xWTd4QVNOU0dlaTFWcmhkZmJzZzVrS29RSGRzTXc4Z2NmRUQrUkllczNtZ1J4N3FVZGllT3doTU1cclxuICBveVhDeHVtTTlpSW5CK0w4dklFQ1FzOUdPb204Z2xGVXBzZzJLQmhNWi9MVmo1bnBCZ29EMDJLUFlDSzFWa3BVTGdjSDA4ZHArQ1pnXHJcbiAgWVJKTjdwTHVLNCtDdEFLVE95SFUySy90TzkwL0lBWVdsRlU0SmdpRjRvM0xUeGpUcFhCeXM1RmdvZ1FxVEQrUmFjejRmQ3dreXVXUVxyXG4gIHRiZVF6VE1YTGlISkNrSlIvb1dHY1NoT3hHRTVSTGE1ZkNOVllsbjRyd1I0TVc4UXl1d0VhdVBQUmJDbUNXbGNpRWd4ak9RR0xaWExcclxuICBDemFtRU1JQ1gwUHo0K2M0WHY2RzdPV0VTM01nQW5kd1l4VHc4b2M1WkduakpTcTNDMW1BY0l6UkVzVnl3R2lKWXAzU2FYNEdPWEZTXHJcbiAgdTBCR1BNZnVwRlZFT2lFakhqRjR4ektoSHlGVnA1eUI2WXg5Q0thcWxNYUxIY010a01YbG5BZWpNSzBKT0hJWGxwVThndGxwd1pUMVxyXG4gIE1GMGs5R2FPU0JNWVRPNk5neWhBQmVuSFRCd2hnVGZKdmx5b2hJeHRuSWVFRWxXYUtoT0tQMFdXbHhyS1AwWFdGbmpqUXFraXIrUlFcclxuICBDWkZka2s4azltUlJLUTJ4S0ZlT0xGVHZya3N4OVhCcElxR3d2QkhEakk0aEpaSzhZR05DSnZSYWtyWklRWGg1NGhJZFNIckFGUmxaXHJcbiAgY3ZDQm1JbG8veWNDTWMyUVA5SG9vdlFTWmVVY0pETGFJejY1WXAwWEdvd1dFOWtJaTlpZG9JcElKMlRFSXdidldDYjBJNlRxbERNd1xyXG4gIG5iSDNqS2gwMzVFQlF4U1J5T2xOQUpXa3FRYkZhU1U0bVlmWnVYMTd0V09DVUV3a3hPVlhYWURKdkxHSlBGU1Fmc3pFRVQ2dEYxZ29cclxuICBRMlFUcDVXUVl6TWhXNHBxd2t1Sm92TGtRL3JKYUhualFrNFFoQmJLRU5razZVM2t0VVdsTUhnUmI1TDl4bENaUDMrZHFjRFp1eENSXHJcbiAgSmZscE9SaSs1WUU0RGJVMVM3UjZkUS9WMXFacFh3NjRqQmFJUS9hZ014MytNVWFCM2tVNU93Zjc4NDBPT3FNbGl1V0FreHZ0RVU2a1xyXG4gIHlFQmpDQjNyZEJJWjdlSFNBNUZPeUloSG5NbFRQMEtxVGprRDB4bDd6NGpLcHphWXZrSWE2UExwcW9CbFU1eldLejJwY0l3WHFJbVZcclxuICBJYXRUbUV3TlBSdWdndkF4dFNOOE9pL2dVSVJJSDZlUmtKQlJpUGRZRmdwUVpPWURiMTd5VUZRdUM0VW9NdFFRUHBHVU53Z0prd290XHJcbiAgRk1GMFNUb1RlVzEyandZdjRrMnlyeGdxYytla21IbGswbmcySTE5YXFEaVRjYzJhWHZxelAvNUZkaUs5Sm5uNTRESWRpQjFnRCtZVFxyXG4gIFVjeUFObDZpck00aC9wTUxiQ1RLeWpsNHVkTXBYWmdYaEluY0dJbThnaEdmZEJrN0VSb3ZZTnF6bkVZK1FuS1FEVGdEMHhYS0lQc01cclxuICBTb1lJMWNTTEl3WXFTK1BWZ3BRclJKSTJ0Z2N0U2s4cUhLTUNVVXZnMUNDQ1lRUnZwT3JFUkFYaFkycEh1SFJCVTRCSW45bFB2RXNOXHJcbiAgOFY2eUlZT2NDVytLUXQ0d0NsOElLQ3FYaGFMZkl5Rmpta1BXd0IzWnpOSE5NcW1BUXhGTWx5bUxSUnl5ZXpGNEVXLzhmckxnbEt6VFxyXG4gIFlHWUNaMjhDenlxeFZHRWNzYmEyVnB3STRwY2JMbk1NSklMOEcwWUxZc1pvUlBhSEtGTGEvYWxadVFTSnl1U09kNGhQRG0rZ3NRcVZcclxuICBkbkloSTU3alVCYWd6QTVnR2pJUnFTNlF5Z2N3N1cyQm9CY3hieXkxUVlUT2hBSENCWTBLMDZoQ3lSVWhrOWFuZDR3S1JDMGhsUWVZXHJcbiAgekJ1cVZLRzY4REcxSTF5YW9Na2cwa1g1UjZTRk9QYzRaSkNvZVJPSFZNbGg1WERsZUNrL2w0Yk1iODhlRy83NmtFT3NURXNpZ1RjSVxyXG4gIEJZeUZMRXp1YkIzck5VbnVIQXpDOGliSlA0YkszTFV1WmdKbjZ3V3ZvQVF2ekJoSU9QS003SUUzV3FJQ3VVRC9RRVdCalVTVjVFNm5cclxuICB0T1lWeXhseWhoanRDREdSamJDSTg0N0RtTVFPWU5ybnFUclpoZzBIQjZhOUxSRDBJbDZCdlpKV3ptREFZTnFsNFlBSFFwY1dYYi90XHJcbiAgY2tqVEtoeWpBbEZMU09VQkppdkpKM3hNNVFpWGNkQmtZSEpubDVJV0FoVkNoRVRGbXpna3lzb0l2eUh6NFh6S0FxdGY4bEJVTGg5S1xyXG4gIFBzc2oyVUVtUk9vRXNTTHNTUUp2RUFvWURsbVkzTms1MW11U25EbEVaR20rS3RQalltYUNyRzA2ZUk1aGo5V3J1MStXclEvZ0VuNTFcclxuICBmRENaRGtlYWthV045Mzhha05MdUQ4dktKVWhVSm5lOFEvekhSL0lnQkdNQlVVUUxYRG1BMkE0aHRkTThqV1hDbXhUa21iVjFqSWhYXHJcbiAgWUs4azlxWDdDMkN1S00zU29rMDdyRHdMcTZiR1BZRU9XRm9UYUJrUlVubUFOOGlvbFhGbEZiRWpuSDNRWkdEeUtOODQrNUJqSENKNFxyXG4gIE1XOWNLTFBOd0pYWWZ6aHRIRmhVSENxaUtFSDFBWTlqTFM0c0ZBWjlWS3M0WFJvcW9NaWNRL2EzWnorVmtXUVVCUk1uY0VJTkxuY0pcclxuICBNUkVZRGxtWVBMTWZpemdFU3VCWjN2aDhZNmhNL25OeEZQTWFDWmltT1IvV3JPbWdQL3ZqOThzZytzc1JLM2NnTlhVVzQrQXJxWWdaXHJcbiAgb3hISm4rQ1Ewa0ZWWUNOUkpiblRLYTE1WmVSRit4YVRWSzRYaWRKNU8rTVJnM2NzRS9vQmlhMVhNR0NIWUt3UXlvaDRCZmFxaXZZbFxyXG4gIEVLRUZFd2xoakpDVisyMEZzb3pKV283WmlWaGFTeXI3TkE3aUNLSzBZQ0tCSzZPV1UxUkN3TTVKUkpxQnlhTThYZFlhQXFVaGdoZnpcclxuICB4b1VpdXdpaGpQYmhOQzR3bTRaQ1pJMldDNWNPdENJWDUyZHBldUEwVFowL25nVElxcHFpTFNncVY2VlFnSXhKZk55eW4zTDR4RkV3XHJcbiAgY1FJbkREbEtpSW5BY01qQzVORStUTUloenRFZ0xHOThuaEg0Um14MnRId0EvZVU4L2dGY1VndWtKamxZMllOdXRFUUZjZ0huNGRtTVxyXG4gIERWZ1JWU2YzLzNzc0Y2SFJRaGlmT1VIMEFqREd5UXZzc3ZucFIwalZlY0FPd1ZnMVVFcFVnVmVJTUJKRmVsSDVQUmxFNkUyVWNFR2pcclxuICBjRUZYQWJGdjBEU1dWb2hjYXBOTE1KSEE3UXNmWVMzQXpqRlptRHpLejJXcklWQWFERjdFR3hleU5oRkN1ZmpEdGk0d200WUVXV1ZSXHJcbiAgS0VDUm1RKzh1Y1FBQnpJemRKRVc1eGE1SHF1TkF1c1crRTY0SUUxeEtDcVhoVUlVR1daRGhJd3FQdDd4cHhnK1VSUk03T0VFSVNjSlxyXG4gIE1SRVlEbG1ZUHNwYm96ZzNnN0F3TURtM1BLcDMxQzgvWEVJTEpEclk4WUdQL3doMzhBVXByU2VXMGptYkZjb0w4L0hsaStRU09UbWdcclxuICA1WEIwc0l0b0FkT1JuWDZFTkhuUUNlOVlOVkJLVklGWGlEQVNSWHBSK1QwWlJPaE5sSWowb2k1SVV3WDAvOGprSjVCTUxaaElvUHZSXHJcbiAgajdBV1BNRWhoc21pdkZ5V0dnS2x3ZUJGdkNuTld4SEt3eCsybGQ5VG1pUldaRU1HUlNhdVBISElHS1dmckhZbFlZa2RCY2F4aXJURlxyXG4gIDB1SlFvVFJGdjRlL3VaQkRrWkVMRVNLeCsyL2lUekY4QWdzbThuQ0NrSXVFbUFnTWh4Z21pL0xWS003SmtHR3pxT1U4WHE3UGZ6aGNcclxuICBScnNyUG1oR3l3RXZrQXY0Ny9Gc3hnYXNpS3FUeTMrZmxZdlFhRWNnRWtPblFOcUNjbmc3QjZZeitRbUpUWklmSTJQbkdCRm5iVUdYXHJcbiAgMktzSysvRktoZ2k5aVJMR2lNcCtUekJnaU1MbzVaQzFzN1RKUGdIZGg5OFROaEk4d1NHR3lTd2ZsNTJHUUdrd2VCRnZTdk9GSlBxd1xyXG4gIG5SempVdk5ZVVdoUVlNS2JYQm44SHZrVFM0dERIa1ZXbFFQR041WVdjT2ZyTzk4ektFNlhEeW1LTFBLaDRKZkd4OFZFUHVTUU5jZ1lcclxuICBSZUw0SEhhZlBMeXhCUk41T0VISVFVS2U0QkREWkZHZUdzVzVsT1BsL1B5SHd5VjFZYVVIMW1pSkN1UUMvanM4NndqRUhJUTFXbEJaXHJcbiAgcnZsazVEN3pTQzZSa3dQWk1uQ1F5R2dCWkNZWDZJbWtKcklScVFKMmpvOTBJbzU0Z1FnalVhUVhsZTRuUUlUZVJBbGpSSlcxQjBUaFxyXG4gIHpTS2lDbVRUQXJvUHZ5ZHNKSGlDUXd6bUpROEVIM0hRYlFnR0wrSk5hWjZRMklkdDVMZ1dtc2JDT0VSSVZMeko3RGQ4bkNRTktRb3NcclxuICA0anh6b1RoSldjQWltSXZ6MHpROWRLcHk5MGxCMm56Z1RWa29UQkJRcE5XUU9WSkp2cEZoZ2xnUkIwTWtjdjkxMkU4VzN0Q0NpVHljXHJcbiAgSU9RQU0wOTRKb2JKNHZ4a0JnTmFnTVZPL09VKy9nRmM1aS9IVVhhUjBmN29BL3puOFI4aS8xZEdIaUluQThybC9uK1A1ZTdQRmhpQlxyXG4gIFNBeWRvcVFNbm5kZzJyTnNMeDhoM2NZQU93UmpIU0ZpbjhvZ1FtK2loREdpZWdIc1ZhR2t3R1RWSWpIWC9QMWVuQTc1ZXlZRzg3SnZcclxuICBCTlZxQ0pTSEYvR21ORDlJN01NMkNHS1NNM1BDQW1XaTRrMjB2L0F4ZFJRQ01wbzREeC95WnRXaEtHRSt3R2xNRHg2anhibHA1c3ZnXHJcbiAgS3JYaVBLcENVYktpMzVzelVoUnBraU9jNUJNWkpZZ1ZHYVdKM0xrUThzN0NHMW93a1ljS1hHcFJDY0ViQkpWRU1OblNJczJNbnNZMFxyXG4gIE9CVy9naHd1MFlGRUJ6MzVBMXdNOEovbDJWUXVySWlLNUY1cHNjc25JL2VaUi9Ja0xkaUNNb2hKYk1jeGVNY3lJU1EyeTlpcERHS2tcclxuICA4UXFHQ0NWU2dEQkdWQytndlJjSFJsVFlCR1VGcUYyeUJ4RzU5RjVxWUY1M29LUktPQVRLdzRzS2RBYTNaLzJ2V0o4emM0STRHQkl4XHJcbiAgYjZMOTZNZHhHZ0l5R3BjMjNyOExwY2dhVmhPcWh3eVNsd0xPWTBiSlVoVHRmN2xRZ3B3cGIxeklLUlY1VGNRVkhXdVBXSmhSR3V2T1xyXG4gIEZmZkp3eHQ2TWtBRkxxV29oT0FOZ2tvTWFJR1V6TDVpMjVmNytBZHdpVjFZRnNrQmQwanBvSEtFSkREV2FFRlc3cUI1YUQ2UlhJUkdcclxuICBPd0pScGl4YWdTb2Q3Q0lheU9RbEh6R3BiT2NZRlhzRkF3SVJHa0FZSXlyZFI0QUl2WWtTeG9pcVduc1ZpQXFiWUZBUnpsS3NoZUJOXHJcbiAgWVhxVFMxQ3Roa0I1Q01zYm4wK2tZK2d2NGcvcnBhdzVFeWZJS1NJeGI2TDg5ZU00RFlwSTR0TEUrM1FoaDZ4QlVTaEdzcHVLSVJ5RFxyXG4gIGZFQkdtbDhwQ3ZOeHNzcWhIRkF1RnpMSW1mREc3eWdPS2FjaDRudzZFeVZ3d296U1dQLzc3WlBDRzFsUXFVSjFMcFdvaE9BTmdrb1lcclxuICBUUnlhazdCbXpZYVgvZmdIa0RnUVRCdThjR0dRRnBkN2d0a2ZhUWRIOHgrQlA5THJnenhFVGdhVXl6VVBJSko3SVdLakpRbzJZZjlBXHJcbiAgWkJPRURLYWp2UFFqcE5zWVVqdW5nd2o3Y2J6RUlqUTJzbFdWMzROQmhONUVDV05FVmIyOVVGQmhFd3lxUTIyZFM4eE1OcTNKSmFoV1xyXG4gIFE2QUVudVZOWVQ2UTJNZnlrdURoQkJsRkl1YU41YTJmU01WQkVVbWNmU1RLSTFabVF4NCt5eVRvYjRvRFM2c014WkFWQk5ENldNS2xcclxuICBDVHUwTnZKQlhrR2N5eWZPdnp3VWxadS91VkFNS01wQ0JvbWFONUpwSEZKT2cxRytJSkhTSXhaR0NtUGw5OWduRHpHd29LeENHWjhLXHJcbiAgLzhQU2doeHQxZUgvQ0tHV3I1MDFhL3BlMXVNZlFQTHJxM3FkclJ4ZGQ5VDFvQ3Y0d0R2U3l3Q212Wm1UbTBBaW93VkthejRadWMvY1xyXG4gIFlsSExSbGpFT0hFYzdlWFovTUU3bGdraHNWbkd6a1c2RDY5Z1FHaWtFTVpBekxhMkI0TUl2WWtTeG9pcWVuc1I2OGJMRkNhTFJVWGdcclxuICBDcWlwYTVQRUFaYVhwVGVPUTZBRW5zM0lEZm9yK01ONkxhTUlJemhCSlBRaTNrVDU2c2R4RHBIRTJVZWlGTEVpRGlsOE5qNkU4c3R2XHJcbiAgcUNLUHk0UG1pZkdQcVlHakhLTUxDOVVYdWxEU2dPZXdXdnAybUJONW9aRDliZW52MThEU0tPU2g2ZkloUXFMaWpXUVVoNVRqdlFiT1xyXG4gIDc5eEVIazRRQ1kzMVpiZFBDbS9rU1FVVC9EL01EcC9pdUZKWDRpdElITWp5cjdPTmo3SS8yZ3o4U1VabTVNcGk0K1FXZTdtRDVxSDVcclxuICBSSEwzNXdxTXlOaTRrMXNSMlFRaGcrbklSajhneFJDVUlyYy9aZHhKR0FBN0JLT2RUc1NWYkFFUXhvaXFlbnNSWTVQWUE2TElpMHNnXHJcbiAgT2ZCZGxNL0wwcm9zdER3dUdJUXRrRFAwRi9BblpCREJDVElLTHdxNlFHbFFHQ2Q1SXdSUmlsaVJOeEFKYjBMUThvYmpHWWRxVVpRMlxyXG4gIENtRm55NFNRWk5rSDE5aStwcTVlSCtqTjVWTVE0c3dMUTdWSTA4WEh6KzFLQWt3VHFIMGFJaVFxM2lCRWRqR1hTTnpPVkdod2dvekNcclxuICBXQ21yZlZKNEE0bWtuZmVLODFnV2w5aitpZysrbmp3cWMzS2p2ZHpCNkFKNVlSNHFWRnA0UkVZTGtDN1FYcDZ4RWQ2eFRBaUpqVThMXHJcbiAgd01ieG9sUkt4RTRPaU1DcEdVWWdZcm5sYm9BZGdyRnE1RWwzTWdlSTBKc29vWXlJc1Vuc0FWRkVZczB6bTNNaE5GT2ZYTzBESlJDV1xyXG4gIE53aXhuT0gzazJaZ2NJSkk2RVc4c2Z6MEUxUUs0NXlkc1NtY01BNEJQcWtFVjBiWXhHRTVaTzA1aEV3dEZKdjVzRkxBZWZoMDJsMlZcclxuICBEZWxLRUZVZ1c2WmM0RTBjQ28yV1EyVExlYmhqN3JKRVNHRzJTWWpneGJ5UnhDNEVTb05SZmtlbThIQ0NTR2lzbE04K0tVUnA5Q3VvXHJcbiAgaEV0MElBQWZkdndCY3B6amcyMTBrUnlzSkhEeWtqd2c4S3dSV1J1bU5SMFEyUVFoZytuSVJqN2V4aWxnZzJDc0kwUU0yaWxFRUZnaFxyXG4gIGpHRzVmaHhnaDJDc0VNYUlLclUyb1RkUlFoa1JZNU8xUjhpa1NYTDFSR1dvR2JZdU9KSTN1ZjJDczQvYmQ2SjJna2dvTEc4c0wvMllcclxuICBtSVBDT0dkbmJBb256Q3Q5TWdsV3RoTGJQREsyU1daNWRXVUV3MHY1b045OWV1Z2tMYzFqb1Q2WEYxb2p1Qk8yVUxOQUxiM3JxYmF1XHJcbiAgd1ZKVi93bDVJbFJBMWxRQ2IxeklLU3NoMkxuL0pza3FRYkRWRU1HTGVTTUpYUWlVQnFQOFRwajFNRjBzTkZiS1paOFVqZzhPUEt6QVxyXG4gIG03VjkrZUdTV3lEeUh3cmlnOGcwV0JFNXVRa1NHVkNTaHhjaU5scGtRZTVPd2tvMndndUxVd0lmRmR2RzRHd0FFTXE0a3ltZzJFN0VcclxuICBZdXNnQXE5V3doaFJGZVdMWUt3UXlvZ1lteko3TDlZOGhSVTU5SWxCQlVSMmppeEk2L1lnNWNtcG5TQVNDc3NieTh0cEVSVEdPUnRqXHJcbiAgQTV3Z0RncWZSSUtWcWNBdWo4Z215U1JWRlVPVnkzK1d5U1pHYk93VGNRVWx2d2NWRlNEQ0NGYUpzYmdHbFJmVWNWZ0dxWG5sVDdBc1xyXG4gIFFLeVd3QnNYRWtVWmdvMzdENU1zUElKZENBWXY0bzBrY2lGUW52T1ppOEFBeGdXRHNWSWVMOGN4eDVScFBKT2pZYzJhVnZxelAzNmZcclxuICBUT045dWVNU0hJaisyWXJvNE11UnQ5akxMZlp5QjVjSE5rN09zYy9ZWWxFN0dWQ3c3d0licHdJaHBMZHhDbzdCQ3h2a0lzcmxoV0NzXHJcbiAgSTBTTXZMMkNrYlV6QnVKQ1d3UmpoVkJHeE5oVXRBYzBUeEZoazB0VEpaSzBhWHJKMyswM1VUbUJDVDNMRzh2TGl6Z29qQ3ZNRDNEQ1xyXG4gIFZPR3lsR05vZVlkUWhFZ2ZFbnVSaEJ4VVVmNnBtS3drOEtaU0tFZzBQelZLODlPalRBUE9pY1JRTzMxR0pKKytjRDlKS0U0bUlZT2dcclxuICBLdjVVa1pBRGIxeElGRVVJZXZkZis2UUpnbDBDTDA3MU9jNWxHb1FNeDNoQlFtYWhUNkRqR1pETDZNRDVFc0dLajBENFF4MWhCMTVZXHJcbiAgcjJTWUxKR3JRUE53TW9iN1F3VkdaR3pjQ2FVeVp4UFJpSDArYkNzZkZkdkc0R3dBSXlBcXpRc3duVVErWndQa3BsTURFQ2F1WkF1QVxyXG4gIFVFYkUyRlJoNzNNVlZtVXhNQWRpYVdteHNBcEtVSkRXNVM1bFNWVE8xb1NlVlVJL1FheGdTdkpCVURiQUNWS0ZOK2ROT0I1Qm40ZnBcclxuICBmY0lneWtNVitVK0J1Uk1tZ1RkeEtEYXlzSExVTmJWWlNteGJPT0Q1Z3pnMFVIMXp1NFJMUTF5K1RNaitOdjdtUW9RZ1RqK0Z4a0NzXHJcbiAgY3Zzb3MvVlF2VHNYZkRJUGw5NEZneGZ4UmhLb3pvc2xHQ1UySmhUWU9tVHlLQU9FcUNLZGdUZDZCWVpMYW9HRUEybXhSUEhCWmRyTFxyXG4gIG5EdytBWnlNb1FJUUZoQkZ0S1NMYlN6eU1vQnB6K3FwRVd5Y2dtUHd3Z2E1aXBSV2lNQUF3aGdSeDVZUWlOQmdoSWhUU3hONkV5V1VcclxuICBFVEUyeTlpN0hFVWtoT2NNeHJPOFptbGxVeEJkN2xLT0pGdkhlSUd4S3ROUG9tVXdKL2tnbU1nREFoY1UzcFEzNFRnRWZZcEk3eE9hXHJcbiAgS0FkWHZ2aVRNWFVDSDNqalFsN0o0WEpRbEY4YWF1b2FxYjRGM1NKdy9hakFjSG5Hb1k0V1pxZFlXNXcrSHk0SEJmbkZ4OGRFUGhpQ1xyXG4gIEtQMGtSZzdlbURlNVkxNEUxYmx6eFNmemNHa1RvWWw0SThaQjV6aGZQckZSNTRGbDlKY1c4ZEJnV3hUZzFHSDdDaHd1d1lFNDZNSFdcclxuICA0K2tPcWdrU0dhQi90c0lSc0l0b0Z3VkRSa0U2aVNJYis5TVZlaXJrYkVCSE5pNEtGUllnZ3NCbTdDeG5KL0JxSll3UnNWY3dJQkNoXHJcbiAgQVlReUlzWm1HZnQ0ejBKVVNPT1NvdnFwWmdxaTVPMFNJUWdjNHdYRzhzYjJuZEV5VE9meThnQVRCNFUzdGZ4aVhRclR4WG03a0VDUFxyXG4gIFV2cUpFS2NMTzg4cU9GU0xvclFjNHJ4ellYa1RZc2UvT08rV0tFR2NiVU9pKzJxSkZxWkdDdE83NFBaVnFIUWhHR1ZDdGNpa1MvS1BcclxuICBWQVpsMDA5aUFEaVJCTjRrNVN5QzZ1VDZkT1llTHAwTEJtRjU0L05XQkE0Ni9CVkZEcnpXbGpCNStiN0NOZ3QvRktwK0NsMmdCMWszXHJcbiAgUW9UWXl4MzB6MVdacytIWW16aVozMGpzVGdxVk9adUlScXdHUXN0SDFBVTJ3Z2E1aXBSV2lNQUF3aGcyck02T3YxbGJ2MThBaERJaVxyXG4gIHhpYTJCWjJ4VDNJRFVTRk4wQVNxS2lTbW1iU090ZjE2bG9PQ0tkay9nb2tFWUZ4UWVEUGVoTjhlOUFFbTl3bE1sTUFkbS9nVHdhV1JcclxuICB3SnRrZndqVklKUEdsOGVGQWhGQ1BtVXU1QkcwdGR3Q2FlcFlJMUtkZlpWZjc2cW10a2xhS3Zxb1ZuR3VJY2NLZ1RmWlVLaklwYXdHXHJcbiAga2IzUEt4SWJsRTAvaVFIZ1JMbnlaS0Z5ZDQ1NWN3K1hMaElLeXhzeFZIbWdpb0d4RDEzQzVKVUJkTUE3a0txZVFoZmdnRnZzWWJKRVxyXG4gIERwbitrVUhHU1A1Vm82TS9FSEV3Y1hvRUwyUXdIZGtJR1RhRzFNWkZhZVV0QW1NanVZZ3RYNEVJdk5vVElvYWRWekJFR0dqVFNYS1JcclxuICBPeDBnd2tpa2VRbUxqUVJIT0RCdGFWU2pXdzJPTkhwWlpOSUNQbjBvUzlBeUpmdEdNSkVBakFzS2IyWjV4Ym9VcG5ONTVzeGNPZHduXHJcbiAgZ3JPWHdKdGtYd2lWa0xGMTZhMGNHVFlYQW9xMEt3a3B1cnVhNVFGUEJXYjlwQzNKcGNVbG1oMGY0M0xGYWJONXJqUW9palR4Y1NnUlxyXG4gIFJLRVNJanVmUnlRMktCdi8yNUVTY0tKay8wVlFuVnlmVElxNWgwc1hDWVhsamMrM0dMVzE5ZXhFWHQ1THVNZndSMkg1cDlBTmNtempcclxuICBBNHlEYnJHWDI1OW10QUtDaUJZZWtaTUJtazVoaEVST3lMSFBHS2NYUGlDeEZVcmp5TWJKVmFTMHdOc0FSa0RFOHNwMnhtVHRRQmZrXHJcbiAgaWUyS0hBY2dCRFpld21EYTBxaEd0eDdDWm1UVndxWGw0TW9SY2pFdUtTOWc4a2hvV1hESTZ3Sk03bzFONU9ISzRENFJuSzFMR3dRY1xyXG4gIHlwQ3hpL2JyU1dXVG9NaEtpMEtWS0VwYUVFWW41cWgzelVabUhDWTRwRSttejAyTTBzellVR0g2SkZTTm9zVFpVQ0RsalF1SklHZFpcclxuICBoc2pHWjJZaWc3THgyWkJUY3VCTnN0OHNWRjZOTTVHMXlDcXVCSkFrZnRsalpXN1UvMG1BMGNJNkdhQi9rc0lSemc0d1FpSXY5SCt1XHJcbiAgeWpoSVpMVEFaQUk5bFdRVGRzWkliVnlVVnVBaUNIUnM1MmdCQkk1SGJMU0lZMHNSZUxVU3l1aHV2Y0xBZkNLSzh2TDJzUUhUbHI5cVxyXG4gIGRPc2hiRVpXTGFLMGFRN0cyWDZEd2pGZW9DWVM4cm9BaytmeUE3RHYrQlBCMmJxZGVFRVpJaHVYSmlhVjlVRVJTN0toQW9yTUpmQ21cclxuICBLQlFiSjZHdGtXamQrazAwVzg5M3VBMFlzQVZ3UXpmT1lZcERlQlpoYnB4djl1Wkxwdk82VUZRT0NjWG1sVkdVd0lXTWhEY3VKSUxFXHJcbiAgcWd5bTk1bVl5S0JzZkxia2xCdzh3U0VMbFpjNUV3eWdUdytlTDNBaU1yS281Q3Z3V0lFRDRRTmUxeXF4QmhmRi80RCtLYWtOeDk0a1xyXG4gIGtubWgvcG1PRHBHVE1USjVCSFc1ald4RlZOa0drVG9FcHhDQlYzdEN4TEVka0xWVFJwSmprN05GTUpZSm54czJGZXhWbzFzUFlWT1pcclxuICB5ekVjejhxbzRlc2htNE12WXhBeVVvR1lTSER5b0F2d1JnVW12cVQ4aWVEc1hEb3ZLSVBwby8xRXBBK0tXQktIQWhTWitZd3RGQnR4XHJcbiAgdUhTTWpvN1Q5UFFzMVRXMlVrdnZWczdPWFo2b3VOS0gyZWFuejlQYzVITGR6V1VvS2plSDdHL2tieTRVb3NnUUlTUGhEVUlCdzZFTVxyXG4gIHBuZjJ4am9vNjg2a25JSURiL3grc2xDNVhOZk9qS0d2RXM0Qy93R08vU3RPSk1hS1d5QTE3cVNXZyszK0ZQZEhPTnJnL2hIVEt4bnBcclxuICBmUnJBNmYxRzR5Z1ArWURWalVpek5zcERaTFJBQklGMmNvZ2RMUkNCQVlReEl2WUtCZ1FpTkNnaG9tUy9nQWdqa2YwT0pWV25uSUZwXHJcbiAgczFlTmJnV096S1NSL053K2dyZ2l0SjhkRjRNbFNzb0ltTnlFUXZGbVJVNGpnZjVxL1VRQUk4RVRISW9RNlcwZjhhNWNVTVNTVkpNZ1xyXG4gIFo4WWJoTHlDUS9Vb1NoMStlL0ZuWFY4bjc3cUc1dVptaEc5czY2UE9UZGRUWFpONzVpT2Y0OVRGSTl3U0dXQ3E3Sk5QdFRJVTVGQjBcclxuICAwQkVLa1RWU3cwVENHejNrbm9oQ0VVd1hsOEdnYlB6TEk0aUlOMzRmV2FqY1gwZXZvQ3FzeklHNEl5dVJPOG80Nkx4TlpBd1ZnQWlSXHJcbiAgbDRIVWRLWUFZWHBudzdFam1SQXliQlN3ajJ4a0s2TElCblRHUmtUWXYxZUl3S3M5SWVMbDdGUXJKMTVRTUpqTzJQcWNzS2xncnhyZFxyXG4gIENqd1p5UmlTWDdJUHdOa2t3aFI4RTlEVXZZVnE2cHN5cHZtMGtyMXV3S2t3Z2VseTVRQWJmd3dnSk1EZU14eXlpSFNXZDd3YkJJWGpcclxuICA0cEJCb3VhTkM2bUNRMldrMWlXZk9QOGs1REpJd3N6TURMVzF0VWx3c3JyR1puWWkxMUZ6ejJZV3dObkQ2VGRFb1o1bXhzN1I0c0pzXHJcbiAga2xjSXZNa0VkejRYZjlqRXd2S0lyVGtrKzRsVU9jVEtZT1E1M2lCNEptZzRaR0h5N0g0dFNuOVpCRkh5eHVkZkhjSWFXQ3VzTnIrRVxyXG4gIHNjSVdDRUo4MFBtdjhjYy95SUxRWW9tQ1RDdGJwWDBVTW1JdzdWbjcrelA3VGZlaHRPWWJ5Y0VMRzhsRlpMUkFCQVlReXJnTExhRE1cclxuICB6bTBjbVBiN0JUUWZZYkhSQk9BTVRKdTlhblFyOEdRa1kwaCt5VDZBeUNZaUM3R0VxZG9MbW9jZ1RTQlpTMGpsQWQ0Z285WmY2ajRlXHJcbiAgSUNWNGdrTVJUR2Y1eHJ0QVVEZ3VsWG9rYXQ0ayswUW9SN0FxK1BqQ3VKQWtDT0VTTVRrNXprNWtpbnA3ODIrNGErbmRRaDBicitYV1xyXG4gIENKNUdqOGM5YW1sK2FvcW1oazdMeWdOVkl5NXZFbmhqd1ozLytZK2FWb2F6MHJ3MFJPSWNZcVVhZUk0M0NKNkpiUEl3WGJ3L1Era3ZcclxuICBFSlkzUHU5eXJGblRUWC8yeHovL3loVGVDSmZXQWhId1grRlpSM0NjbFVrVTlMazBHYjMvODNrakg5QWhFY1BwQVNNZ3F0SUduMGpnXHJcbiAgMVo0UXNSY3lST0RWamhDUjJIa0ZBMElqR1g1dllpWWJjQWFtTFYvVjZOWkR5RlFtK1NWbEFTSWJqcVNIVmdZQUU2TWNGbVluZVJ1bFxyXG4gIFphUy9LY2dWSnN2dEg2ejdSREJ6c2ZkTUZpYlhIYnNvWSsyNFZDcElWTHhCU0lURkNCYnBKMWVBT0N5TG9rVFZoNEdCQVJya2NQakVcclxuICArVUo5ZlhNbnRhM2V3MDRFNDVBWUR3bjk5TE9qQXpUZWY1ai85bVVHMVhOaEdSUWxzV09VLzZpNkhENERTWjg3emdsaWhTbzl4eHVFXHJcbiAgaUxDUWhjbmovUmlVZGFXT0lDdzJ1SXJna05PZ2EyQzlNb1UzeGlVZUNUNzAvbURibitEK0tFRWs4MEtYQmlqV2V4SzJHcm1Ob21BZlxyXG4gIEtxcHNneWc5V2JJMnlxY09ocEhMU3htSUl3V0Q2WXl0ejBjaXIyREFEa0dsYW9kZ0VEYVZTVzZGWlRHQmtNclg4SjNvREpZRVI3ZEdcclxuICBCY3hQajhsTUU4bFdncVpQWVRLMzcwZ3RaYktQaDlqQTFobEhPZytUVzU3NXJCMlhTZ1dKS21FNDVCRzA2Y2VYTVJob0tFWFdzQ2hjXHJcbiAgT3ZyYUcrVEo1NDcyanVLc0xkUTF0MUhuNWxkUlM5ODJGc0JaNEQvV2xzZjg1QWlOSEh1Y3BvZjdoYThPQlR2SmhSTGtUSG5ESWY5UlxyXG4gIGRURjhZa2tic3lsaWhTbzlseWM0WkdGeUsyTnNrcFlVd1BIRTFHbk1mSXNEYnJoZUdVRFA0aEljQ0I5cU9kYnh2K0JveEJ3a1N2VWhcclxuICBqY2xqdlVzanNMOHliRFF1MkVkYTZZa2cwR1lEV1RnNUlETzV3QWdSZVNFREFzY2pWbHFTaWp6U1pmTHplOE1tc1FXWTFxOUpJNTBJXHJcbiAgZ3dhUXZETDV4M3BsVmVZMW1PVGdaKytVWTNGdWtoWm14cGp5S1NNdzcvYWJxUFRYNmQ0TXppYjNXMk9Zam0wa1d3U1RLaHdYSklKWVxyXG4gIDdQTjNJUS9WaEU5dVp5NFVJbXNVaDJWUWxDUUp2S2tReHNmSHFidTdtM2J0MmxXVU9CY3dKdEs5L1RacWFFVlhDdDRkRWg0Mm5CbzRcclxuICBTYU9ubnFINTJTazJaZnQ4OGpRc2k2SkVMaFFnWjhZYkR1bW5ERkhDYk5rVHBBclA4UWJCTmhhS1lJWVprMUE2T0lxaThBcXlXS0VEXHJcbiAgNGNNckJ6dys2bzYyT0tOSEJhaGNwUGRwR082UDVJMzcrMVR2Ykp3ZU1FSkVYc2dvdHdsV1dSdmx0WHhlQVlHcUJVcUlLQ2tUQUtHUlxyXG4gIFRQaGN4RXcyNEF4TVl6K0lITy8wUWtZOFEvSUt4b3hVcjZ6S1VnM3ozTHl1YlhUUEVGVEEwaExOako2bHhYblhVckdja3YwQ1VocjdcclxuICBHTXcwbE50cklyQk04dUowampTTlVuRXdKT0tFNFpBaWFPd1Q3OFNGUXNRR2NTaEJrYW5mbHdWVGxIK2NSVDUwTlM5UlMwc0xOVFkxXHJcbiAgMFBIK29VS2JvbEJiVjA4ZEc2NmkxbFU3bVVOM0ZycTExSkVzekV6UTJNbW5hZXJpQ2JZdC92aWNzcitGdjdsUWlpSmpoQUlrSmx3Q1xyXG4gIEJQOHBTeFVseXBiTkl4YXFRaWplSUVRRVZCbVlQTTc3RmF3SUszSWc4ai9FUjFrRklLSW95TFRTVlRwRWtTelNlNVdYQWJBeDBnaW9cclxuICB6UnFjRXlqdDVDd3J0Z0djRGI1ZXlJREE4WWlWVnBHVEEweG44Z3NrS004eFlJZmdwTmdxcFdURU02VFVTZDVBeElpNWJKU0VUTUJVXHJcbiAgbEs2K3FVTmx5MkJ4ZHBLbWgwN1FJaFplaEhtU1JFb1RSRTd2eSt3MUVWZ201Y0R2eUZvNUxrZ0VYaHpyRVZLb05IemNma0JLeU1FcFxyXG4gIHNxRUFPVFBldU1DQy9NZk1NdUZTTURJNFJQMzkvVFF4Z1c2VGxhTzVld1AxN25xZERMUUhSNkxqSStqT0dqejBFRTBObmhZK1JsSDVcclxuICBOYVFma2NiSHcwUStGQ0pyNUVJR1hzVWJEdW1uQ0Q2QnBURTJnUk9xd25OdW93U0hMR3daOTZVd3R2UUtsc2VLV3lBK2xqL0NhQjhGXHJcbiAgbVZlWDZEM0pSRkI1SVpQT0JodVZxME5TV21KSE9nSWl0dkhpbkkweTd1N0h3KzhMY0RacUZ5a1lFQnJKaE05RnpHSTdodVVwS3RzS1xyXG4gIGhJeDRodVJqOWdHUmpaREtSMUlHVTBrNjFlTFpnZHBHRExZdWovbXBZWnE2Y01nUHFvZVBRYkxVZkRWa1lYSzJjVVVKVm80TEVvRVhcclxuICBsK2daS2cyZkpIT0VIR0psb1VIZVJQSlVKdjFFSmh5cVJ6WmxRWEQ3dERCMHZwOWJnWE8wYWYyR25HNGxBZU1pdmJ1L1RCOUFsSmFJXHJcbiAgYTVFc3NnTTVTY1BIUGs5emsyVmRsdVZ3MWlGa2pwSXZROGF3RU1zWUplcDRUL2dVd1l6ai9TZHdRbFY0TG13c0tMQ0M5ZVRGbzdZU1xyXG4gIEw2Wk11K0JXNGNWTHBJTDlLMWl4QXdINEFQcGphSVQvTXdEK3M1ZlJleEsyRW1YMUVXMlJWdVlPRUJnWjJ3UWhNeVUydVh3Y2oxaHBcclxuICBGVGs1d0hTVW56K2hzUkZqVXdpWVpsbVFSam9oSTU0aGxva0lqQW1FVkQ2U01waUt5cU5FMEtKN282bHpYZFd6UlJabXhtbnkzQUZ0XHJcbiAgaldBNWNaZGQ3cmM1bUJ5L1U2UEl5blNSSkloNDQvTkVDQWhTL2ZoTVhVZ1FLd29OTW1yZTJIN1RUekNwak5neUNpNWZINHJOa2hCaFxyXG4gIDV6cDI4Z3NMdEhidFd1b2ZyVHpwb1ZxMDlHMFZSeUxQanRTZ0l0UXhrc1g1U1JvNzh3Uk44TTNDRWdhS3MyVXZMQ3hDT1ZMTHpGSDFcclxuICBlVWRHT2NUS0FxTkVsZHREQmliTjd0ZkRDVlFvRkc4UWJDUERIUG9VdXZGUndPd3JYWVUzUDgzNjVZeVZ0MEJ3UEFWR3lNRjM0RDkzXHJcbiAgR2IwWHl3ZEVzZDRSVUpzbE9DZFEyc2xabHJOeGRLRU53K2NES0NFaVNlc1ZKalNhQ1orSFJKRWRhTE5WS2JaS0tSbnhETWtwazdkblxyXG4gIGhGUStraktZS2t2REVKV2xxMi9wcHRWcjFxcWlDbUJHMXV4b1AxY3lUOUhFK2VkcGJtb2s4MnlCN2N2Mm54VEQ2U0pKRUJYb0RDclZcclxuICBqeFhlQ1ROd3drSmxSczBiMjJmNEJIVTVZaXNMMlRKbHc0cVJabkR5NUVtaXhrWjc5aVBWWFc1b1hiVmRCdHIxSVVSQUI0Rm5SczdTXHJcbiAgOEpIUDBUVEhDWXF6NGNBYk81NzVVSXpVS3ZvSGlvNW5EckV5WStERnZPRVFQa1V3NDNoL0hrNmdRcUVDVzRoWHB2QVdZd1ZIZzQrdVxyXG4gIFA4Qkd5RkZYb09KU0Zoc09FZ1c5ME1MYVgxNnFCNVJJSy9POFhrUnM0OFZWMnpnT3NkSXFjbktBNmNqT1NxMG1JbmM2Z0duOWNvaDBcclxuICBRa1k4US9LQnpJc2l2WkRLUjFJR1UyVnBHS0xLN29mNUxWdXduaEthNENzQU80MzV5U0Z1a1J5azBST1AwUGpaWjJoNitCVE5UN05EXHJcbiAgV1p5TDl1eW9zTThnS3RBWlZLb2YvNXZ5Wmd5bktGREdLdHRYK0FSVk1XSUxEbElHaEx4cWVSUWxxaFJTREEwTjhSM3RHaGxFZitHQlxyXG4gIDk0czBzQ1BaUVQweVJvS3VMWjFOaEp1RnlmT0hhUGpZd3pRN1BpQzJ5eUw3VXlUd3hvNS9HdkpJTGFKL0tudnNjNmlnOUNxWG8rYWFcclxuICBoeG5HKy9Kd2dySzByNkFTTHIwTFMwNGNoVlplUWtWUkpJdjBRZVZrakNROUIzeWovSjFNWVlTSUlodllMMmVqQW9NU2trejI1UlVtXHJcbiAgTkpxSlFHYnNRTE1zbUpzT1VjWVd1Y2grdkNqU0M2bDhKR1V3VlphR0lhck1maFNpa0lvSjd5K29iMjZsM3I3VktsOEpscFprcXUvTVxyXG4gIDhHbWE2SCtXSGNxalhPazhSS01uSDZkeDVpY0hqc29kN2V6RUFNM1BUa2hmdnI1TE9vV1dVRC8rOStTSzRvUUZ5a1NsUlBpb3VCZytcclxuICBFWDlkU01YbHlCb1doV0lVV1VyZ2pRdmQ5ZVB5OGpaTTMzM3UxTVZFOTRLRWFML292Mi90MjBaOXUxK2ZPSkxGdVdtNVFSZzkrUmpOXHJcbiAgVFk1RUtjcENDWEttdkVGSWhIa0ViZlJQWmd1ZklGWmtsRjdzY3RNYzh6QkR0NThFeFNsZVFUbHFsdWFla3JidDJiTVg2S1pYdjV2T1xyXG4gIGNGeU1XcXB0N3JaRitNS0JYdDU1R01sRVVCWHJYWlQ4OVQ1L3dObkVGcExBRUVtejZXTFdHRFVwczR2MlVjRk9vMGduWk1RekpLZEVcclxuICBsTGZQcGtnRkdhMmx5U05OdDN0MURUMzY2R05VMTloQXQ5ejhhbnJxeUVWWndYV09XeGlZZ2ZXaW82Wld6cGNhYmdYVjFOWExIWEVOXHJcbiAgT3pUMmFpcGpXdlE0cDh4V2JOalc4V0lEMnJJc1IyU3h2SEdFNm8xemxoV1RsaXYzYkdqbC8rVlJOcW1sM2J2M1VqL0d0djlOb04xWVxyXG4gIHdPVEFNWm9hT002VXU0ZGNvb2EyWG1wYnRaUFBsNWJJc2hxc3dEb3hyWnd1YUNPNzBpUWxDaS9tbHBkUmVhaG1jVzZXeHM3c3A2VUZcclxuICBqQnZGV0tJTjYvdm9rUWYvaHRhdng0M1lLM0FRQjRLWHFEejExSFAwMXJlL2wvclBvVWxiQkhZZ0xleEFhdmppRm5DbDU2OFJJeVJ5XHJcbiAgUW80anZhcThnSkhxWmF0R1FoZnBWZVNGakV1emtXMVNGa2FtYkNGSnhnNGEvU3J0SUdURU15U1hSSlMzejZaSUJSbXRwY2tqbXc1c1xyXG4gIERkVlBIS1BoNFZGYVdKaW5WOTkyT3gwNGcrV29GWXQ4a2NDSnpITUxBODhONEc1VUZ1VmJ5WnBLTHhGcTJNblUxamR6YUtLNmhpWjFcclxuICBNcERCK2RRM2NveGdqc2lqNkxqbGtWZ1ZKcWt1bjBwb21EdFAvV2RQRTgzTzAyMnZmeU05ZHhwUE9yODBVRWR5Z2lsM3JCYW91WHVkXHJcbiAgZEgzaG1TS1BxUFl0cjRpenFNSXlNYWxzSDdSR1ZUUXZVSHBSc1RQQk0xRmpwNThvY0NERURtVDFLdzZrQU9KQXpwMjdTRzk3eDNmVFxyXG4gIGswOCtWLzVHUXI1YnFtM3U0VXBNV3lDaFhqVWlVd0Y3OFRKNlI1UzNHSXdRVVdTVHRiZG9PUnNWWmVTZWpWSlhzTk1vMGdrWmVNa2xcclxuICBVcGZaQmlsVGtZa2kwZ3FaTTJEazA4Vy92M25tRkEwTUROSDgvQnpkY05NdGRQaENQTWZkN0RKWm9Bc0tnK2U0aU9Ca0VHTnV2TWp4XHJcbiAgdkFoMG1DdXZrK2I1aXo1MTJNMkxBNUlYOFh4Qk9xRWFjVGkxN0hEZ2ZPb2Fta1dHRlcveC9nMjh3QW16MTlLajhlSmdidVFZalY0NFxyXG4gIFI5MXIxMU5kQjU3ZmVPa3hOWFNTSGNrcCsrdmdPT2FwcFhlRERNYm5rYWtqakMycE9USll4aXBSbDlzR2pWRVZzeTFRZWxGd0pqamZcclxuICB4MDdCZ2VSbnhMM2lRSW9oRG1UNTdpdUdkeURvVWpDWnU5aXlGYld3VnBXRmpjTGJCdG5LbkVlQm5yRnNIZ3cxS2JjTFpHd0RxSjFLXHJcbiAgSTUyUUVjOG9kUjZSYmFJR2x3Z0NreSt2UXpZTjJFaGc1TUxBUVpxYm02T1ptZG5JZ1lTMGFSWXBGOWlNbktFU2srZlZqRUpoSkU1eVxyXG4gIEtFR2tMVEJVUjhlL3h6azhkbTV3WGhMRG1jSFptVE9UMXBZNHcxbTV5NVNweWhXQloybmFxQjdQMDdDalFRdW52cmxERmpSTXo3TXNcclxuICBLdjhpWU0rbVZucjQ0WWRwZm1LQ2JycjlkanA2UG4rM2UxbW9XSkhHS0RhY0hEZ2V0VWpnU09hb3BXK1RqS0VzanlqUFlySUF5eFE0XHJcbiAgVVpmYkJvMVJwYVlGQ3BlRWI0UkcyWUVVblIrdk9KQmlyTkNCWUJxYm05VmpGMHQ4UVhtNlN1ZkJVVnJ4UmJTM2lTMGtnY0hwOFEwV1xyXG4gIFJUYWFiWmtOU0dNcTJHa1U2Wkt5UWhOc0ZiR3RicklwVWtGZzh1VjF5S1lCR3drOHFjVGk0RUdhbnA1bUp6SkxOOTN5R25yK1BCNHNcclxuICBpN1BJWkFhSXFFRE9VQ2x2aTlXTUFvVVgrZFFWWU5yS1JveHlBNjlKVENwbkNPZXlNRHZGRmNlMFBWREp6cGQ1MEF1ejQxeXo1Q3NkXHJcbiAgUEt6WmdDNWRiclhBdVdCZEtobkxXUVkxazZkbDVkMm1waVpxVzdQWHBDOHhNajhQam5ocThCaUhVOHpCa1dDTWFvRmJJMXVvcFdlVFxyXG4gIDJGU1BLSE5YVVd0VWdzcmFvQzYzQ3hxakNrM3pRdnp1MFZOUHlqcHhXYXhmdDRvZWZlaERyemlRREZia1FPcllnZWhGd2hla1hKUFJcclxuICBoZWtyVkt2U0VqM0hqblNFaUx5UUdVZVg2RlZnS0xGSktuV2w4NVV4MDU2TlVwZllxU1NTQ3hueGpGenJ4eUd5RFZLbUlwTkU0OG5FXHJcbiAgZ0pGTkF6WVNsS1Jybno5THAwOXhKY0RpVzI1OUxUM1hINjk3bFlHSThuS1ZtTHdnV2FIUWk1TFVKVEJ0UmFOaXBaY202b29aTFlPQ1xyXG4gIHRKRUlyWmY1bVhHYW54cGxia2xXTko3SDh6Sm83VVJvYU9zVHA0SXVzOGFPMVRJZTR6Qnc3REZxYW1taGJkdTIwY0RVQ3psOVZ5dkVcclxuICB3cnJ5TW9BbnMwT0xwSTUvVXkwN2txM1UxTGxHOUplR3FKUkdscGU3d2kveXFtcFNHMVZvcWtKMHg0NmYyUzlUMXJOWXQ3WlBITWlHXHJcbiAgRFpmenU3LzBVTDBENFdaOG5Sc0RrWXNxdXJLaXlqK29nc3lUUnFTVmVsNnZJaTlrSnFLOVRXd2hDUXlSTkVuSHlPUWpYTmdZbURaV1xyXG4gIG81Z3gyaUE1SktLSXNYMEZTZFlXaUxSQ1pnM3lhZExqWW5IV1NGQkRTME1IYVhTVUt6dFczLzdhTjlEK2s1azdxd3JwVmNMYnZJcFJcclxuICBLRFN4VDFrQzA1UWJNSXFWWHBxb0syWlVna3lhUzhuQ29FbDFPejg5VHJONFR6bmZ5YzVORGN0c053KytBVnV6ZmlPZDd6OUhMWjA5XHJcbiAgMUxiMktsTzgxS2cwT3lsQUhRbG1iY0VaMXJHRGJLYlcxZHVrRlphaW10eXlpTklZV1o1TGhmeTlxdGdtU0prcXlXYmkvSE0wTzRaM1xyXG4gIHNxUll2YXFIUHYvd2gyalRwblVtZVFWQWRRNEVyWSttSG5FaU5iSVdqTHZpT0hZa0UwS0dqY2FSWHJhWlNqeXJWNUVUTHFjSDhqYjVcclxuICB5amkxaVVpM01haWRTaUs1a0lHWEhDSjFrVzJpQmxkaVgrbzRvZ2hJY3ZSa05oM0FNdjNTOExIUFVWMWRJeTB5Y3h1M1FKNDVOZVZOXHJcbiAgaXROQ2F2SkNkWUhRaTdLL09VYWxQQjJLbFNKTlZCVXpLVUJrdjlLa2pFcS9xbHFnVDMxbTdBSXRUUS9RNUJqZjNTNkZGa3RUeDFvWlxyXG4gIHhHOXNYeVd0Rm8raTNaWlVlaTgyWWhlVGRTUk5uWDNVdW1aYjBzb1NKR1ZkYWNFamV5YkxVMWZJMTZ1S2JWUnF1c2dFenpWTlhqeHNcclxuICBYTURXTGV2cDNyditoRnVPRzAzeUNvRHFIeVJrSjdLODh5alh5M1paNTRGOG5MQklqNjhYTXZJMjFUc1BVSkVkZVAyQ2thMGdZeWM1XHJcbiAgUkdyUGlKbHNJalZUbHE5QzlVS0pLdkFCVUdpa1FINlJqWkNKZ1lGNXppL2VIYVpoTGl3c2NIMDFMMk1obWt3Mm9uZFFpZTBucDNhQ1xyXG4gIFNPaEZTbGpLRE16SUZTaHZ3SENLb1BRUzNtajJYbUtoRWlJN2wwRWtLb09xaXo4clFyeXZLR0RtMTZiMXE5aDV6RkFETzRyVzNzMjBcclxuICBhdCtiNUgzbmVNTWd1c1dHano5TUZ3L2VUUmVmdTFjZTBKeVVicU5NUnY0M1ZRcjVaSVZoQllpUFI5dXFIYlJxN3h1cHRROFY2VFROXHJcbiAgako2bm9VT1BjcVY3VW8wZGt2M3hCaUVSVmtKa3grbXlQeTNBU1ZLcHdLdUtiVlJpOGlqek9uSGlZQUxxNityb1YzN3BoN24xVWYzU1xyXG4gIFFDOFhyTUNCK0kzRy9oanIzNkIvbEVPcWwrMHllcVFQRmtWNmZJT0YvOU1GU3VndXltMjhPbGNXZnlyNWJkWU9GdklidkVnTUFnbTlcclxuICBJd1ZNQllZUmFZUk1sQXpZSXhqTGhINE1JQ1NobHhpWVozbVNWSTJwdnI2ZVd5QTZzS3R4bWxhdGtCREJCQjQ1Z1lsVTdzcVdzV0NZXHJcbiAgdEZqSmNJcWdGSTQzbXJVbkxGUkNaQ2ZwSWxFSlhNbmpUOFVFRG5IZVNlQk5yc3o1Y1B3NDd0cUpWcTFpQjdKbWo5Qm9kZUI1aTg1TlxyXG4gIDE0cERRZWhZZjRYb2NDZDg4Y0JkRXNiT1Bzc1Y5QkdaYmJZOGl2ZWZDM0c1VFpRTEZZRHB2Y0dSekhDcjVDUU5IUHdjVFYzRXdIc0pcclxuICBrdndUaGtNbG1JMlZOeTUyQURnWE12RGl2TjVKM0htQTFtQk5mZHFhbXVlYk1Gdy91SjVlUVlycUhZZ2NZSXNkeVlTUWNqSTRPRDAyXHJcbiAgU2lmT3cvL3oyQ2dOdllnRUtsTVlJWG9uaEQ2aVRaUGV6WE1jMmZqVVlXT0FuWk5nYTdva0wxQk1CNWJoN0JCa0U2bVpnc3dMVkMrVVxyXG4gIHFBS3ZFR0VraXNvTGdNaWxBWmhuZVpKVWpaVmtvUFd4d0swUFBQbmQxZFZsVW1lRmhBZ3FDMUN0aDJPeEwva2tXb05KWFg0NUF5Y01cclxuICBDdUY0ZzJBYkM1VVEyY1g3UWlpQUszSDhxWWc0UHg5NGs1UXZHNnFEekxycTdlVzcyTXF6bUxDS3NxeGZ0ZU5XY1NnOU8yK1hoeVhuXHJcbiAgWnlhNWdyNUhITXA0L3dGeEtDOGNpbjRYQi9mYkk1RVBCblVrYjZDV3Z2WE16VXJMYWVDNWg5Z0JYbUN6Wlk1N2ttZkNjS2dFcytFMFxyXG4gIGNSRURUSitSQm5HeEhoeG1tVGEyOXFrZ3dwTlBQV2ZVSzRpeEFnY0M4Q0gyeDl4T0Mva3pEUDZmTkptd0diMFNQc3JwaGNWRzVjczVcclxuICBGOG5TNXd1a05rSjZHNmZnMlBhbEVwTWpTdklDNjQwWVloQkkzZ1FKYjB0c1JTejVlaVhEK0VpRTNEd3Jhck5Kd0R6TGsxMnBzWktBXHJcbiAgc0RVWXl4VTBjdVgxeVBPRExMWTlwSWtaa3NDQ3diTStWUVptNFBMS0dUaGhVQWpIR3dUYldDaERaQlB2QnlFREZhZWZVc1Q1U09CTlxyXG4gIFVwNDRYRDdhYVpnbUp5ZHBkbmFXNzJSeGQxdTBuK0pRMTlEQ2xmUk82dHg0RFR1VU4xUGYzanRrZGhlbUdic1dDc1lsZEhWZGwrNkZcclxuICBSbG9tQ2U2WUdkdTJlZ2YxN1hrdE5YZXZJbHFhWVNkM21FWk83SmR5QXZIL29wOENXRjRhRW9aREdVelA5bkdSQWt5ZmtRWnhYbytaXHJcbiAgYzFrOCtPQ1RScjJDR0N0cmdkZ3g5aWVBSEh5RHA3MlJzektta3A1UnBJL3oxd1FHSlZSZGJoUFVlUnRJMU1KMEVobk5nQzYzZnhlSlxyXG4gIFBDNDlVNEZoUkJvaEV5WEQ3TDFZOXVaSURvblN3RHpMb1FxYWpKMndrV3hwaVJvYUcyVlJSY2svVWlseUFoT3BQQ3BWQkV0alVRb25cclxuICBEQXJoZUtOWk9oMUNHVXd2aVFLYmhZckRwOUFJY0NvZmNnSU9sNE9pL05LQVZYZm54c2VsUlhqbzNKUS9IcGNTc0p3NEt1dk9qVmZUXHJcbiAgNml2WW9leCtIZThENzBJL3pzN2trelIwOUhQaVVIeUNndkxrdytVZzVJTUhMdHZYN2VQVzAwM1UwTlpDYzFNRFhKN0hhU0k3UGlJSVxyXG4gIC81MStDaEN5NWhBelpUQTkyN3FmbjFxYlBpTU5JaVV3NlNHOTlvaysvOWl6c2l6UUswaXh3akVRUkk2SURyQ25OZFkvTHBJNTBoRTVcclxuICBmVVJibEp4U21xRkJDVTNpaE5Bak9NNVNoNDFCYlZSaWNrU1NtZkVNU2UzWlNDZVI1cTBTM3ViS1pocFJCVjRod2tpa0pZMVl0NGtBXHJcbiAgZTRSWUF5cHd5bVprQnZUYk5qVHdYVytpeXRnNmx2Tnc1WW0wREpPNHNpZEtKd2hDNFhpalJYSTZoREtZdmpCL2hZckRwOUFJY0NvSlxyXG4gIENXTmhwU2pLZzRQOVFJdEt3elhidTNYOHFiNlI5dXpaSjZsZlNLQTFBb2ZTdS9NMmNTaXQ4bXBib292UGZsSUN1cnJ3WUZ4UjJWeUlcclxuICBpSkt3TXRRMXRsSFg1dXVwWThOZWRpcHo3TnlPMHNXRG42WEpBWFlrcGRtRi8xWS9CZkJGOGdTSE1waWViZDNQUzYxTkgwdU4zYnRyXHJcbiAgRThlUm5ISGg0aEE5K3ZsbmpIc0ZEaXZxd3BLL1ZRNXlkSEE5cmJHeWtjeVJqaEJSdFhwR2tyOXEwb3FaWTBlSzNwaWNEV3NRT2Q1SFxyXG4gIFJqTWtkVEJpUkhhV24xZUJDZ3dqMGdpWktCbXB2ZXpMYUNFcy93RGo5V3VhUUFtRXpjZ1ltbmNOMWJQam1MS3VFNmRKYkQzclVtUmhcclxuICBCdDR1UmlvVWpqZGFIS2RES0lQcEpaR3hHYmhTYWNrS0RUSWhLNmdXMlhRYzdNZFlsQTltdVJ6d3ZuTTQ4TmFPRGhxWWFUSXA0SEo0XHJcbiAgSVlPK0l4ME9CYzRFZzl6QTBOR0g2QUk3azRrTFIyUTZjUlkrQjk0VWhZZ29DT1hBZUU3Zm50ZFQ2eXE4MUdwS1drWVhEenpBamtRZlxyXG4gIGJxMmNUZmp2OGNuQnAvVUVoektZbm0zZFQwbXRUVzk0NW9HN3FMc3ZQK1BxTC8vcW40eDZCUTVWT3hENUUrVVlSNGRlL2p3aGRKdm9cclxuICBPWGFrSS9BSFZ0VGpHK3NqR2x0RVhnYkF4a2dtaEN5eFVZa29oZExJYUViNGZRQUlZeVRTdkZYQ1crU3ZEQ1BTaUNyd0NoRkdJdVJsXHJcbiAgREtLY1BjQTh2aG9wSDlzSW01RXhOR2VXOGZmV2ZYam9VL1Y0NzBSaUM5TFNXNG9NV09KMm5paWRJQWlGODZKVWw0ZnBDL04yb3ZBcFxyXG4gIGhFdm5keHFIYXBCSlkyV1JLQTVtVVIyY2RUNWdMYktKaVFucVlBZVM2bDRNeFBuekVheXRaMmV5VXh6SjZpdmVBZ04ySW9jck9wTWlcclxuICArQng1RXdjdkRCWVdVbUJTQUNZRXFDT1paa2R5bUFZUFAwTHowL29lZmdtU3FiRUZDR2NGUGhtNGRFbFp5bUI2ZkRXS1lEckc1SVd6XHJcbiAgMU5jYkpwNEEvL1RQOTlIUVVQNHA5WmN6VnRpRjVRNDN4L0puR1kxdFRtK2tJOWpBaXdyMHFPeUNSWkUrMElyVUpxanpOaW94T1NMSlxyXG4gIHpIaEdZYXNETUx2SU1sRTdScXd5ZVFxZHlUZitoVXA0emdCN3RrRmtrc1FHWkc0LzRDem5TRFUrUGs1ekdMU3RyNmZtWnF3OHl4QzlcclxuICBHa1dtQnBPa096ZVl6aUFjekJ5UjBhY3duY3MzWTZZaUs3K0VESnhZUXN4VWc5aWVBNmVYWXNUQnRKWGhyTXBDTWZadGJwWG5iOFlIXHJcbiAgQnN5QnZMU0FNK25kZ2E0dWRTWll5dDA1azRVNUxQVmYvVzhEdkJWdjRtQ2JUSWdkeVJaYW5CdVZsNU5oM3dGbUt4a0ZOZzkzeHVDVFxyXG4gIGdVL25DUTVGTUIzYnllNFFWQ0VBLzNNLyt3UEdLUzRPRE5QZi90M0hqWHNGd01vRzBWM3NqN1FTYWVWWnJQZWlFbjFBa1Q3UUFnaU1cclxuICA5U2RSaVkxS1RDNlIwUXhKbTkyM2kxZ3VrUWdZMFQ3TlFDa2h2Y0xBZkNUeVpRUzhmV1FBMnZJUFVsREdlVEpvQVJYejF1c2RXRnE3XHJcbiAgUkxYMU5iU3dOSytWbCswelorb2tlUVVqRlFvWE5oYUtZRHI3VFZrelBSNzZ5U2tCSjA3Mmc3QWNJbHRPSzd1UGc5aVVBZHF5c0VKWVxyXG4gIHNzT0hEOXNEbkRVMHN0Z2VzaXNOdktrNkZLV3ZJaGpnVEhxMjNlS2RDVjV2ZStIWlQwZ0xKVVZSSmk0VVE3UzhpWU50SkdCV21UcVNcclxuICByVG8rZ3BsazdNeFNCSHZOeE5nY3dybUVUd0tYSnRwM01VekhkbUxLMkhyZGJmUTkzLzF1dXY1VisxUm5hWC81Vi85WVdwV3ZRTEdpXHJcbiAgTVJBOXlFWWFzWHpsSCtsQkM0dU4waXR6SHRBSDJwOHdJa3R0VkJMSkpUS2FJVHJQZ2pCR0lwOHpnNmxzR1ExYTlvd09NaTlDUHNZZ1xyXG4gIHl0a0R6T3ZYTklFU0NKbktsT050c2k5QU5VS3hUcnV1aUthbUppS05nMGx5Q2lkUW9WQzgwYUlIZVI2bWMyWEttT21SMEU4T3psNUNcclxuICB6Q3lIeUpiVHlhNWRFSDBab00yR0tsR1UxQWZlSURCenpmWXVPZjVvQ1NvU3c1S3dFaFNscnlMRUI4aEMyNXFkMUxmbnkyajFsZXhNXHJcbiAgbUljakdYaitVd1hPSklzb0V4K0tJVnJlaEVPa2pxUm54MnRrWmVOSjN0Zm82YWZFdGhpU3lESUliQmJoTE1zb2ZScFBjQ2hDS3YrclxyXG4gIFAvL2xTRkpEUjQ2ZW92LzdEM2NaL3dxcVd3dXJ0b0hxVzFkVGpUM1Y3QTV5Y2VWdk1tRWp2YmRkVGc4b1hjbTVDQmsyQnJWUlNTUlBcclxuICA4Z0ViODBaTHBIVFFNdVdaU0NwazRCV3hMY2lFY1pzSWFoK2tHYjJ3cVV3NTNtWk1jd0ptcjlwVVIvZmZkNSt3blQwOVZOOTd0ZERGXHJcbiAgNllGVUtKd1hGU1l3bUs3QVJFVWxhUk54aVUwT2FvZlZiOUhsSWkrN1dselE5M3pnblIvek04b2p1SGVGWUtFamVmRVZPMU84TnlSYVxyXG4gIG1sMytJLzR6NWRXNWRWam5EVzgxdExjYjFqZktNeGlJa1JZNnZJUUt0dGhYYnUybkROb1hMOUt4WThlb3RxYU9ObTdlUkZQMVgxekxcclxuICBnT05ZNGlWVGt4ZU9VT3ZxSGRUY3ZWRmZ3aFd0RzFVOWxrK0VyaXozY0NTNnVvcGZaRldFS08vUzNaUXNHT21GcVhiaStYdWxCWExnXHJcbiAgNGQ4WC92MC85M3YwdnZkL1FHaGcrN1lOZFBDWmY5VFpqUzl6MUN6T1BybFU4WFcyTmJYaVBQanNzWXBYTCtJWHgzbG9MTnZDL0FGTFxyXG4gIEdUWUd0VkdKeVNVeW1xRVZoakdDMUM2MmpCaEdwREhiZ0x5dFozTzJnUEVjQlUxa0kyVEVNNVRqYlNwbVpBVENxbXpQMmdWNjhJRUhcclxuICBxS2ErbnJxN3U2bW02OHFDOUVBcURGa1VHaHRNVjJLUy9MY3hFbkd4RGRhRmdtUEF5clpZTGgzdjZGaGNZSWN4RTE0Y25rMFo4NkRqXHJcbiAgNnFCb0wwNWZYSUp5SkZNUjJER0lrMmxrSjhPT3BxWWVienBzbEJkUXlWTHVrLzEwOGN3Wm1iNjdadmZObHVpbFEyRUZXaVhRRXBrWlxyXG4gIFBjZi93VGc3azUzUy9aWExjY1U3S0U2QWZjbHpMSXkyTmJ1cHBYZXIwTlh0SUxJcE1TOWRlOWlMbDhTQkFGT3pvVVYwdzgzdm9zY2VcclxuICBQMkRjRXYzMmIvNVgrdjd2K3dialg3Nm82VDkxejFMRjE5bkNnYlN2a3pzdmQvbThxTTVEb2tpdkNZenloTnNvTEk5NG03V1J0SjROXHJcbiAgY2lYakVzVjJnREw1Y2dHcGJmcTcvQ2FDMmdkcFJpOXNLa3QvczBONU9xZloxRGxPVHo3K09MVzB0VkZ2Ynk5Tk5XYmZLSmZtNGYrR1xyXG4gIGJONEpURmRna3Z6MkxESjU0NzBhQzdNVHN0dzVBdDR1T0Q4OTZzM0tjb0ljWjZqVEw2SGx3QlU1Rm8xRWpNcWJtd1pzVUVPMXRmWEtcclxuICB3NXA1dEREd3pFUjQ2Vk4yTDV4enBxV0NsZzdLcWkwZHZObVFhWHVqSVdRc2tIUnhtYks1d3FLem80c1c2cnRralNWNUVWVnJyemliXHJcbiAgZjNzVVhOOFpMR2NoRlR5SDRFaGlaRkl2djdzSXdSaXR5N0hUVDh1UytDMjlXNmh0N1o1TVh0VmtiRFlWVEF1ZENZc21ucjlIeU5pQlxyXG4gIG5EclZUenYzdkoxbTUzUWw1ZDZlRGpwMDhLUFUwNVBPMUhxNW9lYk1pYnVYbGx2S1hSMklMaVQyd2prUFlReEtxTGtYT29FZ3JVaWRcclxuICBuR1A5R295U0tKYkdSbmticndMbG1VZ3FaT0JUT3lENjFUbGJRTzFUYWNRSldhVGxiU3BtUkFKUEprZGQwRk4zam80Y09VS05qWTIwXHJcbiAgZXZWcW1teHdkM0xCVXFnb2ozS3dya1NkMzdQQnhIT1R3MXdSak5MY3hFVnBWYUJTaGlxYktyNlVvYXR2NFFvWDV4N2Z6ZGVCNW9vZlxyXG4gIEQ2amhQSlF1Sis4SUNwQXJVazVRaUZVZGRYVDBvWDh4cmpxNGV5NUVMalMyZGRITTlCUXQ0RVZUNlA1aUdRSjBqbmJBYjJ0cVh5WDBcclxuICBtbFhkTkZhcjlJc0tLM014eXBXeEJvNWthdUFZTytsV2VibFUzcGs0WlBLcnVHOEhOVUpMeEkzRG9Gc0x6N2NBNlgxdU5SbWFUWWxwXHJcbiAgMXBHc2FwbW00MDk4Tm5FZ3dGLzg1VC9TTjMvclR4cTNSTi8xSFY5SC8vdDMzMmY4eXhOVk9wRDFldEhHem1PRnprRkY1ZnB5NXhGWFxyXG4gIHpwRWVVdjBxN1pEWWdJMTVveVdLcXo2bVlqTmoxQ3hSTUZMYnBBTFZCRUlHcUgyUVJub2hJNTZoSEc5VE1TTWpFRGJadTBFbHpiTkhcclxuICA1U0cyeGJrNTJyQjVNMDAzNmNVSFdGSkRQZ2VGeVF2VVJYdkZ1TVA4ektnczc2MnRpMkZ2aFprYXVFU3oxeTllQTR2RjY1cnhtbFJ1XHJcbiAgUVRTMDlaZ21SbG41SW1STUd1cHFhTTdXQVJ0N1ZxZGR0cS9kS0lQYVdFNEU2MUpoSmcyV0JYRXREVHgwV1Q5ajcwdTVSRXd2TlZGelxyXG4gIFRmbys3YVhtMVRRemhlY2RGcmdGVXNjdG1CbStsdmdJMWl4SjF4emdpbzhZQWNlcG9ibWRtbHM2cUt1N2w2WmJWL29hMlJjQWhaVnRcclxuICBYb2pmTURsNHZFS3JKSXRNSG9YN1NURngvbm1acFlVV0pCYVpqTWVmSkxuUG80ck1uRTJKS1p4Sm1RTUJ2dlhiZjRyKzlNOC9ZdHdTXHJcbiAgUGZUQS82R2JiM2JqaXk4L1ZPRkE2cVFGZ3NGRmo2aHlkMUdvVklReFZLZlg3THpRQ1VCRXBwRWVVdjBxN1NPakdaTFNzMEd1WkpRdlxyXG4gIHFFanRtRnlaQkxGdFhEYS9pYUMyUVpyUkM1dktmSTZKdURoZFJzcEkwOWFOUDBjWEwxNlVkNEZzM3JhTkp1cTN1cVNHZkE2S05KOFlcclxuICBicStvZFBFcVYzbnIzc1NneE03Y3hiZytoV1lIVWQvRXJZaUdabXJzMmlCZFNmVXRuZDZ1R0pXMVVGK3pzVUdXU0QvOS9INFQvdHRoXHJcbiAgdWhhRHlmd0wrU1JwYldwbGh6U1JjeHpWQUZuZ09NM1d0S2lYWFp4bGdYaytob2dzbGlOU3h3NnF0WnVkWFNOMXN0TnRibTJoZGV2V1xyXG4gIDBjRXpnOUJHS0trZFh3Z1VacTFDdEJZUTRFVGdUS3BESnNPU29rOE5ucUR4Y3dlRmpsc2pNU1NwVDErU2tZZnBDOHpHbjd0YjRpSUhcclxuICBBdXphKzNZNmZBVEwxaS9SOW0wYnBTc0xOeU12UjFUbFFCbzZRaGVXbk1weU50dEZMcXpSeWhpcTA2Y1ZkYW9QS2k5a3FJMUtUQzZSXHJcbiAgMFF4SjZka2dkMDRvdGl5eXl6dVAyQTVrd3JoTkJMVVAwa2d2Wk1RemxPTnRJazV0bEUzMmJEQkpSdEV3ZVlqT25jVUtyZHdrWDdPR1xyXG4gIGxqb3hueDNJNTZBb3pnZFltcCtUd1czTXlzRmdOc1lGWU9aTTNUVll3MDZpb2JsVFhuUGF3QlZkTGQ2dDRNOGIxcGZ0V2xDdXZHcERcclxuICBIWjA3ZDA0Q0xsUzBKQWJaT2RiVzExUGovQ1JOYzhVS09kYWNrbFlHNXVsejdkeE00YzEvWlpqbTZybW1Yc2RRR3VkVzdnUml6TmUxXHJcbiAgMHp3ZnF6cDJrdHplb09aRk40VzNNaGI0QnEyems0OFgvNGJCd1VGWityMlZ3OWpvQUxkZUp0aUw0Q0UvQlk0U2pyZXJycHJhK2xoWVxyXG4gIFI3M3JkOUQ4d3FJY0E0eDVOVFkzMGFtTHVnWVdIRlZsTEd1d1BLSXNKaTRjOG80a2JwRlV0NWZJcWlBQjh0WFpXalhVcy8zVlZNOHRcclxuICB0U0trdjNtNVBadmVvcDNybStpSisvNmwxSUZnUEdUN3JpL240NjNuMTQvLzJMZlJMLzNpZnhiNjVZWVZPaEErRytVNnQ0dGRXS09WXHJcbiAgTVZTbi96ZHpIbVlUckJoSmJhYTBtaVZXRE9ZamtjOUZqWVVNVU5zZ3plaUZ6V3A1bXpGTEJKN01sRjlRbnJaNTVnaWRPYW1yb0s1YVxyXG4gIHU1WWRpTDZvS0kraVBMZ3luQnlXUHVpNTZWRytzTFFmSDVVV3JqR0UydnBtcXVPV1JDTlhZT0lzMkhsZ3pDTEFNaTNPM2xDczJiTjZcclxuICBVYWJBNGhtS0VhNVFHMXRhWkVWaHZOOTlhV0dCNmhzYjJhRnhaYy8vVlRQcE9sL1RWTCtzdzZqdlhFZGRtNi9pWkRVMHYxUmpsUXdHXHJcbiAgM0d1STYxNnE0K0l2c3N4VlByVTFTMUxDaGFYbDd5NmJhaGZwekxPZnBRVTRWM1pzR01UdjIzMmJhUzhmK3paMDBjandCUnE2ZUk2UFxyXG4gIHl6QU5Yamh0bW5BVTVmOXA3S1RtbGxaYXhLQjlIZDlGOHpIczd1dVRsc3JnNVBLL0l3ODdHSmVBaWZOd0pFZWt0ZEMyZWhkTDByeXFcclxuICB5em15TWhJM01JTkhIcENKRE5vYWdaTXF6azJrWGxWc0U2RDZQUnRiNmZOMy8xT3BBd0grNGNPZnBIZisrK0EwWHE1ZFdTdHdJRzVGXHJcbiAgVnp0ZE9RcFZtakNHNnZURmcvR0FwUW9iaGRuSDI2ek5aWTEzbUYySzJEYktvNEp0a0VaNklTT2VvUnh2RTNGcW8yeGNkb2RzT2lBVlxyXG4gIGRDeWVwT05IK0U2TmY5ajZqUnRwdGdVWGNJdzBEOHlHbXJ4NGpCWm1KL25DekxRdzJESEllN3M3VmxOaisycDlhMXZoSUxhbFNMUE9cclxuICBvRmh6emFZR09uMzZ0SFM3NGVsdGpGTmdudjNzbEk1TDFQTWR1VGdOUmt0N3U3UTBadGdHMlRVVHR6alFndWpiUm0wOXE2aTJxWXZtXHJcbiAgOENKNFJuM3RFczBiWFJuVjJGVEcrZjMzcWhkaUQ5VFYzVTFORzY0enpZdUhwY0VqVk05L3hiblRoL21ZYVBlWCt5V0lGMnRicVk3dlxyXG4gIDBoZHFHcVFsQ3NBUmI5aXdnVnBiVytuaWVBMDFOdFRTN0J3NnkxYUs1U3BreGZUd0dab2NQRUdOclQxUzRZY3hqRFQ5OHJsRkZreTZcclxuICAxZ2k2U0x1MjNCRE5iQ3ZPU2FSZVZXd0RqQis4SzNrT3BBdy85YjdmcHAvL1JiWFp1R0VOSFQzMHNaZmRzeUZWT3BEMUhGa0xSR1Q0XHJcbiAgUnFlcEl4M0JsWllYRmVndnhYa29sOHBpck54NVJGS3pDNGp0UUNhTTIwUmdpMFJVYnE4VWJ5T1RER05zc2xkRE5oMlFDaXdwZGRlY1xyXG4gIHBjUFBQOC9YeVJKdDNiR0R4dXQwbWU4NEQrYzA1cWVHaFlkWTdsSFpZZFEydFZFajM3RTN0dmZKN0tmSzBBd3pmMG1FWXNXT3ZqazZcclxuICBldmdJVGJHVGNJUGJYQXVxRXMyQTJscDVuOGtjT3hTMFF0QTlnM1c5MW03YVNSTUxyZHd5VUxNRmJrMlU3S0lFS3pJdVJpWUxic1JRXHJcbiAgLzFQM2NFdXNnVnN4aTdUdmlpdG9jRWtyYk9BRjJHTlZ3SXVsTUlFQkZUWmFqZ0QrVSt5L29ZMWJpdHh5WEJ6dEZ6blFzTzRLUG9iY1xyXG4gIDB1SS9EMTFvVGQxWThQQnlVRjR4ejAyTlNLdFdscUJmczF0YWFTbEMydkpjSE5RQ2t6ZUdqajVJQ3pNVFVXc2tSbkZPT0c4VWVYMjFcclxuICBEZ1Q0Nm5mK0lIM2tIM1hhN3pkLzQxZlNuLzNKTHdyOWNrRjFEcVFUczdETXMvS1pHS28yWVF4RzhJbm9SUVg2bFRrUDFTdm5aSXdvXHJcbiAgRDBubDJkaEdON0ZsWUNLcDJRWEVkaUNOeWRrQmFodWtrVjdJaUdla2VUbGswd0J4dVlHaWRFQVFDQlUyMUVXbjZjamh3OHpXMEpWWFxyXG4gIFhrbm5wbGR4M1R3bmc5N1R3NmRsRUJ5QU5VSXRPNG5HenJYU3lxaG41NkhRdklwaE9vNktyWXFsVjZ3bm1WNk1sZ2FXbVYrRUY0RFRcclxuICB3QjloTWNZMkZ0bWg5SzFhUmUxb2JiQkpLN2N1aGpDWnlhRTQrd0pVYlpoSGFkS2djRlJIN1FnZGUvNHBtcCtkcDVhT0R1cmNkS05wXHJcbiAgWGpxZ3EyZUsvK3ZaOFFFT2VNV3NsaGR1cGJXbG5TdjBjWFV1UmIrell4ZmRjc3V0ZEtEL292TEY5WENWU0JOalBHM2kzUE15UmJ0dFxyXG4gIFRkUXlUc3pTTkpWM3Y2U3RrUXRIcUtWbnM3elVxaGo1WEVUaXhVcXN4SUVBVzNlOGhVNmNWS2Y4Zi83eVYrZy92UHZMaFg0NW9Fb0hcclxuICBza0hIUVBoRUMxV2JNQVlqK0V6MG9nSjltZk1vcnFSVnI1ekpKREthSWVrOEcrVHVpZ2lxU0dkU0ZjVnlnSGt2aW41TEJkc2dqZlJDXHJcbiAgWmpXOGpVd3lqTEh4OFhQSXBnT0N3Sks1alVmcjNERTZlZnc0TmZJZCt4cXVpTStjdlVpTGMxTmlKYUd1Z2U5SSsvaU9jNk4wQWVCaFxyXG4gIHZKQkZtbGNLMDNGVWJGVXNYZDh5TE9NYW84UGMybkczZi9nVDREUFlZZURjV0p5ZnAxNHVLNTViNmVucG9TTkQwZnN6aXJNdFFOV0dcclxuICBBWVZKVkZodGJwTm5IcFVXMU1MTUhGMXgzWFUwT0o5L3IvWkxqZG14Q3pROWVvNW1SczdJbmJzRG5BaENYWVVmMjNrVktzVjhCVndrXHJcbiAgV2g2YWFIWmlTTjd2M3NRM0xZa2pjVWp5RGt6Wkx2RXc2dkN4UjJSYWR2dmFmZFRTVzlhYXl1Y2dFaFAzTlUrVVR1TXR3cGt6NTJuTFxyXG4gIDlyZlFBdDhBMVhNcitmaVJqOU9HRGFIMSthV002aDFJSFYvay9uTGkySjlzUm5BRkVNNi92SDU1NTVIWHE4VHAvVVlnNlR5YjJzUldcclxuICBFY05RUm5jVksxSzdPQWNsODdaQkV1bUVqSGhHK0gwYUtmSnAwbFFBUzNMQ0lMQmticE5nbnB2ek14ZjIwelM2aEF4U1NUVGlvYS8xXHJcbiAgM05KWUkrczhlZmdzOG5rRnFDNzVtenpLMDIxb0hlRUw3QXhkT0hlT0wxQytRdmtDUTFjSnpnZDBTYzFPVHNzZy81bzFhNlMxY1d5a1xyXG4gIHFGeVZVSlZSUU01Y0JTdk1KWWR6ejN4U2ZodHh5Mm50bFc4MjZhV2dtcEtVVmFIVkE5MlhzK01YcFV2Sk9SUHNXV2JSY1VzVUZmcmVcclxuICBOYXZvME9Hak5IamlmdEU3N0w3OW0rajg4TVdvRkpueXJMQjRlTVlEamtSbWJSVTVFaURKczNUUEFtMk40TGtVNjlLcVdKNjhzcmRwXHJcbiAgWlE0RStNUW5INkE3di95OVFsOTE1VTU2K29rUEMvMmxqdW9jU05jR3Z1amQ0QkNmWnY0Y04wSkVUcGpYdi9UT0k1S2FYVUJzQjlLWVxyXG4gIG5CMmd0a0VhNllYTWFuZ2JtV1FZWStNeU8yVFRBVUVRRGxlUVlmQWJYVk16WStkMW1RMkcwKzdZdlp1R2x2QXNUMmFBcnlDZkZDYm5cclxuICBxTmlpSkIyTG04Y1AwOG1UNklkbnZoWUR0WTJFc2V6NWFjeWVJbTVoOU5LR3padm93aHlldkk3eUtja3lSVlZHQldZcXFESjExZGl4XHJcbiAgZW80K2UrOTlWTlBjSk0vZHJOMTdoMmxXaUpVVXJHS2x1QnpTeEF1elUzenVuSkpaVXpGYXVqZklwSWttamgxYU9lMkZ3UUdhUC91d1xyXG4gIDhGakJGNjhMR0JqWHlRNGg1MHdCcXlpdnp0bzZWTm1SQUVsZXhYdWNIRGhPRS9MY1NJMnNOT3dIMkV2TEVSUmpCejY1b2k0c2h3LzhcclxuICA3Z2ZwKzM3d0Y0VCtudmUraXo3d3YzNUs2QzlsVk9WQUdyczJhaGVXOE80c3Q1aWpVQVVLWTFEaWk4ZDVST2x6ZG9EYUJxbFJFZ1VwXHJcbiAgb0J4dkUzSEVDQm1YMXlHYkJnZ0NTK1kydERBM0k5MFJNNlA5c2o0VEFBMjZwSHA3V3VsY1A5LzFjOXZqNWx0dW9hTWpyYUlYK0N3OVxyXG4gIGtZSEpPU3EyS0pidTQ0b1U0eTVuenA3bHUxcXNZRnRMZFJ6bXVWSjF3RE1LVzdkdG85UFRVUmRQV1RFOGxqVlE1TXlLanZIbG9EaTNcclxuICBOWTBYYVA5VCsvay9tS01iWC8xcU9qWFJhWm92WUpSVXBESnVNc2lWNy9ubi9hL0ZtRWtIVitndHE3YjdlbUJ6VHgwOWZYL3hLMTUzXHJcbiAgM2ZvVmRHRXNkSkhwcmpJN0xLM0lZMGV5aXgzSk1nOGtKdmtFeGxGalo3Z2x6amRXdVVVZ1MvZS9KQTRFV0VrTHhPSDdmdURuNlFPL1xyXG4gIDl6ZEMvK1dmL1hmNmo5L3dGVUovcVNKeElPam15SUVkU0wxeklDKzE4OGphK3lpdUtKanlUQ1JOMGdLcFhab2t0bFc3SUlsMFFrWThcclxuICBRM0pLUktsZTJiaThnSEVsNlN5SmJMRFlIL3F5OFdRdWxneHhLdngzOWEwOTFMSm1OOVUxdGRHbTFpRjY1cGxuYUg1dWtXNjQ0UVk2XHJcbiAgUG1Zdk5CS0V2Rk9ZbktPOFJVa2FGbCs1ZXA2ZWYvNTVHUmpIOUZvY2Exa2loQU5tVitFWmpvMGJOOUxtelp0cC96bDNJNkpST1pZMVxyXG4gIEtEREpIdGRMUlVrdUplTDYwUU4wK3RRWnJta1hhZTNWbDlOOTlRVUVybURuSmdab2RtSlFuQWtnNHlUTm5YeER1WjRyNC9Ba2VFZkRcclxuICBISjE2WEN2ZElsejNscStuWTJkMHBoK2dkWGVtQmkrbzBPRkkwTDJGNVV2cW0vREFZR210ci9EcVlBZktkV2sxOTJ5bWp2WHg4MUJtXHJcbiAgbDhuMnFtMXQ5TG1QZmZpU0hBaHc1OXUraXo1eDEyZUZQbkhrRTN6ZXJ4UDZTeEU1QjVLL0p1dW9EZzdFZDMrWUJVZmhjaFhHb01RWFxyXG4gIGl2UFFaTUVpdFFFWk03RWRvTFpCR3R2NmpVQXAza1ltQ1NOa1VRV1hUUU1FZ1NzU0ZpUkVmN1diY2d0QTFkalNUYzJydG9uemNESnNcclxuICByOWxFOU9pamo5TEUrQlJkZi8zMWRHd01NNnR5T3pLWW5LTzhSVWthRTgvM1AwWlRVek0wYmM5cnhFQUxCRTREenh3Y1FRdW9KS3VBXHJcbiAgWlEweUprWEhjeVVvU2IyQ1RMZDJqTkZEbjlYS0FsTjRWKzk5bzlBcncrWDhpa3p0OXlKaDh0enpORE01UlBQamZKUEFQT29LV1c2ZFxyXG4gIFd3bDZiV281MXJUWDBQTVBmbFRvSWx6NXhuZlM2ZlBwdWFJcG85K1IrVWxZd2dRckJhVGRXc3Y4YnE5V0F1OXd1WGp3WGo3VU5leVFcclxuICBib3RtR2dKbWJOSFlnVTlJZktrT0JOaTA5VTEwK3N4NTJyWjFvendmOHFXSzZoeEk5eVpydXBxV28zRHBDbU5RNHNWekhrSG1iTHdrXHJcbiAgbXllMlpoUEFkTVNHOHZoTkJMVU5VcU1rQ2xKQThrbEZqRWhnYWJLcDRrZ1JHRkJZUGh3UFlTRXNMWVp4RGN5Zng5MFVIRWVNZUE4M1xyXG4gIGJHK2crKysvbnlZbnB1bkdHMitrNCtNZHBvbGg5aHlGbEE1NWlZREYxMjJwbFlIeEkwZU8wYlQxZmNOWm9Oc0s2T2pzcEMxYnR0RDZcclxuICA5ZXZweWRPWVppWGlFbFJVS2hLVDdIRmNDVElwTHowamo5bit6OU1RdDd3d2srenFxNittOC9OclRmT0ZqbVVxNEJKZ3dCMTM4MmdkXHJcbiAgNFBBaE5IYXRrK2RITUpzcVlJbEc5b2VWald0Vzc2V2xDN3FXVll6cjd2Z2FPbll1TE5XaXBZcktaaVNlVnhvL2g0RjJkR3RseDBjcVxyXG4gIC9KWkVwZE45RWVEODhpK3RVdU94WnkvZmdmVDNYNlQxbTNFelVVdmY5Qi9mUVgvK3AxK2F6NGZBWjFRSnU5bzRDcGV3TUFZbFhram5cclxuICBnVFRGemdPMHk1RzMyVHl4bFNnajk2ems3RWkzQ2VERVNLOVNiRTB2a2RFTTFmQTJpQmdxRGFUdUt6RUJGNWtwbE1FV3JZeVJrNC9SXHJcbiAgMEpIUFNuODBuQWZrYUcxMGJyNkJ1bmUvTG5FZVJYdVluY1hUM09qaUNuM1JBYkRsZ0s5R0VVeVhoWWs3NWsvUVBmZmNSOC9zZjVhbVxyXG4gIEp6aC96cURXSHZCYnp5Mk5tMjYrbVZvMjNVd1hsdGJTazJmS25JZmJSNkV5VmZ2ajV6N1ZJc2xFUTFhMFlxUVo3RjAxVHlNakkvRG9cclxuICBzc1RLU3B4SG10TUxFMWFHb2h6aVVBeXNRSUQzYzZ5NTV1M1V2djRLcXU5WVF6TWovVFJ5L0dHNjhNeS8waVM2dXlSNW1vZHpIbnRmXHJcbiAgOHc2YTc5bEswMDNhcmZQRTNmOGdqbWJiV2gzazFyMUgvN2Fkb0sycnQ5R2FxOThtTnVmM2YweTYxZ0kwbFlZTUVsV05PcURWTzZWYlxyXG4gIGJ1TGNjeEJHU1BPWXhKVHpTOFM2ZGF2bzNrLytNVk9MOUJkLzlWRVpZUDlTUkpVdGtNMDJCb0t2c3hER29NUUw3VHljT0NLWURDVVFcclxuICBlWUdON2lid1didUlkQnVEMmdWSnBCTXlxK0Z0WkpJd1FzWmxCWXdyU0lNN3U1bmgwelExZk1yUG9nSnE2eHAxTmd5M0FtdnIwMWxVXHJcbiAgMmR3RklxcWhLOWZOMHFjKzlXbTVxWHIxcmJmUzRhR29DNHVqZk1xeXZJQWF1bkZIRSszZnYxOWFIZ3V6dXY2VVlLbVdldnY2YU9mT1xyXG4gIG5kcktLY2dtb0lJeVVSWCtzbVdRU2JIeURDSlVtWGpnYVRwMzlqU2IxMUJEVXhQMTdYcTlLUzRSS3lsemhadnVhbkZwV2VSVExVeVBcclxuICBzZU00VEZNalo0UkhQZExLZC9oekYzVHN4S0hycXJkTHZLNXJnVTZjT0VVVEUyTTBPenBLelF0cFJiM3Y5cmZKTWl1SHo1UjNkY21NXHJcbiAgTVNiTFoydFYrSFdtdW5EZ0xsbVdCNHN5eG5XVGV3WEE0TUJucUtYajhpWkUvUDRmL0MyOTkzdC9ucWthK3R6OWYwNnZmdlcxcXZnU1xyXG4gIHdmS0Q2RnlCMVZmeEhNaUw3anhNNzhXZ3NqYU1GOGQ1eEhiUUpJYU1WSzlzWEZZZ213YW9rWUZ3UEVFN041a3V5WTM1K0pnNVVzK3RcclxuICBEa0Z1RnptQjJ3amdRQjU0NEFGNXVCdGRXRWRIK0VKZ2RTWVZJeThKb2hwYTA2QnJVNTA4ZVZMWHBjTFRabmllZ3pOdTcrcWl2WHV2XHJcbiAgb0pPRjNXTU9CZm5IaVBhMWpHVUJvaFFyVDh5b1BsR1I1WVdEOThwTG8vQmN5NjNzcEk4TVZUUE9VeTJLTXFwUUthNEVWV2F6c3IwdFxyXG4gIDBlTGNORTBQbnFSeG04R0ZnRG9GcDB6WDFlbzhFdkFPdHF5cG9iTm56OUxRMEpDK28yVVF5NlNuNkpLSEdGT2diTExxNzdublM3cTFcclxuICBZcFQvRXAzeGRaaTZ0OTVNalcwOVl1a2N5T1YwWWNYNHNSLy9kZnExMy9nTGFtOXJwck9uN3FiMjltaEc1QmM1YXMrZEc1Q1pNd0MyXHJcbiAgU1VEcm81MmI1WGlabEQraE9YYWtFWmZ2UEJBN2lWY3luRjQzWGd3cWE4UFFjZ1JlOGpVV3FiMG1hd2RhdjBvN25aQkdHOUx5QVJGalxyXG4gIDlzbStCUGswV0s5bzVQZ2pFcnp6NE9PTnBSZ3d5TmU1NVFaMUhwS25xb0ZjN2w0ZnlSaTRHREVMQ2t1Q1RFeE14SWZDNEJNR2VKRVNcclxuICB6Vk5IYVA5VFQ4bDdOK0E4ME0vZjFzWXRHVDVmT3JxN3FYWGpMUldjUjBIK0RrN2xqMVh5aXlyQUo5UVFzMVVoVGxDY0tHdmhna2NrXHJcbiAgbEpZWUh3dTh0T3ZJc0hNZWtjRmxoU0lVMlYxQ0tCQWx3VkNrUWloR0RlSGQ4SzNTdmZVTzJyN25hcW1NMFlFNnh3UXEraHc0c3hNWFxyXG4gIGxtaXVmaDIxcjdxQ3JydnVPcXBkczQybUc3cG91cVdQcGh2MTVxbHAvaHp0MllqWEV3ZWdITzNzT05aZXpjNkZtYkd6K3lzVURvcGlcclxuICBKUndQdXJTR2p6OHNqc1JaNFRtUVNYUlB2Z0Q0MVYvK0VYclgxOTFKNHhNejlLWTd2OE9rWHhxbys4ai91L3RuenA4ZkxQYlJlQnNoXHJcbiAgbHVxMnVkOENYNkZxckd3a005SlhDZDRlVUwxSzhucEo0MW1uMTAxc0ZSZ2xzRTJkR0NPYnJ4S0pYTUZhRnFrMDBna1plRkJwK1lDSVxyXG4gIEVUSXVKd0I3QkdNWjB5UDlOSGJtYVYxT3dycXFzQlE2N3FMYTExL0pkMEc5Zk5qUlZaV21BNW5OWFZuVlpORzRNRWpuenAwWHVyV3RcclxuICBoUzlTOTl4RmdiMFhLWEgxeGxxNmNQSVplZjhHQnNkOWx4WC9sdTd1SHRxeGN4Zk50dTFXV1FLWGtXU1dJbEhobCtSK1RRbWloQkVwXHJcbiAgb1NLeXh2a0VwUlpGQ2hlTXdPeXIwMmRPODgydFhqbnRhM0U4eE9DTEFQRVBLZ2dGSWg4aU1pTk9jT0hBWjZUbHNVQ04xTmpVUU5PalxyXG4gIDUyWGNBVWNMQzNUbXdMWWprM2kveVdxNjZzcHRWRjlYVHlQbkw5QkNheGVOWExoQUowNmU0Z3IrQkhXMzFkSmlROXF0aEZjS1lGMnRcclxuICBDODkrVXZKcGJPOHRMcFF2YmFyRU5kZlV0WjVHVHowaC9OSWt0NGJxR3Vucjc5aEh2UnRmbUxkQi92dXZld3Y5MVYvL016MzE5Qkc2XHJcbiAgY0dHQTN2SDJMelBORnpkUXZlVjhoeGZ3SFhGVHp4WWQveERlSFhpTmxZMWtSdnFxd2RzRHFsZEpYaTlwUE92MHVvbXRBcU5FV2dZZ1xyXG4gIHRnRnBUSWxka0VRNkliTWEzbnBSMEFtRXpWYUl3UjR0QWJ3L2VucEkzMkxtVU5mVXdSWFBIam41QTBJNmgyek95bVprSGlwZjEzaVdcclxuICBubjVxUHpVMU44bzAydkhHZ2dyZlo2SEV0cTV4T25YcWpLenBoUGR3ZVBCQjd1UVd4NDRkTytqTWxIV3BKU2dyQ3lQYVJ3V3JEQ0xMXHJcbiAgNmhNeHlvMUxOU3RYQ0dxR25wYXVGN1JBVnE5ZFMzV3JYMldhTDJYa3FncEZScnh2UXlOOTd1UC9JSFRqcXEzVXN1NXFtcEVudzUvalxyXG4gIEZ2R3M5RzVnakVTZGJqbTJyNjdsQ25lL3RnUXdVV0hhWm1zMU5WRm5lNGZNOUxzd0cwL0hKZWsrbTU4YXBhNnRXTXpTQ2xaU2JFV3FcclxuICBIRDcrS00yTlg2UW0vdnVmdnY4UGFPY3R0NXJtOGpFNk9rNnIxcjZSNXVibjZFLy82R2ZwUGQvODcwenp4UXZVdjduRDZ3VzE3RUM2XHJcbiAgellINHlsN2p0T0xtMk1oUVlUc2RvSHFWNVBXU3hyTk9yNXZZS2pCS3BHVUFZaHVReHBUWUJVbWtFekxXSklhTXZHMmlkaHhIY0J5NFxyXG4gIGFHYkg4RVI0UUVOckw3WHh4Wk9zUnhXbGM4am1ITmlNM0lQbCtxVzFEZXBBR2hyclphbUp1dFUzcVltRFpCSHkyZFEyTEt2a3lxd2lcclxuICBZR0dKOEE2Tyt2b0dXcnR1SGZXdTIwNm5oM0RweHdqcEV5VGkzSzhvUVdSVlhRSkd1V0docG5waFJXenRHS1dISG5wSS9sK3NmWFhMXHJcbiAgYmJmUmlmRXUwNzRja1ZZaGpWT242TVRoUTdUdXFqZlFqalUxZE9TODZyR2R2bmlVSnZvUDhyRmJpQnpKSHRNV283NTJFWDZhR21iT1xyXG4gIDBja1R4MmxKM2d0VFExMjl2ZFRjMWlyVHA1OCtvUS9WQWxoTThmeXpkM0dyZm9kTTEwM3lMdDFOVUF6cy8xZnBldnY0QjMrQjN2SzFcclxuICBYNlhDRndoUFB2a2NYWGZqdTVsYW91ZWUrUWp0M3IxVkZWK2tRQ3Z6WjR6T0ExMVl6VjBjdVpjSDZjVjIrYzdEYjNqcmxZeFU3OFdnXHJcbiAgTWphVm5RZlNHbE5pRnlSR0laSk1ZdzNUZ1dWRWpKQnhHUUd6NXpET0Y4bEUvelArYVhHZ2dadktYWnV2cCtidURabDFxVUk2aDJ6T1xyXG4gIHltYU1QRmpHWlVmeG5iYWpmb0xPbnp0UGRYVzZsRWhUdDAzN2xTeGtJMnhYOHp3MVRwK1UyVlY0MFJBcVJIVEx0UFZ1b05XcmVtbjFcclxuICBsaXRvYkttSHhxYmRCZWJTYXZvRVhvelN1MDhsdUFRY0lySXlpZzFqcWRkVUwxd1JPaHVtNU9WWGNxejRXQzUwWDJXYUltVDM5MUtFXHJcbiAgRnh2cC92cFBIcEJuZ2lid2JwTG1UYjRJaUJyd1VxazF1NmlXajl2OHhBQ0hRV2sxNE94cWJNK3NpMlpZeE5zaldiNVEzMEZ0Zlp0b1xyXG4gIDA5cE9PYWRIQmdab1ltS1NqaDQ4UUEyTGsxVGZycytoNE0yWTdid1BUUFdkR1Q1THpaMXJPYldWejZJOG5JTExkZkVRZGF4ZVQzL3dcclxuICA1eCtoMXBabXV2MzI2OFhpaGNEYXRYMjBiZXNHK3NqL3U1YysrRGYvUWovMm85OWltaTlPVk9GQXVqa0tFM3lsN3ZIL0FNZU9aQ0tvXHJcbiAgVXIxeUpwUElTYnlTa2VxOUdGVEdKaTBEa05wRXBOc1kxQzVJakpJb2xhWmxBeUpHeUxpTWdOcmpEV2xqcDU5S0hBY0d3N3UzM1VUTlxyXG4gIFhYaXZTdndtUCtTZzZSeVFhNUt6bVNSR0hxckU4VWkxTmV4QXh1amN1UXUwdUxESUYxOER0ZmJ4blU0bW4wM2Q4M1RnOGM5d3EyT0lcclxuICBabWRuSko4bHRxOXZicUYxVy9iUlRNTWFtcDUzYy9PUUx0MkxoMWZsU2w4Q1MrRFNWVXdRRzZXR09Xa3NFR0ZXSU1MTFJ0UGlJRjI4XHJcbiAgZUVHbVhyZDNkVk5qRjE3V1ZiUXZCRU9SNnNVT0hrWEtiSGhoc0dkOXZVNzE1cHVRenE0dXZtbkNzdWFjZjJaM2VKVUFCdHh4ZHNHSlxyXG4gIDREMDFlSVlFNmdidlNGeElNVTB0OHZ6SjZ2WjZtaDQ4UWZVMTgvSittN21wWWVwcFhxSmRtN3ZwNHZpU2pJMWdXUjlNMXdYdy9uZzlcclxuICBPemtVWnkyWXVYQ0k1aWZINmJmLysvZlNELzNFYjR2WkcxNS9zeXBmQUx6cVZYdkZBWDdzNDUrbFJ4NTVtcjdoNnd0bXFIMlJBTFZaXHJcbiAgMVE3a1M4ZDVZR3M2aVl4bWVMMFhnVEJHU093akxpTlFRek9qWjJuMDVHUHlUZ0tIK3BZdTZ0ejhLcGxabGI0dkhPQWNvcXlCYks3S1xyXG4gIFpvdzhXSVp2b2dxMjdYV2ozQUxSQlRMeGdxWTJkaUQ2aG0vRnFycCtPbmJrT1pxWm1aSVZaUEVnWEd0YkcyM1p1bzJhVmw5RHMwdnVcclxuICA5YUFoendST3pNRWRrUUtyQ0VrQ0RhV0liQ1BFVXE5WlhuQ1ppUFBUTUhUbVdackNRNVNNSGJ0MjAzUnRWNUZaR2w0S0ZKV2pLQWlLXHJcbiAgRkM1VWoxTkhucEt1dlhrK1BqM2JiekVwa01uUHlJWjJkaVJyMUpIQWlhRFZNTVdPQklCT2tVbHJtRy9zcEJ1djJrMVRjMHMwT1RaSVxyXG4gIFM3T1RkSEZ3aE03Mjk5T3VqZDIwWTMwbm5aOUFhMlMzNUlzQXA2STUyUmxia0RVY0NQRHJQL3VkOUJQdi8yRjYxOWYvS00zUHpiK2dcclxuICBUdVNPTjk1Q0J3NGNwWC80eUwxeTgvYW1PMTY0c1paL1MrQ3dsZllLNmhqSVZzSTZXTG1LMjlkY1ZuRWtlbzcxcTdTUG5NUXJHYW5lXHJcbiAgaTBGbGJLcDNIckVOd0xySXprUEl3S2ZsQXZLMmlabzVUTUVkTy9zTUg4VXdQZ0RIMGRxN1RWNGhtc25Rd0xJazY0eU5aOHZUNWpXcFxyXG4gIFpHM0RLWHI2cVdmWktUVHhUVUFuZGF4bnA3QlFUMWR0V0tEQndVRmRobVI2bWk4TUxLK09LWmpOdEc3SExUUlBzZU1vZ0JmblNsMENcclxuICBzNnJLT0crVWt5d3Z1RVJVeUNkU3RjOGNva1AycXVENnhrWmF0ZmRMWlBIRU1wVFhEb3k4c3YvcGUyV1FHKytFYjFrZEwxeFlDU0dmXHJcbiAgcVhQUCtTbS9rS0tWZ25HU1BQTDczdFF3U1BzZis1elEwMHNOMU5EY0xHL2o3Si90RlJtbTZZNXovcXYzM1NHdjFZMmh1ZWwyZEwrdVxyXG4gIFhSVS9CM0xkRFY5TFYxKzFpLzdxTDM3WkpDOE1kdS83S2pwMCtBVDkvWWQramQ3NU5WOTg1eEl1amZ3LzRTQU9aSnMrUkJoWHlwNjJcclxuICBTaVJzTk5hdjBqNXlFcTlrcEhvdkJwV3gwVjBHaTlnbXFjcmljZ3BZNjBXeG5kOEkwbklCZWR0WUxlOTM1anNWdklmREFmUGcyL2h1XHJcbiAgcWxFY0I1Qmt5R0ErSTBwelpRaWJUUWVvTFBmemlteFp0SzdoTEQzMTFOTmlqd2ZkK3ZyNnFLdW5qODZjT2tWVE16TzBPTHRBdFkwTlxyXG4gIDhnekR1bzBiWlJyeDJDeWNSMEYrZ0JmblNseUF5R0paNDd4QlRySzg0QktRendPdlduWEw0cGZ1WS9TUU9HQzhES3Vob1lHNmRyNmVcclxuICBqM0hlOXZKS1dDbDErZVc2SEM0OVpRRUtNdHUyYXBFZWV1aGhXcHljb0hWWFg4cWlrc0NTZEEyT24zMldaZ2VPeTVHb2FldWw3dTIzXHJcbiAgeW5FdS9nMUJ1bWFwbjU3Zi8zbmoxSkhnL0lZajJYOFdraVVhT3Y0b05iUjBTc3NrQytRMGFtdDRaUjhrL0padiswbDY3UEVEOU1UblxyXG4gIC85NGtsNCtSa1RIcVhvVXB2WXQwOXVSZHNnVEtGeFB3LzVTZlYrWkFraVUwL01WaUZVbllhS3hmcFgza0pGN0pTUFZlRENwam83c01cclxuICBGckdOVDVtellYRENJSWwwbVFzK0xSY1EyK3JHU2ZDMnY0bnp6OUVDVnpZT21LV0c5WUdhTUlobjlubXdMQklybVJNd0lwa0h5L1NiXHJcbiAgUVViaTJScmEwbktCSG4zME1lR3dUaFg2WEdVMkhkODV5eE8vN0ZTYVcxcTQxWEV0alM5aXFleDg3b0lvenhLTENHYXhyR0d4UVNJdFxyXG4gIFo1WUZIdExVaFIzeElPVWN6VStQTVYwajgvMW5Kd1k0NW91MEpwejJEYTNvcG8zSHBzcHg3cGwvbFM2L1JqNTIxMTEzUFoyYTdLR0ZcclxuICB1U2srTCt4R2d2Yzd5L3RIbHlVbVRlQ3RmM2p1QWU4bHgvSEh2cHJ3bk1KTGl1V3E0VXRESDFvQWp6OHB4M2JkRmM2QlhIcXV1TmJHXHJcbiAgdVhXL09IcE9aa1hoVlFVNlk2dFNycXBaWFh1UkRqMzVrTkF4cnJqdVZqb3ozMHZqZkEzakhPbFl0OWMwQVc0UnlLSW4wWC8yL1IrZ1xyXG4gIDMvcnR2Nkl6SisvbTZ5cHR4VndxSG5qZ2Nicjk5ZDlLTzNkc29FTUgvOW1rWHh6QWxWbitYL0JGMWR5elhWb2dDamFYYTlrcWs3QlJcclxuICArQXJiWkJsOXVGTkw5WkdGVnpuaTBweUgyZ1NKVVJKbHBid05Ja2JFUkE1b1lXNWFXaHg0RmFnSFZ4SXRmZHQwakVONHY0bGdmQ1NPXHJcbiAgZjdHZ01CMmdzb3kvWXhTbEI0SjhTOHVBTE9lT1k2NE9aRkVjQndCKzE2NWRkSDVwUFhPNXpCVlJuaVVXRWN4aVdjTzhRU0lwWjNKQVxyXG4gIGhZeDNvMkNaZTFwQzlZSUh3clRQWEdmelpMQnMyZkxJSnRtN2VwbysvZWxQODdrd1I4MnRyZFN6ODFMdnNvbG0yTEhNanVOWkd6NitcclxuICA3TXpoY0JZWDJER3hzL2xDZEREVnVJRzZpU04wK3NnUkp1cG8zWlY4YkFvVFZaTlRDZ3l1VC9ZZmxHbS8rRTlhMSsyVHA4Y2Rpbk5jXHJcbiAgb3BHbmRWbjU5alZiNk9LNWM5UmNvNjNMSzYrOWxVNHY5TXJiTzRlUFAwS3I5cnlCNmhyRGxQcEtEZ1NBRS9tWm4vdGRPbi9tUGxxOVxyXG4gICtvWDVyMzduQTM5RDMvK2Zmb25lODAzdm9ELzlZNnlkOWNXQjVRZlJXM3JrQkplL3pxNG9xVktFTmdIZ0sxdHY1RGFDTDN6bkFjSVlcclxuICBJWFVQdUtpeDVzNGszN0ZnclIrSHB1Nk4xTG54V3IxN2hTQnNJakFQVVNTT2YzSFFSVElQbHVHYnFNQmtiSVhOeXp2cUp1ajhlWDBTXHJcbiAgSGEyUGhRVWRvMm5yV2tVYnQyeW53UnFzaHBySkMvQlpvYVJKYVF0Z3hqNU5FWnd5R09RazVZdzRDdHpSejR5Y0ZZY2gvd0h1N2xzNlxyXG4gIDVaME9hRldnMG9YVHdNSjRDQUtYRFlmRnhYa1pxNUxYL283MDg1M25ITGNnSitUQlR1UVBRSWRWWlZHcDRFRTBkR1V0SU14TytURFVcclxuICBmNWpHaHR3TkJMcGFNTU50U2RLNlZ3cGpBQm4wMU9CSnNRSmQ3OG9VQWJJbWNSWmNkdnlHdGg2aDY3a2lnM09aa2pXaHNGWWE4am90XHJcbiAgTDFTcTlUZHlMemFpZzJmQm5RdHhpTEdtZVVSV0xwaWRuS1JWR3paUWJZdTF4bk1KY29KbDRXWnNvZFZmdzYzSkJUaGZqcHQ3OUZXN1xyXG4gIHhUbnlqZE9hUFJKcTI5WlFUOHNpalk3UFVPM1NMRjA0ZDRxNjBWdmJ2VVc2c1VaT1BjSEhlY0xmZ0xoQjlQLzJVOThyY1JZWVRNZStcclxuICAzdkh2dm8vZWZNZXR0R1VMYnNRdUQ3ZmNmRFZkdURCRWYvakhINmExYTNybzVwdXVOczBYTm5BY3ltOEp1TW5kM0lNeGtBYi83L2dxXHJcbiAgSmE3WnJMS05qTnhHOE1YaFBBeEM2aDd3MWo4c3B4NERVd3d4WHVBRzRmTGxkR0JaSkk1L3JhQlNPbXh6cXFMMFFDb0hkOE1Xb3VlZlxyXG4gIFAweEhqeDZWWTQrM0FqWTJOdE9xVmF0b3pjYnRkR1l5ZlhwWEVPV1gyVk1CektLaVlWNlpTQW9ZVk9aNFVobGRUcUUxVWJEc2hTQmtcclxuICBnRzRpeHlJUHBFRS91blpMMWVUeVNIWXR5RXVLTUhqb2JwcmhDaEl2anNMVC9RdGQxNWltT21pclkwQW1WN2d1TTFmZXBxSldVd1l6XHJcbiAgYkRzN1BzVDIzUkozckNzWVhGNzVEZjVsUW5jNGZ2Wnhtc0hZR2p2VlZUdHVFOW15eUpWMStjTGplR0hTU3MzVUNPRkZ5WGdnRjkzSFxyXG4gIGdpaDVVVTU5ZEk2ZWUvWUExUytNMC9SU0V6VTIxTk9yYjNzMVBUZlVUT00yY0kvblI1WnJnVGo4djMrOGgvN2RPMytRL3ZhRHYwNWZcclxuICA5N1YzbXZUeWNNdHQzMGdQUC9JVVBmSG9oK2phYS9QZGExOW93SlZUL3E4NUIySmpJS0hpamk4NHB1WHJkSDRqeURrUGdHV1JSYVJTXHJcbiAgUXBNRWk5aW1iRC9PSmtpTWtpZ2p6WmJmd1d6eHlsaDBWK0dKVm9lNnhqWjUvd0Zpd0V6ZEpnT1dSZUpjbGJ4TXVsUlRZQ2VpdkJ5U1xyXG4gIFBiM2pkT0xFQ1JvY0hLYng4WEdxcjYrWEZzanUzWHRwcERIN0FoMkQ1VmV3cHd6TW9xSmhxc3laZWdFZloxU0lFd09FcFZ5d2JIMjVcclxuICBzMURBSGkzQytla1JjZUQxemUxVXgzZm1kUTNwUW50WjVJdGJJMTFmY0ZZTzJvcVlrdFlBV2poRkdEenlXZGJwKzA5ZTlhcFgwZUYrXHJcbiAgYnNsd3V0b0dMWXRETmM2Z0NPb2dNR2JDNmZtcXhGMnhQTDlUQ0wxc3gvb1BzdjFxbjI1RjNWL2xWLzZLc0sxbm1qNTczMzE4ZDlVZ1xyXG4gIDc0U2hybER4VmIyTG5HSGxsSzViQzZqbGxtajN6dHZEV0cwbWFjenVXNzFJVHoveEpFMXdxdzZZcVdtazlldlgwdFhYdllvZStQenpcclxuICAwbkpzbUp1UXhSUVBQUHo3WWxNSmp6MzJMTjF3eTd2bzEzNzVSK2hIZnZpRmVTaXdxZlZtYW1scG9PR0JCMHp5aFF0Y1crWC9GQnhJXHJcbiAgcjdWQTJGUXV4R3pscTErbEpRcDZTZUhab0k4dHNucE5IaXhpRzUreXhDWklqSklvbGlaR2pJaGhFdDBhNC8wSGFIRXV2SWZBRFpESFxyXG4gIFQ4bktObXdpTUo4UnhiODJrTmwwQUZ2bXhMbk1ES25jY2Z0V1RjcTd5ZEYxdGJDd3hLMk9ScHFkblpWM0s3UnZMMWk4elJJbVpTeUVcclxuICBOeXhCWHBGSWpGR0hNU2hQNGkvT3paUTZqSG11bEJlNU1vZHp3WlBMR0IvdzR4cWxaVkJJYTBTZ0RncmRyM0Q2OGJUTlM2bmdhNFllXHJcbiAgbHhsczhpZnhYZmI2Njc3U05PVkFpd05BT1h6NUdhNnliNnh5OEY1Ykxwb0djZHVxSGZ4NzNIVHJGRk5EWitSNHpiR1RiZXBZeXc2eFxyXG4gIGFPMnl5cFd6b0FvVGgrYVpZM1Qwb0ZibU45NTJHNTJaeUw1REkyUldWYlk1bytKVU9FOUdqejZFQXlRV1RYeWQ1cFpGS1NhcGQvNE1cclxuICBIVDJnazB5bWwycXBzN2VQdG0zYlJ1Zm1WdE81cHo1S20zZGRTUnZYZHRCZEgvazFhdTBxT29ZQms1TlQxTloxQy8zTVQzMFB2ZStuXHJcbiAgaTd1OVZvTEhIanZBVHVrLzBEdSsvSGI2cC8vM095Yjl3Z1F1eCtKL0IvQU9wRkd2MjdEUldMOUtTK1Iwa0hnbEkraGppNnorcFhJZVxyXG4gIGk0dHpmRWR6aU9hNHdvclIxTFVoZXMrQTJzczJiQ0l3SDRtVXpBb2kzc01zYzZxTW9DQzk0MjdlWG1ldGprRlpqbVJzVEI5eXcyQTVcclxuICB1aFV3aGJkMmJiUVdsaVY4c1IwSEhBQXFTUGVxMnpLSGdRcFd4aHU0SWtEWFZWelpDaks3Y1U1Q0I2RkR2bm5Ia0MrZlZPb21kcFV5XHJcbiAgb0RPMzVzWFp5QnBsbWFTRFIvWDVBbHBZcE9hMk5tcGRmNTEwazJHOEJMT3RCRXVMNGlCbHZNSmFSZFYxVFduWFZuUFhPbTRWelVtK1xyXG4gIHpaMTRncnNjU0RNL3pTMU1idmtzekV4eVN3VlB3K2VCRmdwV1FKZ2VPVmZjNVZXSThpcWhTRFhWL3hqZkxmTzFzN1JFNjY5K2kwbkxcclxuICBFREtvc0plQW5GRSsxY1NGSXpTRjJWcE00MGFoYis4Ym80ay9aaDhsYzJRZm5hVWpUNGNwdjB1dG5iUjI3Vm82Zi9SNWF1cnVsWnV2XHJcbiAgL1hmOUZtMi9NWDRnc2h5MURkZlErMTRnSi9KNy8vdHY2WHUrLytmb0YzL3VCK2kvL3Bmdk5Pa1hIbkNaNVA4UkIzRWcyN25KN3NaQVxyXG4gIDNGWEZzWDZWbHNqcElQRktScXIzMjR6K3BYSWUwME1ZNXpoaG5BTHJmOGxpaHpMNEdlVWpaSktSZ1dXUk9GY3hMNU11MVdUc1BGdHNcclxuICBkZTJHUlhydXVRTjBpdStPOFd3Q1doMTRRQkF0RUhRZnRyUzBVRzh2WHd4ZFZ5ZDVaZmFTZ1dsTGpmSUtKNUZXeGlTZStNWGdkbkhsXHJcbiAgS1RhRlhWZFJ2a2Fpa3NjVVdReWVPenZrVzFTMG1lZ0dJSFlPRGxXMVBJb3ladUhaSi82Ukw0ZDZMc2NjWFhIMTFUUmN2OE4weXdOM1xyXG4gIHlxamtYWm13akQ5YTlZNXY2dUJ5RlZ5RnJ1VWhyMkM5Y0ZodFM1d3dNTWF0WjB3bG54bS93TTVpbjBrREZyalZOem1BYzMxUit2cXJcclxuICBuYm9ja0M5a1Y5MElIWGp5RVhrakk4YmExdTVaNlZzWlE1N2xGWkVoTWNoYkR4NjhsMnFzTmRMb1d5TU9aaDhsYzJUTnhjZHB1Ris3XHJcbiAgdE9CRWFpWkgrY1p4QTQwTURkTDN2K2R0OUQ4KzhIT2lXdzZZUUxGcDY1dm91NzdqNjE0UUovTGU3L2s1K3YwLy9CQjkrcDQvbzllK1xyXG4gIDlnYVRmbUVCdmIyNWYwTHZGeG5zUUZyWWdlZ1lpTHV5T05hdjBqNXlFcTlrcEhwbjRjU09lQ21jQjZianl2c0pvbjV3QUc4QmJPN2VcclxuICBhRnlVajVCSlJnYVdSZUtrYXZaa2NUck5NMFpHSUd3cUMxd05YYisxaHA1NGpFLys0VUYyR3JOVVgxOHJyUTZjeUhOemZIYzh6M2ZVXHJcbiAgN0ZSMjc5NU5GMnQxdmFiY0xoT1l0dFNvdUN5cDAwQUZsOXBCTDdPYTJBazB0SFNaalVPd2hWUEIzVGRhQTdESk9nQll6a3hvNjJOeFxyXG4gIGZsYkdMREFMRHJpa2NRZk9jR2JNZFhrcDhJQW91cWdrMzJnc1pQRFFaMlIxNG5sdTBWMTV6ZFYwYXFoR3lvQTczUWIzMWtnR25HSmRcclxuICB3OHFmRDBBNVlxY0h1blhWZHMwcmM0WENVY0JCdUZpUkd1RWNHRCtIOFJITnIrajRqUFUvTDA0UnJUN01hcnNVdE04ZXArZWYxKzZyXHJcbiAgbTIrK21VNU44ckhJMVNqVklpUmNOb3ZFSURCNDBoeFBzME9DN3MrZVhiZXJ3aU5LR0pFN2VpYnA4NSsreHpnKy90d0t4WU9pMy8zMVxyXG4gIGI2UXpRMVAwb1EvK3VtbVd4NzZydnBLKy90MWYvb0k0a1d1di8xcDY5dGtqTkRQNXFEeTc5WVdHR3I0SHlmMFZ6b0dnL3g4dGtKcTRcclxuICB2NVZyUGIzazdjS1h5RWs0Tm5GVzd5eWMyQkdYN3p3aXVaQ0JUOHNENEtMbnU3RHp6MGxGQVpYNzhWaCtwR1BEMWRGZG1TYVViZGhFXHJcbiAgWUQ0ajh1VUZDdE1BbWk3VlpPdzhXMlpWUTF2YlIramMrYk0wUGpwRzQrT2pNdnRselpvMXRHSGpKaHFhNDd1bzhST3lxQjNlN1lIM1xyXG4gIGVFeTBWcHJSWVRsbmloR1FMNGUySXRocHREdW5BUVE3MThyUUxxbWl1K1l3aUM1VG9mbTRaeDNHTERzTHZNeHNldlNjejBNZTFsd0dcclxuICAwazFsUUVXc0ErNGR6SVh5eVYyL1Ira1BGMnh1T1U4UGZmYXo4bndEMzJiVG0rNjhrNTQ1SHkvRm53ZTY3ZkRiQU84WXNOd05PeVhIXHJcbiAgcDJVb0JtemhYREJ1TkQxOEpxU0xybHIzZTlFRmlHVnJaQ0pBZWxuVDVNVmoxTWpwcG9aT0ZiWk80RXpRWW0xYnpkZjdDbG9tWThjZlxyXG4gIG9QR1JFWG13c20vM0cxaVM3bGRRSUZvZUlWSEY1SWt5TUJlZS9oZXE0NXNSMUdYTnVkWUlFQ1UwOG1xK2J6eDA2QkFOREF6SWRZTVhcclxuICBxZjNoYi80dzdicHFuOHkyR2g3Z2M2QktYSFh0Vjh0YkNDL1hpYUE3ZXRYYTE5SHJYbnNqZmVKZmYxLytveThrZUFkUzZOdjQ0cTN2XHJcbiAgMnlITmJjRmxPUStHLy9FYVg3N3pBSXlTS0pZbVJvd2FtWkk3UFhUU2k5MHAxTHA2TjErZzhWeHV0WkJ0MkVSZ1BoSXBtUlZFdkFmTFxyXG4gIDlCc2hZeWRzbVVVTlhiZXBSdDdiZ1JsVzg5eDZHaDBlNFZaSG8wM1IzVWxIaDlUWk45WE4wNFhuN3BmdXJIWHIxdEhTcXFJbHFTM25cclxuICBUQkVDVXNXY2N4cG9hWFRrV3hITE9ZM2dkT0FFRnJWU05lQlpqZm1wWWJFSnpzTHA4d1YwbFNiR0lEQm9YR2N2NVVydXRLdjhYUTR5XHJcbiAgTTR0dk1ISVllWTRHTDF4Z0IxSXJYWVR0Ry9HeW9nQTh3eUZQK1Y4QzBOckN6WXc4dzlMUUxCVzhPb2x5UjRsak9NTk9GVE8wSmdlT1xyXG4gIFU4ZDZXM09LV3gyQU96WndQa1V0RkR4UEE0ZUNXV2hsemdUMkhldXlsVzZLbHZvRk9ySC9QcHJuYzZ5Rzc5YlhYVmswL2hIMjYxRWdcclxuICBxZ3hOc0d5eXhBQXRzT2RvbWdQK2JUZ1JQOTAzUVpUSXlMMXI1cVJMR0M4TVd4d2I4dE41TWNieDlCTWZwaXV2REE4eFZzTGVLNytLXHJcbiAgdnVFL3ZPMnluY2lERHo1RnQ3NzJQOUpQL2VSMzBmdC81dnROK29XQnhJSGtMaXUrS09xOEEyR3RmTTFLb3BBaU4xM1g5TjRpcTJla1xyXG4gIDNwVHBZS3hrMkJqVUpraU1raWlXSmtheTFMTjdHeHArcDJ0aG9ZbmJ2dTRLL24zeHhhOEpRNVpSUmdMbUkxSDBDeFdGYVFDMnpJbVhcclxuICBUeHU0R3RyZE95WE9BKzg0eC9SY3FsbWttYWxwYm1Gc28zT0xtODJPd1lsYTJJR2NmT3B1NmNyQUdFajkrdXhBb09XYzdpNkNLakNvXHJcbiAgTzNYeGFIQUszbDZKeWs0RHJZeUxwbCtsRHNQU3o4K095N2lHY3hqUTVZdWlFbFNJU3d2ek1tVVdMVVVjOHlJSEZXZUEzNDI4QWF6eVxyXG4gIGlrb1R3SDZrQlJEZC9kZldOZkc1VVA1Q3FQUDdQeXI1b1FzQnozL01kVjlubWhSemt5Tjh2TlFCWVIrMGhIS3VramZjdWYxcWE2dStcclxuICBvb053bUJtN1FGaWZDMm53SUNWZWpsVDJNT0hZMldlcHBYZXpURU1ORGtVdjdySCtaNmw5elY3Tzc1d01xQ3RDeFltdU1QQlpaNEpKXHJcbiAgQlRPakYybHVlb3gxK1FINGhiSFROSVlCN0xFeFdydHhJOVd1S2o0dUtjSitCUmwyZVdpQ2lza2lKY2FEUm81OGpuRFVNQ20vWi9mclxyXG4gIHBCdTFHSmJRb3EyZFkvVE1zd2RvMDRaVjlEdS8rZ1AweGplL2x0NzRwbStsNzM3dnUrbmQ3M3FiR2kyREhidmZUdS81cHErNGJDZnlcclxuICBoMy8wOS9TZDMvMSsrcXMvLzBYNmhxOS9oMGxmZWxUcFFQaXVscFdxTjZ1b05xemVlUUJLTCtzOGdBS2JJREZLb2xnYWpLVHlPMzlJXHJcbiAgK3VmeCsvQkQ1Y2Z5SFNzZUJtenFYQmNuWlNnajI3Q0p3SHdraWtxcUtFdURiU0l1U2dla2Nrc3AyN1gxNTJTV0ZWb2U2SzZDQTZtcFxyXG4gIFhhSTl1M2JUa1RIcmc3ZmtLSmM0a0tmdkZqdU1pelJ2Zm8wcWcxRUpWSUhLRjYyQ2xzNjF3Z2Y3MFBWVTVEU2NEbE5JMFcwa2QrYVdcclxuICBGbDFTc2NNQXNzWEFzeEFBS24wOGdWeHBiQU5qSVBPekUxSXhBNUtuWmFnVmREYjNTOFBaeHo3TUxZUkdPZTdYWFhkZDRxekRIbGErXHJcbiAgTHppSVdhN2czTEVReDhaMEplZWlhWnhEdWhDY1JRWndLTkNObmRIWUFla3hjd3N0a0E2K2VRTHdOTDNEMVBCcGVaQXoyM0laNjM5T1xyXG4gIG5CZmU4dWR3OXZHUGNhc012M3VSMWwvejVTcGNFY0orQlJtMk1vSnh4V1NzeExqYXhObG5hR2JnbVB4TCtRSDJMQ3hIanJaMVQxSi9cclxuICBmei8xSDNxV1B2SVB2MFYzdnVNTyt1bWYrVi9jR0sydDJpbHMyUHdXZXU5M2ZzMWxPNUVmKy9GZnAvLzUyMzlOanozeW9hcGJRUzgyXHJcbiAgTUV3b1J3dTlucmxMUUJ6SVRobEVWNTFaUkxWaFhHSEgrdGdpcS8rM2NCNnpmTWMyeVhmTytIa1ErVllIVjBwNko2ZE9NVUFaMllaTlxyXG4gIEJPWWpVZndMbGN6YUE1b20xV1RzaEMyellJcS9HeG92MHZIangrVzRZV29oWnJ0czVEdStuYnUyMDJOdUFwbmw0OUkyMVMzUndLRlBcclxuICAwOVRVbEF5azkrNjE3b1dRZVFhcVFMTWZqc0hQOWpGN2RRem92aXAzR3FxekNoOWw1WW9PRHFTMnNWbW42RG9kd3hVRHJRdWtiKzNiXHJcbiAgTG5mYlpRNUQ3ZFJSQUZMUmRtWXIydUlmVnlSZFd1UVdDcGNad00wRkt1UGFobFo1S0EzMkNORDNORTdJc1hkMXl0WnQyMmhrdnBOYlxyXG4gIFF1cTBJY2FkK3J5dGtkWmdZelMxamR5cXNXNjFHSmJOc3BnNGYxaTYwOVJSVkhZczNsbEluTytTZ3FPZEh1MlhGbC9zVEJibjU2UUxcclxuICBEZmtIdVpad1pwUWRHKzl2bXErajBHcFJZTnBzVi8wVW5UeCtqQS9Va281LzdMbkR0SmVLekpHcDlrQUoxTGhpRWxhaXBUVnQ3eHBwXHJcbiAgV2IxVEhnd3VSNVFiazhOUC96TmRjZE9OOU9ZdnU1N2UvTHByNmJPUFBpdXFhcDFDZTlkcjZNZCs1QnN2MjRtODhVM2ZUazgrZFpBR1xyXG4gIHp0OXZrcGNXdUU3a1NNWHpyRHpnUUZidDVNbzIwa3FrZEZ4aEIzMWN0ZWIxNmhlY01OVUgwbE1NdFFrU295U0twV3FFaHdBbitFUkJcclxuICBkNGZUd25tZ0cwNlhXc2NBbzlvR0tKT1dMVVpxSC85Q0pjdlRwSnFNbmJCRkZpYmphRXZyc0x3K0ZkMVdUVTFONGd6d1hNZUZKVjBIXHJcbiAgS0ppbStRQjFnMC9JUURxdzlwcXl0NTY1RnNVZzM1WHREcmtZZ1c0WjNNRmxuUWFtMWs0UG55cDBHcjZWa1Jra1JwYk9ZV0JxS3ZyK1xyXG4gIGl3YkZZYU5QaGsvNnZIM2xtZnVaMlY5ZUkzZlpycXR5WHU3dzhhUTIzM2x6WE12R0RSWHU4TE5ZT3Y4d1hiaUFycVFadmg1cWFlT3JcclxuICB2dG8wQmNpVmpZOGZsd1ZYR01xRUNoa1hHOG9HSHVYUTN4VXFxMERsSWEwUHlZZWR5bGhjNmFkWXpxRkFublZJK0Q5eFU0V1ppVmxuXHJcbiAgTW5ZV1hWemtXeVdRTm8wZG9PTkhqL0c1TVVkYmQrNmsyWTVLbGZGS2tUa0tsUTVLZ21CWWxnVFB6Z3dldkVlNnRMQzA2S3A5YitMV1xyXG4gIFphVUpFVkZPVE1LUkFQL3ZJNzlORHp6OGpORFZPb1hhaGh2cGZULzE3WmZsUkNZbXBxaTkrelo2NTFlL2dmNytiMy9UcEM4ZGNNckxcclxuICBFU3B6SVBYc1FLUUxDeEFEdFhJVnRzSUkwenNMSjNaRXJvS09ISVd2QmhMbndXQSt0Z3BSTEdXYXY5UGNSSjNoSmppQWkxVFhhT1c3XHJcbiAgMWM1MTFMcHFCOThOV3p2TEo0M3lFREx3aXRoV0VaZEd5V3dhZ0sxeTRtdzZJRFZTem1RY3JhMDdKMCtWbzlXQjdwTzJ0amJhdm4wN1xyXG4gIFBUOFVMUmpJbXpTWGdMN0Y0L1RjYzdvd1hOOFYyWmZWcU9OQWR3Wm1LY1Y1NE01Yld4UVl0NGdkaHpvSXRGdlZFWXRJOHZGT0F4VitcclxuICBwa0NxdDd0bzUyd2lvN2gxa2EzWUJHeWFaZ2tuY1ZIL1l5eXd5R1d0YmUxaDUxcGY0Qnd5aGFrQzhSRTkvZGovcFNhK3c4WWFXQzN0XHJcbiAgN2R5U2U2dHBMZ2RwOVFZbmd6dCtsSDJsem1Yc3pEUGltT0JZZE5wdmZsa1h0QmpRbWxISGtPWlM1RXpHemg1a1o3R1hzR3hNR0hNSlxyXG4gIDZkQXF3WDduMktuV05UVFE1czBiYVdpbWxmZHY3OTBYRkpYMlVwREpwK3BzMWJESUhNZGk5T1FUdERCNlR2N3A1YnUwQU11Sm84MWRcclxuICBVNXpKRkwzMzNWOUdoMCtlay9PaldxZFEwM0FUdmY5OTMwRS85ZCsrMnlRcnh3Zi81bVAwOWQvNFgraVAvK0I5OUszZjhqVW1mV21BXHJcbiAgNHlkSHB0eUI3Sks3ZDFXcWhhdXdGVWFZM2xrNHNTTnlGWFJVdy9vTHRzQW10Z3BSTE1XS3BlTTB5UmZDZ2cyU0EzQWVjSHp0Zk5jVVxyXG4gIEJzMDRuVThhNVpISlV4SGJPaklyaUhpQldTWGlqRTFCdXNBeHhkOVhiU1o2N3VBaG1VR0ZKZGhIUmtabzFhbzFkUFhWVjlPVFovanZcclxuICBzZ1R4MFVtaDh0VTFwK253NGFNeUJ0SzRNVHlKanRsR0dKUkdoUi9uNExwMHhBbDRXS3RDSEVwd0VNZ0RxOWVXT1EwSUZyQnlLbCtzXHJcbiAgV2FjQmg0SG5jTFJsazNjWVloVTJVcUZpYVpQRjJRbXFaMXY4eDhGUjVIWmNBWkd0a1VGU25NL3BSLzlPcCs4dTFWQkhaeWQxN2xwQlxyXG4gIFYwMVNleVhNTWdpMjQxeFJvMXZNT2N0bU55WmxOdGxjWTRkUzFFSnhEZ096dnVxYjBsV0NvUVBpZEJoREFXTFoydnF6OU5qREQvSDFcclxuICBWVWVkUGF1cGJYTTBRY01LbFArMWVjbktrY21qcWl6VnFNaDA5UFJUTkhOUngwVmEySUVVejlMS3duTGlxRzNtQlBYMk5OT1gzYnFIXHJcbiAgQm9iRzZVLythUGxsMk1mSEo2bWo1M1gwVjMvKy9zc2FEUCtxci81QitzZC92bzlPSC84RWJkaFFlZFdDRnhNNGRuSkVjSitSdTRUWVxyXG4gIGdUUjRCeEpkYXA2MldLS29Pc3ZvOHhVMDA4WmVydk9ZSGpwT00wTlkrbHBiSGVpMlFHanFYRyt0RHVkU09KMVBHdVdSeVZNUjI0TE1cclxuICA2Q3VrU2FVWkcyR0xMRXpHMFJWclpxVEw2bHovQlpuMWczV3MwUExZdFdzUGZmNEVON290anpTWEdDR3Yxb2xETWdDSUdVUmR1MTRuXHJcbiAgejFQVTFqWklwVzhtZ3NuQkU3bzBlcWFpeDROL2Z1ekNqT0ZNWkxrUGVVcWY0VEpoNEk0VkFyUUVVbkNMd1ZvWnBRNUR3QlIvNVk2Y1xyXG4gIGJSczZWcG16d0FVUzdhZ1FwcTlnRmxReGxVbVFZYzg4OFdHK1k4WHZxcVhkZS9mU1ZQdFZxcWdhNVJXWWgxZFd0UElZUDdPZm5jb2FcclxuICBQazduNWJVQzhReXlOSWNsNzFBQTdTNE1GbkFZbUxtRkZtaDJkaGRhalZqYTNqa09qS05naVJkTVRHa1lPMEJuVHA1Z3gxcFBMYTBkXHJcbiAgVk5QY3h5Mld0UExGT2JjNFA4MG1MUVcvcXJyZldSbFJIbFZscDBaWlV5enZQM3JzWVRuUDZ2azg2OTcrYXFhcXlWQnRybHk5UVBOelxyXG4gIDQzVFRsZXZvNGFjTzA2ZnUvWE9SVjhJenp4eWhxNjc3T3JyLzNqK2kyMjh2bWw1Zkhlb2FyNmRycnRsSmorTW01eVVDTHBmU295VVBcclxuICBFcklEaVJkdWt3dE9Maks3MG93MmprbEhhWHhKemdNYXo1YllMQzdTeE5tbnBZSnpMa0piSFEzeXdwbkc2T2xnU1pmTmovR0Y1anhXXHJcbiAgMVp5U1FXKzBQSVlHUjhSeFlJRzNrMU85a1ZtYVIwREl4NkYyNEdudHY1K2JvV3V1djRYT3p3ZkhNY3N0QUprQjVBZkZJYzIwTm13TVxyXG4gIFEyVFNSV1ZUY1FIYkR3Wmg4U3BmZEoxRXV4YkVxOHZHVGlQWUtUWEg1WUJkUGU5UDdaeEZOa2VBWlFWaUZSWFpSNUNrc0NteHk0ZzNcclxuICBOcHlpaHg1NlNONUF5Q2NXYmJycGEwMnpFdGpsVlVXZFZHZ2l3a3FKbDhUaHlvM1Q2SG1xNzlsc1Q1VnJtamdsbkVuSGhpczUzcytPXHJcbiAgNFVxVEtyQkVPcVlMWjZmNXdzbTA5bTFMeGduNm4veG5tWHcxejFmZVRiZmZTYWRIMERWY1hFYU1yVW1YSjU3c0I5Z3NiMW1jdGpwRVxyXG4gIGFhdktSbzFpVTV4N1k4Y2ZvMXAyZUJnWFFYZXZySWUyYklaQlh6TzBuMXFhYXFpN3ZZa2VmZmh2VFZxTysrNzdQTDNoemQ5Qnp6NzFcclxuICBkN1J2WC9YTDRzUzQrNTZINkUxM3ZwZit5Ly8zSHZydnYvQkRKdjIzQlM2WjBxTWtEZ1R2dnJBeEVMbjQvRVZtQk5mQ1hsU2dMNXR4XHJcbiAgNVZOSmxOb3M1enptK2FTY09xY0RlNjdWQWVmUnlIY1FyU2h2OGlRdHA4dm14MWl4OHlpMEJ6Uk5xb2s0VHdaWlFoblRQSEdBaG9lSFxyXG4gIHFidTdXNVlnbVo2YWxTVklqbzV4WldBMlNYa1NlSU1FQzJjZnBZc1h0VnRxMTAxMzB0aE1qVDBNT01DdHM2MXk1Nm1KMUhITTgxMW1cclxuICBLOStSdW53Z2czTkE2eVRPSE9tZFkwQ0lkMXZrTklKZUtWUjQweE9SVFhLT0FJN25PS05TTm12UEVGRmVIaVNPc2podm1wTU5IZmdYXHJcbiAgbWhnZDFTNHNQdE0yM2ZoT1ZSU2hZbDNqbEVVN2RXQ2J3anppU2JZR0VSUWFNNVpvK3R6elZNdkhkbmI0RExWdmNDMG10WGVwSnM0ZlxyXG4gIG9wYStyVFRCdHRtdUxqZ1RRSjFNMkE4ZVd1eXFIYWJqeDQ1VFkyTUR6YzdNU01zajMxV1dMeHRhTHFoUGt2cUF6ZktXZVVuMWlOSXVcclxuICBtNDBheEdZREIrN0JDU3ovVXZPbTYvaGF3UEkvMVpSSGJhN2JYRWZqbzN4dWp3L1RJdzk5U0dTVjhLOGYveHg5eFZmOUFGOExuNVBKXHJcbiAgTVplQ0gvcmhYNVZYN0g3MjAzOUd0OTVhelhNNEx5eHdyRXFQVU94QXBQTHkvNzBSZkRKNFVZSCtVcHlIZlpYMmtkSm9GazlmUEVMelxyXG4gIFl6cjRoUURIc2NUbFJQOGxwdWhhS2dOelhoQTBMNlR6eU5WOXk2UUxIRlA4dlhyOXZMekpEVSs5WXFaVloyZW5QTHZSMDkxSEYybWpcclxuICB6eVBOSllibUV3T3RCV0JkeTVRczc0Ny9vV1BqdFZMeHQvdXVCaVN5UVhHR2EyMWdmU2RNZi9aakc1WTVGdUtiR2p3bU1wV0gzWlk3XHJcbiAgalZBd3RETG0yYWFlYmFSTEtxZ01MTWdjek1KZkxhSUN1VURsd1NTMVM4Kzc1WEh5b1EreTM2aWwrb1lHYnNVdDBPYWJ2czQwSzBVTlxyXG4gIFgyUUZsMWtpS3JzTVdWNllOQ01VdGlnUGRHUHRwNmJXWG1yb1hCZGRreUVIMXpMQllIdmJxdkRPR0l3OTRmL0VRNWg0Mmg5cE9tWU9cclxuICAwY0g5VHd2ZDBOSkdxNjk0aTR5SFNhc250L3VpOHBTQVRWUHJGYVROSVVxN2JEWnE0TXhHVGp4T3MwTW41YkVHSFZ4M1N3QlZVeDYxXHJcbiAgdVdMdE9JME5YS0NISC93YjRTdmhWMzcxeitrRHYvZEJPblpZWDc5N0tkaDMxVmZUd01BZ1hlai9sRW4rN1lDenlSK1ozSFhGZC9MTlxyXG4gIHEzWkxGMVk0OFN5V3lGMlN2SFZxSnpHOUl0VUhsUmN5MUVZbGtkejJpMmNFcHM0ZEJDR3REaFFhenFPK3RZZGErVS9HVk9Nb0ZjTm5cclxuICB4Z2lhdEZ3T3NTM0loSEdiRE5ncUVXZHNDdElwWnpLTG1zYWZsUllIMXQ2QkE4R3lJenQzN3FSbkwraHNtcVFzQ2RKOEFFeFJkTThPXHJcbiAgQUYyengrakVpZU15V04yRGVmcGlxd21jazhsMlU3V3UzaUhIVXUxY2w5WkZtWXpnQUUzcU5OVFJhTTY2UmRmV3d2eVU2S0dSY1RSQVxyXG4gIDFRd21JanBPNjVFZTRBZ21qOVR4Y1ZJcVZ1YnRLME1OVDMvK2Ivbk9tYzh5VGwvSDVkOXdmVkVMSks1WWx0bUJtTWIyQVNxTmRKNHNcclxuICB0dWRhM1FpSGpFc1JKcDkyNHN6VDFOaTVsaFlYbDd5emo5UENtUUJ3S1BFK1hLdWtZV0ZZSm5Vc3pFelR0cDI3ZEpYbkJKd210OXQ4XHJcbiAgT2JSTE5KMGE3cEhMSXArK09rVHBsczFDRGJCRjYyejg3TE5TeitCVnVtM3IySW40OU10bHBQcmI5OWJSTTAvdnAzLzRQNzlDZTYrcVxyXG4gIFBEai9zKy8vQS9yVXB4K2l1ejd4QnlaWkdZNGVQVTA3OW53RmZldDd2b0wrK0Ercld6bjRoUUxPZUg5RWNxZC9EVHNRYm9HRXFZRm1cclxuICBJVkYwMGZ1RUpqRzloNjhJb3NzOHFSeVkxcS9TRG15RHU1L3B3Uk0wUDNKR05BalNaY1YzUkJna2IrclNkM3RIcVJqTWVVSFE1TW9sXHJcbiAgaUcxQkpvemJaTUJXaVRoalU1Qk9PWk54ZE1PV2VqcDQ4Q0FOREY2UWxsVnJTenQxZEhUUUtONGFhT25USEdLd0psSjZaK0RITWxRMlxyXG4gIDNmK2tkT2RoTUw1dCsrdThISWdkQitDY2pxYTNsZ21UUWM0cy8yaTgraE5Md0xpRkFMV1VvVEI0TWh6L1dVTnpablZYSExCZ1p1bVVcclxuICBDbEZrSUloMWl1S2pFdjhmc1o3cFluTkRVR2JOdGpTZG9zOTk3Z0gvL01mV2JUdG9hVTNacTFvMWRWcTFHRmRhM3hRb1JKU1hKNjdCXHJcbiAgazFrNzVoUFI4ZzVsa3AwSldvUDFiZXprL1FHTW5BbG1aZkc1Nlp6SmxXdW11Wkw3T0ZjTGRiUTRPMHNiYnNBVTBqVFBCTGw5cHJhWVxyXG4gIExneDBySyt3MENjblNWT2xYSFdJMGl5YlhBM0d1VFUyd1MwM09KR20zaTNVc2ZtNlROcmxNbHFTbHRuVStRUDA3TU4vUmx1MlIwc05cclxuICBGUUJPWkdoNGtIN3pOMzdjSkN2RC8vcWREOUlQL05BdjBUMmYvQU41Wi91L0ZYRFcrQ09SdllndytOV0NRWFEvZ01ZV1loUmR4djdFXHJcbiAgMDFoWnIyVXdiYXhQbGRpb1hqa25ZekNKSlJVbXNSaGFORDBYem9PYTJtVU5LK25ENXgxR3FSZytNMGJRNU1zRnhMWWdFOFp0TW9nclxyXG4gIEt5QmpVNUJPT2Q2YStLWnRqZlRFRTAvSXFwOUwzSTVDbDlXK3ZWZEdnK1haMytSZ1VvdUtIQWVBZGIvd1RNRDVaejRwZmF2SXYyM2pcclxuICBxOFRFT1FSMUVOSHpIS3ljbjVtZ2FTem14ODdCT3c1T016dVd0alowVDlncXBkMVRBOVRFKzNRdlVsS3czc3pVVXJkQjRIZ0g0MzFVXHJcbiAgb0k5RVNqcUJ4UkpsLzZNWWthTFVoaStLczUraWs4ZU9DWTBucmQvd2hqdm93TEM3WTY2UTBLR0t5a2Fsdk0ycE13SmhVNW12NXIwNFxyXG4gIGs2WkFuMWhrV2pEajdFelFiZE95UHA1bHBtbWtWY0pPZEdOUEhSM1l2MS9HaEpvYjZxbjNpdXg2VUd6UCthTEZtMXV6S3lySHd0eWtcclxuICBEVklyeHM3cTArRWQ2eXU4OElyVHB5Vk91ZW9RcFZrMk9WWXFHS1RoUTUvUlZUcjQzTy9aYVRjUVB1M3laVUFlMHhlZnAzLzQ2MStnXHJcbiAgSFZ0VzBhNTk1Yi94enJmOUFOMyttaXN1K1VIRE43N3BPK2orejN5ZTVxYkRTN0plYk9CSzhFY2hkMWx3QmRQTWQvbjZIbkRUSmhVMlxyXG4gIFU1NVJJdHpKQUVIdlUwa1UyV1R6WXl3dExkRFV3SEdhR3pzbmpzTjFXY0Y1TlBac29SWVozR0lrYVFIbXZDREtWY2pVTXJVRm1UQnVcclxuICBFMEg1NU9kbGJUTHBFc3FZcTlZdTBPSERoK25peFl2eXRrQ1JYWFVWOVMvby9QN3NMd293dVVWb0NlREpjWVVLcDRaT1V6MVg0T0pRXHJcbiAgY0d3dVBNYjd1Y0JrRGIzNXpXK2h6NStPeGp4OHk4SzZxZGdCWUlrWDNGMnF1SVptUnM0UkZxREV3THJ1d1pVTjAzSjFUQU5QZVNjUFxyXG4gIDcwVUhLRGtYaE1RbWtvSDJiT2FYeDJrRnlzdldOcEZFNGRKRUlzZWdWVFF6ZWw1b1FKWWZtUm1uaHBhZWpMM2kvTk1mWTEyelBJZURcclxuICBKZHkzdnNhOTd6b1k0NXhFWllteEFnZnd2Skh4d3hpNjV0VnFlZXVncGpSNE1wSXhsT050SWs1dFl0N2IrNmpBTmhLbERpaTF4WEhDXHJcbiAgRk41T0RNQjcxUkwxUC8xUitVL25wNmZvelc5NUN6MHpvTytCeHpMemMxUEROdWdPTE1tZ09ZNVZtU1BSWjA2NGRSTTlLWStYWFpXOVxyXG4gIFdURUI1NUdXT09XV1IyUy9URkw4RGl3Tmp3N1lKYjZSN28wZnlQVnBLMmVDNnd0TEJPMjY0VTMwMFQvOFp0cTZJMzdnTXNWclh2ZXRcclxuICA5QlAvNVZ2b0s5NngwaGR6Y1NuWWVkYzIza0R2K3JvMzBkLzhuMTh6NllzTFhBM3k2K05yeUIyTzJzWldhdTdlSkdzRUNkZ29YT2JDXHJcbiAgR0pSWXNmT0F4ck5LekUwTjBlU0Z3OXpxbVBQT1E2WW8xalZTRzdjNjlMME9ERFpQcXh3UlJGQkc4MDhVak5RMnlhZk1IdHRFbkUwRFxyXG4gIEJGbENHYk8zYjRhZWVlWVpHaG9ha3BZQmxnYS84c29yNlRoZXdzTklmMCtNa0VkUnF3T0RuNDMrUlUxcUM3dm1hYndUNUt3OFNOaTZcclxuICBVV2RvWkIwSGxyREFzdUNTbFdSWFErTm5ENGhkMnRwQXhHbjRqZ3J2dWdqOTU0em93TWh2Y0t6RU1XTTBSN25mbWh6Y2lNN1lLZ1ZoXHJcbiAgWktOR01xZmZBWTRQRmZiQzlLaFYyZzV4T2t2alJNalQ3c3pQUGZVdmZLZk5aOThDdXVPYXFIZjNtMFR1QUFlQmMzRnVVbCtyNjdBd1xyXG4gIE8rMjdmSXRXdmdYQVliOVlZVmNXOUdUTWpQYUxmVlB1VmJZaHJWSzhUYktMbUV5clFweUVGOFc2V0c1MkRsRWVVNmYzeTRPYkRWaHpcclxuICBqTVZubi93bmtlT3RqTzY1RCtuZXN2elMyVnRBbEs4QlMrUEljeXVtQ280RU03bTBCVE4rL2hCMStKdWpDdERkUnNqdnJ6SWkrd3BKXHJcbiAgY1ZOd2Z2L0g1UDBpL09kUzc1VnZEamNJU2JyeVRIQTlUZzRjb3gzWHZwYis1MC9leWEyUk5iUjlkL0gwWFR5dC90QURmMG8zMzV3ZFxyXG4gIFgxb2VILzdJUGZRMVgvZWY2WlAvK252MHBqdHVOZW1MaHhyMnJMbERnTWVtY0ZVMXI5cE85VTNXbHkwWG1idVVlZXN1T2ljeHZTTFZcclxuICBCNVVYTWxnZTJjakt1UmVQeUFVcFRVWUxLQSttSk9LZEhmNUZONnhJS3lBUlJGQW1MWk5EYXB2a1U4RStsVWFjSjROTUtlTXQycmRxXHJcbiAgVm1aRVlVVmRqRW5nNVU4WU1EODZqdU9iL3BxQWtBZE9RQXhFaHpmSHdRRU04TjNncU0yY1lTT3p3emdFbkVMYjZINDZmSlNkUzBNRFxyXG4gIDNmSEdPK2p4YzVpT0hiZEN1R0t3WFNBZDVNRnhoSDFqMlJBc1NZNEgwWHhySTZyQVkxdlpCQlVEdkFyU1l4MGJHUzFSYktWVWZKNEFcclxuICBHTmhHV2VlbThTSWpkcjRzVmljUlVpNWdUdi9rc0Z6b2FDSGduUjJvb0xFTUI5RGNaV3VKQVNHWko0ODk4Q2ZNOEswTGZ6ZHYyMEoxXHJcbiAgRys4MFRSN2xkVWhnc0YrM01DSEtHc3FSZHpKVGNHcFdrZU9KOHM1TjF6QmxlbSttaE45bTVJTElHVlJxY1JUYUFaRzhlZVJKT3Z6OFxyXG4gIGMxS0J0cmUzVTVjOGtiOUVvK2plWXJPVk9CSjFHdEN6MDBoVWdSazd5L3RpVk96V2loQVZsWkh1YjNsRTlpVkowV0lkT1B3QU41UDRcclxuICBuS3FwcFM1NVZpUjY4NlJQVjc1dm5JZVlDZm1lcjdtSjN2clcyNmludTVNMnJ1dWpIYnZEekRmZ3FhY08wYlUzdkl1VzVpNnRLK3FyXHJcbiAgdnZvLzBULzk4NzNzNko4d3lZdUhHcTVTa2w4TUJvMVBvS2xucXd5WTZsVVZYZGoraXRaWVdhOU45RjZhclREMEt6UmVqb01ueXJsbVxyXG4gIDhLME9ZSkYxVFd0MmNZWG1sbTlnU0tKTUpSTVlodVZxZGlsUzI3UkM4NXNJYXA5S0kwN0lJcTNKTExwaTlaeU1lZUFoUVRnUHRBajJcclxuICA3TmxUdGZQQUhSbmVZUjNBclFSdUVtUDlIcGNhSjZaekhNSnpCYnQwOFZtWk1ZTlhjKzdkdTVkT1RXbnJUUndId0FjSmRnaHdHdG82XHJcbiAgc1J4NUl3c0JNcUZQZ2dNczFOMXhaQVRnL2x1SkFxMDJqcmRZRUd5Y2xZSXB6d1Q1OU9oNStYMnlKQXJYRkZMcG1oS3J6T0l1ZnVUa1xyXG4gIDQxSXhBK0ljNHF3RU5mSmVpNFhwY1JuandXS0VxQ3kxMVZ4RDlleVk4WElxWUVQRFdYcnN5Y2VrcFFWY2YrTU5OTlFjbG9KeHdITDNcclxuICBzMUczR0lBRklodWE5Y253cHE2MTJnMjR5SzNwV3VrRThTOHVDeGVkVXRQRDVsQllqeFlsV2pIcVhGUXZUZ1d3bWpMcENndVpNWm1WXHJcbiAgeGNwQWkxMUZtOGlWc096Qy9vL1M3UFEwMDR1MGUvdDJtdXk3UGtwbWpvU2hBKzRxOHpPNlZ1QklaQ3J4NmxDaDR1NC9yQ1pSQlRpZlxyXG4gIHNKZDBmOHNqc2k5SWlwdGNuR2R6N1B4eEs5dDFCUlppVEplRENlbUs5NzAwY1lyZS9kWjk5RnUvOVpQQ0g5eC9VSlkzdWU3NnE2aStcclxuICBNVHl3ZmRmZEQ5UFAvOEx2MHoxM1hkck1ySnFHNituZC8vN045TUcvL2xXVHZEaW82RUFhT3pmd3hZWTUrMFVYdVVxMFhnamFvRWZrXHJcbiAgaUx3ZUVpeVBNSG54c0R4TkRqNTJIbndWeW9DZWRnZFllb25LS2h4QW1YeVpnTlEyemtYSll2dFVHbkZDRm1sNUc0bDM5MHpSc1dQSFxyXG4gIDVEa1BWRlo0emdNdGo0SGFUV3lXcGcvUVBOQXFBTFJyQ3FpUlpuQjlVMGRZWDRydDRHQlE4ZFEzdGNzS3RuaXBVUHU2dlRSMzRqTTBcclxuICBPRFFvLzJsTGN3dDF5Wkx1eURzNER1MkQxbkxJbGpmVGc2ZjRCR3htcDJLT3cvNi9lT3VOSlFxeThKdkFPQnB3Tm1YL254TFlZc2tWXHJcbiAgM0ZSZzNTZXRSTlVPM1Q3Z1IwNDl3VTZEZGZ5YmZYS2pVQkZEUG56aU1VdXIwSW83V0tQZkhpeGVtUXRIb0lDZWIxcEduNlFUcDA3UVxyXG4gIDBqdzdFRDRocjN2VnEyaW9VYnNBY1NjS1I1VEhFclYwYjZBcDVBdU9uWTgrTzRGOXc2R0Z5d3hMeE9COUovaGpVSzdnUE5RQmlxVnRcclxuICBVRTYwb3JCZklQNU4rSTFkbTE5Rkk0aTNZRWtNMjBmSXdFaVRPejJ3ckROSlphY2UrWHNjTEM3OEFtMjg2V3RwNmpTZUJlSHphaVBHXHJcbiAgU2J3aE81TDlFbXVMaE1FNmpHMWd5UlQzejRjV2lqNkFpT09QLzBIQVdRWEhvdU1qT2x1cmh2bnFXaU9DdVBnUlZSM012aVRaMFBGSFxyXG4gIGFXNzR0Q3ovMUxIdkRudlFOb0pQbDgvZ3RUZnZwS3MzekFvZEQ1WS84S2tIYVc1dW5sNy9wdkFPZDh6TU9uM21MUDMrNy8yMFNhckhcclxuICBYWGMvU0c5KzYzdnAzay8rQWIzK1JaeVZWZWhBY0tvaWJzQnFyTjBicWRZdUJMbkEvRFdveE1yR1BWU1BoZnl3YWk3NmZiRW41TzRDXHJcbiAgN3ZtdzdIWXpCblFsYjBzclVWbmxBeWlqWm9tQ2tkckd1VmdDSVFQVVBwVkduSkJGV3Q1RzRqMjkwM1Rnd0FGNXZtTUtxN20ydHNxQ1xyXG4gIGlCanpTTXFRUVBQUXlsSXJGR0IyZkZDNlpWcTY0WGhNeG5mbFlOellCeHdIbHB4d0xZbmFjdy9UbVg1MlhNdzFOelh6SGRQYmloMkhcclxuICBaWWl1S2tBZEJ3dE5YdnhmTXBCUXZobVo4Q1pMOU1JWWdnem5BUndHV2hJdCtNMmlxcEZqZ05DOTVRYityZWhDNDk5bGhSVkgwYk9CXHJcbiAgaHZsaTd0NTZvemtPNjVaaUUxUzhMWHp1d3JuaUxoSE9DSTRKTW1jVGtEQTA5T1FIYVhoa1NFOUdQaWx2dk9rbU9qMWo2UW9BeDFFWlxyXG4gIGVvazU1d0swc09NUW5sVmFiclhCZzV5anA1Nml6czNYY3V0R0IrZlYrYkdGbUN6eGIvNDgvK1liMUhHd0ExR3dYSnptQnJaYnRITkhcclxuICA4OVJJNlVKblVlaE1nbXhIMndXNi8vNzdaZXdEMkhqejEza2J2TzBUYjRuMDlpWXZjaVFKbU0wNkVtMTk3UEJaQmFnQTY2T0ZoVGx6XHJcbiAgUnNWZ3MyQlpaUm9Qc3k5SU5uajBJWnJuOHhaMVZ2ZmVOMUpkczA0b1NPRFRoUXpnUVA3Mjk3NkRuY01IcUxtNWlYNzgvL3QyMHhBOVxyXG4gIC9NQ2o5TWxQUFVFM1hyMlY3dndLSFhQN2htLzhLZHE3Wi8wbHpjejY2bmYrWjdyN25zL1I2RkQxNzNKZktTbzZrRHErbzIzdTI4RjNcclxuICBCellxNGE4ekpmUmFkc0tnTDZ0d0pHK3U5UEJ1OGlXWnBjSDc0QUFMNXp3YWV6Ykx2R3RGbWsvSWllRnFQWUhTWnVZMkJxWWpOcTNzXHJcbiAgL0NhQzJxZlNpQk95U012YlNOeXpjRkxHT3k2YzF5Nk81cFlXZVVEd0FtMWdzelM5UW1YaUZCaWgxWUhaVmFla2N0VVZBYXhsd29TK1xyXG4gIGw1d3JZSzc0Y1RpYzR3QlFnZGFOSFpFeU5OUTNjTnBhcXUvWkxvTzBXT2RLd0thd3hveXVwdFllSGQrd213WE5SYmU1WXcyV1pWN3FcclxuICA5YUt3YnlRVDB2RU10bCthbitFSzVJRDhMdHg1dzk0NURDeXowaVJsdERRY1lYQjE1Q1FxVEYxOERyUEZvSjJ5dTNjRlMvaWJWdWlhXHJcbiAgQnlwcmFSRnc1WXBqZzBvYlkycXVtd3BvNlZFbmNlUytEK2lKdWNDdGl2WldXbi9qdDRrOGorVFM4Y0JiL1lCcGpyR2ZiTjBKdExEelxyXG4gIDh4RDlrbmN3S1AvUXNVZllTYURiVEJPUDhoMS9KOS90VDV5M1NwYmxsc3ljNkEzNnU2eUZNajF5UnRhMndtcTYyam9CMk5nbEVuQWVcclxuICBqblF5RS9ndGYrZFAzeSt2RllBRFdiTitQVFZ1ZXEzb0xJVlBvekRhb3RFejJsS0pIUW02Z3ZSaFZVT1VQdHV0bFd1TjlEOG44bzcxXHJcbiAgN3VHOGtMWWkyQ3hZVnBsR0VObG1rZzBkZTFoZVhJY3JwcWRLSi9JL2YrSk8rdmRmKzBhaDhXYkRONzN4MVVrTDRlUC9kQmM5dXY4RVxyXG4gIHZlYW12ZHdhMGJlSTNuenJOOUt2L2ZKL3VxU1dCTHF5dnZ1NzNrbS8renMvWlpJWEZqS0lIaDhYMEhqQ0c4Qnk2QzE5MjdXZkw2a2tcclxuICBIT3RrakVnZlZFR1BaenFtaDA1SWR4VUFEUTY4aTNFWk42M2FTWTMrcnR2U1dqNGhKNGJmRjZDMG1ibU5nZW1JVFhMSjJRSnFuMG9qXHJcbiAgVHNnaUxXOGpjZmY4Q1hydUlEZTdVVTQrdWxnRy9Jb3JycUJqRTJoNUZFR2w2TS9QdGpybVo4WUliK3R6NmVCZzhLeEZmWE9iT2hKR1xyXG4gIDFuRmc1UURJWmsvY1IwTkRJMXhSMWxBOVg3QjlWOXZ5MFd5S1l6R0JKVXY0SmlFc0xRS3A3Y2w0aFNRd3l1ak0rUURlcDNVMmljNGhcclxuICA2RkI1NCtZRWQ4eXo4cjV1clZUQm85c0dheS9odDZDbGdSekNIYnptb1k0aTVJemY3bUxYR3NGeGtHN1FZTVozK1hNeW9Ca0wwUXBDXHJcbiAgTnhGbUhaNTk3UDlTZldNZHpTOHNVazlYRjdWc1RaZHdsK3NGamdndGFOenQ5MndTT1lBdVJOY3ZqbWRxbXMwcGlYUEtWQ2FZZHExT1xyXG4gIFpxTmNoS0E3TjE0dHJVaUI3a2dxcXA1dE4ydHNUc1VmQzA1WTE5UVdKbGRJUHFxVExqSExZNUpsYU9WMVJ5MFdwNVBJODRCelRpbzRcclxuICA5ZWpmTWNuMHdnSzkvbzQ3NlBBNHpyZGc3MTJKUkVZTGdrMXdKRmZ4ZG9uR1RtZGFLQXhaVXNWYUl3bmlMSTFabU5QVmdRTVNvM0tFXHJcbiAgSWpHcVRDT0liQ01TcmI2Wm9aUHFSS3c3cXpCWEUzYlZYcVFERC8rK01neThZLzIzL3NkL29XdXZUUittdk8rdUIrajgyZlAwNVc5L1xyXG4gIEhiWDM5bkZGZmNNbERhcC83RjgvUTEvK0ZkOUhEejN3bDVjMHEyczVTQlZudEVjUTFPaHkwVzJycFJKeUY1eldIZUhpaXlzVEx6VVpcclxuICA1dHJQOE1rN1A2V3YvQVJ3c0ozekFMQS9qSGZVdXhVN00zbEhISU01TDFCQ3RtRmpZRHBpazF4eXRvRGFwOUtJRXpMd0NSV1pyYTA5XHJcbiAgSTg5NFlIMHJOOXRxeTVZdGRHUzhKemFMZ0tteCtWYUhQdWVoSnhYU3dRYnYxbkIzcmxORDNNTGdpc285Q0lodUtVQ2NpUjM3NFdjL1xyXG4gIFNuUHo4MXpITFZGYld5dTE3OEhMa0hoL1hIbmkrRmZyT0lKT2VVV3NzNEJJTnh5NVZJRUgwTUxRS2F2YzhtQ0hvVW00OWNFdENaMmxcclxuICB0TUYrSTFva1o2V2loQU9KblFWK0s3cDZVRkYyOEYzNTNNUXd0ZlM2THFZYVdjN0ZkY2VoVW02Skt2aEFXN2xpc0doUHczTjA5OTEzXHJcbiAgeXpNNmpjMU50R1hUWnBycGU3WGtHUU5MNlBqM2FTQ3J3bG9EQ0FvTUNPTjNva1hwbk00ME94RTRtZUJnMUg3bzZFUHFCQzI1YjdFd1xyXG4gIDcxbzQ0cnlzU3k2MGVzNndrN21SS2EzV2g0OXA2MFJnRGdITDk2TTdxTWlaNkRibFQzejJyL2czOGsxSWZUMjN4a0wzbGJNMndrczBcclxuICBXcUxad1pQVWlNVTVJVEFWeXRka1hYSUFIRW5yNnZBaUxEZ1JUSExBTlBIc3UwaFNucDFRNFpQc3RxUGxFSXJFcURLTndHeWpKT2hTXHJcbiAgbkJrK3BVN2tpamZ6elVmUkV2WU1GbVlkQ0hERHpmK2VQbCt3Z3UvSC8vbHVldkw1ZnRxeHRwMmEyanZvMTM3enJ5OXBVQjBQR0o2L1xyXG4gIGNKSDJQL2xoazd4d3dHV2QrNjJ4b0w2NWk1cjRaQThydHlKUmZQRXhiYXlyTW5BSGlaYkdETjlWems4TlF5QnlhSjNqc0NTeXI3Yk5cclxuICBONlJQdXpzdzZTc3ZnUWdNU3NnMmJBS2lNaVo1Rk5tQzEyK0VpQk15OEFsbHpJMWJhbVdtRlp3SDNpQUk5UFQweUVPQ3p3MTNSR2xpXHJcbiAgcVBPSUhZZE1wNTNBNjJXRDh4Zy9yek91d0VDUDR4dlBUQnZ2UHlpRDV1NDNTeDRZNXlBNHNvdHkrTnZibTZtbVl3YzE4TDVrak1NS1xyXG4gIDVCMUF3WC9xanh0MFFnWmVLY2hCcGZKcGVRQnhobHRPK3NCVWNCcVl3c3FWQjl1aEM5T3Y4aXpKMGNJd0o4SVZwK3RPd3JtR08zWGNcclxuICAyZU81Qy94MjFlaytvVk9iVTk0NWVDZGgrVHFnc3E1cjdwUVhYVTN6WFdOenoyYStNYXJsZWpoMFkyMnNPMDZQUFBJSTRRMlFlRllIXHJcbiAgS3lMUGJ5NTRIYkRQTnIxOHBnYjEzVFNjQWR2Z2JGL2k2MmNqMzZWeWE4TWNSM012bHk5SnBneCtBOUwzN25nMURSNTVVSDVuN0ZqUVxyXG4gIDc5NjcvUmJSOVhBYzByR1Q1R09HRm9wMmUybjNTcysybTJSMWdYcHBFWEZMQm1NbkJkMVpRM3dYWGRZeXFlLy9OQjA1Y29RcC9CYWlcclxuICBMYmQrZzhSWkp3TklLMFVwM1hJMGRmb3BvVnU0WlNWeU04RTUydER1VmtGZ1pOSXFsTVlOa0s5ellyVXhPTithdTZLWm1vTEVzQnhzXHJcbiAgRml5clRCUGJHVGwwL0JGWi9SaEhxZmZLTzlraDZoVGZiSTVkTlhrSEF0eDR5N3ZvMFpJVmZPRklmdVYvZm9nMnJGMUZXN2F0bzU5L1xyXG4gIC8vZWJwbnJVTkx5S2Z1czNmcFIrOEFlKzBTUXZETENzLzg4WVhRaVpJVkZYTHc4VGFoOHluclRGSDJxdXdGMUlmTUhnTGczUGNlQkNcclxuICB3VU5TZUQrNUE2emRlSWRMZ2xWMDI3ZTlXcm9wQWt3clVWejFNK1daU0dwMktZSnRuSU9TeGJhcE5PS0VESHhDUldab01adzZkVW9XXHJcbiAgUmtURjA5dmJTL3YyN2FOREk1MnhtUWN1N0ZrK1Z2R0RZM0pSdGFLQzEybTJjMmgxOERIRURCWmtNdDcvbkR5Rmo5bFdBQ3FPcFlWWlxyXG4gIFdaWWJCd0pPQXdQcHJiMWJKWSsrcGdrNmYzNUE5ci9JZDc4OXU3NU11cjV3ekhCY2F2Q3Y0SCtVZ3dnaFFpMUhxbFUrQkpHYlh0TnBcclxuICBBSStubC9FQUtHSDl0TzUxTXJDS1ZXQnhDYUZ5ZzFQQVlvOTQ1emJzRy9rT1h2TER6QjZPc1pROEJraGJ1WUpGdHgyY0loeUJ2RGU5XHJcbiAgYzYyMHJPYW54aVNOTE5USXh3OXZtc1JEYVloeGpCQmptaTY2UzdFWUh0WkpteG51Rnh1VUczcDBlNERIY1VTTTZidVNoNFJ1R2ozK1xyXG4gIEVJMk5qVWxsaUFjOU1mMTVySUVyZk42dnZGQWRjUktpWThqQjU5WFdyWEZMTjR0NTM1eTM3aE84SGt0Y0ovaE5zSU56d3pIdjNIaWxcclxuICB4SGo2SDkxU3NCdUNNMkZlSEFVN0h4d1h5S2U0SllIamlMRWt5T0JzSUI5bTV3RkhzOERIRVRQMkppNGUwWllxL3liTlUrK2E4YUlwXHJcbiAgZEJWaVFCOEQ4b2hGQ1hBTTh2aFQ5MHBMR3I4UnN3ZnJlbmFvVGt6ME53dURVZ3RyT216NTI4RC9YUVBmN0V5Y2ZwcW11ZVdML3hKeVxyXG4gIHRKN1IycGpGUzdIa2hxYUdmd2Q0VENuSE5jRzg2Sm52NU5aSS93RnBPY3Uxd2VreE5vSVZLL0Q3Y0U2ak5lTFdaMU5vS1pZRm02RGNcclxuICBpaXJUeEhZVzRSeWZteDZWSHBmcGk4ZW94VjZoSGVlMnBXMlEvdTl2dm9kNk4rYlh4YnJ4K2l2b1AzN1RqOU8zdkNmL3p2MmRlN2JUXHJcbiAgOWsxOU5EVzNRSC8yRi85Q0k0TVg2ZlZ2aU40Q1dRVzJiZDFBMy8xOVAwOC8rc1B2a2FYNFh5amcyT1hjYmxZQTU0R2wwdUVRNENUd1xyXG4gIDUwdWxqOEYxUGluUm5ZRFhqZUl1MFUwM2pNR25uOTIvaEwrbmh2Tm8yNFQxbWVKRGJMUkVlaUlxbUlyTmpOR2tpWUlSYk9NY2xDeTJcclxuICBUYVVSSjJUZ0U4cVlxOWN1VUgvL0dSbGt4TnBXcUhUV3IxOHZMNEo2OW1MY1IrdUFPMjIrRStiZmo0ZmJBRjI1ZG9hYU83VnBqNnhoXHJcbiAgSTNlZnpNQ3hBTzc1RFRnZi9CZTZJS0lXQkJVUXhrYjhFK0o4Y0hxbTk5UEJadzhTMzhBSlh2ZTYyK2p3cE43WlM2V25oSDAxbi9CL1xyXG4gIHFCeThTb3hYSVlzMWxqdGNQM2lJQjBMNS9LaTM5YkRNQnF1Ym9tOFlUZ1JkT0hpZGJkdnFuZExYajN3VzVtYWxDMk9hVzZ6bzVuRXRcclxuICBESFEvNGE0Y3p4SGdnVWx4cEFiOFhsU21RNGMvSjJzVTRjNGRmQ2cvb0xUOEFpK085VEZVM3YvQTc4b0x2WEFqZ0JkNnJYOXROUHVsXHJcbiAgS0dseXNlUXVKUVlTbWJ6TTF0OTlBMHR5RXdBMVdpcERoeityYXpCNUc5YnpNUUdMNncwM0lHNHA5Y0dqRDRyam1NU3hrR01JVzIyZFxyXG4gIFNGY2d0LzcwK2FIZFNYNWo1dzdKYkNycDZtSTUwcUQzNElxTnpmSkNMUUZlcUhYTDEyTTNTVnFOTk02MVNpSTdKOFpyWkR1a05XSUNcclxuICB5UGhHbzNQRGxXb2pVSGtBbUVUZzJXbStRWEF6emlhNDRsN2tjeWtNc01mSXBDK0JMM0tWOW9rZGsyNTJWajNYajcxWHViWEN6R2J3XHJcbiAgQ2ZyMEIzK1NkdDZpZytOWjNIUHZRL1NwVHoxU2NjYlZwKy81TEgzWm5UOUEvKzBudnBWZWQvTStQMXVyR3J6K2ptL25lNkJGdXVldVxyXG4gIFB6SEo1Y08zUUNvZHJxWEZPVmtTWW5HT0hRVGY4UzZ3czhCZElrNDZCTnpwU0IveFV1Z0tjRUNydzFWVlB1YTdzcmFOZUxxVzkrNHZcclxuICBTaU1raXF2KzJBWlFSdXVKUk1FSXRtWWxXMEZTc1RpZ0lqUlNFTnY3alNDaElyUHg4NGZaY1Z5VWwwR2gyd012aE1LQStUTzJISHNLXHJcbiAgN2RkSGY3WWJLRVhMQlhmRnJrc0tyWTZwNFZQNmREbnZSMXNkVzlsZTU1cWpsUUVucmE4cERhME9WTWd5SHgxbDR4ODF3WGRvRzFhMVxyXG4gIDBObXplS1d0SktXK3ZoNmFxTVVkSFA0Si9BNTFCRnJCV29qbEZzVGVZbTJCMU5MSXlTZUVSL2NidXFmZ0pHQXJkN3F3NTd0MTExcXBcclxuICBiK21RcmpyY2FMVDJicFFwdFZoTEM1VVpHMHNlYUluQVNlRDRvQlV5UFFJSHNWbENQUjhmMTZyQVhidzRENnlaeEhtRHh6NGEyclNWXHJcbiAgNGNxc2dYbHI0V2hRT3JGaGZaeXUvNWw3Sk1aLzJkTFNRdTFiYi9HNjVZUGx4V2U2cDcwOHNzTW41cDJlUHlpamF3MkJkNy9QdFZiMFxyXG4gIEdSUnVvZlJ0a2hZYnpoMDRXcnl2QlRjaTBoSnI3V1Q3TStKWWNPZU8xa2tEL3djWWY4QjVoV09NbHRmUXNVZmxlTFJ4Q3haT2hrbkpcclxuICBHK2t3ZGZqNGsvZElkeXlPUlhOekM3V3R2MXBzWUlZeUNZR05Da3JseXZHSFNiUkFoRFladnRvSzF4YUgzZ0JoclRVK3I5a2hPQjdqXHJcbiAgSCtocXhNMktqb1VzU2NzRFBOYnRRcXNjcmJHbURqNGZ1ZFdTZmQrNzdFaENaZmppVjJtZjJIR0VhZUpUNkxybkc2dDUvcythWmNhY1xyXG4gIDJneWMyay9mOTgxdksyeUJBTnUzYmFUNzdudVlEaDQ4U2pmZGlNa0dlV3pkdnBuZStQcWI2T2QvNFE5b3c5Yk45T243SDZlcDBXSGFcclxuICB1YnQ4ZlMySDIyOTdGZjNvai8rR3BOL0crM29oZ1BxOVloZldwUUtIekhWWkFhaXk0Rjd3akVmTHVuMHNaNDFUQm9KSlBiazg3QVJVXHJcbiAgS0MzYlJBNHdING1TWERTQmtBRnNrWWpLN1JNcU1sdFgwMCtIanh5UzV6elE1ZEhVMUNScld6MC9yRTk4eDhEN3dqRzFVdThNRlRwUVxyXG4gIHZrZWRBK2NMNTRHV0NlNm9aTkI4RnQxWDRjbHkzSEhDY1dEV0RURE9sWVBycnBKeThRK2F1b2dwMHZQVXVtb2JkZFlNMGVuVC9mSTdcclxuICBFVmF2WGtXVGRYeTN4a3lvc0N3WUxYS3V4TFM3QnY5YWtLR2JhdUw4VWVtaVFtc0M0MXdOelIxU0dXa1gxWVIwVVVHbU01ODBIYVpzXHJcbiAgTnJHVFFQTWVEaEY1dHZSc2xtNGFkR3Voa3NQK3hHSEl1QVMzYktiWTl1d3pUTmRUdlhVTEJXY1J1b0ZDV2JXOFRpYmRCNTQzbWRHeFxyXG4gIHZjWWF0czQvSXYzOUdDeGVXRmlnVmF0V1VkUDY2eVZOcGNBYkM5aUhDNmFQanArWE9kNTB2UEhCeVdJYnlKMVRjZDEyMEEwZitSdzFcclxuICA4UFVrNXduZmxNRHhJdDBRdDBUd245VFVOc2hUM2NnRHprUFBQM1VtdzhjZTRkYkt6ZUlzZUFkeVF6aHkrbWx6SkRVMHlzNGFkL1E0XHJcbiAgRHNDR0RSdXB0c3VlRUdlOUZBc2Zqa0diZ0lPVVdQTEl5cFVML09UcC9kcUZCYWZDTWpnUzE2MkY4eGM4SEdaZGZaT2M0K29zTHNvMFxyXG4gIGJ6Z016S1REVFpOMFlmVWZsR3NFeSszQWVXRDFndHdEZmdMWnVaSmxRQkVSSExPY3ZjQnNPTUpxRUxpeFJLL0NJbC9IVFh4ZUE2dGJcclxuICBKK25IZnZ3Nytmb291cmxVWUNuMi8vbmJmMG05UFYybGxmeTJiZXY1aG5WQ1ZwbDQ3UzFYMEtOUEhhUDdQL000TzkxUjJyRkw2NHNpXHJcbiAgOVBWMTAram9CUDNYbi96TjVQbVR5d0YrZGFYR3h5VUJtY0o1T0RqbjBkQzVYcGI4OWllUndCTkM2dW5ua0xlVGJkZ1ltSTdZSkkrY1xyXG4gIExjQVdpYWpjUHFFaXN5MU5nN0syMWNqWXNQRHIxcTJoN2R1MzA1R3hhR0RRSU8rRlpyakJjaG5rbG9GeU5MVTFYN3hxMXV2NXBJdW5cclxuICA1bUw2Slo1N2NGMVllR05nZlhPblhDeHFnanMyblZuVmFHTXFPQWFyNXA2aEo1OThCcXR2QzNidjNrVmpIYllraHo4QTJMOGRNU2VUXHJcbiAgcThjZFJhNThlUDhZOEVhWm9NS2dPT1R1Nlc1VUZxaWdNSnRJS3FyaHM5VERsUk9nUEtiVmJtU0hvWVBibUVHbVhYU2J4R2tnejZuQlxyXG4gIDAxSkJOTFQxaUtOQjM3YnNIMG9IVDJmS0t6QmFaRUd1RkcrRGlKRXdIZzNIUDB6NzkrOFhCNEs3YnJRazU3YmpuUmZMZ0srZzRoeUJcclxuICA2UElTMHM5Vk1qRG5CYkd0c3pOWjZGc3AxV0ZNQkYxNVBUdXhpQjdMK0R0NDVMUFV1K05XbXBTdUxQNi94RlFINURFMUdEVEdROUNxXHJcbiAgQlQ5NEZJUHZtTVZGZE94VHZ5ODNSaktaNE5hdnB1bmFicDllSTJ3NUZNazhiUnBWQ3AvSUdiSUtyMVd5WXNQZmFSa2JXUzBXdUhIQlxyXG4gIGFzWnVTUlE0R1ozK3V5Uk9KQjc3a0FGMWpMTndRb3dONFpwS3gwYXkwREpVZ2hXWHNieXRnbjhaSitwLzhxTlV0NFF1MlUxMHpkVzdcclxuICA2SFczN2FaZi9vVWZOSnZLZVAwZDMwTDMzZjJueGhYampXLzZidnFabi81MmVUN2tNL2M5U0ovNm5ENlllZU5WZUJBeG5Yb2VvN1hqXHJcbiAgRnZxeEgzMFAvZXo3dnM4a2x3NmM5OVVlbGFxQVNnekJ3VGtQUENDSUlCZGE0WVd2bTZCaHlqTkttSW5iR0ppTzJEZ0hKV05iQUJXZVxyXG4gIGtZSnkrNFF5NXFiTjlYVDgrSEdacG91WFFUVnlxNk96czEzV3RqbzA0cVloQjhCUnlJTjdsaDZ0RHZEcUxIUVdGbFRnNFZnd0VLY1BcclxuICBpbWtDM0ZWcGQ1VUNnOHNkZUR1Z3F5ajVpNHVvbG5uWHJTVXBtVzhiZVlTZDNGRnFhS2lodWJrbDJyS0ZXdzNyM0RMUlNPdU9sdVlqXHJcbiAgZVVZeTNNWGhEaFV0SGtpSFQzeWVXMGMySUQ0MUxFOE9DODkzdjFobFZRYjhXWWUwY2djS3l1TGdOTmlSOUtEN0NUS2JtWVNCWWJRdVxyXG4gIE5JSFlpNEVLTW5JZzZQeFc5TXFIbUJHbFV5cldXUXl3M1lYUC9DOFp4d0pRYWQ1NDQ0MDB1dTdMaFMrR08xWU8wYVdVWEZXdXFqU0VcclxuICBHb2tScDRudG1CS21TSi9SRmNpSERqOUE3Vnpob2lVaVlCdm5UTnhzcVpGVFQxS1hqVWRBaGlWV2NMZVA5SHVhajlMSFB2WXgwV0V0XHJcbiAgdFQydmVSZE5MTFZLUGdLT3NjWVhXb2dxQy92V3lHU2VObzBxaFUva2pNbFRUMUZyTkQ0eXlpMFVqT3ZwOWVDU3FpMjZOTkYxMjdIaFxyXG4gIEN1MEs1UlpaKzVxZG9wc1p0Y0YyQnE2cG1WR3N2RkEwTGhMRHlsUUdWZ2VMWld3Ri9LdVdGcW4vaVg4aVRCSHE3RnRGdi9UVDMwcmZcclxuICAvcjNmck9vcWdHZEVsaHV2cUdtNGtaYm1IaldPNko2UGY1bys5OWdob1crNlpqdTk1ZTF2RURyR2ZmYzlRbTk0ODdmUzBJWFBVSGUzXHJcbiAgblIrWGlCZTBDeXQySHJpd0NwMEh0djZxTTBLaStHS01iUUJsdEM2SUZhbGRjam5uYkFGVWJFWUtLdHNyeDl0SVBOYi92THpQWTJKeVxyXG4gIGdocjRUblYyYnBidXVPT045UFM1ZkxOMGRuS1lIUVBHQkpTWDVqZFhsT2ltUWtIZ1BOQzFBeDRYUVIwM3ZmMEFNdC9sWTBEYU9ZOFpcclxuICA4TndrbHZjbHlJL1FWc2NNMzNXMmNITWZUWHI4ZnUwNlVQMDI5bEhIajUva3loQnZkdFF4a0lWV3pOZ0szU21neFY1a0twL21DeEI5XHJcbiAgdUMzZDJwVTJ3YzF4T0EyMEl0QnRoU0N6YVZET1VUeTdnWFc0MnVTaW5tQUhoN3dhdWVKQ1MwUzZwempQMXI3UVpZV3hESlZ0a2JFTVxyXG4gIG5abkU1YkJ1TXltYmpFMmdqQms1WXVaZFdSSElaZ2w1UGVLTWpkZ3hIN3F2c0s3WWNYSFlzRU1yYStESXc5THlBT1RPZTl1ZE10RmhcclxuICBjcER0cGtZMHNLTkVqTEcveGRsSnVVSHdPZzRZQTVwQXZrenJUS0ZGYW16dDlXWFFZT1dTLzB0cDN1aHZFRm1RNjNoS0tIUFFLMTBtXHJcbiAgYitaakxaTVUrRFBNamdQSEdkMkR6bmJvNk9lazFhRXlrdWRPTUphQU1Tb0lubnY0by9JdUZPZHNacGNhNWR5VTFOZ25Zbm1TSHd0RlxyXG4gIHNoTVJHY1RRUzVhUlRHbU52REtWODZlQlc4OXdHcmhod1NRZHpMN0M4Y1NDbEdpZHdrNldQK0UwT3Q2aE4weG9HWXVkakgyMGNXaVZcclxuICBZNDl1Vkp4YmFJR29ManN1RWtNS1ZRNFUxNXNzWXl2QWNjRE12MjZhNEJ1bjJhbEp1bnJQSnJyanJkVy81d05qSW4vMjV4K3ArSWJCXHJcbiAgMTl4MkhYM0hkLzBNZmN0N3ZrcjQ3VHUzMHV0ZWV6MmZueFAwMEJPSDZUT2ZlNUlPUHZZazdkMnpoUnFiZGR4MTI3WU43RVErVDMvelxyXG4gIG9ZOFd6dnBhQ1Y0UUI0TER5WmRtNGp3UVl1Y0J5S25pajcwUkV1bEpwSWh0QUdYMHowc1VqR0FiNTZCazNqYWNBRUJsZStWNEc0bTNcclxuICBObU5NNGJSL0VSUXFoNnV1dm9LZUg5YlZWeDF3MGFIeWJPNktwK2dPV2xNYWVYS0xnTytNNER3QW1SbXpicStPaGJBZXJReDV1SW9kXHJcbiAgQzNZUEhvT2ZlZ0hnS0xQekdlMlhhYXE0aVBEYjViZTVIOGd4THRUQnVTNmFIem9vL2Rpb0YxdGFtcWkyYTZmb3BES1ZkQnhRV1hQRlxyXG4gIGloWUhaa0UxZDY0U0o0RVdROXZxWFZ4eGJCQUhodjUzM05IQ3VVaGZQQWRVS2pnT0FDcmJWdjZ2WllJRk81UGdOSFFBSEdVUFRxUEhcclxuICBLbk9yS0JPSHdjSG8yQkU0Kzd6TzlOQ0pqY3JoSUZBbXFTeTVqSEVsai8waHhvdVEwRmQ5WmNkWjZaSUUwSVdGMXdzM3I3MUs3RG0zXHJcbiAgOExIOVlWL3l1MlcvM05wYnMwTWNQTjRWcjc4RGc5RWQvTDl0azMyNU1rNWVQT2JMNEJ4TjZtRFVEaDhtZkpDUDEra3hRQmxVYm9FL1xyXG4gIEtnZGx0aHlhK2FaRlplcE1RSGRzdUZxN0Q4ME9FeUY2dHI5YTN5M0RMZVNoWXcvcHk3UVlmWDE5MUwzM1RobysvZ2lmRTVnRUVoeEpcclxuICBUWTA2RDkyLzVzV0NTR1psQWtRbEVyVXpzZWpseTJWbEp3TG5NY1BIQ1E5clFxb0Q1ODlJbHkzMGNCTG94cFZ6aUtHRDc1QzN5a1FDXHJcbiAgblpTeW1tOE9SbWhxNElUUVNJTWJybnFiakZJTUtabVNKUWpGWHQ0V2tHNVpkaUs0bGg1OGNEL3R2V0lIWFhWVnZMSjJPVEFHZ2tGMVxyXG4gIHJOYTdaMC94SVBuT25adm9uei82R1hyMjJlY1RSN045NXhaMUpIeWorK0RUSitpSnA0L1FoVk1uYWV1bXRUSUc4N2EzdmtaZWdYdTVcclxuICBBK280QXRXMHgwcUJEUGgwOW9mU0hkYXFuQWRnSjVRSC9pRVBwVldVV0RHWU4xR1NRd1hiSUkzMFFrWThRem5lUnVKZEhhUHlEdlBoXHJcbiAgSVIzUGFHdHRvK1pXcnVEWHBjdDhWeHp2NEI4Q0hyUFkwQkxCeVk2N1Bua0lrSGVHN2lyYzhiZWppMHJTWXVIREFXNSt1NFVQdGRXQlxyXG4gIE53RzJiZERuQlFDOWFJV3lMemFRMVZCZC8zMnlFakM2c0ZwYkc2bjMybmVycGVueHhkMDNDUFNSWS9ZTFp1bDBiYnBPYkhESFhjTVhcclxuICB0TFJ3MkJiOTBmSVNKR2J3c0JwbW5hQ1BWNmZjbmhhSEFWN0FObkJJK2xZNlYrbUpRdkpXUkxLSUZwaE5UaDd4K0dDd0Y0UEZGdzdjXHJcbiAgUTZ2M3ZWRjVtOFVHR3Fhb2NQQ2FYNWMyWGpJY1dEM3djYjVZN3hNYVhUWnIxNjZscmx1K1Z5cFUyMWtwME1XaWRub3B1UzRYZ1loVVxyXG4gIFBuSGhLRHZ6V1psVWdMdDNIRXUwVVBWOUxycVlJT0F1eURaNUVOTnhITXZYZUdzWnBIS2xiU00zTWtxNERicFZqR1lDWFVCWVhxaDdcclxuICBoNzZxZFJEdnUyQnM3MTJreHg5NzFBK2c3N3pqKzJuNHhCUGlPT0Q0NEZ5UUR4NVVkT1hRZlZrUUVmYWxPcld4a2lkMmtDRVdCVFlpXHJcbiAgazRnL3N2NlhMSDJpd0ZnZ3VtdmRsRjhkLzFndCt3R041MFF3Tm9Mbmo5clhYK0hQTWVrNnRXVnlNQzdTSWRkYk5iQXlsY0NLeXFoc1xyXG4gIEI4eWMrRFFORGVxN2p2YnYvOGRTaDFBRWRHVjk2SU8vVHF0WDU4ZFhIYkRVeWVPUC9CKzY3cnJ5My9hSmY3bVBIbm55S0sxWjNVTTlcclxuICBiZlYwei8yUDA4ZnYraXdkZkVaZkZIWXB3QkZlL3RlWEFJbXp6Z05BaHFuendNWnBBYU01a3NyQlF3UUdKV1FiTmdhbUk5Ym5rYk1EXHJcbiAgMURaSU0zcGhzMXJlUm1iWGIxaVNOd2xpM0dOaGZrNFdKOXk4ZVROdDNMS1JuclhYZWdMb2R0SW5yWlZIaFlHN2RIRW0vUHZSMHNBaVxyXG4gIGdlRGhPRkNKdU1GeXRETGN1OGlSSExOS1FQdFdDd2RVN3BpQlZHZFBjQ05QM1JWdjVhdDJlcXhWdG1yNkNWa1JlR1pHSzRQTnQ2RVBcclxuICBWblZ3SE9qR2dETURzSzRQVnJiRmhZZCtaT1NqTTJUdzdJck9JTU5ZeHN6SUdibUR4ZXdYVEtsRk9mVnA1M1JjUS9QRnZyaGtLQk1DXHJcbiAgSUxHVjNXaUI2VVdqU2cwcTVpaklMeHk0bC9wMnZaWnFHM0FzY0dkL0ZBcWhBWFRmeUg5aHdNTjBiV3QyU2lVTmkxRHBjK3VCNmM0elxyXG4gIEg2SFBmUTR0bFNWNWNHN1RwazFVdCtQdFVyblBUZ3l4SXcxTDhYaHdlZEVGaE1GcmR4V3A4d2lYMUxnNUJjamFWcmw5R3U4Y0RlOFRcclxuICA1d3BTdGEzZVJpTllqUmNWSUo4ZktEY1VMc2ZnVkZSbzFiSVpPTnBKWVJETHdBc2pRVlZ3SkNma2Q0aU1QNE9QL2dXTkRBK3lIdU1jXHJcbiAgaTlJeWdhNlhZODFEMHc4ZGZWaDR0ejZYZm9NZVg1RmsrWWgyY1pKT1JCcWpkVGpWL3h5MVlkbDRBVnY2SjlPWGFJU2RCVm9mbU5LTVxyXG4gIEZNNnA0UHB5RHNYRDhzUkRoNDN0UFRvSlpWbFllY3JBNm1CUmJMdTlhNUsrN1owMzBFTlBIYVkvK3NPL280NzJWcTVMN2wvUkEzMzdcclxuICBydnBLT3NDT3B3ejMzZmNvL2RDUC9Cbzl4azZrR2pobjhoUC83VGZvci8vaWwranIvMFBCYWd0VjRKSzdzUEQzbFRxUDNxM3NQUFF1XHJcbiAgVk9XOGRRYU9rTWdxRVVIZXhremN4c0IweE1ZNUtKbTNEWkpZeHhBMnErVnRaSGJ6bGpvWldCMGRIcFlsMlhGM2lzb0ZTMXc4ZVQ2OFxyXG4gIGtReXRqSGlKRUZTNG1NN254enU0SllHN2MvQ2dNVVZSZEp4Zy9OeEJ2bVBhNTd1czREelE2dEJwaUxpTFg1SlZqQnM3VjF0L003TEVcclxuICBMeGNpb1YxUVdTMjF6SjJsL3Y3ejBpdUU2NmRyaXo2OE9YTHlTWGt0S1J3Y0hCLyt0M2F1ME5CVmhhZklzV3dJK3BCeDF3Y2JHYlFjXHJcbiAgT0NaM2IrajZ3QVdLYmk0NENYbW9WTHAwRnVRT0ZRUGlibHhEcHROaTU3Njd5bld0UU1iQjZMZzdDcmJlVHJwL2F1amlRVzRkc0J3T1xyXG4gIEdGMVQ2QnJDY1VRTENmdEV3SUJyUzlkYWFkbWhMT2lld2gwKzBydHVJK2hZSURyRUNPaEtYT2ovdlB6UHNBVjI3ZHBGZFJ1L2pQbGFcclxuICBxWWlrZ2pON0Y5RDExTkRjcnZ2bi9laDRGM1Q0WFRnZVdPNmN5NEpXbU53c2FKY1o5dEcrZXBmRUNESjl0bThMSDg4SktaOXpIcXhWXHJcbiAgcDc3dFJobzU4VGhYMURlSVBickJrRDl1QUJwYiszdyt4VjFiVHFhMEhtZkhhOEMwWVBBaTQ4K1pwKzZpeGFWRktUOXVsT3I2OXNvaVxyXG4gIGozaFFFYytYNkd3Nk9FOXVmWFp2a2luQlV6WkZuWE9SL3dmZFM4TW5IcFZ6eTYxdEpzQnU4QUVySWhFSTZjb2xFQUZPa1hvWkc4SExcclxuICAwblRwR3kyeld5NGU1d0hHVEViUFBrUE5mSDJnaTBxZENEc1ZEamhXT0JjQjNJQkJqMmRGTVBWNWJtcVV6KzJDRlhRVFdFSEt3Q3BYXHJcbiAgNURLN2ljSGo5TDd2ZlR0OTgzdS9rYzZlRzZBSFB2czQvZE0vM2tQdmZhLzJCbFNEYTY3ZVRiLzBLMzlVK3E1MGpHdWM2eCtpVDMzcVxyXG4gIFlYcjk2OU5la1NMZ3VaSFh2ZlpWdExxbms3Nzl1MytHM25qN3EyamJEcjNoWHdrdXlZSGdNQ0doTzF3dTlzN0RGbmdEY0xKNEEwZElcclxuICBKQnBEYkFNb28zOU1yRWp0NGh5VWpHMEJPMUU5eXUyVjRtMWtjdFBtV25yZ2dRZjgrenltWjZhcHU2dWJycjMyV25yMERGK1lCdlNGXHJcbiAgUzkrcXBjVkpLM2ZmNExrQTRqQ3NTd3QzOE83RlFUQ0FvOEdkS0V4aEp6TkxvbmQxeVB2aCtjaGllcTRlUzJ3bDQwRGpSOG9QWlU0cVxyXG4gIGoxQnAxSTRmbzRzWDhRNTJyYS8zclcraWkyTkwxTDV1dDl6ZHpZNE55SVUveDNmWldPNEUzVlBJQTkxWXFCaGxhWkNaTVhGK21MYUxcclxuICB3VmJvd1RmeWhUbkpkOVM0R01WaDhFNjBra0tsenpzVHg2RzBWbGFPWnpxU0p6Wk1vd0tTQnhXWmJ1SXlhSVhVU2UxcmRtdjNGTGNrXHJcbiAgNEZ4UlBsU3didllOSEI1V0dIYmpJR2lCb0dzTkxUN1lvdkpFQmQyK2RwY3N3Q2pqT2pJZHVvOU9QZjdQL25rZXRFRHdQTTk0cTNZN1xyXG4gIFltcXg1SkVKbVBUQW1mS2VPU0JtV3pnTEdlZmcvY0JwUVE1SGpRa1ZXTmdRNmFTOCtOMnNRNHNFTTUvdzdJODRGODRMWlVXTGFwWjVcclxuICAzTjBqUDNRWFFRZDUyNXBkMHQyRVJSTnh6UENTTWRqSXFzWE02M0hVR1B1Umo4WGdWV2JIMjJUeTRYakwvQk4wNU1oUjV2Z3VuMy9aXHJcbiAgcmJmZEpzY0JUL3pEcG0vbmJZa2p3ZS9GYkt3dWJwSENrY3p4VFFXT0wyak9tSjNmVGVKSTZwcGErQnBwc2YzajN3SXBlMWVBY0R4c1xyXG4gIFZHQ3lHajVHalRSNTVtbkNXMHJ4MytNR0RBNFg1MFl6TzRwbWJuVTRlN1NHM1VPSmNHVDRUN0V2cE1NZ1BOTENCbU5XVXdNbjJZNWJcclxuICArYkxqU3Foc2dDS3JSZDd1L0luOTlQM2Y5R1o1Z0JBTzRNLy84aC9sWWNFekovdnBLNzlLbDNaZkRoaW5lUFRSL1JYSFE5N3craHZwXHJcbiAgdmQvN2kzVHJxNitpRFJ2QytHc2wzUExxYStudWV4NmtDd01qZE9XT0RkVFIyY0dPR3JWN2RjRFp2eUlnUVp5OU8xenFQTGF4ODdCVlxyXG4gIFF4bHlPdmpqbVI3WWhDdGc1QnpLcElrUm5YcG1sclZsaTBSVWJxOFVieU9URzlnSDN2dnBUOUxJNkFpZE8zK08vN2h4NnV6b2xKYkhcclxuICBJNmVESVFhVWEycjRpSWdJem1KUSs5cU5sMjRycmpRQTBHN1ZXSXgxSUxpN05yUTZBRjFwRkpJYW11Zy93SlhGYm4yMlE4NVF2WmdrXHJcbiAgam1qWW9qS1NDdHJzbE9lNzZ5WnRKZFhXMTB0b2E4TkZUTkkxZ1lzSSs0ZXp3RE1jZUZJYzgrMWRYcGdJME5LbnoycWczeHZQYy9UdVxyXG4gIGVvM01zeC9tU2dTT280MHJSNnpGbFRnTnBBY2Z5WENNUEMvSFMybTUweFlaVjQ3c1BGRWhvSUpkYytXYlpLWU5CcHJoTU9SZEtKYkhcclxuICA1TVhqWWovQkZTY2NHZEpQc1IxMFdLWURQR0pNVzhVYk5lRlVkTi9ZTHg5WHJyVGx3VVQrelpNWGo0aCtkRlJmWnd0Z0VQMWMzenNrXHJcbiAgbjZvQzh1YUFmS2FHVGdyTk5TdnJhcWlEeTRIdUtYUVR0WEhGS3N1STRIZHdPc2hCNHdiaS9ET2Y1RllmTzBtMjRSOHJ2NitocFVlY1xyXG4gIGc5dlA4T2tuSlk4TEIrNm1OVmU5UlJ6MndLSDd4YUZncVNIWW9LV0dHT25kZnZ4dmx6Z0VzWEV5bEpsamVYTW0wM1U0WHpqL1J3K1BcclxuICBpYVB0MjMyNy9QZURSODJSN0lJamVZaWR3K2U1TmJWVHhzTndYa25yaWZQQllvOTRGZ2l2Q1lielEwc0orY3RaaS9OVDlvZVllWEg0XHJcbiAgeG5Qd05naklWT2hhYXR0NHJaeDdVK2Qxc2dPNlY5RXlRbXNZZHJER3VCTHNzYVlZV280SUtBOWFKUUM2dE9CczBScEJGeFp1MXR6N1xyXG4gIDF5V0RpckR5bEFIRmRFUmtOOGMzSmpFKy9pKy9MMlBFZi95bi8wQy84OXQvcWNJcWdDVk9mdjAzS2o4YjhyOC84QlAwbm05N24zSFZcclxuICA0UU8vL1ZQMHUvLzdRN1JtODBaNitLR242SkVIcTMrWE92OXIxUUdIQThaeEFuZUlndlBRQjh1QWNQZ3lFRVdzemRQeE5vQjVFK21wXHJcbiAgWWhBeWJ5dm5ua2U1dlZLSnNlRFFvVU0wTlRGSExXME5mSTd6WFdGam96aVBReE02OHdOQXQ1VXNiR2g1d2tIZ0RoTThIQWxhRkIxclxyXG4gICtlNlRZd1FkTE5mQlVqd1VxT01kTmI3TENuZE1BUHJjSi9xZnBmYjFWM0ZlbkpuOUdIZFJ5ZTkzY3ZBaXd3V0lmOGZ4MFBHRjNOUERcclxuICBGUUZYQ0hWOEY4ZmhVL2ZmTHhVbjd1amdPRFFQdERqUTFiQko3dHF4R0o4OEZjNTNtR2h4aU9QWStSckpFMDgvWTVaTDc2N2I1WW56XHJcbiAgdURKeXRGYlVxTHkwd2hlOVZCaGxGVnFkT0E3Y1hkZlUxWHNaN2d4eGx3aUhnVW9TNmNRR3Y0OHJXYlJJMEcyRlZnbjJqd29aTnFpa1xyXG4gIFVabTNjWXhGQXVYSllLbXN0VFdBYmpqY3ZXSS82NjU1Qi9XTlBlUVh3VVFYWlZkWGwveEhjVUQ1Y0xlTi9RSTRka0YvV0FKYW5WSTJcclxuICBEaGpvUlZuR01ZYkIrK25jZEIyZkMzdGxuNUNqZkpoTUFRZURCK2xRWmt5VnhqRWFPUFNBZEFQaWdVcndhQzJpQ1luSkNQSzcxMkltXHJcbiAgWFIxZGVQWXVXclh2RFZJaE9oa2VCcnh3RU11eDFMRXp1VmYyaHp4aVJ3RmRPUFlhVUViRW1HWG9WaWZHelVmdjd0ZkplZUgwZmZ5L1xyXG4gIGl5TTU4cUNjRDlvaWVVaTZrZkNNQ1J3Smdzc1hyVGROcThjRno1NmcxWWkwNEZtWjZLWDFLQTVGZVpFaEFCTFhVT3ZhZmV3UXNGeS9cclxuICB5dUZJeGkvZzJRZk00bG9yM1Z2UW82V0Jhd3F0RWJSUzNITHdlTW9kZ0xOSG1wd1RzZDJWbzRJQnExeHh3Vnl4ZHA1Mjd0aEU2L2JvXHJcbiAgeEJoZzU4N05kUFQ1ajhtTCszN29oMytaUHZPWngxUlJCZkJjQ0FiVnk0RHVxM2Q5M1Z2cGwzNzVqMHl5UEs2K2VoZDkyN2Q4RGYyN1xyXG4gIHIvbEJ1dTIxTjBwOVVTM3dVMUgvVndTTUVPSnMzVEVLM1ZaUlB5Y0RKMGhnalpCSU5JYThqWm00allIcGlQVTU1T3dBbkhSR0NwS0VcclxuICBiaU5JcU1pc2IvNjRyS3c3UHFFdnYrcnA3cUZycnJtR0RneUZLWURvZjI3dXhHd2t2c09ZNHJ1MDBYNitpTkhsb2M0RFFNdERXaUFkXHJcbiAgYTJYd0c1RCtXVDdKc2J2RmhRV3VlQTRsWFZZWW9LNnJhN0ozZGJCTXhQcWI5SmlxbmNwQU81bkdhcU42M0kxdGJ6bEhUejd4T0UzUFxyXG4gIExuQ0ZYMGNiVnErbDZWVzNTR1VJUjRJMzMrRnVFUmM3bmtqdWtuNzJPaGtJUjM1d0pIaEhPcnF4Y0xlSGZIVy9JSFcvY1RsMC8xRlFcclxuICBpYWNuQnJqaW5CNm5yczNYOFc4L0tnNmhsZS9BTWY0Q1I0Q3VNSFRod0I3ZFk2aWcwUUxCZEdJQTNUckRYR0dCYjJlbkFqM2VCSWN4XHJcbiAgZ3JYWHZFMHFrZzUyTEFCZVp3c25jKzdwZjJIZGw5T0VMUjJqa0ZKSmhCTHUvNUErSVR3M3QwRDc5dTJoNWh2L2svQXJSUmdnamhFSlxyXG4gIG1NVHkvRUQ3bWowMEJwcGwwakpoQW1XbXBTVnhSaGNPM0VWcnJuNmI4T2VlL2xkYWUvV2RmRDRkNW5RN0pFZFpmNHdkQ2h3a2JDQTdcclxuICB2LzhUMG5vRDhQd09CdUZYNzN1VE9CczRZZnlmc2tPMmR6RW94eC83NUcvUTlOUVVOZkFOMHhXdmV4ZE5ONkhGYlBaaWF6UW9qdUFNXHJcbiAgME9xb3JXOWdYdVZpWi9UUUVWMk1FVjFaMGtwaE9aNTB4K3JMc3VRNXpDMk5NUktIdkNMZWFBSHo0OXdpcStkclMyKzhkTllXYUl4OVxyXG4gIHpFNE95ZXdybWNYRnRtNXdmWlNkaWJSb01XN0hrS2ZhN1FsM2NUb2QwVXduMjFWbFZEQmkxYnJHYy9TbTExMUp2L0pMUDJUQ2dELzRcclxuICB3NytqNy82ZW42WEdobnE2ZU9FejhzNmVhb0NwdmZkeXFMVG80cDRyL2gzZC9Zbi9UWnMydWU3eXloZ2JtNkRPM2x2cGlVZi9UbDV1XHJcbiAgTlhoaGdIcFhhODlKSmVCMnF1SVlpRjcyeXpnUFRKRVRvV3EwRWhHUzRRa21yVElSeERhQU1sTFBKSXJVTHM1QnlieHRrRVE2SVlzMFxyXG4gIFRFVm1tSzZMMWdlY0IyWmJyZXBiUlR0MjdLREQ0K0VwY3d3b3U2Zkx4VmxndVlJK3ZqQ1p4NVBtdUVqUlBZVG5LblFnSGV0Q29XV2hcclxuICBBKzNZSFo0WG1Kc2Fra3BRQzRCblEvZ0U1bU5aMTh5T1N1N0NJT1pmTE1jTnZObzVtZkFTb2pzNDQzR2hvQ3ZvSXJlZXB5OGVvb1lXXHJcbiAgM05sekdXYm1xR1BIN2RMMWhvZjZjS2VNcmlyYzdhTDdETXZ3NC9mSnN4b3RYZExpNk5oMGpkelp1YnRLM1ovYlo4d3pqVHQwZEV0RVxyXG4gIHNrbSswME5MQUhibzdzQktyNHRjZ2NodjV6eHdCNDA3WXBRWFkwbTRTMGIzbU01bzB5NG5KdmpZclpMV1VHUGJLdG1Iam1mczVuSjJcclxuICB5bDM2K2FjL3huZkJ0MGtsN0dhd29ZeHdHbWhGWXFhT2xFbnV2a01aMXc5K2hBNGV4REx6dkJ2Rzl1M2JhSEhWalZMZTh1Q09kUnBjXHJcbiAgbnU3L2tJK1hhVURYQ2NySGpKUUpnN3F3bldEbndMbElLK244TTU5Z3AvZDJsZlB2aDFPZDQvT25BNjBSdmhyUDcvKzRkTWZnUDJ4cVxyXG4gIDd4Vm5MT004bkFIT1RUaG10SkpXNzMyajVJRnVNanpIZ1VVM01kYUNWWDdodUpHWEsyZkw2WS9LcXRMSUJDM3V0dDF2dGZLalZQYjdcclxuICBJbjZlajcrc3RXVVBFc1k2bDZkN1dkWXNYd3NvdTd3QWkzV1l5b3hYMjQ2Y2ZGeFdMMEFxeUFYWWxjV09BYWw1RzVodXhBS2s4N044XHJcbiAgbzhIL2Q4YzZhWEhvdUlpT1FXSmNSRlorNEJzNVBDTUNKNFRuU0REZWgwRjVHVXRCQzBYR1JUQUEzOHJuNW9EWTZqNHNWRVFGQTFiTlxyXG4gIGNGbmUrZGJyNllaYjNQdFdBbTY4NFVwNi9JbUQ5T3l6aCtuakg3dWZ2dk83M21XYXluRFBoMkRQWmM5d1hIdk5idnBQLy9uWDZGdmVcclxuICA4NVVtcVl5bXBrYmF1R0VOL2Vxdi9ZazhYTmpDenV6aXVRdlUybDdwdVJtY1BSV0FBc0lnTm5LME9JK2VMUVhPdzVNcFdGWWtWbGphXHJcbiAgMHNRS25KQWVKYlpCVXA1UEFOdEVacnU3UnVqUTRlZDh5d04xNGVZdEcrbjROS2JTS2pEckIzM1ZTT2RhR3Jxc3V2S29ySkFsdXF4a1xyXG4gIFRSNHcvTU93aUdEY1pRWElRRHZBZWp6ZklSZUUyWU53RjZGY09Jbk1LakNPcFZMaWoxUnF6S1BWZ1NkM3U3alNSOTgxTGs3NG9vV0ZcclxuICBSWnFmbXFlcHFVbTVHOE1BS05MaXJrc1hLY1NZeHhseGZuallENDREZDdlOXUxNnIrMEQraUszckkrMFNNWjd0YzEwa0hHTXE3T29yXHJcbiAgM3l3T0FuejNsaHUwNjRrdkxyUVFjR2V0emlTa2wrNHhwbm5EZDlSM2lqTkRSU3JkUU9hZzJybWlIYi9JbGE3dGE5MjFYeUV4M2xBblxyXG4gIFpjSCtKU0JmRjR5WG9Ib3NTZ2NzTG1MZHAxcHFibTRPdHFYQjVlZUN5ZU45SnZ2Rk1kSGpraDRyWjZ2bGJzZmI5WmlXMzhKNnZBTWRcclxuICAvNi9ZWVprUnRrV3JBbzRUVGdDVk1ycm53TVBwb0ZXRC9OSGFXSnlia1R3V1ppYnBQTVpOK0RqaU5ieVl5WWIvQTEyRHJneElnM1hBXHJcbiAgWm1kbTdNRlRqT0dnblBvZmFEbk4xbUxNS3NPU0tjTmNEaWQzT3JSTTBMVUZHdE45OFJaRTZPRFVjQTVqZ3NIb3FhZWt5dzFMc2tzNlxyXG4gICtaMTZualBCVytRVmVKRWhscHNyRGZWY2hvNk4xOUljeGtHWTEzR1JhMlF4U0JaSUY3S09mM0JhL2kydUpZSXhOY3d3QlBUWkVUemhcclxuICB6aFVwWDh0d0lzSTRSR1F4eWcwd3B2U0dtMTJyTjQ5LytQdmZvcXV1MlVPUFBuNkFmdVNIL3J0Smx3ZGFIei8rRS8vRHVEelFsWFhqXHJcbiAgalZmUlAzejRreVpaSHQvNUhWOUhoNCtjRk9jRXJGcXJYZXFWZ0Y5ZTJBYURnaytINU5DQWg3RTZqODNVMkkyK1VXaUNGZjcyd0JwaFxyXG4gIE5yRlZZSlF3RTdjeE1HMXNuRnJKMkE3QXlXV2tvTnhlS2Q1R0p0M05pelI0N0JFYUdzSnNKTG1lNUgwUXQ5MTJHejErUnVkcm93VWhcclxuICBMUThHM3NtQWFiZU5mUGNJd0huZ1RnZmwxT2RCdEhzTEErVWdjS2VKR08rOEVNY0NKUU9EZVhnd01JeDNRSXJmb3Zwd0FZa1VBdVBCXHJcbiAgQlI1MmVOaXJlK3Yxc3YvRzFtN3BsOFlGTy9UMFAvTHZxWlUrMThXNVJYcjdsOTlKbjNsK25HMXY0b3NYcjBLdFpjZmhYbEtrWFZjNlxyXG4gIGk4eVZJOFFpaS9hckpEYW9QRlNIaTdldW9WVmFYbGhTQW5lL3VQTUY0bnhNSUdrY0RkMzRoY00weWEwSVRDQkF4VGgrL25tcXJXOFdcclxuICB4NGFUVC9lSElJbXdrZGhuNldSZTcyeUFZS2ZnRnRDRHYwSUhEanduOG9hR2VucnRhMTlMdzV0Zm1EZTM2Y1dWdmNTWTl5S3prTWdKXHJcbiAgbmQ1MEdWNVhOT2J6RXdQdUxEcjMxRWZaQ2I5TldsN29uc0ZkTjdxdjFsNTFKMXRwOXcvR2FPUzVFNlpkZnVqV3dnekMxVmZjSWZKblxyXG4gIFB2dytQZ1pjS2RmWFM2dTdkcys3ekJiNzFYd2tJV0tmajhvR243OWZWRDI3WGtNRGh6N0RNcEl4RVgxNzRzM2VEbmxndFdBOGI2VC9cclxuICBpK2FCbXhkME9lazdTY1JTNUU2dlBMTmVqZ2h4a0dNaFJiUkNuQjRPQWkwTDZER1doZ2RpVmE0TE5RSm9xWGR1dUVLeThHKzFaRWE3XHJcbiAgczF3WGp1WW5pTWhpQklOTmpSZm9vUWNmcEVPZitRRHR2RVVmMWl4RFo4K3JhWEo4a3Y3MmIzNkR2dWFkYnpGcFpUejk5UFAwUDM3clxyXG4gIEwraVAvdUQ5SnNsanBlOVN4NHlzbi82Wi8wWDMzL2NYSnFrTStJUUU3bktyNkR6WWNZanp5RUF1WEo4b1R1MHZhVVpzb3hBMmJBeDVcclxuICBPMEhPRHNoWENoNFplNlY0RzVrQU14ZWZvOEZCZFI0QWxyTEFzd0I1NThFVkhGZG9hRTBFNTZFcjZlSlg0dW54TXVlQmRhRmszQVJLXHJcbiAgcytWN3ozU3duSU9yWk9NNHREcGlYZ011Q0l6SjRPSkQ2d05QaDljMXRZdnpRUGNCN25ibnVRVkM4M2lmUWgzMW56c3ZNMlAwcFV4YlxyXG4gIHVHTGVMTFE4U2Q2M1ZZTGNKZU91MEFMMkU5K3RpbHhpM0ZYWHl5RHp4UVAzaWgyNkF0RGF3TVVJeDRIdUZBbmM0c0JzSXp4am9PbjFcclxuICB6aHRwTUtpTWJobmNYZU91Y2RYZU82VFNRMFhZc1hhZnpQZVhPL1U2Qzdadm40OHZyOUhDbzl2T2JFU3VPdDVZNExKelBEazV5WG8rXHJcbiAgdEF4TU9oalorczFtdTF5dy9jaSttRWQrTEU5YkdnaXEwM0tZcmVsY0dZSmRyRGVkNHkwUGpKbGhRZ1pvSEtOMTE3NkRCcmtWZ05idlxyXG4gIHhMbERNa2xBeGxRNERhYU40NWlqcFhmK21idDhmbkFlV0daanpaVnZrYW5qVGNjL0xKTUlaRnJ1d2p6VjdmdDZMVC9zT2RaMElYZ2RcclxuICBhQTRZYk8vZDgxcW1NVVByZGc2dm9lR1RqMVB2emxlelNNOXJCSnlUVEhBU04xbUN5OGczUEZNc2w5V0JKVCtjMzNxZXcxWjUyQVllXHJcbiAgY1p3dkFsNXJPM2I2YWE5SGF3UUxLWUxISzdreEl3dUFrNUUxMmhqb3doMDk4eXh5bGZOVldpdk1wQzBSQkVORUZpTVk5UGYzeXdENlxyXG4gIGhpdjQrbDRHOTk3MUo0UkhmZC85N2gvbWVraGJ4TXZoNnF0MzA1Yk42M3lMQVZDbkduRDNKMzZmdnVxcnExc0JHTGpqamErV2xuaWNcclxuICBaeVh3R1JyR1FOeFBoekErVHZ5WHBzN0RuakJYSTdWVU1rNWxORWY0K3owS2JGU1VrVWRzbXQ1dkRHb2JKSkZPeUt5R3Q1RUowRE4zXHJcbiAgbUk0ZTFTZVozY0tEVzdkdW9RczFPbHNqZFI3NmZuSU1HZ0k0eWFTdkhUb2IvMEQrT21WM3ExU21FS0NsSVJVendEOFlzNnp3em5BTVxyXG4gIEFNc0JrSUN2MHU3aVNDK1NjTUU2SFJ3R25zL0FHbFhvc3NLekFMaElNYWFCQ3dKckZ6WC8vN1NkQjRBZlJmWDQzL1ZlVXU2U1hITHBcclxuICBDUWtKSllWQVF1Z2Q2U0lvcUlnb1Jab0ZVZXlDRmJFZ0FpcWdJb0tBZ05KN1NXZ0Jra0JJSWIyM0s3bTdsT3Z0L3o3djdYeS9leVhGXHJcbiAgL3cvZjNYNm43TXpzN083c2UvUEt2R25aS3ZYMVRYcXROQlBSNU9Ya3lxNk9mTW50NzVzenVkK3FZYWJBamlPR2NDMUhYbEU4NUVkNVxyXG4gIGlDWVE2ekh6UlJFT2tVQjgwdGJtbmwwaHJGbEZnNFM5VEVCaVdzbHQ5clUrSWlrc3ZvaXpCendpcWFDblNNM0l0RHdUKzRVK0liclNcclxuICBPRzFZWDB5VXhhSGxDYTJjbndNeDI3bEkzT1hsd3BGcTc0ZlpLUjRBNnRhOEpZMk5UWm92TW5qd1lHbk9HR2lUQXB1bGFpYUxFcG5kXHJcbiAgQjJ1NmNHQ0JCMmRFLzVraE16YVlOREEyR3FyWDZ6M3JNOGpJTVNKSXZ1M25rdGNuZXNkK0g2RS81TVg3cUkxRzU4TzU2TjZzYmxST1xyXG4gIHk1aUp1TVo1ZitTaFg4Rm9vTytvdzJUN3V2bUN0OXFnYTRLbzh4SFRGdThMcXlUTWh1RlcxODE3eXRZNjBUNG12QjE2eitpbWpHdXhcclxuICBhL2sxT2MvaDE0LzZFdjExTDVlajd6M0UrV05yWGpnZUpqcmtBcGlIRnlwQlpOd0M1TmV0dzd1c2NrSTZwcWxIdXdaRW96QWt1cWV6XHJcbiAgaWtxbGZ1TWl3MVVRU0YvN3NkVGVaWHBtdnQ0VEp0enVpSkhGaDRRVzEyZkJ1S1E4UklUUWRTTHVvTkhCTHVSQkZPMGQvR1NUZmdzM1xyXG4gIFh2OFptVFp6Nzl2UERocFVZczVaWDM3dFhYbnB4VGZsMG4zVWgrRC82dUpMdnBkd2l1alBPd2tqaHBmSm4rLzZqNFlEOTlubjFlaFJcclxuICA1WExWdFQrVHIxeis2U2huOTZDajFDRThFNGhISENqUUsvRXdpSGUybDdnRmV5NFQvKzBOYkFBRnNHaThyTWI5UDRMWU9ZdjJlcVlMXHJcbiAgRE1uY0xKczJiVENpb1JPd3lEWDdTS25MZEVzZUp4NVlacVFraUVkb3pKRk1JQjdMOUJ3SVVneloyQXpSQ2pyblljZ0kwQmZjcGdNVVxyXG4gIFY5ditZZWloSVMvZXlrZWhweDJKVUNaK0h1UURFa0JKaitrbnltUzRFTnVQUTRtSW0xMzZiTTk4VStYbXVSNmtxVjFhR2xxbHVhbEpcclxuICBFYzdRUFhJY2RrUjVkcjBRajBJemE5VnJtRjVEUTFlRXA5bks1SVp0YTZSRk9hTEtqMTZ5c2lpNUlSYVl0SkkyVGtQVFBFdG16NjdYXHJcbiAgb04xb3hoM0ZLWnVZaFpNWFhkdnpRenhONzQxMFZON3E2YUhuZHlxUllMdlduVnNSVHluUklOUnl2Q3RtbmhBUCt0N1k2SHYzTXdhS1xyXG4gIGlvcnRuTzFOSGwwVGk1MUNSY1RrK1RIQkRsYnJoMzZnRk1iaWg3cTJmNHMrOEk2MlJwM2RyN004cnNQQ1RUTTUxam9Rc0YxYlY5ZzZcclxuICBpWnFWYjF1L2FLY0xSMkwzazR4N2Z1dytOZC95b25nb0czUkJmWVpQVTJMeW5GMnZjdEh6Tmk0eEJhNVk4b0paYTJHMUJuZlNVTHZSXHJcbiAgdURBc3IvalNTMHBLakRNcDNmOTRNd25ldHZ6MTJMWDhHb24rUkVkOC9JUjhkRFFjeEd2UXFlbTFpNFljbUNpRDJFb2pVUnpkaU5aUlxyXG4gIDRzRzNBK2RNZnpYVHhqM1B6OHVTb3YxNE9qb2Y1ZVdYSDJoYnJacDRWdk13RHNITEw4WHora000ZmQ4TTNoZEV4T1BPaVFBUUV1T1VcclxuICB0RHpmTjkrWkpReENxQkNMOWdTZEpOYlh5MUZUSFkvc0MzejNPNWZLakJrSHkvd0Z5K1Q2NjIrSmN2Y09Eejd3Sy9tVWNpNjdnNmVlXHJcbiAgK0oxYzk2MWJvOVRlZ2YxRit2Y3IzaWN1aE9mOEk1NERoNzdXTGtBNkVJK000c0dTWmNRamVtb1dlSndYR0xKakVZM2FtUWg2bHJIZlxyXG4gIDVFOEVHbytTOGRvZWpaY0RHRGhSMUdEMzVUMm12N0VpaGRtZFVyRnVpYjNvb1Bjb0xWWDJOc2ZOK3R4VEt1cys5SVB2aFhnRXBiZ1RcclxuICBENVNmS1RiVHRNVnRXZ2V1Z3dWa2ljV0JlcDZ0Wm5Qd1oyUWQ5N3pFNENmT1h5d2RQc2FRSmc3WGdSV0pPVDlVZ3BHbHJMdHRXYXFEXHJcbiAgbmc4UHJpQ3YvekRqUXVBdWh2ZnBsUFViTjlsN0JGclpnN3hnY0EvQ2tVQUljUVRSRFZsQU9KalpZYzFDSE82RFdTeUxBTm1uSGVzdVxyXG4gIE9BMjNVdFBack03U1dYT1Nxak54T0JSN1pwclByTnl0WS9LamEvaTlPYUlLY1EwNUYrVnB4TXRwMmppT3FBem5jTE9QR1RJV1RCQUdcclxuICB4SU1naUcwclhwZisreDJwNTVlNVh5UXRHemdJMmt0YisyL2I5aGZnRXZtVHZtanZrSFVEMW41ME1BbEF6eFhxMGo2emYwZm85TVVQXHJcbiAgWnJzYVNSeW1vTVZvd3RwQnFldWlKeFp0N3RpSXptcUtyUWZCS2crT2FPc0hUOWg0NFI0UXRXaXJWcGUyckMvUitQRDhibm1VUzV6M1xyXG4gIDZ6Rm1Rd2d5NUR3VEhVeUF5WU5iN0ZQOXNxeGZ0ODdNeWpNeWxXdk1TRGVDQXBlQ0dBaXhLM29ONDBoS3NkelNheWV1MHkwZWhmeVpcclxuICBDM2tNTkVLY2lZM0dLY1BLZGx6bVFKaHBnVWtHczMzV3hXRGVpeTRPNHdzdDZrQzFxRzR5SFFFUnUyNFUxeDg0ZTd3TTFHOWFKSm42XHJcbiAgZlhBZm1Qa3lEdmsrY2JqSU8rNk5FeUhFaUlObmhLR0Fjekg2UHV6NWVmc0ppRVhqVU5LNVFiSXlPdVc2NnkrUlRPWDQ5eFhPUCs5a1xyXG4gIFc4UHg5dHNmeU5GSDdwdW4zUHo4WExQa29pdTlsY2ZuMXViTlZiSjA2UnFaT25YdjRqUUFWL0pmdXV5SGNzMVZGMFk1dlFPdm85T0hcclxuICBYVmNnTHhDUDlNSkJrZzJ5Q2FVczhIamlOenFWaUZoV0lsTVRzWGlVNzFuZDhtUEpSUDBlNVFBOTJ5V3JTOFh3WStBeC9ZMFZJWkcxXHJcbiAgL1FPcFZPVFI1bjRHcFcrZlFuTmhzWFI3SDBYUURRbnhFem9QeENzQkF2SGdYSDBYNGdGU0lkK0pCMGdtU1R5MEhvbzVsSG9rTEk5N1xyXG4gIDhKQzBmNFJFazJsQ1M5czU1U3JnTklxY2NIQUtzMGpXb0FUaVFCa1U0dWFMUzBQNmtyNzJDVm01Y3JWazVXVW9zdXF3V2NQZ1k2L3pcclxuICBObVBYOE9zVGQrU1R5TmMvTEtaSSszb05GdVZwWEJFTU05aFNsTFdheG5XMkw5TFM4bFdzVnhodE0yQVc5S0hYd09RVUt5QkhhdEdvXHJcbiAgNHpMMncvV1RjUS9pZVFUV095SVdCbXMyMG9ocVRKYXRaWGptbE5peDFXZVVRS0Z5ZkNBS0R6K0tacHhMWk5OcnZ6YjNFQmtaYWJZR1xyXG4gIFpPSzVON3NCUVFMMFN0SGxBVGhTakNkc3k5NFltSkkzQXRwTmdMSTE0Vm9BQ0JNSWFac2RhOXp5dFFuYjc0TDhnZU9zbjc3SWJha2hcclxuICBNY3hlMFFXNW1GdC9RcWhISWkrVzMxM0pUSHJyaDA4Yjl3bHhaY2M4OHBzMnZpdmI2MnJ0K1daa1pNcWhoeDRxZFFOUE0wNFJ3R0xMXHJcbiAgRmxIcUgxd2xGMFB4YnUxM29qU01yaFZkcjdjNG5nS1lUUFVaaFpMOURaczRzSzdJWE9JcndLR2d1Nk04ZTR6d0RxeXV0b0VWRi83QVxyXG4gIGFNZU8wSzZHcEltRmZFOFRXcVlkdXpZc2xMd2hFeTJKaURVdFBjZSt3K0R0bC9Jc1BtUnNBSW4zRWNWdDRxR3djL05TZXg5UjR4SEVcclxuICA0ckZvNjZaMzVDZlhueStYWHZ2RktHZmY0Y21uWHBNenpyNWFFSkszdEM3MHpIMkF2VzFBMVgvQXNWSmQ4VXFVMmp2UTNvOSs4QlhqXHJcbiAgU0hZSHpPM2kzNGRCRitKUm9ETVFJeDV4aU5lSWYyQlJ4SUp1WlJMZzhmaHZBbUxKZ0NwNkJ6M1g1WFNYaXVISHdHUDZHeXVTbGQ0cFxyXG4gIHhTM0xaT05HUmJ6UlN5L0l6N0V0YVNFZUpnT05pQWV6YlBibUNMQ3Z4QU13NGdFRzFIK3Npc3hDeERxaWR4ZVFOSWVsdVdQUy9rWVNcclxuICA1OGlQenFFb2grdUFOVWRtRExlQmwxaUlDT2ZaaThNVy9tMkhlSlNiQXBXeS9mcjY2dm1POWc3cDFGa21INS9QK3ZWYTlDT0syNUVRXHJcbiAgcFNUejhYaksrZzM2WWFhM1NoQlFpaU51d2ZvSGdrSTU1T2FJcGxDRXcySFFGczhIcEV0N3VBOEJNWkp2N2RzUmlXUVlpYkY0T0pJaVxyXG4gIG5UVFordjdqSm9hQzQwTThWYUFmUHpvSXhFa1FFL29FUWlDK1U1ODNjYTBzK2YxSEdnZkI3bnZoL3JDNElXeHE4cjFkQWpCeFlKTXBcclxuICB4SEdOU3V4MlZIeGtoR2huZExDR0JSRmRTSE9PSTRqT1FQYTAyNmtjQmlGbTFGdzdQRXZ1aFFNelprTHlPS3llM1crcTNSZjN4MzNSXHJcbiAgSnE0NjRCWnhnTW56Q09LdlpKdDY3U2dlbnFlMWJYbCtMcVFISFhTNmlaRklEenpvRXlidXdtUlhNeVE5UFVNS0N2SmxlWTJiTWZOdVxyXG4gIFN5ZWVKRlU2U2FoZStxcGhDeE50VFRqQlhPZXp0cWZMdXd6WDZTWE9wbWQ5eDh6VWVJcjAwNUNGcE9SVEg5MElLOW9adTR3eGlDUVRcclxuICBJT0w0MUFwV1hIQ1ltbW1IZlIvYVo3c0dmNG0wcFpKcFBSQnB0U0dHMHFSTmNEVEUyelFFREcvSmxDOHNtOWlMT01zOUNnU1JGeWJXXHJcbiAgaUVPOTNRQ3hlQ3lLNjZQanBqc1IrbS9oOU5PT2xtdXZ2dENVNmlmc1lkVjVkL2pKamRmSWoyNjh3K0o0VnFpdDdhcU1mL1RoVytURVxyXG4gIGt5K1BVbnVIbTM1OHRYejU4ajI3U2tRQTBBWDB0U2VKUjE1LzI4UGNJU3JaL1hrbDB2R1dlQ1VCTk5hdGpQMG1DMFNReklqWDdyV3dcclxuICBKdU9sRTlDdHJNZjBOMVlFeUcvYmFBN2pBSXlUY3JMZFBmdTZsakxieE4vMUZSQ0ZHbVd6Y1M0V1dXTDlGOFREMnJEQkxDYTJ5dE5aXHJcbiAgdHdGNU91Z0o3ZEFTREhZYjhORVJFQUR0RVlmcmNPSXhXSnFVdUlWMUcxaXYwQjlmdjZGY2h4SU9pQWZuK1NqRDVrMk5paVFoa0xnb1xyXG4gIFNNK0pWZ3hyZmZ1QUNmWEF6QmRrRTgrdlo1MkFoc1dzR2pmQzRlNUVRQ1JPT054TkI0UEYzSWpRamlKR3VJMlM4Y2ZZT2RZMjlHY3RcclxuICBDZlUwN1FndVFuSWhMN3FlNWVGR2dYU0U2SzNONlB6Z0taKzBjM3pzSE1qbU96cmFyQTJjK1hYcURKMjJJQlFvWmgwcHAwbTl6bnpaXHJcbiAgZkd1SHBqRXJSdnpGZ3JOZGlqQjRBMENZU0xCK0J0RWE1ZEJQSUFvcUdueUFJaHMvTUMzT1ZXSWEwdWFqUzh0UW5tZFAvU0tkN2VJNFxyXG4gIGtIZmFvc2dmc1FseENKTVJFKzF2WjN1YmhjbDc5MmZQWVdJd2JUVVFGVGhPUklPbWw5SHp1N1FONGhES2lzVXZXbDA3REpuclljK09cclxuICB3NjNRbk1CRTZhaU1wOU1rZmZuZkl4MlF1MjRmZC9EaHBwZUMrNmhZNG0wUG1IaUtyWWl2V3ZKeWhNVFRiRTBKSGd5c3JYaTdISW00XHJcbiAgMzV0bWFKZ2MxM2cyUURkQ3ZHYlZISE9Mb3lkdHpFSkVXcFZUdFFsUTNSYnBNeElyTGw5WEFpRkJ4NmMzR0xWSkdQOXVlSnRSV3NQRVxyXG4gIE42V1FvZThmSWtJS2tTOFJKb3B3MFU1RUlCeGRpWWhaWk9rWkpvSlljREZ1Y0FPUHFNMGFTRUFzSGtYTEJ2YVZRVEgzSmY4dC9PNDNcclxuICAzNWFKQjR5VlYyZlBsZi84ZTkvV2NoeCsrQ1M3UExvTFRMSDc5Q2t5NDVBQVJ4MDFXYmxzUDc4dk1IUG1aRnRjdUtmeStnYVNRQ0lRXHJcbiAgajdTY1lza3FWWVRCaWZCVUxJamlCdkY0QkpyVkpiZVhJcDRYUDlHOVVnUTl5Z0U2TUtMWW5tQjNaU2FXTmtqVjFrM0NYam5aMmVtU1xyXG4gIHJtTzlyS3hNS3ROR0dadU83SlBhTm10V0FKa0F0dnE4TitKaHNuRFBoejBHa3NRanhYYml5NDltd3A3WGM5Q0hnVy94cUZ3NFo0cEVcclxuICB6VFBpc1oxZERnZGFpTmtqWmMzaElWeUhpYXhjUjRWbEZSK2w3ODJ4U2RJR1Q1ZStmZnNxUXZRZDV0cmJPMlh3amxsYU5DQ3Y1QWZKXHJcbiAgZ1p0cjVOM1dyd1NDZzZENENsKzRqRkNlMlRobXRlWmpTcDhKY3V0ZHluMzRCbFRlcnBkMTVKSWtHaEdDc1RSSVIrTktQQndCb1hOWVxyXG4gIEpsdmdPUFJaazBkNjAvdi8wZDZ6TUs3Unl2UVpPYzNiMEdPSElsVmIwRWxaZmVad0J5RHpYU2FPbUNDdCt0RkRDTFNpcmF5M2NQQ0JcclxuICBSbFM1VFJiUFlZRVgybU9XSGc3cmEzU3dVajRqQ3g5ZzNuL2NlRGpST01DZURlM1NoM0NOVG82MlZrWDRCNW8ramZyY0MwUUdkL2dRXHJcbiAgTmFaeHdWcXNvN1hKMnVMK3ZML08xYkNySFNZdTlJRzlXR2lER1RRdVdpaTdSWjhOZWlCN2p0b081ZlFuOXY2aXRNWDlJTDVxelFacFxyXG4gIFU2eUM3Z054MHVZTlBoRVljSUJ5SndlY3FvVGtlVk82VzU0U2tZRFFRMzBmSnozYjlUanZtK2ZrUjRqbjZCakI3SmN5Y0NPTU15Y2tcclxuICBNeXdQcXpCZmhLZ2N5SVlGTmlucnE4UXE3SVpvWWpOZW1oNzJSMXhEUzBmNTRlRFA0aHBDUkZxTmlLUTRFVkVJUkFSUkZhV2NpTGpvXHJcbiAgRTFFbDUrMmVGSWliQmFFV1pESnBrUVQ0TllDaTVsVnkvVmZPbHR6aXBOKzgveDk0OFA1ZkdSZnlxZk8rSnMzTkxaNjVGMkNCWWVCQ1xyXG4gIGdOV3JOMHBGaFU5cWdkdHUvYWFldnl0SzdSMFFZVjM3OVY5RXFaN0FmTStVNkR5aVFEeFM5ZVBQR2Noc1J4TUdVY1FDai91THNhaENcclxuICAxL09KYkdMZHluaVJaQW1EV0RwZXUwYzV6bmJKaXBkTi9CaDRUSDlqUlVqVVZ5NlhyVnZkSHB3WjErREJBeVZud0RocGFIV0VRQm1jXHJcbiAgeWJVMjFabGRPY0JnOGUwemV5RWVFYmVDeko4VjZvRjRVS2RwMjdvWThlQ2ZqNHVJSDBIUnlabjR3Q2ZPSDF3SENMbTlxZDVtb0NnaFxyXG4gIFdiVkxpRDhwdUE0UWkzTWdtT1FxRVZHT0EzTmNSRmVJUFlpM3BPUktmdE5hMis5QzJGdEVDVWh4Y1pHMDlabWczM3J5WTBkOFkyMGhcclxuICBHbXZjYmpvTXhFSytkNFk3S1V4Snp6Q3JyN0NmQnR3R3lrVWNBam9uNXNwSXU0OEVNdU8rUVg1K3Y1NzIvRVJhRDJibkxFaWpUcEhPXHJcbiAgQUJIaG1Pc1hUYlA0RXJOVGxLSHVOaVpGdG56d2hDbnoyUlNMdm03SGhiaVdMVlRrakhtMTY1eDRoeDJtTE9aYTdwS0ZjS0NVYm4zWVxyXG4gIDNOWUU3cU9rcEwvME9lQnNhNFAyOTM3NGZTVFMwWHYwZ3o2WDJ2VVlSMzdOVXJQb0k2UWUzRzVLWjRweFRNeHFRVmdZSWpDdXNQeHFcclxuICBVdTRGUlM5dGs1ZkpQaTE2Z0ZCWlI4RnozdnorWXlieTRpRE5kU0FtbUJDekQ0ZjJ4UHFTNkZzVWtrN3RiSk0xYy83RnJadmp4THk4XHJcbiAgZkJsNHpMZE1OMUpmdWNMZUxmb3JXME95NkRsYjRFbWNOdWdUZjl3UGVwRUc1VUREV2g5TWYrTmxMSzRRcm10L0ZoZXBYZkdtVGN6c1xyXG4gIC9VVGwwSWYwRzNXWW1mR2lWMk5kQzNvUWlMWHBZblRDZ29reTRsd0RMdVd4S0I3TENOSG9CK1Y2cTM1WFp0eVJuV2VjS09iVmJPU0ZcclxuICBwVloyNUZ2TFBFUG9ONCtCQStjWmg4UjVMMHd5R2UvQktLRXI2R1N2ZmF2OC9qZlgvVmZLODk2Z3BLU1ByRnExUVQ1Y3VGemVmR08rXHJcbiAgWExTUCs1ZWpBTWRYMXNFSGo1UFMwcjVLUkRaSWJtNk91U3NoL2VoanJ5cG4wWGVmRlBTVWVlamg1NnpOM3NxYkNJc2pFQThTT2Jhd1xyXG4gIGpRUVFSU3p3ZUN6YURjSVFBRFRXclV6djllSTFZaWQ3SzljbHIzdlpaTnBqK2hzclFtSll6bGJ6OVFQQ1VBN1BMSy95U3NaSVZZT3ZcclxuICBVUFVLU2d5cVYvbE1SNkdIMkVvSE14OUdrbmo0QmpycGNHemhZNGZGYld0VzRvSHlqWDV3WjBsRTArVkQxby9iUG5EN3lKTngzRk1nXHJcbiAgUDJmV0gvd0p3WFhrR2hGSmNoMFFDaU1laFAwamx5VEtkWmlMZFkxN2UybVNXanhDV3R0VHpLVUowTlRFdW9mb3ZDSnZacEpZd29RNFxyXG4gIEM2OXdmQWpSb0QvNG1xS3NjeDk2TjZrWjltSFRQNnhWUUJwc3hSdmE5Qmt3Uk1Obm5VbWk0WVFhS3lObTBlUjN0TGRZR29JeGVPcTVcclxuICBTanppaEkzK3BmbE1YYS9MTTRlem9rMUVTSnh2YTl5cGc3ZFRTZy9DQlR2UEZRN2lBQ1VrZXBRZm9NOFBzK2JRSG4xeGtVdE5UWTJOXHJcbiAgQVNBOVBWWDIyODh0cFA3N3crL0oraHlPZUw0ZW1tbjN3Zk1semprNGpLSnlPQnczYjJYbVRaOUJYZ1VEeDBzenBxMWF4N2dvTFF2aFxyXG4gIGdIZzdNVjFrN2RvejF6WkJoTnMzTHJDOHNpbm4ya0pSdTdiV3IxNyt1aEZiVDNOOW5vSDJaY01MOWt4UkV2ZWZjS29NUHVnVTY5dWdcclxuICBnMDgzWGNuV2hjOUtoUjdVRzNDZ2N5UzRSZUVlK0M1d25VSWNiblBBaEpQTW1BSWRDZVhKdCtzUko3VHJkc3ZUbzkvWUkwMU1qRmlMXHJcbiAgUEJaRXNoQVJzUzJPR05HTmtOOVhPUitzQ2xsamcrTk1uRE15OXBBTTZNVVM3UkZxSlBsOWFSalNoS1NORTlsWllYbk9pZmdPbkV3OFxyXG4gIGR2QmN5ZGR2bWZmZ2Vrc0g4bGpyQlJTVzRSSFlKNkoyalFqSzByYklKMDZlSWZsOVhYTHhmNFg3N3YyNURCNHl3RVJaUDQxeEZuc0NcclxuICBsTjczL3YzeEtDWFN0MitST1VzTThPVGp2NUdUVHQzM3hZVndJWEd1Smc1R1FBTHhTTlZVWmk3eWZudmMzU0NlMDB0Y2c1NTFBaVRMXHJcbiAgZEMyMW0wbzl5amtrYzJMbnVwWDFtUDdHaWdDRE16YmFiTE9seFZsQjNIWVBIVFpFR2xwQ1FRL05YRGV5dUVKWkdZZ0hqZzdkSFh0WFxyXG4gIDRvSDVKYk1aSng1S2NKUjRwSFMyUzFaa3NoaUloUTFlNHQzRFhzNGg1eTBZTU5wQ1gyZUJ2c09KQjhwRk9JL0FkWEN1cVc2akVReGZcclxuICBUYjdST0E5cksvWVJOeFFmTEw1UHRIWGJub1BsVjY4emhCeksycUl6SFFkNTJvWkc5RCtKQkptQjBsOElCeWFlYmdvNk9vSEVLRU03XHJcbiAgNFdPMmRBeUpjc0QxMmZvTExRZkJvSDFNZ0JFenBVWmx2UTBYM1d5YTk1aUpwRmpyZ1F3YVYvZHdYM0JJVGlRT05LUUxad1EzWmlJblxyXG4gIFE1QjZQZXRUOHZxR3dGbnNvL245VnQ5aEhwY2hIQUNyc05zbmZ6ZFJ0c2RoYmUzcDREcnhhNFVqSXFTSnc0bFh2RythOExKUk82WGpcclxuICBqN2Z6aUl6SVF4eEdPWkFsNHc1UHlRV0l0N1JNdlk1UkYzRVZtYTRsdkM4NEUvUXMxRzl0cUJGYzNQaTEvRHpIcGxWdTRjT1liYXV2XHJcbiAgVWtUVHg2N3I1V0tFWkZHU2tLVG5GbG9JRVVOOGhxNmszNmdaeW9VRVhVeXF4bCsya0gxTGFNZE5yYjFkRHZwdDN3WHhLQThsTzNuOVxyXG4gIHh4eGhlVXhpRUduNVpFSEh2eEpURitPNVoxL0dQOXdZVGpkOXpVYjBEY1crSjBzVFJua1dpOUlaeW9FbWlVaXBXYmloZXpFQ3Jwd2ZcclxuICA1WXlJc0ZCWWlVaXdtbU9jQnNMQkRvaU1UUWZhVlpxOFlZT01IbFJrOFk4TFpyM3lOOFBQUDdycFRoTzE3Z3ZFM2I2enRtMldFaUEzXHJcbiAgbG5ENC9uZS9MSGZmOCs4b3RXY0lWbGk5NlVKU0EvSEl6czZVSVlNajE3LytMQlNpU0NKTlZCTzlubzhWNnFWTS9EY0JzYVMvM2dEZFxyXG4gIHluRzJlOVovQlNsU1hWMHRkWFc3REZFQU90UWxKWCtZS1BOcTV3SDBIbkhpWWFJcVBXZmlnNGhkTmZ0OGlJZFdnWGdBZ1hqZzViT3pcclxuICB0VkV5SXkreThjR2JTQk5HZVlrd0ZtZDJoYjZEajhpNUR0dzhiTmF6L2hHWjJ4RWpIdVdtZElUTmgyQ0FWQ0FpYm1XUy9EQURRc2xwXHJcbiAgMzY3Uk5GT3U4VDFEUUh6VitDaGp4U0FjY0J4bW9xdlhZdEVmZWcxYjhLY2g3c1N4b0tMZGhJV1Z6cElEWXJUclJjaUhNTXh5U2FPa1xyXG4gIFJLeENQanNzZ2tDeWxMdmFQQi9pc05SRUU2RXVZaXgwSHhBMlB1YnlhWi9XU1UxZmkyTUN5ck9DcXpEWE1Wd3JjVjIvbGlhc2ZjTGtcclxuICBlVDJuOTU3b254N2NmMDF0cmNiMVlTaTB0TFI2dmVqWXJqUFJjSVQyY0JFZThuWlc2a3cwWG5hVEgzYjk2SmtrRGkwVHZ6YUhsWXZhXHJcbiAgOWJ5dS9Rdm5pYnNlSmxVSnkzR1docEREdlRBTzZEOXhGaWxpRkdBNkNkcGx4SmdpUDFXNXVrL1p1QXBqZ2ZPNTIrZEx4UVo5RjhxNVxyXG4gIHRUZlZTdm91ZmZlRjdzby8rZTQ4UHVpZ00reG9WMDZSK3BobVZ5eCt6dHRpN0NyeFJ0Rk9tbjRQbUhpUzltT05LZHJiMjVvc3o4c21cclxuICA3NGs4eTZldmRvN3ZBQTdrVFF2UmpiQWdNN2UvVG1RMGpYNkpuUkRoMW5DOXd1UXBNeUlvZkNmczltanZrbmI0SXg1OVV5SGZqbkJPXHJcbiAgRHljaXJoTXhJNVJ0NjZ3OXVKSWtFY0dsQ1JaYkVJNWdJS09jaU9rbUlTaktLV28vSFZLa3FxcEtUanhDaWZ2SENDTkdESkhmLy9iYlxyXG4gIHBnODU4Y1F2ZWVZK0FLdlVRZm9Ra0ZOT25pa1BQdlJzZElaRmkxK1VMMS8rMHlpMWQ0QUwrZTRQZmgrbGttQUVoSWZabnRvaFcydjhcclxuICBBZkdZdzY4SFhYSjZoUzdudWhXTU5SR0RaQVl2TUFHOWxldVMxNzFzTXUweC9ZMFZJZEcvZFlWVWJON0tmTnJNcnZLeU02UjBvQTZZXHJcbiAgbEVJN0Q5aWl3VWhoenN3ZmF4dUFHVTZRZFVJOHpBNWNxNWlNM1RnUkp4N2NBNnV2emVSWm42ZmRVelJRTFIzQ0tEK1J0dEF0clZnZ1xyXG4gIGlMMDdNeXJ5SVI1d0hlWlZWd2M0NnpwOGZZZTdJR0dHeGtLbkxseUhmWXhkRHo3YXBreGwxZXRXUzFOem16bVYyMXBaTGNXdDZ5SWlcclxuICBvc1JEUC9qZ2FvVEZYQ0FRNmlFVHhpTXNSQVRDNFg2WUlsRlYrUGdOS1VTSXg2N3B5QkFSRlc1QVVIcTZKMWs4dVBiVGozR2lOaDI1XHJcbiAgQU5jOHJJbzJ6WDNFbEplSWFnWlBPZGM0Ryt1N0hsaVNFYy9yUDlKRlB0RjFPQmNRVXVLSXBXMzJIOTJINTZXWjdUL3h6Y1VuSzlGb1xyXG4gIGs5Wm9FUkF1WG5aczlITVc2bWpCRlFzaGFRNWJMYTFwRGhUaklaOTA4ZEJKaXNpR21CeWRhM0JzbUhOL0ZGOXM3UVpDUTcrOVAzcDBcclxuICA2ejk5VFo3MzV4anVOeERrb1lkZW9NWDBlZWc0R0tpSW5ieEdDSWVHQmFiclNaV003Q0xaUE84UjQ5eXNyajdyYmN0bld6M1NLOTU2XHJcbiAgU052VDhhTFRSNVRvQTBwTGszMkpRbzBrNHhxYXEzM3R5OENEVGpQelh3aEp5WVFUYlpVN1NKU0pBbUl0VEh3Wno5UzFWZmxhMzdpUlxyXG4gIDBIN3NzR3RFNDRCNHY3RkhhWmdpdFd5cXBSTXBWc2x6SHVJQnA0T2VqeFh0akZ2YkExOG5VaEFQTE1MZ1pQMGJpSDFiK25Zc0hvV0pcclxuICBjMUU2UXptcFFFU1lwUEMrQUhSbjRUdDBUZ1J4Rml2VW5WandyU1E0RVNVNFRMVHlHcGJMMlAxR1NNa0k1ZUkvWnJqNnFndWxUNTlDXHJcbiAgZVUwNWlYdnVjcjNWM2dDRitrOSs5bWVMczVod3dJQis4dUpMYjFrYWVQbUZPK1c3My85RGxOb3p3SVZVVnRhWVBpVU8rdFpFMXF6R1xyXG4gIHlpSkZTZ3F3UU5vVDhOQ2phSWhZa01oVTZDWGVXNWw0TWtDUGNnN0puTmk1Ym1VOXByK3hJaVRHNUZmTDJyVnVIWldSam9LOFV3WVBcclxuICBHU1laZlpJTEl6RkhOVDlRbWtSTTROdW51cHczUFN2SHlqRmdBL0ZBaHdMeDhKWE4vS2RFMWxhKzBqa01Uai9wSDBnODN3ZDI4Z09DXHJcbiAgWUhFdStMRUNFUVhpQWNIb00rSlFtMjA2OFdCOWgrczQ4RjdLaXQzQWRTUSt5amdDaU9XaEtHWEMwTjZtaUZNSmFWRXUrMi8zTStKaFxyXG4gIE9nLzlDQ2piM0ZCai9ZRndaTERYQkFwVkpSckJnUitJb1V2YlVaNWZKOTFGVk5FNTJvWHRSeFJpSnF3Wi9td2hmT1dIbksvM2lxTFhcclxuICB4Vk5leHhHK3R4OFFxS2Q3SUtBSW9ZWnpmcDQ2U2lnMks5TFdjTU03OTF1WjlZck1yWnhlYmZ1bWhUSzgyUmRVVVUyekpEc25TNG5BXHJcbiAgd1VvUUZtcDVURGZIUmFhMi9yNDQyUHVDTWtZQWxRakgrd0xpY1FXOXAvR0VYS1JsaThyOTJLN3RtdThzUlg0WVJHeGI4VWFTdUdnblxyXG4gIE5zMTkyT3FacUU3NzdTSTdQOEl6c0NPNlI3c1hqYlBhbWp6RWVVT21KUjBndHJmc2tpSjBtVkY2aUQ1cnlsS1BkRnUwSGdpQ2twT1RcclxuICBiUzd0dDd6dmVwSkFkRGlYaUVkaHVENXhMTXNnc3BqOXNoWUpqaFU5Q1hxUS9tTmRGQVdpaFN0Q1AyTDE5ZEFmRDZPK2VaNjNIZnJYXHJcbiAgZCt5UnZocGR4L2syOUNKS1BOd2x2RytEQVBMbW0rREFNZ3ppbnR0dmhINDNUckMwOGVnNmZHdlJkeGVGM2RNUUViNHQwaEFSNGdCdVxyXG4gIGdoS2NTS0VUa2V6aWdSb21PUkhXNndEb0R6ZHVXQzlmKytLcGt0Zm4vMlo5dFR0QWxJVVE2dkt2N043N2JuZjQzbmN1TlM0RUpYcWJcclxuICBUcFpxYW5iWXdsbmcyR01Pa2IvZCs1VEY5d1h1K3VPUDVKSXYveUJLT2FTKy8vNWppVjJycW5haWtBSjR5Q0h3ZUN6YURldzFSS0N4XHJcbiAgUk1JanZWYUpRYngyejlKNmRtOE5LT3lweU9yVnE2VzVoWStGOGFvenhlSWkyWmt6U21wYklBeGlxOHpOMVhqVUNNaWNXYkk1MjRzNFxyXG4gIEQ0aEZlbFlncmluT2laaUMzSHE0QitKQi93bGpIMGswdUQzZjlSMGdVSWlIaTY4Z0hwR3lYR2R4RUF3VTVOUTFObjcxSFAxUVVKbzdcclxuICAxeEZZL0hqN0ZvOGgxNURudm82VWdFU3JmNnUyYnRCN2RkY2lMTjdDdlFaSW9BMzNKRW93VEVtdXJIcVk1Y1kvOEVROFFnTEV6ZGNVXHJcbiAgOGVnY2JEOHJuekd4UmZsSldlenBOK25NMkVRbnl0M0JkV2tsS1JoeVVLUy9pTnFQMmtta1k5ZXhvOHU1TkNPOEcrWThZUGNOc3RZVFxyXG4gIFJneUtGWGxUSm9TaEhYTmZ3aXZnUWVqWUtDd3NpT3A1KzRoL2lvWk44bnVKRGhBWUhBUW13c1paUmUrUXc0a0VDLzAwcnR3SXo1VHJcclxuICA3RkJpQmVKaDlUMmJhSEhmS010eHFnanlwVi8wczJ6UzJSRkI4WVByZGVGVzZIZDBZRHNaVDN0ZVJHeERXcTlmT0N4YXJLZm5rTlhYXHJcbiAgMTZ5MVo0KzVOQ0pkYzVxb0U2clNBUU1sZGI5elpkQ2swMlh6QjQvcm9ZU0VldEd6Q1BGd09ERkprL3lTNGVaS0h1NGRCNDRtMnRJRFxyXG4gIDAxL0tvUjloVzExclF3ODhBT1ByQ29JU2YzL2h2SWM4VDArSHNZMWV4RGdSblp5ZzZ5SHV5dlVVbllCRUU2cklxQ1NJZmEwOVBQdEZcclxuICBiUkZhUFBvdTljZkNrS2JlTG4xWHBJbGpBUW1ZQ3hUbEhLMmNRdUJFNEhab0EvRXFlUlBLc3lRbk8wMHUrTndaVnU1L0FYamZaYnRhXHJcbiAgZU9aOVhXQUk1eEFVNElpMDNwdTdTSjU1ZG5aQ0gvTEFmVCtUczg3cHVWdGliMEJiY0VCYnR5Yk5nbFBwRkZBK1pxcUZYY0VmbWtNdlxyXG4gIGNaNjl4M1lQVnFCYjNTZ1pYb3BCdkloQnNweEQ5N0xkSy9Rc1gxaS8yUGIzd0ZZWlFQOHhhdFFvUmFBNnNCUk1iR1UrbXl5cFhNWUdcclxuICArOUN4cWdKNWhoUG9Ob3lZNkVCRFpoOG5IbnlZdlJFUFF5RFJMQ2llUnp5RXdmVjY0RHpNWFlQbU8rZWhuRWp4SUxQNmdIRFFBaDlLXHJcbiAgdjlFejlSekVBNlZqOUZFUXhqLzRibmtNZGo3YWdvSThTSmNmcVNuMlBFeUJybVV3UTA1VHBMbEx1UTRXVHJIVkx2bStjanpXYmp5dVxyXG4gIEIvR3dWa014aStWaFM0OStnM05tK3F2NVFUeGwzQWEvYVJtbXY2RU1xNUloSHNTOXowNzhRdnNjSVcySGxnSEp3bFdnbHlBUFYvSndcclxuICBCK0U4WVJhdTh6V0VNTEJWNy9aTkg5cWlQRDFwTXpKangvelYyQVNENThvNWMzT2hkV3psTis5UUVSRnJUd3doV1RvNnRPMXdPUEZJXHJcbiAgeGwxZjVPKzZaV2VGelZBUmM1SEhlZUlzZ3FTZjFMRTl2WG0yK3F6Z1hEYSsrNkFVRHp0WXFsZk1WaUw4bEJicFJsRHM0Smw3L2ZoOVxyXG4gIFEwVExENzBnVVk3emhvQjU3bnI5aXVldXR4dkdrQVJnalJDSW1Jbkt3QU5QTVFTNitmMklrRVRFeXQ1TFBHN1hjdjBJUHNIS2xNTWNcclxuICBkT0JwZHNDUmNGMjRrWkx4eC9zWTBIVHBoSk9rcjNMVDdHTml1cHFvYnhaYWU4bDBQQStkQjV3SUIrT0kwQ1pTK2wzQWhUT2hZdTkrXHJcbiAgSXlLMVRMN2NZakVRSTJ1VGwyeHBZdjVlTkpGSUUrYnJHR3dKMGdEV1crMXdIMmxtQWFlY0NCeW1nMzQ3K3EwWU1WRXVoSFZUSDM3NFxyXG4gIG9mejJwc3ZsN3Z1U2VvYi9CZnp6L3B2Tjk5VXJpc2hmMzhNQ3Z6ajg0bWRma3g4ckVjR005d3VmUDFPZWYrRXRXYmJNcFRJc0x0eStcclxuICAzWjJKN2d2ODVhNGI1YWMvZDdFWW9FL1hZY09LdVZFc0FwNXZCQlpOcEdNbnVzZTdsWW4vT3NUTHhNRHllcDVJNXNUT2RTdnJNZjJOXHJcbiAgRlNFeFBHdUxyRm03d1JiTllibktReThyR3l5ckdzTWdZRFpSYWR3R2dHaUxnWWcxQnFLRzBDRGNoaW5XZFlEQnVzYUpCMmFWTHNaS1xyXG4gIERrSTdZeUVEMS9Qc2p6Q0trd2R5Z25DMHR6WWx4RmJFN1lPQkhVZFVwVE1xUkNsOE5PWUVUdnZIeHdEeHNIYjVNT3dEOGJoL2NMU2ZcclxuICBSTUJzSit0TzZWSmt5R0NVOC9RTi9ORnBLNUE3TzVUclVLTEo0ait1RlN4bTlrZzRvamo5NXZtRWZBakhwdm1QV2h3MzVwVEROREt2XHJcbiAgM3dpYnRkck1WZHN2VU00a0lLQkFPRUs3aEtRRDhnajVsaGZsZzl4M0dCSSsyRVFMSUV3dGFPY2hFZ0ZSWTRZWjRpQWhzL012eG0xNFxyXG4gIHFteXIza2Jnb01RRFpKcmIxeTNaekV4YTMwZWZZVk9pUHFTNDUxME5kM2RrWkxOd01rcnJIKzhYWXVrWDBYNXBHc0lSdnlmS1duL2hcclxuICBkRFR1ZmZWelRGZ29oMzVyMEtTelpQM2IvN0Q3TloyTDVxOS94MFZ5eWJhaTU5TTlMd29ISGZRSnUwYS9jY2ZJMWdybitqRGxMaXBXXHJcbiAgYnVqUWIwbFdYbC9UaGZFcytvMW1kcS9kVHVuVWlRQUxGTjFxTGx6RDRucFkyekdpQWhIY3VvZzFKS3NTM0VoRDlTb1RqU0pTaEp1bFxyXG4gIEhLNVJNTnBvYjJ2Vk52VkN0R050OC95Nnhya2VJbG96bjlWNC96RXpUZGRpRXlsOU5qYTUwdnkreXBHNFNUdmZVYk5Qd2lBaS9IRU5cclxuICBMV1B2dytKMmM1N1BqWEt0RUdwZlRHeWxmMHcyK0M0Y2RDS0EyeUFsSXB3MzNXY0VpT2xxdDFYTDRRY05sNjllKzFsNTlMRjkzd1h3XHJcbiAgdndXa0tFODlmcnVKc280NWZ0LzhiQjE2NklHMkxnVFliNy9oTW1IL1ViSit3eGJadHEzTzhuNzBnOHZrdERPdXR2amU0T0l2bkMxL1xyXG4gIHVPT2ZoajhBZmFLN0F4NXVnSGc4QXA1M0ZEWG9Wc1NTdlZRTFlDOXN0NkJuOTNRNkFpL1NlMEZzL09QQVBnOTFPYmdXOFBKbWNhV0lcclxuICBreVRpS3ZzSUZMQWVDU2E2NkVCYzcrSEVJOWlFMDNlODRib0NuWlEyWWgybTN4NWFmblRPQjNESVYyU1MyRG13UW1jdmRZYXNZTDl4XHJcbiAgbUpja0hqcXpNcEhWTzdiUWpCbFI4TjlrSHh6OTVhT0lqaENQaTY1TVZORFpvUnlWSzhnM3RndzBRdFNoV0FJV2xnMXZHQUp3SDRoZ1xyXG4gIG1FbnRDK0VnamxVVjVzdWtiZlV1K2cyTjAyZnlCazAreTV6UGtjZmFCWTFZdkFoUmxWNHJRZVM0RncxRHU5M3pBbklKK1lqWkxEODZcclxuICBCMUxtR0hiNHhZNkk5WDdxQXVlZ1pRTFNwZzhRSzNPSndjWmJ6YzJTbVpGbW5BZjBwN1MwUk90UE5tVGRkOVNNaUZOSnRUdy9wblNMXHJcbiAgVHpFQ0V3NmVXeUt0bkdTZjRaUHRTTTltajNlOWQrME9hU1BRZWxnZnlReDkxUDQ2MFhIaXczN29kWnJQdWhoLzd2NzhxRXVkWVRNdVxyXG4gIGtnMXovbUVFaFlPODhJeXNYSFFFYm80NFhFbHAxWCtrU1NjTzdIbk96ZmZyNTlaczRUbG41RHBYT0dUcXArelFUSnZJaERhNnZLOTRcclxuICBYQS9jeHd3NitBejdabEMwRHpyNE5IMHUrK2t4Vm9yMXZaUFBKSUkyS1YrejhuVlRqaVBLREczRTJ3NTVoSERGVFRYclRTL0NoSWVKXHJcbiAgRVNKYzU2QnBEMHNxWHcvRmdreFcxUWNpb2dYc3ZKWFQ1eHphVE9ScjZPZDBJcURmR1dGSVk4eUJHeCsrZmI1UlRrRkVHbXB4aitOclxyXG4gIFJYSjNMcGJSbzRmSjhrclhMWnh4K2xFeWF4Wjdtdnh2NE1nanA4cVJSMHd4QnZxbWZWd2JFc3g2bVNnaHl2ck5iKy90d29YVTE3ZnNcclxuICA4MnIzazA4OFhMNzVyVjlibktmWUUzaW1FZmpEakJJaFlrR3NVRy94M3NyRVR3WFlRem1IV0tKSDJRaTZsUytWTlZLcE13TDlkZ3lLXHJcbiAgaS9KbHF5UmQwZU91MnpnUFRTYk5kU09DZ2VnaGlzZkZWdTVGbHlxK0pzUjBJbG8vRERhTEVkckJJUFY0MXhEaXdTS295VFo3QndMeFxyXG4gIE1MUGNOZThaOFFDNUczdU9ySGYwNGZaeFE5aU04d0FaUlI5QTRCYkNoeGNPQnJ5TENIUzJqMldWdm1iTWNwc3lTcVFUVTB5N2NxYzBcclxuICBOT3lTZ2ZudDFpYnUzMjNma3hqM0VtODd4T0dTbUpHeWlaVzVjTkU4bmcvWFlvWkdmOUVSV0oyb3I2enlOVTRqUWpoeDViZWxMYy9UXHJcbiAgM2ZOQ3VaQVBBZ0dKRDV1SkRGanpEZkV1c0xLR2dMVWYrS0ZDOFEraDJMNUJuN2VHZXNLUi92QkRyQ3hxSU5hZE1KVXJ5TXVWa243TVxyXG4gICtKUDMzdlB3ZXdtY2xIRlR2UjMwbWZ1MjBCRmZJRGlhNFgyd2ZpaUIwWDZ4MVNxaHYwdC9ueHdRRlFnRGltL3VDd0pKUG1QRjJyWnlcclxuICBMdTdpZ0ppUWgrVVg1Uko5b1Z3VWtsNnh3aGZDTVpPbGZwLysraDJFODVTTlFzb1NoNGdNbkhoU01sK1BydkhrUkNEa0U4SnhZT3JLXHJcbiAgWWtRNGtqcmx0Q2lEd2NwQTNLOW9HZGE1OU5meHdzcHU5Q09oYm54YzY0K0ZIRGtsSTR3YndjRmlubjRMYmMwTnhwV3pGdzdsSVloT1xyXG4gIFJEYnJwQ0RkUENza2lJaTFFejNqeExjYSt1eDVWa2IvY1ArK3kvUmhuc2I2REhFVnhoTXNPQVR5bEZ0Rkp3WmhXYkY4bVh6N3luUGtcclxuICBsTk9PTTRVMVNMcTl3NjM3L2xmdy9ETi9NaTZFdFNHclZxNzN6TDBBaEdQcDB0V21TMEVpOCtERHp5WjhaY0dGblArWjZ5MitON2o3XHJcbiAgenorV1AvN3BZWXZyRSt3TmVLQjdobVFKSG53VWpTSzkxdTZTR1NVczZGazZtUk03MTYyc3gvUTNWb1RFOE53S1diNTh1ZXpjMmFpSVxyXG4gIFdHOVFXZXpCWTZkSUdqdkhLWVR0YUVPOWpGdzJpd29FdzRrRVlwbmczOHAwSG9vRWlQT0h3andqV2dkQ21rRm1NUnVReEtNQkdUdnNcclxuICBROUI4M0ZsRFBOaFhnclFwNnhDWEdQRjROMkxETjJ0Zk0yeG14UXlMQVc3V0tKaG54ajUwYTVPd3k0ZWJab1FEOFFBZkZsd0g3TDZaXHJcbiAgNWVwNVpvTFMyYWF6VDV6c2FkOTBDdE80bVQwMDhCcnNiY1hiamNlRHFBcFJqVVlrSTYrL1BSdTRvMEFvc0dTcng1WSt1dWRpSlJxRVxyXG4gIDhjT29la2hIZmVkd3NaUWVteFlxOG5SbGRwZTZsRlhDZzl2MmdQQTYycG9NVVF3LzRvdFN2WHkyMW5FaXdZTEo4a00vWTJXR0gvRWxcclxuICBDMEhhZGs5NjVNei9nV3pac2tXYW1scU1BOG5OelpXR3lUOU45Q1YrelhDWVJWSXNIY3JRbHk0SGViR2plL240d1htYklHam94TTJKXHJcbiAgQ3UrR3NHam9RUWxPaFRZZ0pEbDlFTm1rV1g2ZkVZZHBQZ2pjbnluUGR1aU1MOFR5L0hEQzZBY0wzYkp6Y293RDQrWXpwMzFIODZQK1xyXG4gIHhQcHAxK1NJN2lrZTMvTEJrN0ladjJTOWxMRlEwempnWkRLRzlSME9OU0VTSGEzTlJsUndBOEk2R29nSlpiRUNIRGpocEVSYkZuWTdcclxuICA5Q2NLOFlGMnFISXZid3A3NEpDSFdKSm5obmt2aXlMNW52QkV6VFhOY2hFaW90K1o5VTNMMFpiK2VOeSs0U2cvK3A3NXc0T3ZyZS9RXHJcbiAgZEJCYmNUNVlZd0c1K2k3U3ErYkoyTEVqcEd4b1Z6Y2Z4eDR6VFI3K2w3dkQvMTlBZG5hV2Vld0ZMcjNzaHhidURURHJ2ZUxLbTh5a1xyXG4gIDk1eXpqemUzOFcvUFdXRG5naTRrdnRod2R6QjQ4QUE1Wk9vRUk1YjZSbnBDbjF3ZUpvK0xCMnBSaFNoaVFTS3pkK2hSSmhtM05uY0xcclxuICB2TlFvdWdmWVhaR0R5NXBsL3Z6MzlTR2dJUFN0YVl1S2lxU2lNZHFTVWl2NjFyUU95RlVoR3JiaVBDSWVyTGt3TGtUTG91TXdIMWpSXHJcbiAgb05xVHdyeEhYQS9pTnVnMW4zYVpQWkh1NkdpTkVZOGhTZUtoZzU0WmxCTVA1MENhYXBSVnAxNlhqOVRiOWJpRzBUbDhlRUZvNEZiWVxyXG4gIHJ5THNBR2plUnJVTzh0eHg0OFpMYzB1YjRncnRCenl3dFBkb3EzdmNuTXRwZllpczU0T01NSG1jYU0vRTZ1c2ZHd0dscHJ0YmpnUWlcclxuICBpUG9HOGpja0ZtOC9PaUFhN0c1bzVmVEFKUWNpdkpDdVU0TEN6SnJyNHc5ci9adC9rM1Z2M1d0eThLQTRMeGwzckJNSmJRZWk0bldUXHJcbiAgYmZwMS9ibGhnZFRZMkN3NFQ4U2hKc2cwOU1YNlM5bW9uK0VJN2RoQkdTd3pJdmwvdkZ5NFJvODg2bWpjRCs5WHZFOEpKSy9QcVhqWVxyXG4gIFZEMmZwdmN6TmJvblA4OTE0YWJXNmYyakE3SUZtSHB1MDd4SDNmSXIxcGYxYjk5bkxsNHFGajl2M0FsMXQ3OXl2YTFrYm0xdHRiRXlcclxuICBZV0p3YjkrVjBJUjN4ZHFOalhNZnNYajE4bGwySGR0REpMSkFzMnRGOXhXdUcvcVF5Tk0wdTBJaXl1S2RvbVJuVTZwQ25RaHdQakUyXHJcbiAgZGF3aUZrcTBZNGRmdzlwS1hNZWZIUzVRMEdzUmI4UDlmblNPUllCWVRSb1JNVEd3NnhKN0pTTFd2b1k2ZGoxZnIyRnh6ZGMvUERpM1xyXG4gIFJGYUNMTmFNRXhIenlxRDV1RzMveHFXblMyNEJhOHJjVWltczJEN3ZVeWZLemIvYS9mNGMvMWZBWXkvb0hzdW9mVldvWDNqQmFkYS9cclxuICBUNTE3a2h3NjdRQzU3dnBiYkR3QWNDRVhYZng5aSs4TldGaDR3L2R1N1oyQTFEWjA4aGgzQXp6YUFEenNLQnBGNHI4SjZKWTBzTHc5XHJcbiAgbFlzbGVpdEx1bHY1VFp2Y3l5NUhhMnVuOU8xYktDT0dzOTdEVGh2QkNLSXJmdENCZ0pUd2xVUVdoOHRqU2JqNUxxSWE3aGlkaDN2aVxyXG4gIDlNRkZTTUhFWUxRNGc5elQ0U01nM3pkLzhqVHNOS2E2U2VMeFhwSjRvTVJ2WmJ0WlpZL1JkOENsR05HaFRhM2ZoYlgzTU1SWnA4S01cclxuICBDZUtCaFZOWTB3SFhRWDNFZElRREI4QlppV1JsSTRZUnFkbXFIRVAwMFhkdkYxR1Z1eC9INzlSRWUxYUdZTFFkUHFoTmMvOWxpN25zXHJcbiAgZVlCUXRRNEsreURlU2JZRlF2STBkWW1EMU9BME9GQWU5eGs2V2Z2aGltVEVOVmphYUdFajRzek1oeDcrQlVNRTdLSE5iSDM0ekV1MFxyXG4gIEhYOGU4U09PUk9PSG4zZEV5UTZVV3RNTUxCcWIycVJkS1NtV1RuVWIzaGYydUZnMyt5N1RsZUEvaXBBRHF5OXJ1MXY3ZGV2OFBBY21cclxuICBzbXRtMzIzV1liV2E1cHFFRlV0ZXNqQlpMNG1zUWVEZXI5ZzlSTS9JRHIxZUVIOUJUQkRYd1ZXWldFN3JRa3h3OWhlWDdhOTc2KzhhXHJcbiAgcGtqdHVya3k4TUJUalN2QjRuRDkrdlZHT1B5NTZiTXVadTFUZE0zb3Z1SmpBYmN4R3JQM2pBdDdQU2xsazg2VXdZZWNMME9tbnVmbFxyXG4gIDlkZzgvL0V1ZGEwOURrMFRSemRDdUl2dGhTdVdtVWlMQStzczlCbG0rYWpqRm45cU9HWTBFU2h0UlFjV2c5WmU5TDdETlhKMXJLRVhcclxuICBZWklYaUFubk1MMGxoRnREbE9aRXhLMnphaU9IbTlZR284Q2VOYU1oeE1tbmZZM3JYMmJ4UU5tbHhKcDBuQk5CdEpoVDk2RU1LTzBqXHJcbiAgNWFPR2RTRWM4VGhJT3NUL0YvRFBmOXhzUk9UMHMvZE5DZjZsU3o1cFpyMXdJZXgrK05GSHErWHY5ejFwNStCQ05tNU1tdWp1Q2JoSFxyXG4gIGRqaE1VMHBpTzRiYzkrZzgyVkhqQzJqUzhuMkRJdjRkb29nRmRpYUNubVhzWGNSS3hNdkVhM3EwYXptdkd5QlJLZndZZUV4L2sxa0tcclxuICBLVktTc2tFMmJkeWdzMG1ucHRrWnFUSnM2RERaMU9FRUJMdjk0SUlrUVVnVW1PWGp0QkJ3aXl0ZmpRMEx6RXlKRDVNMEcwSWhnL1huXHJcbiAgd3NYcGIvZDROUEJzZ0NiemtkV3lZSTZaZkVISmFQTk5oRkxjaWNkaENlSUJzUEN1c1hhRDFuUTdlQnZRdEJkOWpJa3c1R3Y3dURTQlxyXG4gIFhXY3hGd3Noelg5V1dxWjlNSlJCbDJOK3EzUVdXTGV6MFpSbEhjMDEwdDdXb1VlTDlKdDRSaGZFUVJ5dXpDREtRd25OekF0M0R4Z1BcclxuICBOTlNzczdVTUxHQUR5ZU9US2xFL0NwM2dPWElrallpS0R4QUZOWVFDVzN1NGpXSWxIbkFVT1VWbDFqWXVWMUFnMnhxQ3pqYXArdWdWXHJcbiAgcXc4Q3hkUVpvbTV0eGhDTEgxdzcrUjQ0eUlNdzRIMjNic01IcG51cVh2eU1MYVl5bXFkY1dMOCtSVExpdEo4WVVlZjY3QVZPbkEyd1xyXG4gIElKQ01IWlN5MU8xK2NJMCtJNmJhKzhYNkI3TnNaUHZtUFVDZlArbldCdDlYaERUN2FXeFo4SlErbGd3amlMUkJHZTl1dUE4Zk8veHpcclxuICB3djZpL09DQjFzUTJSbkRSNzRnOVQxeWdaK1gzVlM1dHNUNnJ5U1llczNyNmw3MzQxN0pzNlZKOW50NG1wcnY5VC81OTRqeDVOQlJQXHJcbiAgNDZDeEpUS0FZQzJHaVN1ajgveHRtdjl2bmV3TTE3RzEzQzNyOUErd3N4YjFjaUdHS0l0dkVMTmY5QWM4SXlac0tOSUhIbkN5bFdMc1xyXG4gIHRpcm54RVpwNk9Ub0QwM0UyM0h3V0hwdXNSRVJXMWk3YllPOU04enVNYlBsUEo0VTNGcHJpQkttNVNaV2hUUEJyRHJSbGdhaDFXVGNcclxuICBJOFRUdFUwbVQyemxqS0VMNjBMd2lyQnAyZHR5NDNXZmtVOS8vcE5HSkFMaHdHc3RSOGk3OSs5UG1QN2hmd0hvTTNCUnNubExsZTFqXHJcbiAgUGswSjF0NEF6N3JyMW0yV0k0NllZdHpMdi8venNwbjNzcUNVYzMvNTIyTnl6TkhUb3RLN0IrNVJQeUdIdUJtdlBVQi9pdDBnK2ZvU1xyXG4gIFQ5ZkFJMkhRSkNGZUpnWjdMZGV6RWg5d3oxeVJqTFJPS2Nwb2tLcUt6WW9VM09Nay9lQUR5U2pDb2FHWTNvTkZTQUQ2QjJ6ZUFieDdcclxuICBCcVc1TGFKanBxUlh3U29wcHk5RTFCRVJNcy84OElIWVRXck1Cblk4N21VVFNDektyMk54b0NJWEZsQ0ZEekF6djhSbXVrbmk0ZjFoXHJcbiAgTnNwZ1p3YkZ3ajVIamlCSzJ2UTQ5VDJ0UksxNnJaaTNYa1hJdUY3QkFnV09BN0VBaTlVUVdVRTR6RzhQUkVIRHJQSVowbGJuaWxSRVxyXG4gIGZHWjVrV2piZlZHaDJ3RFAwRi95SVdRWURTQmZacVV1U0pkODR6NjBYVVJXeG5Wb1BONWZpQWRwUkZTa2JXR2VoaWlJL1h5S2NoSmZcclxuICA5RG9hSisyY3lZZXljOU5pVzRqWWY3K2paZmlSekxqUllmanpEWWUza1R5NExweUFQL2YzWmUzcjk5ak1IOCswN0NzQm9rYUozdHJVXHJcbiAgckcvVzE4SHdwdkx6WFpaT1BWelMxNjJmcDIwcGtoMHh6UmF1eGErWlBQejkycldVS0NUeXRRKzRhU0ZlcS9rY3RxT2VsbU1NRUtjUFxyXG4gIEtPajZhcjl3aVVLZGhmKzYzdm9hanVSMWFETTV2Z2pqNTBqemJOZ0tsOFYxT1AwYnBzL1U2VVJVUnR2SFpCdmRCMXhlUjF1N3BLZmhcclxuICAxREY1UHBTMWRCU3krcnY4c0F2MS9SNlVLTWUzQUVkaVlrMzlKakZZR055Rkc4SG5tWE5WenExRzdXcGRqNmVZU01zbUEzcVl5eHI5XHJcbiAgczdHcTQ1WXk2T3pRNDBGa3dtNlgxc2Y0UVo2MTUxeTZpM3FIMlVTSHlXRlkzMlRFQTNHd2ZodHdRbkFpOU1IRldUNmVOQkxGR1EzeFxyXG4gIHVGOERrM1RMQnpTZlNVWmgvUkw5ZmxKbDhSTDNpUldJUjV6N0NQRERIMXdoZDl6NVVKVDYrT0crdi8zY3dtdS82dUhlZ0Q3Q2hlVGxcclxuICA1Y29sRjU4am16ZFh5cTIzL1NNNk4xbis5Y2lyRnQ4YndNSHc5QXpxNitZbkZoTTJWOFFmUUhod2laaERsMFNQWkE5Z2tDU2haK2xrXHJcbiAgVHV5Y1JVT2FUd0xRZEt4SW11YnZxTjRvZFhWMWhoQXRMeTFGU2t0THBha2owOG9tOUI0YXh3TExGc3pwREp2OU93QTREK1QzRkFDQlxyXG4gIEp2WW0wUDlXRmd2cHpOdlRlaEFMQXkzRUUva01PTS9qZ0hoZzBvbllDbVJrZGJRTWlMNFlKS0w5aFhndzZJMTQxR3kwbVNWV0g5NU9cclxuICBhSThQeGV0Nm5vdXM0RlpJUXp4TWQ2TWZIc1NQc3Nob2lidjdlVVJaNCt3RDR1TWJPTkE5RDlDa2k3TzlUZTVkSTM3L21nWkowQlplXHJcbiAgVU9GczREYlkzaE5ySzB3bHpiSkt5NFVQT3JRVDRuQWNFRE5teDI1TzZ5SXFWeFJyR1IxK0lIYU9vZE0vYTg4cUVBdEVWa1kwWXUzUlxyXG4gIGRqaTZjaC91cVJaa3pVZGZ1KzU5dTQrUlIxMXU1KzM1YW9qRjI2WjNINVNXNWlaOTlKM20yZ0VZT0tCVWtmWjg2YlRYcUp5T3ZxdmFcclxuICB0Zk5rOVd0L3RMVU1JQzhRdiswdG91MzRnZmVBY2pPTFJ1QzcrclUvdVhoRTQ3VktnQ2lERVFOOWc4QUVYUVp4R3d0Nm52NUNoQ0VzXHJcbiAgdHZCUC8vQnZaYzlGK3dNaFlRelovY1lPMHVFSTl4L2VSZCtSaDVtWUMrc3oza3ZWc2xsV1p2UG16VVl3VVh4bDZVeXplTW9YVFUvQ1xyXG4gIGtXaFh5M3VieWV0NDI3NDVGbkVRdFNaczBqSmsycWVWVGpnaFFqL0N4TU8yRVk3NjVIV1NZam9uS0drMkRsR2lVNDlKRFZ2clVoNVJcclxuICBGazQ3VFMraTUyeUxBQjJMVGtSQ214N3kvdDJvd2RPQmlFQThTTHVKcnpzWTVidkNQWkhyUkpoVWFqMzlwYTNRbmthaU9HZjhTTVQxXHJcbiAgUEJJRHMvWlN3UGZWeG8zclpWajVBUG5GTGQrMlJYcTlBWWc2blB2S0ZlY3JZZm5mbVBZZWNzaEU0eGdRWlYzOGhSczhjeStBRGdOQ1xyXG4gIGQ4YnBSOHVCQjQ2VjIrLzRwOHlkNjM3QS9uajdkK1RsVitaWWZHL0FrMHRBajhXRVhZQ0hHYUNYdUFYZDhoT25Zdm54SWdhOHFDamFcclxuICBBNUluUEthL3NiSVpPaDdUT3hSeFZLNVhaTkJwaElPMnNIR3ZUeDhrMnhxZG0raE43MkYrblRRSGYwY1FDTTYxTmUvVThaMmhNYTZUXHJcbiAgSXJzMmZ5UVp1eU1lR2lZSG0zOWNJWTgvMW5pQUVQR1M2Z284dDZYM3hVNVkwbWdwL2ZpWUtXRVZab05ja1lrUk1pM243ZkdCUkdIc1xyXG4gIGdQTUF5VFBqZ25pd2NoN3pXdTZWdm9TRmc0TU9PczNLUXp5UzdhVkovLzZ1QjhIZ0FrVjZTc1U3WGxmUHMxTWU4bWp6OTRReVd0c2pcclxuICBUVDlNTTZidDR0RFFGbGZ5QWRObWFEc1dEN29ONVBPa3c4cDVMSWtnR0pyUTV4TVJFbzM3Zmg4Z205Q09QaCs3ZDY0WnBhTVE3bUxOXHJcbiAgN0xzU0I0aVkvcU5VQmpsVGpyQm16Unhob3lWazVCZ1ZWSDMwa2o2TC9hUytzVVhTOURsdzc4dzVNTHZFTk5UY3llc2Z6dm1venpIcVxyXG4gIDJDdVZVempFRmlIaWhnWGtIZzcyNjRDclFZN1BDbXVyd3k2Si9Hay9ONzMza0JGY1RSb0hyWmxHWkNBd29aL2hRQnpJK1JSOS8zVVJcclxuICBwMEk3SUM3T3YzL2ZaZlljSUhUK2pMaUdodmFNd3ZQM1BDUEVSM3pKOHZEZ3UvR1JMOGo2dGV2Yzhrb2hOeWRYeDkxbVd4eUpNbnBQXHJcbiAgaENUUmR2UmVFSGt5bzdkSmxhYU5HOUh2aFBFQ3g0cGhoZVhQLzdlRm9YK2hMYytEaUxCaG5VNy9kQkNpbUE5KzFud1ZlNG9TRXQ4RlxyXG4gIGthMlNJY1NWUzE3dTBZNkY5RXNQT0dEWGliZ3VCSjFJSUNLRWJEckdPOU9LL0p1U2ZUc1REUkxSYzlPSUhWemY4a09jZkQwUDBXUkhcclxuICB3MkZabFZKZVBrZ09tenBXY2dvS1RUejE5dHNmR01GZ0g0NDRGNExsVTRpenNQbC9CWCs4NHdjMmx1KzkveW1kVE8vd3pEMUE0RUtLXHJcbiAgaXd1RlBkaHJhcmJMM1g5NUxEbzNXYzQ0NnpxTDd3MFNPaEFncmdkSno4Y3NqWWZuZ1Q1S2p3UDJVQU5FWjVJL0VXZzhTaWJxOWlnRFxyXG4gIDhKS2lhUHhjTDJWOTBFUUpoWUxNWnAwMUw1TmRPM2NwOFZCRWtKV2hpQ0ZWMGd1R1NMcCtrTHRxdCtyZzhUM2QzWHczcWZkZzV6d2FcclxuICBxNjl5VnlFQTdzd0xUYVNsYkg1SHUzNUhhYjRxUFRHSXVKTW9qT2RadnhqVVViN0drYkh5UXZGM1ZMdVczZFI4Wm1hN0JTclJJQXlEXHJcbiAgMjVUc1docGxuN1dqczZvdVlkUW0xOEhUS1NLUXRxWmR2dDdCTEszMFdVQVk2MnNkUVNyQ0o5eFpzVUxZczhENlp4OGFNOEJVWmI4WFxyXG4gIHljWk5HNld0MWNXQzdkdVdTTmFRd3d3QjRQYUVQaU4vUmx6QnpCWTVQVG9PWk91SU13TGg2TDRXQXVkQTFvVUFBUC8wU1VSQlZBTEFcclxuICB5bXBtYXVncGpQdUl1QTA0UG5OT3R3c2tqTmhubmhLOVJ1TXlURmVnUjdoUFAveTUrak4xeEltaUc0SUdRa2NjQmhLMlJXUDZydUFhXHJcbiAgMk9FUHF6RHFvaitCZ0s1Ly9XNTdqNGhiVUlSRDFEYSs4NEJrWldWTGE1dE9IdExUWk9qRlQxdjkwQTg0bFhEUUZ2MEJrY2Z6dzRGTVxyXG4gIG5ENkVlcFFQNTJnVEt6SGlFR016bk5CeTlIdmh3OTh3Y1NDRVlzc0hqOXM3SzJQRitWdjN5c2hqcnJEblExOFpKeWI2R2o3VmlCV0lcclxuICAwWjl2bVJMUFAxcys3OUNlRXpIcnI4ZnRlV3BZdS9BUjJiNjlUanJhTzR6N2dEdnZMQmh1YTRJUUU5a2lUUE1WNXVWNVBzN1JSTzNvXHJcbiAgbjdXckllc3ZtTldUQjNGczNsbWhST3JZeE02Sm51Zjc1YkR6NHBZRlQrdFlaSXVFcUNXYXNaaUgxT003WWV5Mk5GU2IvZ0pPR2tBUFxyXG4gIFloeEk1U3A3VGpZWlJDOWlaN3UxUlY4MXd2T3FXVDdiM09OZ0xneXhRL2ZGZHN1dFRkdHQ4b1h5bmdtRDdTc1NFVklhQ2IwQ3ZPMElcclxuICBRbHhERnM5dVdmcTJmUDlyNThwUGZ2Rk4rZW5QL2l5Zis5d1o4dTU3QzJYLzhhUGs0SVBHeWQzM1BHcG1zcmY5NFg0NWROcUJwbTlBXHJcbiAgWDhBT2dUKys4WTlLY0hwekcvVi9nMzc5aW1YNThyV3llUEZLV2Y3UmFqbi8wNmRHWjNZUFFSZHkrSXhKOHE5SFg1QWxTMWJKNk5IbFxyXG4gIE1uN2NTQmt6ZXFoVVYyL3JkUmZDT09pWG1vVEFnWXd2VHk2NmM5aEwzSUp1K1lsVDhmenVFQVpCTjdDODVBbGl6djU2MmtFLzFJNXRcclxuICBVbFhCbnNYTThLSnNoWjJWYTZTdGNxRitySzVib0lBTmtpaU9vMEFEcldScklCUk1FV3pyUFJTMFRBT212UkZuWW9mbTJiMXdNWTZRXHJcbiAgRnlFOFIzN09lUkJIYkFYaWd2UG9PK0l3WTU4cDU3c0Y2cURXQVF6eG9ENElNTzVSMTBKRjBsM1Nlb0JrOEhTS3JKanROa0hRdHVXblxyXG4gIEVnOCtMb2dHSWdFNERvaUgzWSsxMWJXZnpXVW5TV2J4YU9nQUluSFoyZEJrTTBqS3NPTmNic2tJRSt1UnhsK1RSaXpPUnhsbW9va2pcclxuICA2aWNXUWV2Zi9udTB3Qkk1Y1lsWlZpRk9zYTFiTlk4NEloek9EenI0VEJmcldDZWlOaEx0K3ZYYWxNREFZYkJCVVY5RklDT1B2dHhDXHJcbiAgNnNQSnJKbjFaMU5jVTM3TmEzZWFsUXpJbVdmYnJ0ZUVreGg1N0ZYMnJ2Qm9QUEs0cTh5anJyMDlycUVoTTdBdTl4TzdmdGYwN281NFxyXG4gIHVmaVJQQi91alQzY1djTkEvTUR6ZjJkOTVUeEVCVTVuL3QrK1pJZ1NncUVuOUpGbTZEMyt5WWdRWlluekRGSGFVdy9rdW0zNTY0bjJcclxuICBuYkRIcjZseHpXUHRSMDV1cnFiZHJMMzhVMzlYRHVVU2V5NzhyWC9yYjhxTkljdlUrbHArNlBUUDllQkllc1pURlBGM0pvd24wTDFzXHJcbiAgZXU5aEV4Y3lFZUZkOEUyYTBqK3FTNTBRajRlTVU4UmFmSXRZYXBsYkhSM0xJSHJHT2h3N0lad0kzNERWMVg1MGJTdTBqYnVXbzNWeVxyXG4gIHR0NzBpRHd2REEyd2Fzd3FHR0NUU0lnR3o5bWxBYjZRVnl2clA4L093NUMydkJEWGNGeHhuV1JuaUh6bUFuZWFPUFB3U1RaNy8rUTVcclxuICBKeVE0RFpBdmNPQUJFRTZmN2Q5MTl5TVcvK0VQTHYrZmliSWVpQ3l5SG52cU5WbTlhdS9jVHVCQ3hvNGRMaE1uakpHcTZscDU2dW5aXHJcbiAgZHU2OFR4MnY1LzVrOFQyQlB2MmU4SkVPdUFUdzdLS29RWmRFajZSRGI1bVd0NmZLdmJhVXlBMitWd0tNNzdkRDFxeGNZVGVRb1Znd1xyXG4gIFUxbVE1dnBXblZGbWFGcGtpeEtXa214TWNyR28ybWpzWjdBc29rMURrR0JQQldUL3Z0SmMwd3hJRGZQMUl6Q2dDTmtXSjVJY1VJbkJcclxuICBGaDNtVGJkUG1jN0NGNXJZaXJ6TW5EN21CSStQb0hiMUhDTWViTnNKSWdrZkhxeDM4bU9nM1Nqa0k0aytXRDRjbTQzQjB1dUhoWDAvXHJcbiAgMXg4dzRVUWpRSWdBdGk1OHh1cDFJUjYwWlcwZ2c2WmRuVTIzVmt0T2FxdHlNR2w2S2xXYW05cHM1bTZpaUxKSXRNRHoxdHZDWWkwb1xyXG4gIFVlTWZiV2dMVVJWeDFySXdrdzBtcGVobkVGV2g3MEFFNXJMOEZCbHhwQ0pKSXh3NkllalNYdksreVlQUWJIejdIOFp0Y1kva0lhb0NcclxuICBpWEtPR1RPVEFvaUZtMllxMTdFY2VYK3FqRmFpTVVvUEV5ZHB1dThvZmRaR1JKVURuSDJWWkNqWGdSOG80TUFEZmFaTiszNHdVWEZPXHJcbiAgamNQNzF2VklsdTErSk1kQ1BOL3Z6ZS9QajJTYTgyV1R6N0Z3eWhmL3BvUkMrd3FYcFFSai90OHVVVzdrU2pjR2lQYThHSG5NVjZ3ZVxyXG4gIHp3R2sybCtSWldnVEFvVGVSQk5SWG5RdDViNmFXWEdzcjdRL1c2MXFQZ2ZLZHF5V3lxYWVwMXduN3VtVC9lWmQ4bzBRRDIwbDQxNk9cclxuICB4WUpZTlJISFhCWmkwbi9za1ZhbWF2bHJ4blhSWjdobDlDTmhMSWQyUE5UK3hjWUJybEN3ekdJRk8rTVFrVE9JbnZPNHdEZWlZa1FrXHJcbiAgUEwva2M0eUhmRk1RRWNTa2NHMWNCOTBuS0ErOUk2SXp4RmhPUk5oVHhQVlhYdC9mSVgrRUh2ZlQ4K2ZQbDg5Y2VKck1YZUNHS0NEaFxyXG4gIGhRc2Ryd1RSVmZjUStQS1h6azNFWDV2MWpvWC9DMkRqS1gwS2N2VTErN1paMUZWWFhtRDlPdTlUSjVuMEJvdXM1MTk0MDg1bForY2xcclxuICArcnc3U09sc1haakF6T01PdVRUQmhXUU4xSmtTRUI2ZUFROHppa1lSbm04c1V5RlpKbDdUbzEzTGVWMWc5K1U4cHIreElpVFkzM3poXHJcbiAgd29XS3FCUUJLdUhBSkJPbmlkQ0Vkc2Q5U2xYSHljcnFEaHVFWkpnSW9kaEZjd3d1bk9jUjMxbWhpSE9RTHhCRTc5SEY0c3J1UDhSMVxyXG4gIGNFWHg4QkdGQVFjU1I3Y0NBV0cvQjBSWXJCRmd4b083K01CNUJMRVZnNXpWdEdFRG5SNGZBemNTdFczRW95UkpQT0F5UU1Cd0hxRWVcclxuICBJanFOMkV5T2p5VFJsaUhPcUUzOVEyU0JpNGVVVlUvSStuV0w3ZGwxNmt6MzBJdHVrOWFVZkR2UExhTElkMlc2MzI5b2p6WThMY1lGXHJcbiAgSUdhQlVKQ1BtQWZUM0pSVW5hTHBqTmJQS2VGUWdHZ1lXRjNhaWVMV25pVnNZeUoyZm9Sb1FCVHExczJWMGdrbm0zdHdab3htdmFUbFxyXG4gIFd1cnJwSExKOC9aY1FWQ0kxb3lEb3BrRWFFcHYyOEhQOEZ2MzZLZmwvZmZmbDg2VURDV1M3WEx5Q2NkSXhWQjNqVjI3SnZsaDQ0TU1cclxuICBmUmc2TXZiak5uZnQwYjA0ZEpwNU5zK0hDUVBUYlhSUFdUcFJnZk0wbjEwS1RCUVFZU0Z5Y29nK053c1NuNTZEdHVFNVhjdXNmdlYyXHJcbiAgSXh6b0FkZy9IUE52bmdYaUs4N1hycGxyT2lsYk1LZ3c0cWpMRW0xdGZ2alQ1cjRrWFFrRWZxLzIrK0ovN0J6Z2s3Sk9KVkIzVzlyY1xyXG4gIHBWQkw4emZPZlZnUlAxYU5uZVozYTkyYmZ6UE9oSFNvWjJGMDROeVIzU09aVUtEdmdRc2hoQXRrSE5BYjlFaG02YWpsVFNkazdYUm9cclxuICBRQnNlUW1nWTQ0aW0rWjRncEpURitBWHhKN3BDOWhwaFlvT1MzZXQ1VzkxRHZoZDI4TVJTa1hSN1M1T082VkVtMnNMS0VyTmZISnJDXHJcbiAgeGJNV3pJMVlNSk5POXNmYWk5Smo4aXJscmJmZWt0Lys4QXR5NmJVWEo0Z0VFT0x4dk1mKy9aS0pzcDU5N25VNTVlUWp1cHg3NHNuWFxyXG4gIFRJSDljUU9MQXJOeUoxdDgrWktuWlBTWWFCM2NIZ0FmV2M4Ky9VYzVlTXE1c216NVdsdTc4dWJzKyt6YzhTZGVKcSsrN09Pak4raWlcclxuICBBNm12MmlDejNzS1NCUjBJTTJqK1k1K2xmZkFXU2Y0bThpS0lwUk4xdmFCRkhUVHUveEhFemxuVTA0bGYvZWRsR2pMVFJFbCtoOVJzXHJcbiAgWFcyYm8wZ2JDNk5jRklHTGpzYm1WcXNIL20xdGJaR01BUWNZc21VQTR0NmJQbUdxeVpvREFPNkRXYmYzVzg5cUdOZDdKQkNveFFOaVxyXG4gIDlyUWhRcHRWdVhnR08zYytHQVkyeElxUEJVUUNNY0ZLQ05OYXhEbUluOUExdUZQQjBDN3RoRkRiam1acnpOeFp0R2RFWktDN0p1R2FcclxuICBFQTkwRk9nbnNJcHFhOXhoSDJxeVQ0UzA3Yk5wMnNUaG9lbEs5TVBzM0RKSEtpdHFKRU1wTDZ1VDJaMndKVytveWI0aEJNR2FoYnFoXHJcbiAgTCtGWllGRmxDNm8wRDNrOG9pb0lCNHNWelZlVEZrUDNVYlY4dHZRZlBjT0pkcmduZlJmaC9xZ1BWNEVkUCsyd0NSTUVnYkp3Y0VIdVxyXG4gIFRadmM1L2FOaS9RREgyeDZIZm9KWXFZdHhDV2hiM2F2ZHQvK1hEM1VmQjAvRUtWbHMrNlZwcFpXNlFBNUtOUnUzeTVsTTY4d1I1S0lcclxuICBQTEVpeWl3b2xkSEhYMnV6V05NOTZIWDZqemxjaWNGaCtrNzNOOWZ3L1pYd2c4ajZqVG5Dem1QOWhHaVVDUVJJYVBDVVQ5b1l3VEFDXHJcbiAgdVQ0ejNjV1Bma3U1MEhmTk5IakwvSDliWDZuTFVMSysyeGdqR3ZXZkRtb1luZ25qQ2dROTlMQUxUSFRGZWdTMmpEVU9UQ2N3T0Y3RVxyXG4gIG8wTFNlNExJZ2lkdkZqd3o4UDBNSHo1YzhzYWRaZGVKL3UwNmlIaDRYN2pFUjhUSEdieFNOKy9ZNGtSRkM4THgwU1lKYTluYVQ4YXhcclxuICAxQ0lPUjkxdjFHRkdMSm9SNDZabG10TkJ4RnQ4ZzN4ckZTak5iZkpEZTk1aUNCbDM3Q3VEM2dSdTFyNWJuVlRBbGZqbVdXbjZQR3VNXHJcbiAgRzY5aDEwS3pXZ3UxSFVLTTc0MnRrZkh6eGtMSy9OS1I5dDNad2tJbEZpYStZbUpuNFVhcnc3Y2FJT3Blb3QxTlM5K1dmc1haY3VmdFxyXG4gIDM5RytaQ2ZXZWhCV1ZkWEt5cFhyakVCZ2VZVml2YkxTZFFpYk4xVmF5QkhPYmQxYWxkQ05mSnlBcFIzYk5yenc0bHV5UW9uQmhSZWVcclxuICBIcDNaUFN4ZnNVNk9PL1pRMmJLMVd0NTg4MzNGQngxeTFCRlRwYng4b056Nzk2ZmtDeGZ0dmczOWlwTnczRkhSTERFQjRkRUI4WGdFXHJcbiAgUGJLU0djblhDZlNzR3krWkFJdjJMTnNkbXF1WHliWnRPdHZQeXpCTEd2YjhyZGNCMXRUZVlqN3ZJUjdweXBsc3ExV2trSkZpb2l2YlxyXG4gIE9Fbi9kbFVzalJUb2NlSkJTam1STFVzTWVTUStGTUx1OFNodGlFb1AwbXdLaFZ3YW91RWZ1eUlHSFpRczdHS1JZdGdFaXAzVlVFSlNcclxuICBCL2tzb1NPNWdPaWllSVN3Y1hzTkFqUDVMNng3cFp2b21xSmN1UkNJRXRmU0gwTmc4VDY1V01ERlZoeFlPU0dtQ0thNXc0WkcraUZjXHJcbiAgdm1pd2VXdWxjVWFoRFd2SEVINHliWWVtRVU5Qk5JSlZDM1hnTUNDaVdKYWhnMEdjVnpydTJLZzkra05mSUdaZUhqRVVwcXJiMTgyVFxyXG4gIHZxUHhCK1gzdithMVArcTVlZGJQRGU4OGFNZ1JZb0ZJYXNTUlgwN0kxRU41VitSSHo4NzY2KzNYNkN4OTVZdS9rMFdQZnNmaWMrKzVcclxuICBTRXJXM20xcmhmd051Z3ovOEVNUE1SRkhxcllCNGtOM1FudDErdTVRTXJPMmdnTVJIWG4xT21icXRXL0V3MEU5Nm5nYjArMjUxT2sxXHJcbiAgeWV0alJOMzdkTWlsLzVReVJmTG9ZeUJHOUlKM1BQZnV6eGxYc2ZxVlA5aDloUHNqVE54YkZHS2xSUDZRUXk4d0pUT1RpMUhIWEprZ1xyXG4gIHlNRUNqN0tOTDE2aHhNTW5XSVRtb2RyYVNoNmNEUEdTOGNlWlJSUnh1SzBpM25IMC9sbll1ZjZ0dnhzQjY2SWZzZERiSUk3VkYyRXdcclxuICBXTkFUcGxqSDVKZDFKWWhLYzVVUXdtRndMdGxHTXNUM0hCeUdjU3VhdHZWTDV0NWV5L09uZVhBWExHNGtKSjE4VHNsN0lvUWdzczhQXHJcbiAgM3h0KzJpQW1TQUh5K3J2TElDQ1VEVzVQYUl2cjZvL2xjNVNuclpPQy9BeTU0NWF2U202Ujc4VU92UEc2NnpNd3BRMHUwNFBsVlp3alxyXG4gIElleCtyaHY2L2RnQWNSbk9FcDlUSXJLbTJ4YTB2Y0hQZm5LdG5IRFNsK1cwVTQrUzhlTkhHaUc1L01vYmJjejg2QWVYeSs5dXZUOHFcclxuICAyUk82M01IVW1TNjJHbFdLUzI3N1QwSWk0Wkg0YndLNkpRMTY1UEZ5bzJnUFNKN3dtUDZHTE5oU1RlRHZDamZrT01McmdQdlFYS3hLXHJcbiAgQ2thZUlGbWxrMlJnYVg4bW04S1dyWnpyMkRyUFo5TlJRK2JSVm9HQkVxeXZhTGVWUlhKbHZ0Q1B0QStpZU53SGxMV2o2WERlTm9YcVxyXG4gIE0xaG5hMVUybTBRQnlEbmFCNWxZcUFnU0pSNEQzdVd4REZnZjdGMEh2S1lqQk5oUXZWcEtKNTVrUkFuaXdlNXU1RHZ4V0JFaERPK2ZcclxuICBpYTJvYTMySzJvdytmTXFFNndSVFNWNzd4cUlUdVJOTjh5dXlmVnVGenFwOFR3djlzWEplMzVFMGlBTWtndGlxVXptV2hDbXVFWTRQXHJcbiAgSWxGVnA2VVJzMkRoUWx2V25oSVAycUU4aEFNeEJSK3hpYVFzYjU2WDh3N1orZ3BFSUcwNmEwUW4wSCsvWXhMMXZUOGc2M0MvdEEvQlxyXG4gIGVOZldiYngzRjhqWWtUcStzc3FublcvTlRydnNBZGxTd1Q0UE9ybkFaSTlMNlZHOURhU3F4RVNQTFI4K2JXRmgrVUd5YmZVN0pzYXFcclxuICBXajVMMjM3SDhsdFptYTE5NG1qV1dUQjVIRnlic3RSWi91ek4xbkJoaER3NVJ6OUJUcmpBWjB3Z2IrY2V5T2NkanpyK3F6WUJ3Q0tOXHJcbiAgT2k5K2QyeUNvQ1QxTVlSaFF1RGh5R092U2JqVUw5Rm5OTyt2Rnh1eWhLdmpXU3hldkVRZmpidXNSM2wrOE1FSHk5clpmNWExcjkvbFxyXG4gIGJVWmp4TWVjOXdjZEJPOFNNMkJiUzBJNXl1aVk0WDFCRk9CS1BEOTZ2NkVNb2JVSlIrSzZFUk12d3Axb25BbEdNUGZGOUR6UmR0UkdcclxuICBQQ3dzR3k5YkZ6d1ppV1JUakloZ1ljWDRKNDJsRnR5NGgyRnpxcTdqTnVSQlJEQzJ5RmZDQlFjQ0VXbFFEZ1FpUW4vaFJuQ002T3RFXHJcbiAgNGtSRTIrTmw2ckYwNlZLNS9ySXo1Y1RUbEVERzRMdmZ1MXgrKzV1L1dUeHVzaHNBUXZIVTA3TzZFSkZtNVlDQm8zVEN6dnFManh2Z1xyXG4gIFFLNjk1ck1Xdi9acnY3QndYK0R3d3lmSkFkRUdnKzkvc0ZRV0xGaW1mWndzdi9uZEE1YlhHM1RSZ1FCNXhaT2xJRFZISmsrYUt1OXNcclxuICA5aHZsQWRwek5QQUl6emVXcVpBczR3ODlBaThZQTE1eUZPMVNMdkZqNERIOWpiTFFNYkNhZkVES1dsbTBhS2x4SCsydDdWS1VYeURwXHJcbiAgUTZaTFUvME9HMkNGc2swMnIxa3F6YnUyMjh3YUdIdm9xVkxibEdIY2gxdGQ2YXhvcXl1TTZZenBGcFFsOW81eHpXamdFSkpuK1dHQVxyXG4gIGsrY0RkTHZPb0UxZXYyNnVJVG9uU3VWNlhmM2NkR0N5SlczY0NtWGJ5amRNOUJIU1lZQ0g5cXg5cldkK2dVei80T2RCdW9nbCtIaG9cclxuICBzNzJaclllOWI5eVA5eXZXbG9sd29qYjFqOWs4SHkyelB2Ynl4cHFGc3UvOTRVd3VoeFJRMHJXSlE2NThWRGtTSlNMNlJ4dVVvUVVJXHJcbiAgUjNINUpFTUE1T21QQjVUVENOd0lIeC9LU0Q5bkp5MXVDRVgvV3B0MjJLd1N2Y2FJbzY4d1VRNWJyZHJ6VTRUS2JCTXh4ZVo1anlwaVxyXG4gIDFCazFjNXZvR3Q0YTE0cXlva2lOdG9IZUFoMEYrN3N3VVNDKzhxWGZHMEptUEZRdWVrNUduZkExNCtMUzN2cTJ6SDdyWFNuSXpaR2RcclxuICBEZXdIa2k0RHAxMm9zK2JqcFZyZlRWdERuZTBIa2dTL0d2ZkZKS0VySkQrYm1sWEpSVmNZU0lBd0VZUGlTd3NSWEw3ZTIramp2MlpqXHJcbiAganZQR0xVWnQwdzR4a0R4OWh3aUJwTmtDZU5WTHR4cTNza3U1bnRhRzdUTHF1S3VqcStxdlJhSSthR1dUMHl0QWRQb01uNmJIVkhuNVxyXG4gIFJ4T3NYYUNrcEVRTy9NckxYczR5L1lUSitiSGRJUXp0Uk9jSjhIaU1PSW94aUErczlNeHMyZkRlUTZZYmNpL1ZuVTRzcUd2MWdoNmlcclxuICAweWNiWmhkRXNVNzkzaWJZNGxLdUFZSFlqcmNCYlNPaER3bDZoNWhlcEdycGF5WXF0SFZDV3MrK1V6M0hXQ2JPbnVTTTlRN3RUNzRTXHJcbiAgQ20vTDlTS2hqZDUwSW55bjlkWHJyRTJiQU83YUppeVlaWUtIR0JJQ2cvU0F1aTJyWDVEY25EUjUvL1c3ZDd2ZmVlQXFXTlc5WW9XTFxyXG4gIHNtNzU5ZC9rdW05OElYRXV5WG5FZFNiek5Pd3UrZm0vdzQ0ZHUyVFFrR09rb2JGSk5xOS9SUVlOY3FuTDdtRHQyazB5YTdaT2JQUjdcclxuICB2ZWFyUDVlNjdUdmxzeGVjSm4vN3kwL2tqVGZ3Mk51ZTZIc2M5Q3Z0Q3VWanBzck9qa2FaTmUvMUtFY2hqUFVJUE5sclpsZm9rUmNRXHJcbiAgVHpld3ZPUUpqK2x2bDdJcE1xVzhUU3EzYkxWT28veE4xNEV6ZE9oUWFlOTBGd3VVeWNqcnB6UGdJc25JMEVGbDlaUWJxZndvUmp3UVxyXG4gIFhTV0pCM1U2OVNOSmdGMlduNEFJL1hBazNUWE1MUENWeVM3SHBwd2lFRVZvdkFURVZoQVB4RllNY0FhbUV3L3E3cDU0V05xdTUvbUdcclxuICArTEx5Zk9hbDZTVHhjRmJmUlZWZXorckVpQWN6L1IxNnJ4QVBMS3o0R09CbWtGTmpOZE9uVHo3ZmxYa3V0bVlhcTZNMnZDMW0rUkFQXHJcbiAgeERBZ01WL1RBZGVCL3lVcU9BZGk3bHFRUld0ZWVEN1dwMGpmZ1pLV0dhU0o5N1R2Y0J3NGtDUk9uWTcyWnBON1l5bUhxYTNQdFAyY1xyXG4gIHQrY2hhY1JScTE2NXpXYm8vVVlmSmlPUHVkemFNdEdPdHJkS2lRZFdUVlJETHpUNmhLK2JyN0JsVC8zRXVRMEYxbitBeEhBbU9QN01cclxuICBIMHMvUlZEN25mb2RtWER1emRyV0RPazdPaHpUN1VBY2FRMTJPZndaOHdsWkhUdW15K2dUdjI2bTFzUW5mUExuTXUzeWY4bitaOTVrXHJcbiAgQ3dVTEI2SG94NVI3czFua3NZODRiVUEwS0w5TjgweC9zUEY5NDZJZ3BGd2Z2VmtmemNmQVllVkx2M1ZSRndTZWx4YUZRWHdIa2VrelxyXG4gIGFwclVQL2RGZTdkQWhoSks3blgxckR0bHphdy9hdmVqdnV0OStITjE3c2FmZXp5ZVlnaWNjcno3akd3OEpPajdVa0kvOUxBTEV5S3FcclxuICAwRjU0Vng1M3MyOHN0ZlJSRzVIQlNxNncvQURUbDJDYWJlTlNKemRNTEJKdDJFRDArb1FsNDQ2MmR4NDRrY29sTHlYT204bjZnTEdtXHJcbiAgRytMUzhYcUUzcC9RdjY3aUxEZ1J6cnZYNjAzbW40dDFTVXdXV0dTcEZhSzYrZ3lxcXVSYlY1eTVXK0lSaDdLeTBvU0w5RGp4UVBjUlxyXG4gIHdqaEFQRmdiOG5FRFl2MHJMbmZ1KzRidi9OWXo5d0RvWXY1MjczL2tuTE9QazM3OWlpenZnWDgrTFpXVk5kckh5YnMxNmRVbjJ4V3dcclxuICB3c3BzaldmVGhRQlJQSjVsa016UVJ4N0ZnQjRGWTlEN3VkM2xkaXFTbWZYNkxLbXBxVE9McSt5c2RKM1o3UysxYVVOc0FKcWxsWlpiXHJcbiAgdDJhbERDZ2ZMVms1N3NLZDcydnRtalhTcjhTVjVpQmtJeVE2TUFBMjlDa0lvaXNHREQzZ2xKMlA4cUp6bnNlelVTU3dmYXV4d3N6S1xyXG4gIElTQW9laG1NeUhrWndFbXgxVXlyQjhMeXRzSWc5N2dQZHRyMmZQckhPZExNWGhIMUlPY081elZpSVRQMlJEdjIwY1hiVGpQaXdUb0NcclxuICA2dktSb3VEbkk0WjRaQmZqeWlSVit2ZnZaMGdHcjdSNDlkang5aTJhN1cyZ0tHY0dDWGZCM2hNOEkvSnhHODdIRCtFQUdkSXZWajRuXHJcbiAgbjVIWGgzandnU05PY1pja3lnbEJqSXlJVUViVDVpTUxOL0E1Q2JObUY4OTRPL29UNVNrUm1uMlhFV1VRTE9hbldENGhIc0tWaUJhSVxyXG4gIHhGWWc4SzhaZ29BN1FWYVBhSWwycG56eFhzbkp6akpPcTYwVlF3c2wvRGs1VWZ0K2pjVHgzL3pGNnlYNkR3TDJaNk1KUC9TZU1aa2RcclxuICBmZExYWmZDMDh6VDhodXgvOWswNlRxYnJhZS8vM0xzdWtNWWRXeE1FWmZXcmR4cUhOZnFFYSsyZVdKL0RPMFU4dUZVNUsyYnpxMTlHXHJcbiAgYnhJOXIraDY5QU9SQzRCaHlkQ2g1VExzOC8rSnlxVVlJY0ZGQytWODVwQzhCOW9JejRSeEJHSEdyVHd1NXBuUkkwcUZtRkNPOGNHc1xyXG4gIFBkUVBZOGZyYXNqSHA2RzczR2ZDVlpLWXZBeVljSktHUHJtQkN6SGRYR3djSjBOOGNrMVBtS1pqMklERllSREhNc1pDT2RvbFRGemZcclxuICAza1gzTmhrT25GUGlvYy9VeEZjUkVZRmJNVUxNdVlpUXdIME1HenBRenY4TUU1VGRBOFRobGwvOXhlTGYvdGFYRXZxUWxkRjZqQ0RlXHJcbiAgaXV0QWZuV0x1M28vN3RocGx2ZHh3OWV1L1p6ZHk3My9lRkxxNjMyM3hEMEI3azNtemwwc1A3bnhHa3RqYVBMYlcvOHV0YlhiTmM2RFxyXG4gIDZ3bjZWSHRDYzR1N1BERG9WcS9YWm5yTDdKRVh2Ynp1WUhuZFQyaTZXMWJqMXZuUzBjdytGb3pURkduVFdXUjZZWm5zYWdFQitXWlJcclxuICBvYzcyOWp3Wk1yak1iaTRqSTgwNGthSk9ySVlnUkRpdjg0SW85TXhSbW5WTSsyZlg3UnEzRDRQQkY4c0xubFk1eDhjRThXRG13a3lYXHJcbiAgODRncHFOT3FiREVoM0lmUGtzTGdwbDFDSDZ3VzZvMUJQRGlTRmlvcEpsN0JBb3Z5R0FQVW0zTFI5MUx3K2xIb0QwYlRFQTkzTFFHUlxyXG4gIDRZT0ZpRUJrN1FQVE50T3lDbXhtT0dLRTY0T2NDOUhCdm5LbHBMYnVWT0t4d0xnTzdzM1hja0FBbEJ2WjhJSHNVS1RCWmx1NEU4RXpcclxuICBidUw1MEFjakRHNVp4V0k0dUNiTU1IbHMvQ0Jtb0h5b3d3eVYwTlkrUkcxWVlRMHBneUo2OFdNM3lIdDNYV2lFcTU5eUJkd2ppSGprXHJcbiAgVVpkcFNUaU9XKzFZOStiZmpHalVySEo5Qkp6QXdaKzcwK3B3MEI1clAzQmJZdHU1S3VUbHVjK3grQUVYQUFMZjhPNkRGbks4ODhkUFxyXG4gIDJiSHdYOStVWmMvOFhGYTg4R3RaL3R6TnN2VHBuMXArS0llK1pNV0x2OUg0SE91RElTTWRhM2JQaFBaK3VNOXdQZTQzMWZvS3AzSHlcclxuICByemFZQjJYdWl3a0tCSlB6cGwvUk1RV1JHWDNDVjAyWE5rZ1JlMjdwU0NNbUwzeG5qQktTMjZ3ZWJXYk51ZFkrK3V6c1RHbHBhWlBSXHJcbiAgb3hIUG9qUHg5VEgwQjIvSzlJSCtjS3laL1NkNTVhYkpTcFQxbW9iNE9lZm5xVXZJS3ZtK28yWWF4MGw2KzRiM0JlKzVFSklON3o1a1xyXG4gIGt3NHY3M1ZEdlJCblcxc21EVXhrbUpTUXpmNHVuTU9GRG1LcStQV1NJWHErOFNhdUltUXNCeUxDOXh3NGtZUTduMWk5T0VFbkR3VStcclxuICBIcVZ0blloeWRMZ0RDa1NFZlVYNHRoRnpZVFUzcnFSRjIyK1MzLy9zY3Nsbi9jeGU0THB2ZmpGQkNQVFdiR1g0SlY4OEo1RzNkcDE3XHJcbiAgK1Fqd3pldmNGSGptek1ueTVsdk90WHljd01aUFg0V0lhUHlXaUZqdENTQnF0OTUydjV4dy9QU0VucENkQnhjdVhDRTMvdkFLdWZMcVxyXG4gIG5zNGFlOVdCQk1nZUZHMnViK0FSWG5vc1UwSGpVVkpmbDBjQUx4Z0RYbVlVN1ZJdThaUDhqWjBPaVYxclh6YXhGUUFITW5yMEtObVdcclxuICA1VnZSZXBtb25oNklRNFlNSGlLVmF4YklyaDAxaXJnNnBhZ3dUNHI3OXBlbXZxNm9wT0N1TFV1a2dObTl4bjJRZTM0WThLVHRubXp3XHJcbiAgZWNnQXcyWWNXVDR5NjBBOGtnUFdReHVVT3NQcG11K0RPQmtQYld0YWtZdkp5L1ZEY0NJeXh0d3VJSGJDcWdrM0hvUk9QTHIyS2Q0T1xyXG4gIGl4Wk5iS0I1RUErL2xzNys4dnFaK1NOeFE5eUc3QlVCLytNOHFheXVrM1F0eGo0cU03NzhKOW0rczBtSnh5VGpmbGdyQStIUUs5aXpcclxuICBvWDdnS0VMYW54SEpGS2xlOFlhdElXSFJGbWE5RUNPSUNNNzIrbzFScnF4Nm5TblpuYXVpRWtBZkNiMHRGcUZ0V3paTHhwL3hJME9lXHJcbiAgbktObzREUWRzU3JIcFBlSFE4emhSMzdaUkpMV2p3Q0p0cE93OW8rSHkrbzE2K0VGcFVYSFJINStuZ3ljY1prU25iY1VhUXczbVhlQVxyXG4gIE1TZGRwMGo3TFl2RFZYSXQ5cTkzU0xadEhLY0NaV21YeFhPSWFuQWZEeEdBRTBPRWgrSVpzUmltcHdNbW5tUUVQaUZqVWpBTzFTUGhcclxuICBKNEpPMlRUM1VWbjQwTmZra01zZTFMUlBVT2pCS09WTXNEUWJkZnkxVm02VmNpUEREcjlJdGo5MWtTejRZS0ZPc2pxTWlCenhmZVgwXHJcbiAgQUwyZVhTZTZMdVBMdGhIUTlPcFg3ekI5RkpNQ1A2OGxvOURTZXJoT29WTnc1SW5JMGhaMEtuZFJ0ZXcxSTJxMGJaWjFTbUNHVHY5OFxyXG4gIFZEZm9JdnphakcxRWkzaGEzdkRPQS9yZTlEa29wR1ptMng0d3JoY1pGOVdKNnpFOE5HNWF4d0FoYm1Sc2dmRFdaV1k5aVJFSVJJWnlcclxuICByQkh5ZXZFMmt2b1JWc3pqbnQyZWdYNi9qRXZ5Y2JaWWp3c1VKZVNyWjkwbDExOStobHo3elV0bHdJQzlFeERnNXovN3M5enduVXN0XHJcbiAganJpcXE5VlZ6L1VpS05oUCs4UlIwYm1QWHgrQ1RtYndzT01rUHk5SGR0YTlHK1h1SHVnWFN5Sk9PZTF5czhiQzJBTkNkOU9QcjVMOVxyXG4gIDlqOUhWcS93dlVNQzZKZmJFMUlhSSsxQnQyK3c1eWVwMEZ0bWp6ejl0SGRicnRkV3U4RFlndG9vNXFYemNuT01lSUJRSEhSR3RXMU5cclxuICBJZzUwcE9WSTM5SXlFODhBZFR2cVplZU83UnJqdk85cmJxSXIwdFk1UHh3WlIvSG9YTWdqTktTZ1llQkFVR29uT1E5RmJCb0c0bEdqXHJcbiAgeUpSMGttRDQwUjNwODJHRk5IdERRend3MmNYTUdLTEJmZllrSHNrMkxWUUN4TXpRaVFmV0wwbmlnY3daOFJHRUk4ejZRejBXbC9GOVxyXG4gIEFVdzZxbDc5aGRVaEUvOUVUancwclVPbFNBbUgrVjZLNmxMTysrT2VaWEV0d2tkTmNXYURPSWFrTEt1bWNaM1BHZzY0QVZPNlV0OElcclxuICBoNHVzS0llNGhsbDJla2F1NlNiSUR5SWVkQXdRSkFnSy9ScWdNL0FwWDdoSER2cjA3NlNvYklMVjE1L29vRzM2N0J3RlN0TjM3anhYXHJcbiAgMW16WWJOWjVIS242TjNSSXViWi91Qnh3L20rVnd6bFlDZHhNR1hQeU54WFJIMjVJbXNXbG5HZjJEOUp6azRKVVg3WE5uMTZyWnZYYlxyXG4gIGVvMjN6VGlCancwTHRYNDZTOGVhaWJwamxMdVlmTkhkRnFjL0VCRTh6cTU0L3RjeTZ4Y3UzbHp4d20rcy82SE5MdmVpMTJOOUI5d0pcclxuICB6NDY5WXRhOWNZOTBja3JMano3aGE0azZvNCs3MmdqcTRzV0xkVDdDY3hVWk5zeE5zME43ZGgwOThNKzI5Y09uWmMycmQxb2FwNHJrXHJcbiAgMFJibDV0LzdaVm1yNzlQNzRrZmdjaEdsZWI1eWlUbytXTmZDZWJqU1BrT25HTGNJTjhKNXF4ZnFhOW9XLzJrY3hUd3IxNjJNQW0wRVxyXG4gIGtWWlhUaVMwNFNFY0NIV1FPckJnRis2RGRLWnlwUzdPY29lcGNVNGsyVVpvMDdkZlpuMk9pN0UyV0JzSjZ5d2xxczBybjVIeVFmM2xcclxuICB1OSs5M1BZUjMxZUFlSUNFZ1RqeDZLNzdDQUR4Q09LdTJhOS8vR0lzZERKSEh6bFY2dXNiNVYrUFBCL2w3aDdvNjFlLy9ndjV4dGN1XHJcbiAgTWk0RU1kYS9IbmxCdG03ZEpyLzQyVFdKZXd1Z1Q3UW5kT1owei9hWDdFRVVOMGpHR2Z4SmlNZTdRKy9uUEZkL3U1ejJ4TWFOdnNnblxyXG4gIEhVNVVROHgyaytCbFdQakVJR0EyZ3Voa1owdTZOT1dPa0RROW5aV0owM2RsbDVXQTlFdXBrSlpkVmNuMUh2NGZ4WW41NFlNdStUR0hcclxuICBrUFVlekdKeXpjK1dJZ1JGcU5qMGMvOGdDV2FZc01YVTc3ZmZVYkg2dEVlODY0Q3VYUEtpelZvckZ1TjlORVZLSjV4b3hJTTZndzQ2XHJcbiAgdzRpSG0rbUdQb1FQSWRZMy9haVprVm5mTkEvVFNVTE9nYXlybHMyTzFnOVFKeTRYVHBIQ1FuZjZDTENHcGswUklQbHdNdVoyWGY4b1xyXG4gIGl3d2U0d0Rpb1c3b1Q5TU9adHFwZW4xbVdleWo0U0twQmtWMlZJZncrTDRmNFJrazc1ODh1QlBjVkhpYTB5NmFvdjdLbDM2bmJib1lcclxuICBoM3dROG9TemYyTElQZDZXL2xnY0UxczRwM2Z1L0tROGUxMloxSzU4MjhRc1kwNzZwZ3dxNmF2Y3EybHVKRnZ2RmVKWnE1d0RheWZ5XHJcbiAgUzhjYUlhM1I4bWs2RzhZOGQrMGJmMUhpTWNlc3hPQXdRSW90VGRyK3prcnpYa0RlTm4zZmlFSVF6L1VaNmNTT2ZvQU1JVWdRSDlKd1xyXG4gIFg1eGpEUkxqWkt3U3FsSEhYV045UjlSSXVXZXZHMnhyRlhaTFVMVG5RdzQ1WDQ2L2FZazUvU1FmSXJCU245WEtGMitWMVMvOVhsYmRcclxuICBkYXcwTmJVSnprRFRsRlZ2RzNLS3JIN2xkbXNyK2J4ODNSQUs5Mko5WjNBZm5XMHRtdTFsV0Z3SE56TGltQ3VzclBmQjZ5WGlrV2dPXHJcbiAgUjVMazJ4cWcxSFFsS0hnbFFPK0J3VVhYc1ViYnBJdkxmUUpoVGk2dExSYWtWcGlqUk1TMVFibnVkYjJPaDhrMitONEpnM0dKaWJHSVxyXG4gIDY5V1RuTHdUa1dSZCtwRnMwL1JuTnZoMWZDdjMwN0FONGpGTWNxdmVzRFV6My92YStUTDN3NVVSeCtBZU92WUY5QW85b0RzeDhUWWRcclxuICBHV3ZQREw3L3ZjdmxvWWVmaTFJZkgvenovbC9aYmQ3d1hiNmxmWU9ycjdwUUJnNTByOTJyMTJ5VXBjdFd5d25IVCt1aFRPK3lFaDNvXHJcbiAgNHBHM0lGcHNwcmRvTjVuOGNlQ2xSQkNWNkZtR00vSGtic3A1VEgrVFdRb3BjbUJKbzdsaTZFenBsSTRXNVl6MHhROGNzYjlVYk5sZ1xyXG4gIE0zVmUxNjdLNVdMdXhiVTg4bmxDbkNPbVplWkxkdXRXMmRYUUpLbjZCRHUwZWxwSGd6UzBzcS94QUNzWEJoYnRKQWNaWVpSbU9HaklcclxuICBCbERaeFM2NlFsNktGUkJzUEI4YkZqWWdBQllKd2hxenloMlRYWkJ1R0t3aGpNZFpRWTVyZE5LMlFseG5SRGdoUk5uSXJvVVFPYmJSXHJcbiAgeFFvRlpUYjk4UHF4TUNJZVFTVGs3c045ZjNURUN4QUNsSkIremVpRHRiajNvMEg3WDdXT3RSMFFhSjFkYTN0bHgzekQxcmRrSzVmbFxyXG4gIGJ1bW5taVZZcUJmcW91ZkFWdDlYNzRabmlNK2kyWktaMzlmRUU2eGo2VGZxVUN2djliWFA0bHpIcXBkL3IzaytlMlFUSm4vR3ZtcmRcclxuICBudTNPaWtoc05kcnV3Y1F0MW4va3M0VCtIT0FDV09rTUI1aWVuV2VjR29zaWh4enlhVnZBQmxHZ2ZPM0NmOXY2SVNoRmNaLytrbmZrXHJcbiAgOTQyalhQbjhyNHdZSU1wYStjSXRTc0JYUzUyK1R5eDFtQ3hveisxYUlDMWN1clBWTVJ3V2JjSjFzUGlRL2J4WGFOM2FWVzhxTXYrdFxyXG4gIGJIcjNBVzN6VGEyR1cvY0hOZjJRY2pmWDYvMHN0N2JnSk5odXRsYXZ3M29rT0xlQkI1MXV5TlZGWnlreTY2ZXN5MkppTW9PN3RiWnNcclxuICBUT28vQ0pJUXBGbXI5NzN4M1g4YWtzaEwzYUhJcjliRXRpalB4NTcvUnpOUWdFZ2JCeHVOWjJ0UUFXVXhoZzF3MUlTY3dvb1JJZ3lSXHJcbiAgeG54KzdqMmZ0K2ZwcHN6VTVSMm02THNxTXg5eTdrMWFkSnhNc2pqV1dldmYvS3Q1ZnVBWm1xZGVha1RYSkk3M0FMd1g1UFZsbGJqdlxyXG4gIGV0alIycWpqMExkWFNFdlBGdmEwOGJwV093cjlsKzhjMDF2ZUJjOEFNMjVXclZNT3ZCQkVVbGxLbEJ4Q0M4azIwdEl5YlQyS1dXVVJcclxuICA2dmpDelFtRUp5dTFYVDU3NGFseS9BbUhKeEQvdSs4dU5MM0MzbURZOE1GeTAwMTNXaDJzbTZoUHVIVFpHaGs5ZXFpdFJBL0VnL3g0XHJcbiAgbVczVmRSb21SYWtmQjdDbzhMNS9QQ2xybEJDY2Nmb3hlelhweFV2dnhvMWJwYkFvWDdraVh5aUoxNDhqWms2V3UvL3lIN25xSytkYlxyXG4gIEh0QkRCOUs0YzRmMEwzY2ZMZGxsYm1vSitNc1Byd0RRZUpSTXZocUY1Q2lKb092QVNZQkZQWjM0alowT2lZR2Q2MlRKa284VVNXZm9cclxuICBBR21WL0Q0bDBuL2tGTm15d1djWk5NNUhhUXExRHBUc0daNW5uTWg0L2NEYnBVS1JYR2RIcDNFd0VKSDk5eDhuMWJtUisycnJISDBrXHJcbiAgN2dqTzgwTGN3N3AxSDlnTUg0VHRDRFRGekRGQmFvNVVVVXl5T0NtNXdweVpWU2diVitTRlBOeFI1Q2x5aENCQmdKQ2JjeDhWT3F2RVxyXG4gIFpUYXp1RjBWeSt4RFR2WWxJQUMvcHB2cHVwV1djUjcySEozelFFemdCSW8zUkQydlkvVTFoN1Vaelp2ZWxVMnYzMjREbDl6TWpGUVpcclxuICBPM2FzcEV4Q3JxNGNGekx4cUx6VnBaU0dtT0tHL0lCNDhNblVvc2lBV1RhSUIyZUdvVHdsdmJ4ekU1WnRaOTAxaXV0bHRDMGxOZ3NmXHJcbiAgL0tvUlkyYndJRDhIYjhkcnVNNEJ3bURiemVwZi96RkhHYUpGM2cwUjZEdDZwcmxSZ1VNQXRqLy9EVm0xZG8yMFJvdFBjM0x6cEhqY1xyXG4gIFNWSSs0L1BXSXVXN0FJWCt2eUQyT1VWUmZKN1Y2SVFDd1hEMTRoZGxsODZ5aHg5MXFSTGFOK1d3cS81akZsRnNnN3ROeTNGWk9DRkVcclxuICBkL1NkKzhRaTY5MDdQaW1qVC95R2NsTGY4QUlSY085K25VNzU2UFlac3A0OUovUlZLKzQwSTRuVVVXZVpGUmQxS0FhUnRmZGkxY2doXHJcbiAgNHVHYTEvNnMzT29ydG1ZRmNlS0lZNzVpSWtVQXZSZXVSY3hneGRwSzFuTWRnOGR4K2dnQk1ZL0NsbThsek9saW9vNTJ6dlVSbmNheFxyXG4gIDREcUhOVlJlMk0remp3c0tkeU5pVnRaMUdhRmV5R1B5Rk5Jc0ttUjlDTVNKQ1E5NGdUb21OclA2c2JxS0NFSWF2UXpmSU54UFpnM09cclxuICBLTnZrNXpkOFRzNjk0SXdFOGNEdENHc2xpTzhyaExvaEJCQlhRVURZc09tNFl3L3JWVS95bDc4K0psKzgrQnlMZjF6dzBzdHZ5d2tuXHJcbiAgWHlvbkhqOWRubi8yejFIdTd1RWIzL3lWbkhmdVNYTFl6QXVqSEpIZjNuSzlORFMweU9FekRrejBWWWRhVjhncFNQcUMyU1AwOW9IMVxyXG4gIHlBUHBSTkU0V0Y1dko3ckNtUHdhMjBsTmg1UkJzVkxFa1VOS3BMSnlxeE1QYmNNV0VDblNoV0F3aXdXY2VDRDJFWFB0WGo1NGtDbmVcclxuICBRWUE2WG1UMTZ0WFNONTFOVitnRGZkUXdRazUrSkJHdGg0aG5wdGhzbXJ6RzdiNDVGRjQ5dy80VGZPeklVTGV0ZU4zT0diSTJwRTBiXHJcbiAgVWRvT2I1ZVpXa2RIcXcxY3ppRmpoNHZpUElzSVhRU0E5VWxQNHBGb0J3SmwxM0RpZ1lVSjV5RWVXTVlraUlmVkM5ZjJka0Rhekxxd1xyXG4gIHRzb3J3czJMQTN1RU5EWTJHZGZCRWNvbjIwZzE1YWxHdExTMnJYL21FVmVKQjNuNCtZTG9ZR0FRcmhtdVc3UDZQZVU2YmpWdW9wK0pcclxuICBlL3grOEFtRzNIekxnaWRrOVl1L2s0TXV1TTNNWE0zZFIxVFgrcUIvdUhDQkUwQ3NoSzVpN0NuZmx2MU92Y0d1c2VyNVc2UnU5UndaXHJcbiAgZS9LM1RDU3o3TmxmeVBMbmI3YWp2cjdlUEJkRXZJdU1HVDFXRHY3OG54VlJIeWw5eHh3UlhVZXZZTlpTM3VkOVBmUW5lZGduUlpqTVxyXG4gIDY2dUVjTFQyYyt3cDM1SVoxNzBrSi81aWxmV3hSUE5YS1BjelQyZjRlTjZGRTNMOWl4S081Yk5NN0lXb3E3L21tUUpkMjJLaXNWenZcclxuICBFekVYYWZ1THJvUHRmMVpPZXFJSEFHYk5pTGRZSDBNNXpLQlh2WHliY1gvV2Yrc25OVkpseE5HWHliUkxIOVRuUGsxR0hudTFuazgxXHJcbiAgblFxdEVjZVZpU0g2NkgyRWVsM2ppUDd1TWNzOXZDa1VENStzejcxUktwYThGSlh6NjRVSkZUbzdrTHpkZzE0SEZ5amtNNTdkQkgySlxyXG4gIG1hUjdIZTlIQ0VOZU1HbkgxQmR1SkRVejE1VGo0QWpPUXlDOHJGOC9PWm55dEs4UFdTOEQwcmJJeWhYTDVlempEMDRRandDQmVQdzNcclxuICBvaXg4VVFIVUN6cVE4RjRnSHJUZm01NWsxTWk5TzBEOGIrR29JNmZLc0tHRDVJV1gzcFp0MjRJeHlPN2hqTk9PbHB5Y0xPT3dBOHg1XHJcbiAgWjRHY2RlYlJYY1JZUFVSWWI3MzZwdHozMExNV1R5OXdWeC9XUkt3aHk0bVNOZ0FEZUVHTE92Q2lvK2h1eWlWK1k2ZERvcWxtcGJsbFxyXG4gIHgwSW9OU05OeWdhV1NXWDZhR1AzRTRNQnlxRGxNWmxscjNIeWNCYUlLS2lqdGNua3FybEZBeVNscWNyTU9DRWdyVzN0a3BmV0tPMEZcclxuICBFYmRnMTZldlVadXhrSmsyNnp4QVdGajYxSzU5MTVTMnpLSmg2NUc5bXR4VU9RL0tjMlRrOVluYWlBWnBnaFB4MEdZOFdwNlpGMXdMXHJcbiAgZllVSWdoeGRmRlVucmNxT3c3N2JoeFhhaWZkTjI2UlB6QXh4a2RGLzNERTI0OEwxK3NaMy9tbVdQcFMxOHJHUG5QYUNHNUsrd3laTFxyXG4gIDdhYVBKS3ZQY0oxNXZxRXNmWXA1TW1hOVJOOHBPdk93Ni9FdS9QbndMRUR5WmtDUWFEUEZ6RW5wTS9Ha1Q2Nm9iblI5RUJhaUxzUlJcclxuICBadktzTTF3OWFjZW1lZi9TZTE4aDQwNy92aUZReXc5dGFGMW16UjhxVjdMeHZZZVYyRXd5UXM1aXdSWkZacHZmZTBobjkyKzV1RW1mXHJcbiAgeVlaMy95a2IzMzNRMmg5MjZJVXlSaEYxK2JRTHBMRGlXZE9sWldWbEtRRnFsMEVEQjByQlpGeHllRC9oRWxDbWdzQlFjbGN2WTEvb1xyXG4gIEZGbjQ4SFVtV2tOMENZZlEvY0RxYk1Wek4ydmZIaks5R09PQm5RbzNtVGZiWFNhS1RDNDA1UUM0UHljc1JpUk91VjdLRGo1TE9wcnJcclxuICBwZktqbDR5UTVQUWZZWnVIdGU2cXNXZHJqaHYxMlNCeVltMFJoR1ROcTNmWXJCbk9LMzNXSmVabHVMR3gxU1pjQXdhVVNNNzQ4K1c5XHJcbiAgUDUxdkhBeWMxcnBaZjFZT2I3cW1EN1B4KzlIalB6UkZNbW5yV2ZURDgyQ3hJdDU5M1hCRFRKd0pvTVNHMkVIY3pmV05WL0ZRQVpFZ1xyXG4gIDkwOU82ZjdIMmJPRFE4VnZHK2R5aWdaeEJTdnJZWXExdzBKZ1ZrdVY3SCs4T2VvMDRxSHZBbjBJYVVTSDdFVWVhb1pmdm5renZkWEpcclxuICBHOTk5aXo2cmJKd3Y2Z1FDWjQ0QVk4NityYngrd243K2dMY1ErcUE0UWV1dC9uQ1dsUFlybE1jZXZGbmVlbWVoSVhVNGo4ZWZlRlhPXHJcbiAgUC84VWVlZWREMjM1QUtLbWZZSEpVeWJJQXc4OEpRY2NNRFlodG5JaTVPS3E2dXBhVTNMLzQvNm41RWhGOEZtWkdlYkFFQkZXS1BOeFxyXG4gIEFVNFdWNjNlSU8rK3Q4aU1rT2pIbm9CcmYvb0NuYnlVOU5GSlBJdTBmWFg3a0NFRHRZMlA1Tkl2T1lmVVE0UjE5MTBQeWJYZi9LWEZcclxuICBEeHcvVVpadlo4TWRVdUdSQXhxUGt1RUZlTkMxak5jTDBIczVqK2x2TWtzaFJRNHNhNUozMzMzSFhoaVFsWkVwNWZ0Tms0cUdzTUY5XHJcbiAgVkVjdkV1YzQ4RW1GS0lqNExwMjVGRVFyenJPMnZXdWNDeXdZd09ycnFWT255b2JPb0tDbVBVZGFJRHpQODlrMnltSFlYZDh6SVZWYVxyXG4gIEZURms1b1VGVkxnb2ViT1hWZVpKQkd1enJZaUlCQk5ka0QzdXdwa3hzWThIQzhRR0hIQ3FiRjN3bExua0tOSDJrbjFLOW9jd2NEMG1cclxuICBwdEtabWxtejZNZkh2ZU8vYU9DQmJHVkwzYWgrNG40Z0hsakhpQkdQWUdHVldyOVJQdmpQejhtV2RHWGlxRGJqQnJ3eWV4djhJU3BvXHJcbiAgYjIzUUR4VTdlbVpXbk5OQWYvajQ2RFBQaWJLaEhtQytvQ3hOU21mQXlubGdob3Y1TXpMMGhwcTF0aCs0MStIZjYxRi8yOHEzWmQyYlxyXG4gIGY1VmhoMy9SemlFKzZXaHRkdEdHSWhpdXQvcTFPdzNSQW1OUHZsNlJLWlpOOWgrQng1Yi9UZ25yeGszU3pDNk1talZBQ1VqaG9WK3hcclxuICBEYlFDQjR2SUxJQzd6a2xMNUtIazN4UGdyQk41dkNuT3RTd0h4S0d2M3E4VG03ZnNITDFCUHdZM1loOWU4aWNHbXRaLzFwcXMxbU9rXHJcbiAgY2lGdU5lUmlSaXk1YURNQW9xSGltcGVWZ0h4Z0V5VEV0SWNmZnFnVW5QV290YlB5aFYrYlhvWXh5azZPbzQvL3Fwbi93aTBPbmZFNVxyXG4gIHFWUmlXVElXc1RYWHBUVVByV1VOak5oYk1qcW5COXdweXZjUlIxMGVsUXQxT2t5TVpXVXQ3UWRjSnQ4U0tWT2lSeDZDVGJSRXJvWTJcclxuICBzZEVRb29FSEJHdFAwN2hBY1pmNVl0eUcxYkgyWFl4RkhNZVNjRWZCeEpmQ3VEckJwSjl5WENOZngyNFFXeVhyZGtqcHJqZGt5YUxGXHJcbiAgd3BiV0Q5ejlBeVZVTG9VQnlXN2FWR0Y2RHhCNnlIdnA1VGx5L0hHNG85azdCS0lSais4cEx5blMrdCs0T0VuSk9FQktTL3BLeGVaWlxyXG4gIFVjN3VBVGZ2OU9XWTQvWDdpd0JYN3ovOC9wV1NtNU50L1ZQTTBoVlF2Z2JJeUV5UFBqLy9kZEI0bEV4ODdIdUYzc3Q1YnJJOUIwOVVcclxuICBWbGZLanAyTjB0emNxcHhEcS9RcjZTOWJkaUNBY0dBL2o0Q2trdFZkT1VkR2duaDR0bXhyeVplUkkwZEtiaTVFZ0JXNm1iSm9rYzV3XHJcbiAgTXB1amRtS0hwa0cyS0VyTnNramptR25hZ05jNFNsOFFBb2daOXBwTmRPS2lxMURmUTg4THlEL2swYmNPUmNpa0J4MTB1dVRiVEUvalxyXG4gIGs4NlMvb29Fdlg1UDRzSE1FVjlMQ1ZQWXFBeFdQOHpBa3NURDgrUDF6ZEdqSlowTDBWdzcxNUUvVFBKek0yd3c4UHBaRDlLNUMxRUZcclxuICA5VERSbmFmam90WFdjN0JOcVo2d3RUQVFXbWFYeU85TkR4SVJxbkFnS3FFK00yRE1XOUZyUUR6SXc0QUFVVkc1Y2duZVYzcmo5YzN5XHJcbiAgYWMwOFdmSDhMVEo4NWlYYXFUWTlnOXNVVElpWkRRK1I1VHBMZitlUDV5a2lteWJUcjM1Q1p1akJ6TnpiMFVJY3RLV0lsczIzS3F0clxyXG4gIGpIam9Hd1IvU0ZGaG9SUVBuYUpJL1FoVDJ1NzNpUnRzbGt3ZFp2dDRGVGJqQ0VQK1RCQ09zQVBFQ2JGa0hRTnA2NUFlS0hCeGlZSmVcclxuICBnMnZUTHMrSCsrMi9uN3QrcDI5V1hvRnljMzUvdW5FK0tNRGhvdnhjZEdnY0luUHlyZFVtN3NJWEZweEpwNTZDUzBNaGo4a3h4OWlUXHJcbiAgcmpmRnViMDN2VGNtUjRWbi8xdGI4ZmVIT1BEa1gyMjBoYUZ3dTR3RlJGdjVnN0JnVWs1aHYyUGxoUnRHbVppTHRMOEhSb08vRjl6eFxyXG4gICsyNks2THE4ZjNDLzdGRkNlYXNUaGRTelo2UmNRRFBXZVZGNXhpYlBqQ1RpVlp0UTZmdTNVUCtvNXk3amxZdFVEcHE4NUJqM1BubDlcclxuICA3eHZ0eHVQNGlpTTBEOXNRR2EzaEpyN0tnU0FhSnEyVHQrVDN3RFg5dXR1cXE2U3dNRE5CUEVEa25BZXBkeWNleENFZUlXOXZFSWhDXHJcbiAgaU1jSlJSeTI2K3dldU9icUMvVWI3TkF5VTB4UDhuSERqT2tIU1ZWVmpSa0U3QTFZbWM0RWZrQnBjZzNNeG8wVjBxOXZvZnpvUnRlalxyXG4gIE1FcTZ3R0ZUSTZRYlFKL3hYc0hLeEF2eVlxSm9ISHFVMnoxc3I2M1Ryd0hUMGd6Yjc3ZDg4QkFiaEY3ZmtUdFFyek5IMjZJMnRNM2dcclxuICBzRE1SYUhyWFpoWU1UcFNhbklPVlJlMXZiR3lhbHFwWEFsV3o0bFdOUmZWc1FJVXdWZEt6Y3ZWRHdUYmUxeWhnYm11TDJHSmxtUjN4XHJcbiAgR0puRmh2emt3RTRPY0kxWXVnSFR3a2pHM3Fpc1BubDR1dDBaeVg2M2Z2Q0VJYTlrL2RDZWg4eHFnNlVWb2hvK01oWmtoY1dEb2U4aFxyXG4gIERPMUFNTnBiNnkyZG5wbHJDLzFzMFpnaEM1R3lRUU9wYmdRRXFKcHpwNlEyVmZwc1VrOUFBTkEzV1NFOW1yWnZsb3pzQW0zT1RUWDlcclxuICBlbjVORksvMGpUVUt0TTg2R1Rnc2RDNDhQeXlzUmh4OXFZbGtxQmZxSXBhcFdjV3E2N2VVWUxYSjlLc2V0eklGUXliYTlzSVFqV1hQXHJcbiAgL1VvMnZINjM3SWMrSVJDTjZQMzUvVHJSV1A3Y0w4MHpMdkgwckVKcGJIQlhEdW42N0xuRjBwSVNQWWR6UzVEK0cxS3RDQjI5MFBKblxyXG4gIGZpN3YzSEd1SXI5S1dmVEl0MlNGcG5GendYbmF3MlFXSjRtc2VWbjJ6QytVdHNIUnBsaTlSZis2M2tSMXk1Lzl1ZlhEemFtOVA0Uk9cclxuICBWQWlQdFBRQm4zR0V6YnFoZm1ObkdrR0JFMElrbG5pZTBiMUJURTVWWXBMYmQ3Z1JWblFuci8vcVdDMTdpN1ErOTJscGJHelVzdnEwXHJcbiAgOVJIZzk4cnFScy9EL2pTRWtBeWRmcEZ0dDh3N1FSZUZVMHZLc0JpUjl3WHl0anJSUWR4RWprb3c1djNsQy9wdTN6UDlWaUF5MWN0blxyXG4gIEorSldSLytvZzJrMFZtVWhINnN1eG9KNXc5WWk3cGd6R2pjUmQwNDlpSWh0WEtWcE13SXhMcHZ4N3F2VzBZbDQyZWplb2pqdG1MaE5cclxuICB4Nk12b1BWdEQ1Qk1zR0VVK2hER0lKWmR5VHI2TGF4OVROYXRXeWZmdXJ5cnAxMG1pd0hoWTc0ZVIvNU9QTFJEK3dqSGFKMEFZYzBIXHJcbiAgSWkwZ3RJZDFGR0dmUGtWeTAwL2NOMWE2OXZmamhqdHUrNzVOb3I3enZWczlZdzlBMzlqei9jb3JQaDNsNk1Sblc1M2M4VWRmME1vK1xyXG4gIFFqMUVXRUI4TlhydTRCbW1nRzdyaUI0WUw1d2c5dXRCRkRmZ3hVYlJlSDZzWE9JM2Rqb2tSdmV0a2VWTGw4bU9IVHVrdGJWVGNuSXlcclxuICBKQ1Z2dUEwQ0lMZ3hBT3FWUldVbXhjd0w1MzljT0M2NllpQkJRTmlpbGdFekxHV0Z2UFBPWEU3Wm5pRk5PaXM5OE1EOXBhNHd5TzY5XHJcbiAgalowc2RGSldHd1V4Y24xbU5zeFFRV2loWFBDdW14aVFmTDEyTGo2d1hWbFl1ZVFGR1hEQUtXWWlDT3VNbFVtNGxudmZIV1BwK01HNVxyXG4gIGVPaTI4YjU0RVZrNDl4aFdua05FaGg3MjJlaWFQRmMzbGRXSWN4dUtPRkhPTjlWc01QOWZjQXdzL09JOE04YlcxNzh0NzcvN3BqUXBcclxuICBva1dNVlZneVdNcFArTDQyazJWbFFTRDB3NjF5dEk0aWtYNm1LUGRyRUJJRHdacGpRWDFtSUNtNEQzZnRvdTlCa2VPd21hNTNNSWhDXHJcbiAgUkZXbU9OWlp1SXVoZU1ia2svZW1LVVI1ZmxNditidUxxQUtFZGhUd3RJck1IZ1F5N3JUdkt0ZnhvaUVVVEdUeHRQdk9yYWZhVnNjOFxyXG4gIGx4WWQrS05IalpTYTFESVpQUFU4SllZdUs4Y3RDTzhib2dLaVpJMkUzNVZFeUQ5QTEwK21HdTVUUTNLeHJLUC9pQWVaOGE5NDVwYzZcclxuICBOdHR0SFFyRUUwNjFmTnBuSkFkclBRWHV4OFZqbmJiNUZPOWl1UkltMG9XNC9sQ2lsaFIzeGEvYnFZVHFsMDVzTklYUHErYVdOdVUrXHJcbiAgMG1Ua3FPRXk2dEkzYlcrUEFRZWU0aDNqSjZxUE9HZlY4NytXRlMvKzFvZ0c3bEcyNnplQ2ZnT1Q2TEM2bmZVOFZwcDZWcmRUejZPN1xyXG4gIDZwU1duZFU2bmsrMmMzRkxyVkRPNnlBbTB2T1JSUmJpSWl6MDJBMlFoYWZrbWZXZGlaS2llc3hnTkk0b2xnMittSFRBZVVDbzJhOG5cclxuICBMVFBQRnFYU1Z4Tk4yVFdpK2hwQ1BDQWNicDNWWVhxUGpMeGluYml0TlpFcFl5L1VHYkR6TmZuZy9mbFNtSnN1Qzk2K1YvTDZ1TWx2XHJcbiAgSUJUejV5K1JuVHZydXhBUDRNTVBseW5PMkUvejVtb2V1MEx1SFc1U2p1UDdPcU1IUWx0SmNaV25uM3pxTlRuOXRLUGxvNDlXMjc0Y1xyXG4gIHdEOGZmRVkrOCtsVExmNXhRVmJ1SkdscGJaTWROWFBNOWZ1ZUFESFdRLys4UlFZTVR1NmUyRjhuOUgrNjg4Zkt0ZVgxVktJRFAvdEZcclxuICBVc3VlWHVpS2RIYzZyWWQvVHhva0l1RW5DZnFTa2ptOWwvT1kvaWF6RkR6UlVydGFLaW9xYlRhY2s1TnAreGhVMURTWjZJQXlpQXRNXHJcbiAgNXJ5enloVFpYSzlsWjZXd1J6Wlhac2RCV0hYeUczVFEyZjdtSUZhZEFXMVA2Uy9sUlUxU3FXeGNWbmE2UHNnT2FXcHFrT0Y5Mm1SWFxyXG4gIE9nUE05UjU4L05SQkFRcFNRalFXcmtVWkYyc2NaUWdCdllBamJiMUdnb2dFSXVDaFc0U2tXcjlZZzhJQ1FqemNndVJvQzBKbzdqaXNcclxuICBqbDhqSHVlRHdGOFF0dStZZUdKRGp4SytWWjlCazk3N2dQMVBpcTRWOVNPcWE4UkRRNnhoZG1rYjdMd0hGeE1uSHB6UHlzbVhuZFViXHJcbiAgWlZmTkZwdkYxdS9hSmFNT1BVZGFkMVZKem9CeHByTmcwVmlXWHBQZDltd2hKZGZTTmdnaEZndDFCZzVDSm8vMU1jQ21lWTlZKyttNVxyXG4gIFJWSTI2UXlMV3ozNnArWG0zUDVKNC9UR25QQjFRL2IwRFE0RURnYWxOaUllOWdVLzRMeGYyM212NndkaUlNUS95SzQ3Mmx2TVhEUE1cclxuICBkTm5NQ3IzQnRsVnZLRUwrbVMzMm82dm1hbC9Edm9kZEllWFRQMnRqQ3NLTEdCSmxhNG1HdkdjVTAyWWNZUWNHRXJ3SERpNGQ0bjVZXHJcbiAgbWI1ZWxuWXdrSUNBa2k0LzdBSTlQbXVXUGtZOHVHWmVYM01PQ1ZKODUvWXpaWWdTRkJwRzc4STJxMTd2UWhzenBrL1JaNEJWMDhvWFxyXG4gIGYyTWNGMlVCZENvRDZtZEpaV1dGTkRlM2NYdkdzV2RrWkVtL0tSY1o0bDJwM01vN2QzN0t5MGVFbVhMb1VmREJoVDROVTNUdUZRL0JcclxuICBnQ3ZWVTJUei9FZnRQcmljWFZGL01LRGdRQVJwWnV3YXgra2dDdzhYUHZSMU05NndvcUdDSG5pbGhralRKdHNwbzB6dk0yeVNoZVlhXHJcbiAgS0NqVytZOHVoaDRUblplTmMvMWU0RHhzdDBnbEJpMDdxdlE3UUtsZTR2V2lLL0hMeGxPSWxWTlNPbzM3YUtyZFlOOE1IQzNuV0Zka1xyXG4gIGE2eVVzT0FVTkNjN3hUYUpHcWVUeUFBb2tFSHFMUzJ0Q1VSLzBVVm5XUjVLOVVNUFBkRGlvZXkrUUNCQ2xBODdFZEpubE9ZalJneXhcclxuICBjeWVlNkd0T3BrNmRhTmVFUzZuWnRsM0xmcnpyUWdyeTgyemY4L0loQStVUXZkYWVnRFVoS1B0ZmYyT2UxTlppdVNwbXBYbmlDZFBsXHJcbiAgRDdjL3NtY0NNbGpaL01hMGZoSHhVSWdHTGhCZW5BZkpmRHVUU01ieVkrV1NwMlBuWTJYcnE1YWJzaHZPWStEQWdiSnFTMXV2M0FjRFxyXG4gIERJVE56RGF2SHlhc2VyNGI5OEZHVVprNkFCMmhPbEp0emk2WHRGMnJkSGJSWkZub1dGcGFtcVNzYkxBMGRPYmF3RFpMSXoxcGgxNGpcclxuICAxRGUvU1lvZ0VHZTVZaE1yR3gxRVVWa0xUVVJGM01VN3lGN3IxcjVuc3RpcUpiZ3FHYTBIZTNJNFFXRTJ4Y2ZoZFVKZDJrdkdtZkdCXHJcbiAgdkZrZ2FhN3I5UndFbEJsY2UxTzlJVUwvK0pMOXFGNytodDdMNXNnYXhoWG1JRVlqSGxxV1ZmU2hiR2YrTU5uK3ptMnlZMmVEN1MzUFxyXG4gIGhLNVFLaVd0ZUtRUldNcjBVU0xFVnJOK25lUzFXRFdPbUFmaXdUWHNUVWJuTVhVZU9QRVVSWW9Sd2RFOC9USEhnd3NmL0xweEhOanNcclxuICA4MzVaWE1jTUh0RVBoR1Bvb1JmYTdCdUU2blZwT2NWbTNpQlZpQUw3YnBnckNoMmxiUEdLSGdJT29sb0p4NFk1RDVoNVpsYmxHN0tqXHJcbiAgYmp0RnRMWWlsdng4bVhMbEU0WTBPZnc1ZTgvUkUrM1l0TVRxaFFQT0J1VFBRaytlZmZ4YzliTFhwRVlKR1Z3ZEN5Z3JQbnpLK2dqU1xyXG4gIFpJeUV0c2t6NHFMRWlQc3BtM3kyRVFDSUJ1YmZ1QTNCL0huNXN6K3oyMlRkaU9sWXRCNWIyS0tEdzkvVVN6K1lZQXNYTVFHbTNkcDVcclxuICBkK3NIWG1WeWMwU3pXQmp1MkxIVEREN1FsUmpIcGkrejM2akQ1YldmSG1MakJXNlhpL0NIejdPcWoxNlZEKzYvVWtyR0gydGlyYzFLXHJcbiAgOUFkUFZhS2ovUWhidnBJSTk4R0JGMTZJSXUwd3VlQVlkc1FYelRWS1g5TWJla2tIbmtkWlJFUWNlaElSMzI3YS82UEsyallyMU9HNFxyXG4gIFNVSTBNSGZIc3pRR0l4Z3Q5Q1FpU2tRMWp3a21FelRHTWR2amhvV0d0bUJYQ1VyTHNvZGx6WnExOGt2V2Uxd1kzd1BHZ2NWMysrOC9cclxuICBxZ3VYQUFSQ0VPSS92dkhPaERocWIvRDN2ejl1ZFFLQklvNjRpdnFCcUxEZ0Q1TmI3b1gwLzhJaWE5eTRFZkxMWC8xRlZxeGNKMWRmXHJcbiAgaVFITDdvSHJYbnpKOTJ6TDI3ZmVUanA4eE0xN1I2ZCsvNzJKc01ZZGNxbTVkUWR5Qm1OV0NlZ3RSVzhvdkRBREcxUXhzSUVab1BkeVxyXG4gIEh0UGYyT21RR0ZWVXJhempmR2xWemlBNzIyV0FTZkVWSDdndkdreTJvWGxLUUh5VkxVbzBYSmVEakdGVjJ4V0haMWc4SUM1SG1DbVNcclxuICAzMTRoRzVmUGswWkZ6Q2dmbVhVUEh6NVUrdW9zdnpxTmZhR3BrbWJjQ011MG1iMGhpa0dVWVcwa2lJcTM2ZkVvak00aHZrTG15cUMxXHJcbiAgY3hDN3lwWGFQK3pXVTJUTGdxZDBWbjVXZ3B0SnRoUDZtU3FiNXY3TGtFQnUvNkhHbmlNVERtS3IrbTFyWmNlR2hZYU11dGNMRmxib1xyXG4gIE9Tb1hQKy9HQlpxbURFZmZZWHprSHVlUGNPMWZUNUcxRzVSelVBS2lqMFFHRHVndkIxeHdoL0tzQjVzMVZUK2RqVm9kSUtySC9pZWFcclxuICBzTVBPUk9mdFdZSEFGQ0habE4vUG1wNkRtSW1yVHJsZWxqLzNLN01LWWxPdXplODliR2FwKzUzeWJlbXJuRWlvUTRpNGtOazR5QUdkXHJcbiAgVjN3bUhzcXgycnBxNlN0SzBDRnl6TkNQTkNSY2MrK1JNbmZ1UEhOWnoyQWZYRFpJaHB6bnU4aUI5UEVEWmZIbHMyWGtjVmViZko0NFxyXG4gICtTQnUxM1A0K2U0UTZ1N1l1TUJFVGdaNkVVU1YxR1dTUTFnMDVHQlovL2E5Mm0vdkU0VkFia25vTkZFWUFGSGlQWktHYUdRb3h3SUNcclxuICA3RGNhZlUyeUR6eW5SYjg3UU5hdjMyRDNDOGMrYWRKQnNyUC9TV2JCQmFCc0gzdlNOMlh0Ni9jWWdvZHJDd3N1L1drUWFGLzBEL1BsXHJcbiAgblZnN0tZdzY0YXVXajlnTkN5NjI0L1VPNnhHVlI1elZWemtQNHFaTDBmemlFVk5sL2w4dmtja1gzV1g1aUlvUzE5SVF2MmlzY2NwUlxyXG4gIG9vbGhBT2JxbkVmMzRhSWxha1docHJldlgyQVRMcndEOEI3OEhNMTV1NFZsWVVPcXBCZ3JuamI5aVlaTTJCQkRZNW1WdGZaaFdiWnNcclxuICBtZlFyekphRjcvMWp0MnZmZXJQQUlqNTkrc0dTbVpraE45NTBwL3pnKzFkbzNyNkxzZ0xoNkI3MmR1N3VleDZWTDEzeVNYbjJ1ZGZsXHJcbiAgbEpQakl0VC9PNHdjYzdLdGJWbTk0cm05RXFjenpycEtmdkM5eTJYbVVaOVA3S2FJeWZHUGYzaDE3eHpJSCs1Nk11SE9KQ01TWWRsSFxyXG4gIEduMnZFYXFJMGxIY1FNL0VrN3NwNXpIOVRXUWx6MjFZOXJZcHJkSlpOcTdRbSs0alh0K0pCK3duaEFUaWtlUStJQUFXanluNUNNbHJcclxuICBUUzJRdnVuYlpWdFZsZUJFa0k5djU4N3QwaWMvWFNvcnFpUEZvU05OWnRmTUd0T3pDblQyUHQ4NEVBWXppQ0VnYk1JdVNGeXZUWWpMXHJcbiAgQld6VHpjbWdJbEpFUGVZY0VZS25aVUdJdm85MVQrTEJlU3l1TVBtbFA4eCttYW5CZWJDWE50dVlGdWdIMUZ1OTdJSUJOblBFRHI5a1xyXG4gIHZ5TnRwa2NaRGo3NkVQZG5vdjFTQk42KzhRMnAzN1ZERVMxZnFNdlZjN0l6cGFrOTB4YWdKZXY0TlhBaVNCd1R6UmFkS1hJT3dzSHVcclxuICBoR05QdWs2Zm1ZNmRRRHlpYzFnYk1ldUZjQkpueGYzbXVRL0xoLys4UnZZLyt5Y3k5dFJ2bTBqRjZ1Z0JjWVVBOHA0aDNzeGlHUWZvXHJcbiAgQm5nSDdLR09vUU9PSzFzYjNBcHQ2SFFYU1Jubm9tMXNmKzlQc3JXaXl0YTQwR3BHWnFhVVRQbU1JV29JQUlRQnhhMFpUT2g3Z3h0RVxyXG4gIEYwSjlpQ0J5ZUlBMHMzU3VRZnU4ZjdkYVpDWS8xWFJrY0ZDTUQxeG9ERHJvTkpzbDR5TUtiOHFEcDV3cjdjMzFzbDQ1R3RlYnBNaUdcclxuICBkLzVoWWpNZWJWSU01bFpiYkRYQXpCNHhZNU55WjJVSG4ybmNaUEh3YWJiUjBwTGZUNUtOU3ZEeHVvcytENlEyYnR3NEtUMzE5OGE1XHJcbiAgS2VhMEdUdjdsTVA5cm5ueGR6TGswRSs3RWw0SkRDN0w0VXg0S0R3WGtDczZFTzRGandxMXE1Z2NpT2xJM3Z2enA0MnI4bmZqNWVHOFxyXG4gIG1WalFqb056SS9qUVd2YjB6eUpDeVYzeVoxRzl4aGdqaHV6K0NQSm5UVTlleVhDN1Y3ams3cHhJVnRFQVU1NTMycFRHTjZacTNxbGpcclxuICB6VXY1TjJHV2dWWWxDajIyYXpNaTRuSEd0Y04xb0J0cFgzaVh6cnhYU1g1V2lseDk2ZGx5MUxIdVRiazNlUC85and5NVZsWFZ5b3daXHJcbiAga3d5eEE2Tkd1WXNua0h4TnpYYWRqVy9iWnc2aE55NGtpS3ZBZVN3R3ZWZkxrRWIvUXJreG80ZHAyYmthLy9oRVdRVUZ1Zkw0azYvWlxyXG4gIFlzRzltU1NQSGpWVWF1dDJLQ0ZUL0ZEdnhocnQ3UjB5WWtSWjd4d0lFQlRwem9INEN3WEN5ekd3YUN6TjJVU3k5M0tKMzlqcGVBSzNcclxuICA3UUVtN2o5QmxteG8xQUUyV2xNcE1lNGoxTmU4M1hBZkFYRTVnb3dRcS83UndZQncwMVAwNDY5OFQ5WXNYMkttajJ3d3RHTkhnd3dxXHJcbiAgR3lqWjQ4OFhMSytvRHdjUWRCdk1na3YyTzlxUURvdjNrdHhHUU40aFRETm5nT2dkY0dTNGRkR3pacTRieW1EaTJCb3BBeWtiK2huNlxyXG4gIFJtamVTWlVqWXBFYWNuVHlJUWkyMzdnUnhlUzllSDF2QjhzcE9DOUVUcVNaZlpxQ1UrTkdQT0xQUWVNUUQwMlpzdnpEVzZkTDliYnRcclxuICBOR1djMlpRcGs2VGZ1ZjlLMXRFL1BzZ0ZEMXd0MHk1bmE5TU9XMlRuNS9uWDUyV2JhcEhsZFNBVVdDNzFWMEptNXBiNmg3TkNpaUNPXHJcbiAgZ3BzWW83TnBCMitINTh4SGo0d2V3b0Y0aTNiWnh3R2tNLy9lUzJ4MkRrQUVBckl5MEFCaWtGMDR5RGlYaXVkdWtLMWJLdXdzNkg3VVxyXG4gIHlCR3kvemVYMkg0ZTQwNzduaXg5NmljV1luYU1pQWV2eHUwdDlVb2NIR2xodldQT09uY0RJSHhjdUVkWE40RFRDQjhXeEFackpRZ01cclxuICBlanI2U3BvRE0yWTJodHErNlVQVE1ZMHh5elZRUDdOcGk5cWlSRVJLV0lXdGZ2VjJXM25Qc2VUV2cyVDE2alhhTnkya0Z4ODllcmlNXHJcbiAgdjlyM3ByZXF6TWdWRmozNmJjbk1MVFppaUZoci9adjNTbDdwS0NOK0NRN1JLOWlzSFozYXF6OCsySFpUREcxNGl4MDZDWmpqN3VNdFxyXG4gIDM4c0h4YnJsUmVYaGZKZjgrL3V5LzFrL3RqTEo4cXdUMGZFUzVUR1o0RHlMVkFuTjh3SldpQnFQY3lLRWNOV1c3dWlVb3NFVHpHck9cclxuICB6OE9KeEYzQWEzbTlOOUxHZ1dnN3hIRjFzdjc1SDBuMTFxM0tQVndqbnpuM2VQTk50U2U0VVpIN0QzN3dGZlBJVzFHeHJRdkNKNTdrXHJcbiAgR2o0K0xnU25wb2NkRm5HekVRUnU1K09FOUt5RHpFMzlwdld2UkRtN2gxTStjYm5rNW1iTFkvOUo0bWRXdG9OQmRndjVXZWx5eEpqZFxyXG4gIG1KTFoxeEwvWkRRZVR3Ym9VYTQ3Sk0vdFg4cDJyUTRwYVpsUzJaZ2JFUS9wSXJveWMxTHlJaVUwYlRqeGdQdXdwUDA0VXZVTVExY2dcclxuICByU2lQRUYxRitxQnA1blVTYXkrSVIyWldoaUticlpLWHNzc1JWcVJBcFEyUUdqYjlmUGhHUEVENEVYZlR0ZTFVVzN2QXVnZUlCNThPXHJcbiAgc3gvT29UTmhOVGRPQTlIWDZOY2IxZXRLUER6TlpWTk5vWXFWRmZtcCtseDJiTVRrTjVRTDEzWGlZWnY5Uk1URFZsRGo0ajFPUEt4c1xyXG4gIC9GcDRVc1hQMXpUOTJCYnIvV2ZwUlpQUUhPay9LTWVCeUdyRE8vZWIwdHZNYzlNWkg1b1BONkovaUVkb043VE4yZ0wydzVodzdpOXRcclxuICA1azVibUZTdlVNSUI4Wmo2WlczTGlJZVhSK2FORlJMUG1sWDVUaHlPTkVRTHduLzcxbE5sL1Z0LzAxbngxMlcvMDc2cngvZU1NSEU5XHJcbiAgT0VabTE5WEtCYlMzTk1uNnQvOHVlRGEyeDhqTktQQXVpb3VLRXVJaWlBZEFIWFBrcUNXWmlVTThFRDlCSEp4NG9NTTR1dXVoUklLWlxyXG4gIE01TUpGdUtGZkx5OFZxK1liZmZEc2V6cG4yaDdiZnFjMzdleVhJdDJhWlAzT21qU0dTWmk0VDY1UjQ2dEh6eVpxRC80RURkTW1IanVcclxuICB6YmIxTHZlQW9yaStmaGY0MGlBcks4MW1oN2h2NFZuWW40YkVKMzd5RjVaKyt3OW55bXMvTzh6MkRPRjVRTWpXdnZrWGVlYnJBMjBoXHJcbiAgSHRlZ1RvN082RSs5WmJOVTZxUUhFUmJXaUs1Z1Q3UG5IdGFMaFBKbWphZHhyT1VzWC8vcmRCSURSOGxDejlBUEwrL3JSRGpJcTF2M1xyXG4gIHZvMVR6dUg5R1dWNTJIdmZ2cTJvRHVtRXFicCt0K3diUWh3T25mWjNLTGRoMTZGODdKdUV5d25jZnV1SGY1THFpa3JsSUlaS2NVNnFcclxuICBpYWhBMkhzQ2lBZGxBdkVnams1azBxVHhDY1JQeUl4K1gyRjJkTTA0OFdBN1dRQnYyQkFQaUJUQWVjQkZaWHZ1NjM4TE9FZmNzcVZLXHJcbiAgbGkwTFcySHNIdHJhMnVYS3Izd21Tam1zVzcrbGR4RVdnQ0s5cGFsWkgvWW9XVjhialZJRlhrOFVDVDhSOEtLamFEdy9WaTd4R3p1ZFxyXG4gIFRLUklaa3VGYkt0aHJZY08xYXdpU1NrY1pYSE9CY3NyVEY2ekNpSnJMSjJoQmlXYUtkUjA0RnYvbUZGcFp5eHV5TThIazhVVGVhd0hcclxuICBTTmNqUTZud1FLbXEyQ0paNmUybVVLZG9Uc3RXU1NzOTBCWGxqVHRzN1FUN0QyUXJTOTNlMXV6WHNuYWo5cnR3SW1rMmE4WGFoalJ1XHJcbiAgcS9rUUVWMkJ6SEhud0d6VHJhNWMxR1dEUDJxRFdSUFhRV2tPVXNkS1pXZEVOUGlJZUE0b2FNTjlKUHFnSHc2bWluQTM1dUpDWjVkbVxyXG4gIG9xcGxuSGhvdVFUQjh1ZkQ3bnFqanIvR1p1d2d1ZllOczVWZFpRdExMV0xQdmtNR3piamM2bUlXeXF5djM4aUl3OUMyR3VzMlNzWENcclxuICBaMlQ4NmQ4WFRJczU0VVlFS2JKUVo4d2dZY1JWVFZvT0N5bXV1ZWpoYndqYjB1NS8xazJHZ0NuTFViSG9CU1c4enhuUlFFR09kUlFjXHJcbiAgeXp0M25HV0tjdllhTHhsL25PWi9UaWNUN0xMbjl3RkNScUVOMHNkOUJTNXNmUGRGTVhGU1h0MzdVbDFkYmZjRUZCWVdTTTUrcDVsb1xyXG4gIENvTUwzZ1B0RER6Z0ZDdVB1SWVKQWpOMk9KNyt5bkdTdHJhNkhDT3NURGlIT3cyT1JKNHB6SWZidStEOUlFNWhKMERxYnBoem4zS3lcclxuICBSK2w5cmJQK3N5Z3ZNN2V2aVp1WW9GQTJpTHBRNEFjeGwrdDFqcFRGdHg5dVhCVlNXb2hJZGxhMmpCNHpTb1o5OGg3Yk5YSEJQNjlSXHJcbiAgb2xCblhCcjFjSnRpQ3hKMUFvTllFUEVpQjVaSTA2LzZqNjNtMy9LQnI3dXhsNnYvSmVPT2xXMnIzN0pKQzZTWFBUc1FwUUtiNXovbVxyXG4gIE9yR29MQnN3c1ZFWTNDWmVlTWxEbk1XN1h6UGJEUVFDMlBoVFlHenlQV1FYNlpqVk9HTTNSOGU4R2JGb0NIakpLTlI2NlBLd3pJcWFcclxuICBrSXpzUW1scHFKRVU1VEN5Q2dZa3lnTWVUekVwUUduVFBOT0REUjVjSWxkOTZVeVpQTlVkQWlJaUNoekY3Z0FGZDBEMkFIWG1SUHVlXHJcbiAgRStjOGVoSE9rOTRiSEhMSVJGbTBhS1Y1eFdXWFF1cHMzNzdUd3BHUlJSYnhjSVQwdlg5L1V2dTViMXpPdmdBVDUzODg4TFRnOXYva1xyXG4gIGsyTG04YjBBM0FiclBoNS8vSldFSGdUWXN3aExrZW5SeHg0bDc2d0hPZkVxWXE4bnZNRUFtazdtUkRFTHV1ZnFiekpMd1JQVGhuZklcclxuICBLNis1UzRvQUJTTlB0QkRFWTE1dk5ZNXJnbno5dU16blA5WWttdXU2ajBoMEZSMkp1Q0ZNa0RwNXZZV1k3YzZUZ2VValplbnJEeG50XHJcbiAgUVNlU3BUUHJNUWNwdTcrdDFSQWFaVU41Q3czWko5dEk1bkdrMllmSnZzL3NUd0hCb3l5RUNLSVMzTFlIMFZXeURmcU1Jem5mTnhvVFxyXG4gIFVMWldEZXM3TmlwQ0tTdy9XSERUSGk5UC9icjEwYXhOc3hBZnNDWm16ZXk3N1BsZ1lwbHdNMkoxaUtYbzdQQU8yK2FVTlErZXIvMVFcclxuICBJckxvdm91bFJUa3lnR2R4N0hYUHlxcDV6NXVveVdUK1dqU3ZaSXpKN3pWcXUvZFpablI5MW5YTXVlTWNPZXpLeHl5Zlo5cXA3Mkc1XHJcbiAgem80cGY5ZzFicWxFV1VMOFNTRnFvcCtzaFFCS2RIYTg3T21mQzRZUUprSlVKT1ppS2dXdGlDVVpYb3REdWpkZ1JneGliMTkwcjg0MlxyXG4gIDJVeXEzWkR0OU1NT2xYNFhPd2NTQjhRem1BTlhMNXZ0aEZnUklJUUFmUXZ2RFAxSWNHMENWMktyeDQwZjhEVVFqQ1BXd0dDcEI5RTNcclxuICBRbVNjQmhEN3pEUzY5S21iN0Z6MTh0ZWkwRjFMc05BdklHa0FmMUNZNDFZdWZzbjBId0ZXL25tNkxGNnd3Sit0dHJmL2hQMms5S3gvXHJcbiAgbU9rcUYxaXF6NDU5VUREYWdFQ3l0d3o1bEYyaDcySFpjNzgwYmdidXdhYUhlZ0xDZ3U3S2svUlhEdzJaWk1DaE1qNGdHZ2lYTUlhQVxyXG4gIFVFUE1TRnZEK25EWjJwZk4ybEQ4SXlhcnIxaHAzTWFxVjIrWGtVZGZvY1gwYWxIYkllNGlMWjdod1JxZlo3b2xGZ296V1VxS3BaSWhcclxuICBIRE4xOFpmbDdrOGdIcVY2R2xQZEVrdWJsMlpydjBPS056MGs3Nzc3cnVRcEhieitxeGZJdFYrN1dQRHJoSTREaUhNQ3U0TkFQQ2p6XHJcbiAgczUvZkpkKzU0Y3VXdDJMbGVsTjA3NjErZHdpaU1TRFVmZXV0RDJUR2pJT05vTUhsVkZSVTYrUzJ2N0JIeVBubm5hemw5bDFNdGkvUVxyXG4gIDNOd2kyZmxUWk9DQWZySmw0MnRSN3U2Qk5TRnNDZjNpeTJ5UDRMQkhEZ1QvNTJzM2JFZ28wZzBCZVNUOFJCQ1FBUkRMajVWTC9NWk9cclxuICBKeE1wa3A5U0oxdTIrb0l1NElEOUowaGRtM3NDVGMvQkgxZEtZdEVnZVdrWnVTWStvVSs5Y3g4Z1pmclZGVGwzUDRkdWc1bFNadit4XHJcbiAga3QyNFdob2FHa3oyMzk3V0lmVjFXNldrUU12MGo5YVJSRWVJZCtVNnV1YWgrT2JqVFNCN3phOWljWnQrekpXTFg3QVFKTzkxNC8xTVxyXG4gIE5jVWhDSWd0TjdGT3dlcUtHUmtlYTFGa2VqbS9INnVuZDhTc0RCRUFJZHdFdWhWMjJjTkRjUS9pb2NmbUQvNGpRMmY0eW1MYTRSbDNcclxuICB0ckZmZkxxMHIzOVY2aHNhalhqd0xCclh2aXI3WDNpUDZTRzhqVlRaOFBiZlRaeFJnaWlQMXFOMnR5eDQwalk1bW5ET3p6Ulh5WWJtXHJcbiAgcGFibktESDRxUkdnZ3o3cklnM3J2NVpZOWNvZmRES3cwdlFjeUw3SnhtWEsyN2VkWVROUnhIZGNnNWs4SjVtUmIzajdQalBmSFhIa1xyXG4gIGx3M0JnNENEU0FnRmJlV1NsNnc4M011Z2c4K1VEVy9jWmVJZHpGeEJYUlBPKzYzVTFWUWFnWUVUNE5td1R6Ykloamdjd3M3Tmk2eHRcclxuICBpQUp1N3pYYmtHVUFpQW5FQ1k0Q04rZUlMUEhwaGJFRVZtQ3NvcmJ6eWhteGx6alhoYXVpYnhBYjUxcUdKVGdWNXpyMjEvRXl5UWd0XHJcbiAgMWxic2p3RkJXdnJVVHcwWnI5ZStjdjk5MDJ1a1lzdFdxZG1JY2htVDAyeGIrOUhZbG1uclM3QTJHdmVKNzloYURVUi9LSnJkb0lCSFxyXG4gIG1HSkVFRzZFQ1FEYjBiSUhSL21obnpIdVk1c1NQNGoveUtNdXRYdm1CN0VrSWtXZVhvZU9FWlRXY05pSTBkZ0lEZjltOXVLMExHYmVcclxuICB6Zm9PcU51bWt5YzRXTjVyUm1hKythb3lrL2NJd2hqQTFCeEF0MFVXbkNSaGtoUGhyUUFlc2tjTkhBdHJTc0taZkR6cUtxZG41dTZGXHJcbiAgdnQ4RjR5OTk2ZDJ5ZHUxYVNldG9rZ2YvZHFNTUtCc29iQ1ByN2tLU3lteUErTzRnY0FNZzkwK2VvNXh3U1YvalBGQkFvN1BnWG9xTFxyXG4gIEM2eXRQYlVUZ0Y2emJ3Z1FsT2FyVjIrd3Vwd2puRGR2c1lVVEo0eTJPRnpPMDgvTWtyRmpmQkhxL3hWUTJ1UG1mZW5TTmJaWUVZOGZcclxuICBld0w2aWVqdTdZajdBdlpNUUNLQWdJUVhtQXlpdUlHK3hrUXlsaDhybC9pTm5VNG1VaVNyclZLMjFlakFpNkMyT1UvU2MvdnBLVzBiXHJcbiAgcEt4NWlLeVFpd1BZdVZOdmo5d0hDSFkzaENTRUlJZyt0b05laW1TVzZveW5kb213NlpDZWxlYldOdk1FWERwZ2tMU2s0eDdDRVhZY1xyXG4gIDJYY25JaEFIRktVbTQ5V3ZHOEtHTXA1RmNDajhDU0VFY2U0ajFFVlppdGdLRnlGYlBuekN5dUNKZE9mR2hYYmYrT0R5NjhidVFlOFBcclxuICBuUVFmTlI4Y2U1WXdDd09SUVR6NFlNTXo0S0FPZnFZUVI5aUhxKzNnbWdMTExxeW5TdmMvWHRxV1AySUxMVzNTcDFmQTkwMHFSSlNuXHJcbiAgUWw4MWhKQVhsTG9ZeWZ1VFlzaUg4eU9QdlZLYUZMSHFHYW5XV2UzNzkxMHVCMTk0cHhFRDd6TUU3SEV6VVFaQmd0ekk1MkNQRDJiMlxyXG4gIExIU2IrS21iblhEUWppSlUxbU1NbS9GNXV4WUthUmE2Y1E0a3ZsNkpDZ2liOVRBbTV0SnlpSjVBUUJ0ZS9MazA2anZsWGxEZTl6L29cclxuICBURW5KTERDZEJNNE9RZDY1L1REZFRqRURDY3h0QngxNHVpSldSWlpGWlNZR3lzaGxsYkwzUFg3UVB3Z1o5OUdxQ0RNdFBTdWhVd0lRXHJcbiAgVTdtaGdDdjU0U2pvMTlJbmI5UmtpcmxJRHlJeU9BWDJzNkUvbEdWYlhKVG1tSkZqSlJZSTVidzdUNVhOSzk4M1N4aWdiUEJBT2VpYlxyXG4gIGJxV0cwUUhtdUd3THkxYkdFUHFoK3R4eHV3SmhTbFZDNDFzRWlPbWtHaXBYbTB1ZDBuSEhLVkZ3d3cvVzdiejZrNm1DaFZhd3VxSXRcclxuICBQRjR2ZS9abk1tVHFlWWJrV2Z1QzJITHpQSDJQUmtTc3FPWU5NY3RGUmc5N2o1anJIVDNKYWRaazJVNkVFZENQYkowVVVjYmM2K2drXHJcbiAgS0hqUjVWeFBJcUxsTmQzV3JNUkRDMENzMjVUQXMxYkVLdWcxdzJTeWFQMC9aTldxVmJKaHpScjU3VTh1a3o0RGZET284ejUxc2lIL1xyXG4gIGNFQklCZzh1bFRmZW1MOUg1QTl4T09ta21iYndEMExDNGtKRVdTRFdNODg4MXM0ZmNjUVU2OWZlQU9MeDBFUFB5c1NKWTJUSTRBR21cclxuICBoNWc1YzRxMVFYL2lJWDI2Nis1SGpNaHMyVnkxeHo3K3R6QjA2Q0Q1K3orZXRIVXZlN1BHWWxIaDFxM1ZDWGNzQU5oZ0h5RjZLQmJFXHJcbiAgSDVER2UzdGVQY3AxaDNBdVJRNGExQ0RMVjRiOXpVVmFXOW9sV3prQ0wrUGxYSFRsQ3doOW9DU0NVRVFhelhsYXFNTVEwbERUOWtJdFxyXG4gIEpEdWVqc3BGYVk2K1U3OXNDc244UEJlbFZGWFhTdFdTRnlXOWt5MC9IZEU3OG5ha1ROMVFIM05UUE9yaWZJNDhadGFFdnZBdjFkWnJcclxuICAyR3I1cUU1b0l4eDRtSzFhK3JMRmNjdk9maDV3SUVNVWVZUTlPTUsxOUVjUDcwdmg0SWsycStYNTRNcDk4L3gvYTNsZkxOaVZlR2hjXHJcbiAgMHl5NGcyamdxc0lXSUNvUlpEWTNhSklpVnYwcnUrQXg0ejVBdUZoVDR4VkE2bGJZck5wQW0rdXZ5TVh1Z1lSeWZlL2QvVmxoYlVlNlxyXG4gIElnRUlBSXRQbDdIZ2I4V2JjdHB0N283Y0ttb2RYR1dBNkVZY2M2V2JHZXZNSHJOUERzUWhLTWJOQTYrV1IvN1BUbjhnWXBBblN1KytcclxuICBldTNCVXo5cDV3T3lCZURhQnV4L29wV2xiK3lwc2ZTcEc2Vk5FUzMzWTdmUFQyT05JV3lJVVA5eElHOE1JbWhybGxSRjdXRWhaeUlRXHJcbiAgelcrbzNXaklqVHFZejhZUGtENTFHcFM3b1A3T3ltWEtYZnJxWHRJZkthRVllOG9OMWlZSGJXaVQxbStJRlhuRTJWUnE2Wk0zMmZYR1xyXG4gIG5mNERjMjJQMnc4Y1BsSUdSWHc0Nm5mVlN5dGVxbm1jZWp1REJ6dEM0WjZ4Smp2eVc2L0xBWi82bGUydlAyem1sNncrMTV6eDFXY1VcclxuICB1UTR5b2s0R2Y1aE5Eem5rUEhuMnVrRksxSitRV2oxSE82ZjhhcFA1SHNPdHU0MDVMUXRSUC9qQ084eUpaWEJlQ0VBOFY3MzBPK00yXHJcbiAgUTFuTXZ0SFY2VlJQazZrSlo0dzcxbjlnSXF2RTJMZStzUVZDWDV0MEJROEpIQkFUVTdDSGRpMzBldUU2Nk5iTUhVckkwN0dJMlM5cFxyXG4gIE9JL3NyQlQ1NXRjL0x4ZDg3aXhEeUFCSUdTQWRrRFRpbzMwQjlBWkJ4QlRnMm1zK2F5RkltQ1VJb2YyOVFkZ3lGa3V3RjE3MGpjL2lcclxuICB5Qm5vM1hlV3I5SDdPT0Q0NDlnMDBGMm03QTI0OXYzL2ZGcHhRbklDd0NlMVJ5Z2ZzM2VaRzYvU0lSbUxnK2ZxYisrblpkczJWNXdIXHJcbiAgeU93VEtjKzFQRE9RWkxYUUVxRU9GRVZDeG4yUTFnR0RjdHRLTUpEQ0VaWHQ3V0FnSXk2aFhCeVo0enBsUjMyVFpLYkRCSXRTM2EzU1xyXG4gIHR2UmhxeE1HTWtkQXlId2dIZy90ZUp3eWlCeFFKQklQNVd4TDEraDhLRSs3V0pTVVRmNmtKdGxrNlNDZGNkOXYreG93WXl1YlRCdFJcclxuICB1M3BOeWdjM0pWaXRNT3RGb1lqaWMrVFJseHNuNG0wbnI4T21UOXpQOENNdXNYWnExcjVuMWplWUN3ZjNGVlkycTBoeUZOSGtGdlF4XHJcbiAgUXREWTFDcFZiLzlSQ3NzUGNMbjNhQ2NlMWhjTldRd0kxOEYrNWJieVdmTnRjYVRPaUdkYys1UzNxd2VJQ3dVdlBxWWdHbGpSSVhaN1xyXG4gIDgzZW4yQXg3djA5OHorVHlsS1Y5eEY3NFBjS2RCb1FEYXl1UTYzdDNmVWFSN3V2V1o0Z0Z4L2d6Zm1BcmprSEdJR0wwR05ZL1BiQWdcclxuICBZUmtCOUFEUlYwckJZS3R2ZmJKeVNueDBaZ3duRUFmYW9nVUFtYndUSzlyQmJsYUUzZS9jZGJoQ2gxc0c1dllacXVWbWFkTis3U0hUXHJcbiAgTGpCQ0UzUWNoSXNmKzY0Y2NkMHJ0aWtVMThURUZqR1lQWHY5dzcxL0lDYWxFMDR3WWtKYkhPMHJIbEVPdWNudWhmMWI4dk56cExyb1xyXG4gIEJMUGM4akpVNC9sWlZOYTljWTg4Y1ZXQlB0ZnZtc1BIa3JFenBhRnFqYXg4K1Racm56cThwMC84dmxiV3ZIS2JMSHZ1Wm51SG1HYXpcclxuICAwSlA3WmdNcmU5OTZNUHVmZXNsOVNrVE9OWUxpNDBETXNvNW42dGYyKzhCc2xuVWlYSU10WmhHdDBnWmNTWGNpd3VwMS9HTUY2eXphXHJcbiAgWUJkUUpnMm01N0E4TDArSWVMWjRLS2F1cVlLcmR5UVNqRlh6NEt2RmRyNStvNno0YUlsOCs0b3o1ZVpmZkRXeFdEQVFqYWxUSnhpaVxyXG4gIDV3aDVBSXZyZGdlaHpQZStlNW1GRUJMeUZpeFlKci85M2Q5bHloUnZjMStCdXNFaUt4QUlDQlBlY2psSFcxMEpoNWQ5N1dNa0lBRFdcclxuICBXT3ZYYjdGdGJQY0daWU5LQk5QZkFMc1ZZWDMzMjVlWkdJc0ZoWm1GTGo4MXNCY2VBMTVvRk5WRUxPaWVxNy9KTEFVU25yZDVWZktoXHJcbiAgZDE4NGlGaWl2bUpGUXZlQkdNZ1YwRjExSDd2d2VSV1o5RkhPQjF1RTJLTkJsd3dkQVNOek5UY05VVGtUbFpHZk0wcFNhcGRLZlFNeVxyXG4gIFZqMnRmN2pMenQ2NVRESUg0OUphMitnbXVxS3VtK3A2WHZQT2F2c1ljUGRBSEM0R3ZVZW80d2YzNzNXOUhwc3JQV0lXV2locG03YXRcclxuICBOZmt4TSt0d1BoNWliWVd5Rjc5QnJGdG8walRpTWhCY3J1MHRucnhuaUFjelFCQURzbWpFVjRqL1dKdVMwQjladXlteVNqbUVjWWVkXHJcbiAgTFp0WHpFM3NRVEZvNENCSkgzSzRpYmppWlJmLzUzczY2ei9POGxoUWhnSjA4U1BmTnJFSklpc3RaT1hZTkFydUM3Y2QxbjhGUkMxc1xyXG4gIEVnWGhvQjh1eWtvMVJGZTlZcGJOMWhHNTBNVFFHUmZKdkh1K1lCd1RpbDlhd0dLSjhVR0JGYy8veGtST0FOWlZaajJsaUx1NFphMXNcclxuICBXRFpmMnBVUXRTdldUZTFvbFFNKzhYVnBhbTYxZlUzb0NnZ2N0eTRzYUVQL0FjSVBJVzFGdHlwMStteXJQbnJKOUJQR2JTZ25oNTdDXHJcbiAgeDJPcURELzhJcStuUklGK0VXWnBmNnVXemRKMjFzcEE1VTVCblB1ZmZaTnhMWWpIVUtMREZlQWtrRElRUThZbFlqbUlHODhUcFRyUFxyXG4gIG9rLzdHbG03Y3Fuc3JGNXZzLzMyOWs0cHlDdVFRZE8vSkNPT3ZOU3NCTmw5a1VrTCtoby9qcEJSeDMvTnZQZml3Qk1sTzc3RGNDM3lcclxuICB3WDJYMjFqQS94anZqMmZNREFOUHh1aEo0RWF3M2tKTWhZV1dPVmZVNTRCVjFwQkR6cGQzN3Z5a2JiRUxVY2EzRk1UZVBDZU1tbTd2XHJcbiAgQitEN2NqSFRUdXNmZ0ErdHVyWHZtcGpQeGxJRU9YM0s5UG5NMCs5bWlvN1BMUW5MeC95U1Vmb2NYQ0lRSzY2Z1l3Nlg4UnFEV3lSRVxyXG4gIFA5SzM1a1g1Y09FaUdURzBWTzc0L1hkMFloWFZqY0hiYnp2SEVSQXpZaUVPaU1IZXhGaEJoUFhWYXo4bjJkbFpKZ2JEb29wNlFTUzJcclxuICByd3YvQm1vOWRCSFVEZjI0NWRkL05jS0JhQ3o0NENJL1dHeHhueC9ub3NLaW9nSjU2Ri9QeS9CaFplYm5hMCtBR0t0djN5S1pOZHVKXHJcbiAgbUdLWS93SzZ2RHdnL3ZwN0J6K3Z2MTBLSmhNSGwvaWdDc0NIR0VVODBJTVByV3NEUGJrUFp0YWhoaVBZNklqeTRnZm44UkJxZTBOclxyXG4gIFBGSGV6dU1vOFMwcG4zS205T25UUjlNNisrem9OQk5RVEVGVFAvcDdvazZvWnlHUFVrUGtzWVRaeGV4TGtpSmIzbjljKys5eEp4cE9cclxuICBBTHl1cHplKysxQWtIdEswL3VZUDJNL0VZRU9tZjk1V0VtdWhxSHl5SGh3SDhuVE5zWThVWWdVU0hIYjRGeEltdTE2ZTU1a2lxMS85XHJcbiAgZzgwQStkQkJ3SWpWZUg3Sk52MWc5VEVlZE90V3ZhNEViTDNXOVBkUldWWFZsWGhvK1BidFo4bWdBMCtWWXIyZTVlc3greGRIeU5oVFxyXG4gIGJ6QjVmR2lUbVhaVzhTQ05laGxXYTRPUTBEOUJQRUJ5bkVOUnl5eVcxZWsyNjQ3S2cwaVovY001a1FNeVplWk92bk1ic3hRWkhXSklcclxuICBIWXU1Y1dmODBNcGdJTER5elg5S0kwcGRlN1lveUpWSU5WWkk2VGpsV3M3OG9hMkpvTkdQbnZ5eGZQVEVqMlh6Ky84eGhFK2JnSXZEXHJcbiAgL0JuZ2dkajFGY25EMXlGaDhucVV0WU9QTHhUVFM3VTkrc01LOUcyYTNsLzdCS0VlcnlIQUtuamJhMFlyQlE0Ri8xSmJGejZyNzNXaFxyXG4gIFBwT2paZTNyZDVrQ20yZkQrRmorMFNJcEtCMGhHZW1wTmliVDAxS2xzTEJRejMxb1pkYTloWHNXeEZqZmoxeVorUFBMd0F1Q1JuRWpcclxuICA4dWF0cDlwenhtUjR2MDk4MXhZV1FzVERzOTd2MUc4YjhVRDB5RGRsVDAzUHNVYkczZEI0bXJLVFB2Y25KU0xuS2xIdmE4Z2ZKNStJXHJcbiAgc3hCUjBoN2wrSVBZSVVsZzNSQ3I3Zk9VVXh4NTdOVzJvMklvUjBpYmpHR3VReG92Q3hDVGpOd2lHKzlXMXNaalBQUjYvTUY5WUptSlxyXG4gIGg5MUJBL3ZJWGIvL2x1UVc5VlFNZzVCQjh2RTRZWUI0dkR0UWxwWG5GMy9oYkVPOGdRc0JRbHZNNUYrYjVSNks5d1lvNE1QMWdubHNcclxuICBuQnVKQS9ub0lMREUybE1mLzFzSTE3dm5yLysyY0UvQS9iSDZQb0IvR1h1QlB2dTBSb1lYK2QvREcrOG1UY0ltVFRqUVhJNERXREc1XHJcbiAgMDBTc3NQSTlMNnc2MTBzRlczTUE1M3VJZit5RVFYSlEyYUFqMzZLZUpzSE1uWkFkN2tLWmNGQzJvbnE3akpoK3ZtM3ZHcUNwdVVWV1xyXG4gIHJWSnVhQzMrOFBYUktXSXg1S0lIeW5QeStEZzlMN1NGYnVSRkdUejVrMUdlbHcvbmJiMkNoaWdwRVYyVlQvK2NyUmNKNTBGU3lmYVNcclxuICA5ZEI1RkE0K1VLcFh2aTY0VjFrNys4OG1BdEN6V2laV1h0TVFqcWxmdXMvaWlLeFd2WEtiV2F3Z3A3WStXaDEvRnFhMDFYUm0yUlRKXHJcbiAgekdDUklJSUJiUU1EaCszUlFqRk5QL09OUVRKZUVSWHg5cFpHYVd0dGtyZHZPMTFPK3NVYXM3WUs1UlkvOWgzYm43eGtEQlpNbm9jdlxyXG4gIEt3alo0Vjk3WGhFMEp0TG9BU0FlcysyeFlwM2tJaVpSNUt2RVFaRUlOUVBTZHNMaFNtaURFQ29zZStvbVdhcUVBQUxBRG9xNzlQbTJcclxuICBLeEZPMDJlUmtab21PWG41VXJOcGhSR0xRQ2l3ZkFwdDQ0NGVheW1Jd0Z1M25tWmxiR3hGZ01VZXlOLzIyWTZCY3hudVhCRmlGQUFpXHJcbiAgQ1NmRURRU2lRbWplZ2hXeEI0TENCQUNySlJhZVlqSU1aM0xLTFJ2OTN2UW9LcDhvWmYxelpkMzd6NXFyR2U1NDBLQ0Jralh4OHhwTFxyXG4gIE1SRmZXMk9kcmNjQldHd0xKeEpFVytPVVVNL1U1dzNSd0lpanBiSFdWcERUanZ1aG9waGZhNzlUYmtDVm9IbWQwcUQzeS92SCtnK3hcclxuICBwQ0YzY3JRY3ByT1kvVUpFdHEyZW84OWtEYWVNaUt4V1lrVmJZWHoxajhZYVN2b3NmZmVjdzNpRnZUcjhPL0pyRTNkdUExUHQrVVo0XHJcbiAgaUFPSkJZWlJXVUkzU1BGck1LRmE5dkJsK2x6Nnl6VmZPa3RTczNwSFhJRmdCTVFmZ0x6dUs4QjdnOHJLR2xNK1F6d0M4bzNyTHU3NVxyXG4gIHkyTTlrUCtlSUlpeFRqeGhScUpmZ1VEYzlvZjd1NlQvZkJkZUlYcnFTdjR2QUVleDM5amhzbkRoY3ZPMHV6ZFk4T0V5V3hjQ2dHSDJcclxuICBDbVdGL2dMRGkweEF0NlNCNWZWMklrQ3NyVzdGNmtQbmRVREExbk1hb3RHMUlIRWxLdG1GK2tzYjlodEJjbkIxT1dMNUljVGNrSDBNXHJcbiAgVUk1NkM1NXZzbnVkeFNKTzJaazZRRXBMUzZTNHlBa1lIeFdXTDJ4QVU3emhvVVFkMm9TRnJsajR0QXpFM3Q3eVVuV1cvWVN3ZDNjcFxyXG4gIExxN0pNNklUK3VCeGtCTXova0FjMEh1d29qcVU2ZDV2eXJIWGhTWU1zWUwwdGl1U2dndm80ZU1xNmg4RUJGTmc4bENlczU4MS9vMnNcclxuICBiTGdIL1p0M3orZGx6Q25mc25MOXBseGdTQXVsZGdZYmhDaFVQOG4ycFNJdmZHZTBmT0szRllrVjJoQXZQUEtlZnB2T1RHaFREOVoyXHJcbiAgb1BBRkllSWhselNBWGdQakFwUzlYSWU5ekkxNHJKaGxmcHFzUHdvUURrUnhjQkxtZThvSUI4ZzNSamk2Z1NuRTlmQXV1RVhWb0ZMM1xyXG4gIGs5U2lmVzN2NkxBMUNpa0RKcHZoQWNnZVFzRVlJQTRYTWY3TUh4bHhvQjA0Qko0ZDkyYmQwaU5iWjlxOE16TkhqZkxDd2ZhN3RNZDFcclxuICBBMkZnRXNSKzNEV3IzeldpaGZrcjBIL2NFVVpvZU8wUWxFRUhmVUxHS1VlRVRtWGM2ZC9UOWxKTUFjOTZCdGJ6ZlBURWpiSjEvcitFXHJcbiAgUGN4VFU1U0E2UFZ5Yy9PVTIvcUJIVnlmWjhRSm5qdjNncGdTYnFTSy9kMnBvSUR1Q1ZFWlhDQkVpN0hPcEd6RmM3K0lpTGFXMDdKalxyXG4gIGxJZ2dXc1hNMmQzTytQUGN0Z29pNHJzbjJuZ2FkYmdSRWM3akFvV1FmM1JsNXVJa0trY21aczZjUndlREVnZU9EazY0Ym8xdldtYmxcclxuICBhSE1FZWxmcXNKMUNtWEVmbkFzR0tNbnZ3a1BYaHh3c08rYmVxVnhCcnZ6aDUxZkpONjYvVkdiTlJzZlJ1NzRnVGp6aXhBU09vTFMwXHJcbiAgWHdKaDl3WllUbkVlNGhHUU93UWp0SUdWRi9EakczMWpxTDFCdkMrQk1JVHd3QU5jbkIvU2VPb0Z6anJ6dUgxQzl2c0tWMzNsTThaeFxyXG4gIHZ2a1dSZ3g3QmpoS1JIWVd0OTg5UUhwYm0yemVvVTN6UHJ1QURaVUllcHcwOEZ4ZXRFVjZ3SlNZNnhJV0RhNm9jSytuUUVhT3J3RUpcclxuICBkVUZrSmk3UU5Cdkx1QXNOUUZuZHdkMjVEMzVqb1ozcjViQ0EwQWV2bHlVdlZRZXJFNDJzU1pmSzZOR2pKUzgzeTFkbjYvbmEybHJCXHJcbiAgbTJmVzhyOVMyTVFPT000RGZHQmJJNWIydGlFT1B0anRHdlpMT2M5amxiclYwVFRLYzgyMWhZaWhMUXZ0VmZrQ3VsUk1SVFZzcU50a1xyXG4gIDU5aVgydHRMdGtsNXVBbmlvNDY5V29wUkxob29RVUd4YVdXOERuLzBZZHBYSGpGbExnZ0RuY0pCcDMrVEV0SVJLWWdyS2lwa3p1MW5cclxuICB5V0ZYUFc1aVBvQjlzWEZuUHVQYXB4TnRRaXpRWXd3LzRsSkxjMEE0T0NBYytIRUMyTlVQZHlQVUEvbWgrOEp5aWhya29lTXdwS2pRXHJcbiAgblhBZ2VrRzhGRFZ2QjZiTDVJMDc0MGYyTVlDd0Uzb3N6V2lURHRsZVYyM0lGU3N1MXN4Z3BtcU8vNVJnd0VXWVFsNFJPWFhJQXpIaFxyXG4gIEdnWVQ4dXFscjltQjd5b2NRK0xxSEc0eDVDT0sybDhKRVBWRG4zWlZLTmM4ZUx3c2V2UmJjdWlWaitxemJMVjJtZDNUUHdnRDVZbHpcclxuICBlemlXeEdnQ0FrUVRyQUVaY2RTbFJ0aldyMmV2RXpHM08weHN4cDcwZGExREtUSGpBb2l0Sy9vUis4Mnl0UjF3dFNCODQwYWVVVzVFXHJcbiAgeTQ4NjVrb0wyWDJRZXllT3lMRkdpY01ILzRobXpwb0hKMUoreVBsbS9zdVl3SnlZN1pZQkRDY293L1Y1RnhDQ1duMG1WazZ2ejZRSVxyXG4gIEw3N0VRems0RnJoZWQyNVlZM2tRRVpzd1lhMmx2M1kvT29ZaEloQzROYlB1TW00YkI0OFlTV0N1N1dWQ1dUOXFYdmk2ck5lSjNmbWZcclxuICBtSzdYS1RLazdyNmpHQW05QXh4RVdzeWlDS1JJdll3TW56RHRDVUQ2Z1hnRWVQQ2haNldwcWRrMmcvcmdnNlZLWUxDZzJ6c2NxZTNnXHJcbiAgVmdVSUhNM1paL21pMFhDTmtCL1NCeDIwbnp6enJIUHBId2RjOEpsUFdNZ09oSHVESHlteERQM2RyUklkUUluZW9iT1E5UHloMHQ2cFxyXG4gIEw0ckJrQUJlWUJTTjV5Y3pvMXo5alozMmhPZXRXSlI4QUpqdW12SmM4L2tvYmZPWGFOVTVBQkptQnMrZ1FYbWVyWVBScnFWSEdIUWhcclxuICA5THhrR0k5N09kOTJOVEh6anhUaW1KOWk2WlBJaS9KYmlpZEtVY3RxcWQ2R0QzeEZxSG8wNmtEUkxrdmZZWk5rUi9WR25XV3VzRVZyXHJcbiAgV3NFV2NvRncrS0NUQ25LT21OdVNLSThRRjlySXZZdkxKNW5DbkJYckplT1BqNVh6a0prWUh4THVLRFJUcjduY2ZDc3hVMFpSYVdYdFxyXG4gIDJkSnVpamxoeER5U21TaHJQTGhubDFOanVrYzVTaWNKR0xiN0lBR3N1YkR4NzN2UWViTCs1ZCtZR1d5bWZsUzFPM2JJdVBKaVNSbnNcclxuICBTSVR0V3p1YTYyWDZ0YzlZZmRwazB5T01BQVpNT05FVzlYRmZpQ05aVFk5ZXd4ZTBlZC93YythTDZHYVo0blhOYTNmb2pQZ29hVzNhXHJcbiAgYVVwaHVzZ3FhQmE2b1pTR0kwRzhoTjZDbVRIWHRMRlFYR2FJSDcwUjRxMEtKZWhERGpuWHpyT0lyMEZuYWt4QTZHRkJRYjU5NUp3YlxyXG4gIGRleVZKdDZpVDNBOEtNTVJVYUU0cHowVTR2a2xJMDFuaENzZDB2R0RTUTVLY3F6U0JrODV4L05MaHR0TUhOZnl2QzhVekN5NEczNzRcclxuICBGNVNUT3Rtc2tZQjVmN2xZVHI1NWpSRWUra0lhQ01TRS9rQkVtUFdUM3ZyNjdWSm5lakxYeCtYbDVjbXdDLzVwZGRpY2pMMVBHRzg4XHJcbiAgSjU0bmJhSTdaQkxCdlhEdmlOaUlVQWE5MDhBRFQ5V0pBSndpbm5PUGRNKzkreCt2Uk9RS0dUTE4xK3hnVHA2WjI4ZUlnUzMycENGdFxyXG4gIEJGRVUzTG9yNFBXNTZuZks5OFBlSG9Pbm5xdnZhYU5aNWExUVFtUHVVYlNRVlZWZ25RZ2JodlV4RTJWMFM5TnM4V25Zc3NHdmdUK3RcclxuICB1YmFMSit0MUdFdTBpV1FDQmJzWmxrU1E4Y0hQNWIwNWMyVFV5Q0Z5NVJYblMwYW1pNTFSYUh1NHBWZWxNMGdaVVJSV2VvaHZzS0tpXHJcbiAgenVUSisxdklnZEo2ZHhDSUIwaDkwYUlWU294U3pTU1hmRlo1azQvN0QweDc5d2F0clRyR2M3UHRldFJIbWIxOCtWcGIzTmRkbVI0V1xyXG4gIEhsWlgxY3F3WVIrUE1qMG5KMXQrL1p1LzJjcjZ2WW5mNkFObXh5dFhiZGc3QndJMHQvTkd3K3NIWXFNaERyM2xkWUZrZ2VsRDNDMXdcclxuICBBSkNPUXlpamM1SWd3OVFSMVdpTzJwejdzQTJqL0lRMEtKR0oxL0hmZUJnL2wySUQzRVpvZENDdWNEUkttaUtlNzJtT0NORlAvTEtNXHJcbiAgSGpWY2NySlovZTVRVzFVaHE1Nzd1WXdZNFl2UU9MWXVlTkxFSStiNGtYcldrdjVaTy9FMlBVNTV5dmcrMEY2T0dXbzRIdytaaVJGQ1xyXG4gIE1EQjdiTmxSYVdhZVRvanNLaFphWEk4RHo5Y1pJR2tGaUllNXlMQjBWRWIvUUF6WTYrTTRFb1h0NkpPdWsvbC8rNkp4TlJRYk5NZ1hcclxuICBYN1VvSjRxL29hcXFLaVhzU3czeGRMUTB5dlN2UWp3bzRmdUNZMW1EZnNNelUweU1SeDdJTGVReEc4NHVacE1pVFdrV0NHN2pldzhxXHJcbiAgRVJ5cTVZNVdRbnk2emFRaEJyZzNNZkVTU0ZCbmk4WXBLSUswemNTMFBsWkFuTU9UTHZuTWMxaDhPZnZtWXd3NVoyVm1KZ1k1NVF2elxyXG4gIEM1U0FIbWJuUU5KRnd5WXJzWGJSVjN0cm80bWdPSllvMG9ZajRVQlBCZGV5dXlOLzBHaFhudXV4NVBFZjIxcWNGdTBEQUZlMHZ4S0ZcclxuICAvbHFPMlRRS2RlNEhUaVY2SEFibi9FV0p0Qkl3d042VGNqMGdhYzd2Ti8xTVNXMnRrZWFXRHB6TTZqMmx5cUZmUnl5Rkpkc0w4dGJ2XHJcbiAgZk10VERBcld2UFluNDBZNHpBK2FGdUk1OHFBaHZCQm9FMVZwR25FYUhPSFlrNzhwUy83OTNZUWVFVlBxai83elBWUGNreDZnaEdiRVxyXG4gIHpDOFpKMUlmZllkd0lvd3g0MFExNUcrTXRzTXpYUG5DYit3Y0JSRmZZcGhnbGNpTDhsRjRZK0pMdWJvMTc4bEE1ZUFoR0g2ZWlWQ3FcclxuICBqWFBjeUZBZUZ6TzQ2R0VUS2lBbzFYTVcvRUxtdnpkWGlVZTVYUEhGTXlWSDN5OHdac3d3UStBY0VOM2RpYkxnUXNKc09zQXFSWXhlXHJcbiAgYjgrd1VwRXQ1VURzaUxWQ0hkYU9oZnc0aDdNbmdGQlFIZ2ppS2h3ZEFvSDdDUGtoZmVTUkg2OHlQV3lqdXk5dHN1b2UyQ3NIQWh3d1xyXG4gIEpGK3FXK0lLS1JCVUZHVmdCTENvcHhPL3NkT2U4SXlDem1yWlhPa1A2TGdqanBLS0ZsK1l4T3lQRFdRb2h5TkRBRDFJL2dEZk01eVpcclxuICBmZUErVUo0WERNWVJYa0RJeVRBZy9nUnlqZkxjRExoVVo0c2pGS25PTWZrcExpMHdEMlVHNlh1SUJFNUI2MFJjQ0VkYTJhR1NVYmRJXHJcbiAgZHUzY0llbHBmaDhOVFMzU1VMVktoaDl5am5Sa0Zwcklnc1ZsN3BZajJRL2ZyMTNqMmg2bWlpQUorb3BZRHVVZi9VaVc3M292SVgvZFxyXG4gIDYzY2JCNklaMWc0ZkdNcndIRVhHWG9ieUVLV24zQ2VTeHBudHNiYzBuQUNyc3pYVDYrc2ZuQWNpSEJBSjdsTXc5Y1hIR0l2RnJKaitcclxuICA1UmYya2ZYdlArdEtWb1dPempZWmN1U1ZzdUdOdjhpTWI3Z3VoZ1BpQWJJZ2pwTStack9jZ2FNckhYK3M1Yk9hSFBFV3pnVnhLSm1lXHJcbiAgbldkbXNjeU1jYUV5Nm9ScnRCZ212NCtaQ1dlQVhKM1ZNeTdpZ0prd00ybEVRRHduVnZCdlU2S0FLYTJiNGVMYVlxMWsxQzZSbXRwYVxyXG4gIHZYcUtwS2RueXlIZmVFSDZZaUdtYVFoRnhZZlBtRU5IQ0FIdmpYekdBWG9DVnI2ajIxcXRTSm1WMGlETFFGVGl4NmE1ajBtekVuUEdcclxuICBGdmVCL0orWitmQ1pGK2s3bW1wbDFyMTVyM0hWN0EwRFFlRWFIeW14R1RMdDAyYXBSWjl4U2tuZVFSZmNxcy9sRlpuekI5OHBMNjl4XHJcbiAgcGJ6LzB2M0tpYlVyUWhMSnpNcVd0b3creHBuaEJmbUliNzVpbkFwOUh6TDFrNmF6d2IySUd5UE1rbkZuZkY4NXNmdU1NUE9zY051eVxyXG4gIC91MS8yTHZoZWJNVk1OWkxtQ2ZieW45OWNYQWlyREJuSzJMV3lHQVJoWE5HZEVKd0pWcE54L0JRV2ZIOHpSYnl6bm5maklGTjd6MnNcclxuICB6M0tpK2JDRHMyeHRyTE0xTTF5SGVnRGNMbkhiZ2xnallRdmtwS3NUQ25hYXVURmNKK01mZ3NqQjJpRTRFRXA4OE9SdnBGK2ZQTG5qXHJcbiAgMTErWHoxMzhLZG13WWFzMnAyTlFaL04zMy9PWXZQVFMyelo3MzUzWks4aVlHWFhnT0VEOGNDTWhqM0IzQUtjQ2hESWdYdUxzWkFpd1xyXG4gIDF3YUxDL2ZWcERmc0ZjSkNQVGdqMnFMTlFJeEloeU9rQXpmeWNVQlpXWWs4OE9BekpzSmpiL1k5d1ovdmVrUktTL3Z1blFQcGJHdzFcclxuICBtZisrUVRRNjlnWmE3TDJGMGFwbWhWZm1ZMnV2bWJ4NC9mQXBBQ0oyQ0cxNm1EY1FCNHFBSThIdTV6M3M3Und6SFY4TGtXWnJDendQXHJcbiAgMXhsWWZvR0FtZld3WmlQMGhjUGFDWEU5aGs4NFZQcjE3eU90YloyaS81S1Zqb1hTTmxuNzBpMVNzK0JoR1RUNWJHczN0RUhZaFREb1xyXG4gIE9aQTB5Sm84eXZRZGpSc0lqM3U5R1BIUXYrMGJGOXBNRTFrOGJrdVFhOE81bUJ1V21PTGM2dXRmbG41YytKaENmTVBNblB3aVczU1ZcclxuICBMRVBJakpJOGZEMmh2TWVzT1RYTm40MzlhZGlRQmRmaUs5S0IrbDFOTXVmM3A4bmgzOFR4SldVa0loNUpLeXZhWW5FWEJJTVpMNFhnXHJcbiAgT3VBcUVCY3hpMlJHanFpSjJTWmxXSDFPWFdUM2JNSUZZSWtFWXRmcHA2VUJ1QTN5MXIzNU4yc1B6b0dKUnFubXM4aHQ0VVBmc0RZb1xyXG4gIGcwOGtkQ0E4UlFCbmUwdisrbG1wV3VyblFib1FJUWpKckY4ZVkvbkViYktpNVcxeG9TSkVuZ01td1lqTFFQUWM1T09zRUtzMmlCdmVcclxuICBrWEVpaVVsclJuYSsxYWU5SmY5UlRnWXhsUUtUaHYzUGN2MEluQXBJa0djQVFZRndzRmYra2Q5eXptSzhsb01yZ2NCOCtPd2ZiSTBMXHJcbiAgdGd5cCt1Nm5YM3lIalAvRXQzWHN2bW50UWtSeDFSN2lpRUJSd0xNdUEwN0VPUkN4Qllwd0h5MkswT2tmOGNDTklNTENXSUU5NWluTVxyXG4gIFBaVk9PTkhNME0yUm9RS0xSZlAxKzRUN05JR2cxcHQrMVJPbUY3TUxhSnEvQXo5enEza1BJSTlKQ3R3dEV4ak9rOGZ6aEFza2prc2RcclxuICBBL0pHSGlxclgzRzluYlZsMzRTK1BSMzNsT1dBMExCRkFUckFMWTk5U1lhV0Q1QS8vT3BhT2ZFMDF4bmc0NG9EUXZMTjZ5NU9pR05BXHJcbiAgdUh2aVFuQmkyQjNpZTUvdkRuQ0tDRkF1Y0FoK3JmY0VSNGhBeU44YkJBNW01c3pKdHY4SUVPb1NCa0lTMHNESFJUeUFUNXg2bEtUcFxyXG4gIHhIVHBQcmgzLys0Tlg1WVZLOWJ0bVFPNTc5RjVzbU5IaFJUbTVrcER1ajhNZTVIK0gwRVVzNkJicmcyWUFNU2p0QVl0ZFVrenlKVE1cclxuICBZdU1BS0ErSEFkc2YzTGVUWng0MmRTRGhsam5IekhlOUxUNDQ1eEEwYllNdE51aWlJNTZITG9EWk9Ha1d2Y0d5NHlDUWZUdkkyN2J5XHJcbiAgZGZQd0dlckh1WThRYjh3ZUxrTXlkQ2JVMUNEMTljald0YmordExZMlMwRmFvK1RCUWhmNE5VSzlCUGVoQjZJYVRaanJjTXVER0NnU1xyXG4gIHljZ3VrdUQrM2N2NlBSRWlIeTZmZHI0UkRCQUpPL0UxVksyV3NrbXVjMEczWWlFUFZrTVFGVjVUTVUvRjFUWEtSMmFKOFRLc01FWlBcclxuICBnZjhtWk5UcjMveXI2U1RZNEFmQTBvSzFCTXdRMCtvVzYvMWg0T0JFOC9CUGYxOXloaUxDd0tyS2lRY0xHU0UrYk8yS3VJRUZkbGdBXHJcbiAgY1RsTVRGa29WMVEyd1dhamlOTU0rU3ZoR0tvY2c4bnRGZW1EdEJEdndIRjROM1U4Nkt5WDUrQjdjeHh1SWpkVzU2UGJRWGtQZDdOeFxyXG4gIHpnUGFIdWErS0ZyM3N6Wm9ZTWdobjVLdHIvMU9kdGJYR3hMRWpIZjQxRk5sKy9ZNjR3cmdNdkIwdTMzOWZCdDNHWGxGTm1NdUtqL0FcclxuICBpTVRncWVmWXVHUVBic1JjaGNydE1sNUFYc3lLSVJaOVIrbUVRaWNBYkhBMDd2UWJvdlFNYWRiMklQcjl4ODQwVTFVVzQ2RXZXZnZHXHJcbiAgdmJMbGd5Zk5FR0xzS2QvUXNvY1pNUUZHSG5XWlRXNGdKazRFajVibXlzV3laY0hUMHJpclRsaFFuOWVQUllWSHk1ckh2aW9UTHZxN1xyXG4gIEVVSFNLTXg1ZnF3RE1pS3JlWGdYeHRmV3NCa1hhWm1qekpHanJaOGFPTjY0RTU0djd3SHVBSXMrQ0JwNkhYeU00ZGdSZ3N0Q1dIUWlcclxuICA3UExJWUVjUGdxbjZwbmNlTUhOdHhHemwwejVqNHpxdTYyQU00cFdZY2NjWXduOFd1eHFpSHdHOHpCQjlENi9LUUIySGNCNVlxdzJZXHJcbiAgZUxLZE00amFZZzBLM3l0amw4a1czRjcycW4vSWxzM3I1UTgzWHkwbm4rRmV1d0ZtNVhBT0FPRUhDNVltOXZMWUV4ZUNxSW55NWVVRFxyXG4gIGJhRWdTdkFoUXdaYTN0NDRrVGduRU9LRUhQaXdtcUtjeXA3cUI2QU1CSUtROVI1WWczSC9wRU1ZcmhQU0hQUTF1RVg1djhKdHR6OGdcclxuICArT1hhRnozSTQwKytzbWNPNU1MVDNQNTlmYVhMY3dQUWVZZGtMQTZlMi9zNVlFci9wTk5FUG14WG5xZVlzaFZpMFZKZmJXc0ZhQU1SXHJcbiAgRGRDOU5aei9HUVl6Q0Zja2pKQ2tIVUF5RDRzUEVDLzFHTmh0VGJ2c2c4REt5QkEyWmZtb0lyTkhhNGY4YnZHTjJkT2xwS1NFSEduRFxyXG4gIFBVWm11blFxY2xxM2NiTXNtLzEzeVd1SWZISlpQUjZ4aGxFNkhpZGNyN04xU3VGdDFZbEgxL1BNdEZFb055dEJIWEhrWlphUFRtSGtcclxuICBNVmRFWmFMMjlRK1gyWmFuZjRRYzlSWDBKV28zeWdjSkk2cEQrYXc1K3FHL0xhT092U1phZCtQRWc3VWRjR01VNE9OcWJ1NHdvNEVNXHJcbiAgcFZYYmNIdStiWW1Kb3lEMEFMNjZhcFRqTU0rMWltaWNlUGo2QkJUSllaZENGTElBU0EvdUFRQlpBcGl6aGp5QUJZVWdJYmlGOXJZbVxyXG4gIEs0ZS9yZzF2MzI4Y0IySWlOcXN5cmtEYmc4c0pwczF3RXBWdjNDNlpPbTNuZmlEMHJlMXQwbWZJL29Za2c5VlUyYVRUWmRKRmY5UVpcclxuICAvNCtrcldHN2NRdHovbkN1TEh2bVprUHNTNS82bVNtSFVlSnVtdnVvRXZObmJUT2puVnVYMit4OTgvekhHY1NXdithMXV4UkpYbVQxXHJcbiAgMk8rZSt3WFpqai83aHpMOHlDOGEwUU5xVnJ4bGZROGNDZ0Jua3BGYmtDQW1jQ1ZMTmI3c2J4Y3FzWEtFeUxzcTZETkFYdi9URjJYQVxyXG4gIHpDdU0wQVRyTFYvNzhwcWxQM3o0RzhKS2QvSnd5SWh1aHJIRW5pUEdrV2phVzNQWEpJZzdzZllpQzA0RVk1RGx6L3dzS2lPMmR1VDlcclxuICArNzZpWTBiVDJnNVdkSEFnY0xCT05Md2M3OHJxYUJyREFrTHl3cmliZHRsRE52YXN2Qjc4NFljTFhRaDdxdk9NR2Mvc0gwSi9FOStPXHJcbiAgL2pIbXM0cEtUUytUdWZ4ZXFkbTJWZTY5OHdiSktmTHhGSWN3a3djd2R3M3AxMStmcHdpNmR5NEV4RTA1SENvQzdNOUJYcGo1N3c0NFxyXG4gIDkrYWI3eHRTRCtWQ25QcGpJMTFNNEJ6MkJvR3pRS2Z5M251TEVuVkRTTnRBdk0wNjdldkhCYmltNTF2WmwvNVdWOWZ0bVFQSlRtbVhcclxuICBleDk4Um5KMUZpMnh2ZEY1L3c2SmlBK0tDRHpHSUxHSVFvaDRYbUZIbFd5cGRzU1RYcnlmNnpxMFBzUUU3b01GWU14WXlXdmVYcUdjXHJcbiAgUnFuTk9yQ0k4ZXNneDEycitRTVRneG9rNllqWFovcEpaRXdZMHNyRlZDNDNlUzF4VThScXlDQm5SbGt5N2hpZitlR2FJeXBQbUxTa1xyXG4gIFlxYVBCZGM3VXFJem9jeW1EYkpyMTA0clk2eXpQbmxtYlJtdHRaSTlEUG15Y3graExTeVBOT0t6dWFodm1JVHlUT0FXL0JwZDc4VXNcclxuICBWVFRrdWRBUGpBakNlZy8rME5kNFd5bkcvbU9OdGZuOWYxc2ZrWVB6Y1RKcjg3SitvT1RNMVdlSloyQ2V4U2J0MTBCRk5JQi91Q21DXHJcbiAgbTRvcGw5eXJHVW9rMTcwZ05iVktHQlRTOUZaWXUxRTBhTFFzZStWdVJZejRCVkpFVkZoaW5BR0VKNnhqQUxuM0dUWlYrMVJtb2g0WFxyXG4gIFliaytBODRENE5wd0s4aldoK3JzbVFtRE8rcnoxZDJJaXVBV05HbXc0YTEveU1HZi9ZTWl4eHROajhDQjRuYkFoT01Oa1dPYVdqcitcclxuICBHQ1VTeGJMay9zdk1HcWE1c1ZrL0NqNExrUUU2RXg2bWlCUlJLUXM4bHo1eGs5Ulh1d2dWQk1ielJZZFJQdTA4YXh2dWJkaU16MHBoXHJcbiAgMlhnWmRPQXBwbU1vbi9ZcEM4c09QbDA1eVpQTThncDlBaE1TQUFzMlhIZHNmUGRmdGtCMHEzSVFMTUJEU1l4cmtrTXV1OC9HOG5ybFxyXG4gIFJuai9LSkEzelBtbnJKMzlGK05DOTFkaXR1VHhHNldqYXFHa05telJEN1ZXVXJYNzJibVpjdmdsZDhpRWl4K1FoaDIxem0zb013S01cclxuICBpQnJ4eFNYSkYweC9BMmVIZDJBejI5Wjg3c2ZHZ1FJY0tPT0pDUnRqMXZyejluM0dxY0IxOExoUVlDTnlSS1NYbHBsdHBycDVmRHZhXHJcbiAgQm52VnNPZ1NEbzJKQ091cWVMOVVaTFU1bDJIU2dCOHRmR1kxMVd4VWJtV2pXVklCWmlpZ1FHK3dFRVI4eGRobHgwdTRRQlltMnZjZVxyXG4gIGcxMDZHU3BZZTcvTW5mdWVISC9NVkRsc3hoUkRwTDNCWS85K1NZcUs4bVh6NWtwenU0RkYwNm1uSEtrejU5NjVrTUJsRUNMK2V2VzFcclxuICBkMDEzRWhBMkNKWHp2VUhRVjdBdVkvNzhKWEw0NGI0ZE9OeENzSjVDTExVdjFsZzhqM0NkSjU1OFZRNlpPakhCZGNUYm8wekl4eEhpXHJcbiAgRVRQM3pXUjRiOEErS1EvLzYzbnpDZllGdmRhZTRMSEhYdHd6QVJreXZOd1U2YTM2WVk0ZU5seTJzMjdGRUV5QUtHWkJ0MXd3UUFLSVxyXG4gIGUzcFN2MnFaODJGUy95SHBCWklaN1REb0xoY3dKOTFnNGl2RUNtYjJxUWkwdmJsZWNIUE8rVjJibDBoQlpESGl5RGtlNm5VMG5nejlcclxuICBxRjNQS20wbFhvTW5taWlJQVk5NENUa3lvaFN1ZzVWUGt5SzMzQkxsQnZTY3QwbVlabW5pZUUxRlZ0eWVYU0pGQTBaTGFkWjIvY0MzXHJcbiAgU1d0cnV5bWZPQ3EyYkpMTWJlOUszcGlUdkc3VVAzTTlvbkZYUWlyM2dUNUQvNFllZnJHbC9WckpmdXVQL2ljSkJQM3RvNFNtZHUxOFxyXG4gIDdiOE9zbmdkYmNkOUNiMHJwUk5PdGxrL1NrdHplTWVkUjJXUVNiTUJGTVFEem9PUXhXbHVOVVpKWHplUXJlMURiREhwWGEvSWpUbDhcclxuICBlNXZ2MDlEUzBpRVZ5MmJMTVQ5YVpJU2hzNzNGRlBHWXF4cngwTklnRjVDblJpM05yRGRQRVJIaUlseU5BS3RmdWMwNEw4eEpvNExtXHJcbiAgTkJJbEw0ak1sTlNLNUJIOTdOcUtOK0JGSnVMZ2ZMNGlRMmJjdzJaZXBPTmxrNng2K1E4NncvWjFKNXZuLzhlUWV2VzhoMlRuTGhkZlxyXG4gIHBYYW1TdkhnOFVvTmQwcGovVTRUM2JIekkvYytmT1lYWlBEa002VjAvMk5raUJLSHNFZ1Fib1JGbXlENWF1VWEySkVSY1JJY1dOVkhcclxuICByeHIzUVJyUHh4dm1QR2dFQ09KVHFvaDg1TkdYeXBnVHJqSFJGKzF4clIyYmNHc3Vzdml4SDVnUEt0N25wSXZ1TUNJRk41SVZjU2pFXHJcbiAgZ2RIVHo1RzVUK0hPM1h4QlNsNSt2clRrREROejVnWDNYMlU2R2NTZmNEUk1mRGlHNmIwc1UyNENFMkMyM0VYc0JtSEJvQUNkR0FRSFxyXG4gIFFvSXVEVU1EZXk4NjNya0krVVpFOUh2QUV6UUdCSEJRNlZrRlNrQnl0QXk3Umo1dlhCNXgzTmpQL3RsMFd5eExXWnd3THZuUDk4eFBcclxuICBsbzlOc1hVa2kvLzlQUmwxM05YNkhwVnJUMHUzdFVPRHRRN25BYjVGRmgwaXBnSVFjMEw0ZUs4MnppUElYZnhiZWUvZGQyUndXWWw4XHJcbiAgLy9vdnlMSEhIMjdJZExaeUZxeUxpQU43WjBBOEFGeXRUNWpnSGk0bzM1dElLcVJCeXAvLy9Ka0p3Z0ZDWGJ4NHBabXRocnplWU9mT1xyXG4gIGVzbkx5NVVoUXdZa0VIeS92a1dDNDBIYVBPYVlRNk9TZXdicWhmb28wMW1id21NaUhjSkFPRUs2bzczRHdvOEQ2Ty9OdC94RlNrcjZcclxuICB5SmUvNU9MRzNRRitzZlpJUUlCZ2lUVndZTG5VTm9Hc0xLbVFpRVJSVHlkK1k2Yzk0Umw5VW10a2MxVzF4Vm5WWFRnVUIyMHBDZkdWXHJcbiAgN1RRWWliUUFuT21CMU5qUzFIUWVHcmZRQnFqMkJ3NEVOV2xJaDd3b1Rzak1EN2NKekVvaEJDQ2dvUHZBenc0V1AreUZ3R3crTnlGS1xyXG4gIENtMDUxK0Z4T0JpZEJSbXlWY0tnSDBOTlM3NlU1ZTR5U3gvOXNxVzVwYzN1dExtNVNUS3EzcEhjVVNjWm9zREZlbnBPa1F5ZWNtNmlcclxuICBmZWMrVWlMdUF5SVJpRWJ5K2g1eVA1Ni9adFlmemJ0djRuNjVtcFhENHFwY1ozS0hTYlkrUjl5THU5V0wxOVVmWVkwR1ZsZklwRm13XHJcbiAgQmtjMDVOQUx1aEFQOUI2SU5RWXJJbStwcnpOOUJyc1E5a21yVW01cmgrQkZuTGw4Zm1HUjVPWVhTbWRHZ2VsbzhOOFZyTHdRV3hVcFxyXG4gIG9VYk9UOXFRbEQ1WEVON1lVNzVsT2dSV3J5TlNCT0JJQUxwWnIzRmsrSWh2SUJLbUc5TTJDTkZaWU5tRUZSdG0zOHl3c1c0YWZzUkZcclxuICBkcTAxci8zWlpyamNMZWZHVHpsS05zeDdSbHBhVzBYNVEwblZXYlJPZlpWZ2ZVTGZ3NW1LK002dzJUWUVzL0tqVjB3SlhybmtGWnRwXHJcbiAgSTQ0Q29mS09DSG0zQXlZZXI1eklPS3ZEQVZjQ1o4dzVGcDd1MHJFTE1VWDB0K3laWHlsU1ZHVDErbC8xdnRKc0FqVGxDL3J1RGo3TlxyXG4gIExPK3dQS3RjOHJJc2UvcVh0czhHbmQ3LzdCOGFFVzVYN2dXeDI2ci9mRXNKWUlOazZya09mY1hsMHo0dEU4Ly9uU0xWY2hsMS9OVkdcclxuICBNQ2FjOHhNTFdUOENvVEFpb3R6ZHBybVB5T1o1ajVvdWh2dmg0YktYQ2twMmdESzJGNGtTQzk0UFZsT0lDYzE2VGQ4Qm5DTDNqYmNCXHJcbiAgakNUZ3NCQnZzZENVYjRBTm5PZzBlaEQyR3VrM2RxYjV1aXFiZExiclEzQm5BMmpmY1dYVHNHMkRFb1phNmE5Y0NRUm5oWTVGRmhXR1xyXG4gIE1veEppQWg1RUhjZnMvcTZpaDF4WnI1N2d5eFlzRUQ2RnVmSnRWZDhTajd6dWVUc2VIZGN5UHNmZkdUckd5QVlJRjBRTXpQNDNhMExcclxuICB3WHozN0xPVmsxV2dMTWdieDRaNG9BVkI3d2xKLy9LWGR5ZkVTb2loUVBEQmF5MzkvMjhRZkNBUTJkbVpKajRlTmFyYzJnM3RoNzV3XHJcbiAgZE0vL3Z3TFBpeDBRc1VUYm14NEVLN045SmlCWkJXWFMyTzQ3eGpra0lvbVhEWGhNZjN1VTg3eTF5NU5PeGpvNk9oV2grYVpFZUV0RlxyXG4gIGRNR0hpQ2trZVpqSFFsUjI2VWRWV09hTy96aWFhN2VZZVdHU2FJU3dPK0wxQStUaTNJdm1heWNnSEF4WWtBekVnejBuUUFpSmVvcndcclxuICBQUjZaODJvNnRJZENsUStJZm0zKzhIbmJ2Q2h0OEV4SjJUckhXRmdXRHFXblV6WkZxcXEyU2YrV0paSXg3RGpyZjE0L3ZVYTZtL2V5XHJcbiAgM3pWbGhpbjM0VzMzY2k5R0dMbTI1aWxSUkJ3RzhqUW5rSG9maVhPVXQrZnJCd3Y4UURiZWI4MnpzaTY2Z2lOQmJzM3g0WVBYeXBpVFxyXG4gIHI3ZHpvUXlXTzZ5L2dTTkQwZnJhanllWnVXN2hpQ09rWXQ2RDB0VGNiZ1NrWFJGTFdtT0ZmUGpremJhM3VhL3p3QmZWVCtpSkVpVmZcclxuICBGQVp5S2g0KzFaejNEVGtVTit5emZDTWlmZmFJS25nUGNCSVFCNUFhU0F2aUFVSmN4eUpBa0JrSVhJRnpjQUdZNmtJNGd2ZmNkVzlvXHJcbiAgT1oxaEl6NGJNUEVrSXpJczJGdnczSjlzRjh1dzhWSkg0MDQ1NnRyN3phZloyaGQrSlUwNzYzVG0zRzdlWWVFMmhoMytPU05HL2NmTVxyXG4gIDBQQUx4ajA0c2ZBRmdyZ2pnUlBpV25aZ1hxcmNqWmNiTG1OUCtwb01VZ0pCZXVpTUM0M0l0VGMzMk9KRXhLWExuL3VOY24xemxPaFVcclxuICB5SVN6ZmlnampyallQQTlnMWd4cytlQXBROWo3bi8waktjcHNrQld6L3lHZHJXM0dmV1JrWmNyTTc4MlRsY3BwRlNnUlcvN016ZmFjXHJcbiAgMFJtaEMyRXI0SmQvY0lBUmFJZ2VybEVnS0p2ZSs1YzlXL2FxWVhKbVRpNjFwaXZjUDU4Z0lwVWZ2V2pFQTRzdDI1MVJ3WWlJM2ovN1xyXG4gIDRETVo0VjNaT05GSmxVMVFkREtTMDNlWWJSNkdDTTYySEZCQUhNeDRESnRSUVp3V1BYSzlqYmttbmJqUkRoUEM3T0tCOXMwREpoSFFcclxuICBHOEtuSEhFOC84Sjl3RzJsenJsZWxpMWRxZ2dyVGY3OHUrdDBNcEV2bFJYYmpEQWNmUEE0UTU0ZkxWMHRZMGJIdklZcmpCODMwc29BXHJcbiAgY1hIVXVuV2Jla1cyNW1WVzI2SU9SQ0I0eVFWQjk4YTFkQWZPQitSUEhORmpibTZPeFdmUG5ydlBpLzU0cjlRQm1jK2YvNUZ0ZGhXNFxyXG4gIExOcVBpN0hXck4xa25FQzQ3c2NCOCtjdGx2Y1hMSk5qb3Z2WUhXQ2l2TThFSkwyZ1hEb1ZVZmw2WGlBS0xRaDVJWmxNZTA2VTFpQnVcclxuICBmWlZXTUVJeUM5eDZBQVNEemd4TGpFeGxkWm10bXFVSW1kb2VPZ0FRSmM3eDhsZ25BdExrT2wxQ3lub1lSL3I0MExGZEFmdVZhNVlUXHJcbiAgQllpSU8zYnJZeDhUSHdoaFZyNzJJNnJmVzN2WTZyTlRXMFB0ZXAzWnVlMC9DeHZ6eDU0bzdSdmZNQkVXMjZlQ3RMS3lNbVRUcGkyU1xyXG4gIHYyT2U1SXcrMlRpVzBHWlg3b05yeE84QlpCNUVWNTZHWXpKWnZ4SXN5b1U2bU90aWNVVVpEcFNSbStZL0lvTVBPVStmbmJkSlBuK1lcclxuICBoUElNTUYxRzk0SEl3VVNFbk5VeVQxM2JWMmZKZDV1T1k4TzdEeWhoZlZQR25mbGpMVE5DRVdDT3JIM3REbWx0YVlXVzJlcjAxb2J0XHJcbiAgY3NqVlR5ZUlCMnNxMkVZVkJURnRRaXpnSERBckxkZitrSTREY25wMm8rTjlRankwV2RQallHcU51SVdObmpMeWlrM1BzQjVPUXdrRFxyXG4gIE0yQ0lCMHJudVhkZmJFaVNSYVpCYklSZUFSRVF5QklybjdvVnN5UmQzNTB5Q2NxRGRFcG5XcGFzZSs2blVyL3BmUmw4eEplVkd6azVcclxuICBRU2lBNTc4NVNwSHBhOXIyRjAzQkRYSGF2bjZCSVg0OEpFQTRXT09DOGNDT2pZdU1VQVZsZVB3SVlpaG03cU9PdmR5Snl2VFBhRHZ2XHJcbiAgR2tldzZ1WGJUYWFQemdkaVF2L2hnRGJQKzdjUzBCdGx4K0luWkh0ZG5hbVI4VGlHajZZVzVXNXh3Ukw2d1RQWXB0Y2hoTk9ZZXNsZlxyXG4gIGpUaWpBNnZtK3ZwT2VhNkU2S0tZK0JneDFqUUFGeFRuUkFET000SGdlOHVMeGdhV1llYWRWemtKMXBMQTVUSHBZaDhSbW1KZHpjWjNcclxuICA3cmV5S00vUmFXTHF5MVZ5ZEx5UlgzN0lwNDNyR0s3UEhPS0I4bnpkRzMrMVNZUVZWQWhFQk9BOXN5Q1Y3M2JGVy8rVXJMUU91ZjJXXHJcbiAgcjhyeHB4eGpoT0crZnp4cG9pYUFtZjc0OGRFZVF0MEF4Qjg0bERoeFFKbmVHOElOQkFmRUdTY2M3N3k3MExhVzNSMVFKaUQxd0JFMFxyXG4gIE5EUktXWm43WW52dStUZGs2aFNkQk84RHhOdTYreDdmaVRDSTZIZzg1QWVDMGRqUVpOdnI4bjN2eTFxVGZZSGF1aDN5K0JPdlNtRmhcclxuICB2cHh5Y3NSSjdnWVluM3VGam9aV0tjMXFzTzFkOXdUKzdxTVIwQjAwZTNwcFhaU0E2NCtzcnhRUVgzR2VtWnBaWDJrOHlGdzU0aFpYXHJcbiAgbVN3aTFEeEw2azh5MUVnc3BBd0g5dnNrTWQ4bHplQzFERDB3cjJ6UWp3SGxPU3VFSVNMa1d4djJhTHEyUnh4NThaWVBuekp1WXBCdFxyXG4gIEZNVXBYOUZlZHZwdmRKWlJMa1ZGU3V3VVdoVFo1dVpteXRLbHk2WG0rV3VVZTVocm5BZW9ETkVSU2xEcWR1OTdiK0gyZGZPTm5TZk5cclxuICBOZTBjZmJLRXV4Vlo5ZEx2emI2ZTdVVTlQenBuN3JXdFMxS3g0Q2t6R2lERHhRemVQc3JuNlZjL2FacytrVWIyRGRpR1cxcG1oeUxLXHJcbiAgb3BLaFJvOWdRZUJDbXRvNnBGK3B6MURRaGVBOTFaV2pUanl3aGtLUE5lcVlyNWdsRUdDRVV3R3VnOWt6RXdaRVZvaGVjQ3R1ZTZvb1xyXG4gIDRQc0paSmlaVTJ3Y0NVZ1NDeVZrK0psSzlFSFNJRjF1aTNNZ3h4VXYvdDRXbG1LQk5PR2NHeTAvUFN0TFdwWExhRWVFbFpFcGZVWk1cclxuICBrcU4rTkYrTytjMDJhWHpoYS9MWXhXbnl5RVdwTXZ2bng4anJ2enhXMktScHYyTy9LT2Y4ZHFtYy90MS95MW0vV2lCSFhQSWJPZXl6XHJcbiAgUDVmcGw5NGxNNjk1V0taKytrYVpmUG8xTXYxVDE4dVJYLytQSEhYRHEzTHV2WjFkRGdoYjY2SjdaZEZkbjlUMlUreFk4bS90dnhLU1xyXG4gIFNaLy9nOHo4eHROMm40Z0luN2x1cEJLdFY0MnpQT0dtRDJURU1aZkpwczFicFZWWmp6WTRUMzNtK1RyckJ0YS85US9qbHV4NTZETklcclxuICB6Y3F4NThMNGhSTlpPL3R1RTBueWJIazI1UEY4U1dDcHRubmVJOWFPalEyRkt1VTQwSmU0QXR6eldHZ0xKNElva3JFQWNVRjhoV2RjXHJcbiAgSmg4VTZ6Zm1TTFBDSTBGVDA2OTkybHlxMk82TlNuRE0zRGRZWUFFYTVCYVgyZm9RZkgxQmtPR0dVWmJIeHlxbGVaY3NXa1NoWHZucVxyXG4gIGpkSzNPTjhXQ3A3NENWL3JBWHoyd3RNTXlYSXdVeWRrUFVkdndEazJhUXFBYUdaM3MzV1FmeUE0QUh0d0FPZWY1dzRTYVd0M3dMbEFcclxuICBQQ0JTVTZkT1RKUS9kTnFlOTlub0RxRmU2T2U3U3NDQTBIN0lEL2YxY2JwNEQ0c0lQL3d3ck1YYlBhUjB0aTRFRit3Vzhvb25Hd0VCXHJcbiAgQ3NhNWZOQmZjd1FXOVhUaU4zWTZRYU0wYjVRc2x3VnJsTzFYNko5ZktNMERmREVSTW1EY09NVFhmaUMyWW1hUDI0ekNhTjhLc0JmRVxyXG4gIGhGWFR5Wms2WVpqQlJ5SW44dlRESTRTQUJKOVh0cWhKa2FiN3dUcGNxMFZyTkppaGRuYjZQdXRSL2U2NkQzZVllTHJGZCtyTXNYRFFcclxuICBlQ040c09uSnNuN04xamszeXVyVnEyWEhqZ2E3MTR5TUZNbk16RlFrVUNnWkkwNDJ4YS8zdFh2Ly9YbzhNODhuRCtSK3Y4bXZRNTV6XHJcbiAgWmFuR2ZXRE95d1kvdm1CUUViN2VxNXZNZWwzK2NMZGRmdGpuakNpanNKNXorem5tRUpGelhrWnMxanA0aXJ1Y3A2RzNiajFWRHYrcVxyXG4gIEwvU2p3SnUvUFZrT25qUlY1anh4dSswdmpsQW9JejFGUmcwZkx2dGQrcndzbTMyZkVvK2hUb1MxUXYyMjFVYWdFVVdoREFjd29jYjZcclxuICB5WWlMSWpnQWM5dzFpdlRZdlk2QmlLNWszZXQvTWVJRGtRRVJBM0drU1EvUmxVejV3cDkxcHZ1bVBvYzdkZVk3UXlxWHZpb3pydkU5XHJcbiAgRFJiK2xQWTZaZU9HamJhR2hiV0lyRTdPTHhrbWxSdFhtcWlSUlhrWm1hbEtOSGptRG5DTzdIK2VrcDVycmxvZ1lvMjdrdnNmN0E1NFxyXG4gIGY5bEtySkJiQTNBTU8yTDFhSGR3MlZBZEZ5NnV3dElLQlRkS2V3RGlBZ2V5YmVtTDlnb3lNdE9rb2Q2L08wU2k1ZVhsTXZtSGErMytcclxuICArd3lkYks3N2VUYm9URURzNGRsZy9zdWlTQWd3encvaUFCRUo3d0ZpOHNadlQ1R3hwM3piMmtZRUIrQlduL05HMkpWZ1lOalNnaG0zXHJcbiAgUGtPSUI5OEg3MjNwa3orUm1WOS8zb2kwdlRETzIwUUVDN2dIYlE5MjJ1NnJYT2h5ZENPSVMzVThVcDh5Nzl6NUtSbDEvTFg2RHRrdlxyXG4gIGZick11Zk9UY3VqbC85SlQrclpnRXpVZkRoT0RoSnpxMmZyZW11VGlUeDhuMTMzTGR3R013eDl1ZjBDdXV2SUNpNE04NDRpL093VGtcclxuICBHc3FnNzBDM3NEdTQ0ODRINVN0WDRCMjZLMENrZHFjYkNIMmdEQWcreEVONVRJU3h4dG9YaU45UGlIZS9SNTRwNHk3a1AvN0VLM0xtXHJcbiAgR1hoOStMOURkdDVrbXdCM3REcmgyaDBrdjV6ZFFIM2RmRW5OemJDakIvQWwrODl1b09zNWlFY2Y3QkVWTWpQRDZsSkFRLzFIYk1YWFxyXG4gIHcrekRkdS9Udjh6OHlHbWl4bmR0V21RS2RFZDhaQkZxS29xSDBNNTVBVk1xTTVNaG44R01lTVlKQ3Ezb1RKc1prTWJOelRaNVZ0L3JcclxuICB4dU8yT2pxS0YwWnVRa0NZV3lJL1AxN1dFWHptakJ0bGVQbFFLUzdJdFFlY201V3R5S0JaS2lxcXBMUVJkOGxLSVBTUGVqMFBBZzJqXHJcbiAgQTRNQVpOTmR5a2ZuMXJ4MnB6VFdiamJ1Zyt6UngzOHRFZ2w0T2Y3WXpJbjlHUnFxVjl1T2VDdWV1OFdlZzdYbi96b0RMclA5U2lxWFxyXG4gIHZtSmJ6czY5NS9OZGlJZCswNFpFMW40SVc0c2JmUWRES3RYVnNxMWl2UkxTWWRvWEpnZHdINjhaOGdWcHRUVTNTTjFhLzNoelMwY2FcclxuICBFb0xqQXlBZXJGdEFMTUs2RFp4UXpyM3I4MmJKaFNVT1NCSENBWUFzUDJMR2JTbVJRNzcwRjdNMlFqeUduRHg5NlQweU5HMk52UG10XHJcbiAgVWp0cWEydGs1NDQ2YVcxcFVlU3RDRnpyN0ZSMnYyTERjc0dSczVKOFNWVXVtT0hZM053bXpZMXRockNibTlxbHZxWktPYU4xMGxoWFxyXG4gIEtSMU4yeVZETDByNWNJUjBibDVHNHNqSlRaZVdwaWFwVS9ZZkVRRDZMOXJqYU5HalhkdmR2R2FObGUzWHI0K3NmZUZtSmVUbkdXZnlcclxuICAydGY3eXRvWGZ5bzcxN3hpcjQ0dnBGbnI0Qk9XOHVSdDJMakI3aCtUNG9MK2c2VHlyVHZ0MlFUaVViSG9SUXRSa2gvRmFuWUZpRERQXHJcbiAgbDFYdGdST0JTTXo4MnJPeW1VMmtBRzBjbHo2c2E0RkRBWGhITFR2RE50Tzh6OWxhekRrUjNzMGJ2em5KM01JSENKeEl1Ym5qRnhOZlxyXG4gIElmS3lqYW1Vd0pzRlpEUW14NXp3TmVPQTh3ZU0wMi92YlRuc2lrZHRqTnFnaXNxdzhIRkE2NGV5WnUwNk9YRC80WExJWVk3TXVnTTZcclxuICBpZ0J4Wk5zYnhCRXZzS2Z0VzJrakVJL1FYdGl6ZkhlY0N4Q1FmQ0FlSVI3ZzVWZm1STEc5QS9YUm9RQmhiVWdJZjM4YlVneEo3T01lXHJcbiAgOGhjczJEdkhzSytBbUl4eHVHYU5tMTN2RHNMM3VFK1FGaUgvM29CWGI3OGU2UXF4dk5vT1Qrd3NkcnZsK29ybHBnY0IwZmppUWYyQVxyXG4gIDJzTmdRWHdWTFdMVWF1YTIzZUswNFFqU3dkTitBSHJHUGd4M3pvYjhuandRWHBENU03RDVVSmdkVmVuTU5RendVRGR4alNnTzBUSFJcclxuICBqeEtKTFF1ZTBETWdWOHJnNEpGOXNhUCs2SG5xNUI3elN4azdkcXdwNXZEY2k5NkFoNzFreVJKcGZ0bjM0Z2h0OXg3eXJ6OTYyQ1piXHJcbiAgSVE4aXBaSFZ5bkd3TUF6bHFKMEFyTGpYc1RZMFhQbkNyODNKM1ppVHZtbm44bldtUC9iazY2MHM3Yk45NmVIWFBpdlZxOTZVblJzK1xyXG4gIDFHZmZadHhWVk1BOHRjSjE0WFJ2NHJWelpFdGx0UlRrczRjS0JBUjU2VTRwYWwxajRyaitZNDh4NGpGMCt1ZGw1TEUrNjJJclZmWXFcclxuICBvUUtMOTV6ejZFd1FENGpNbXRmK2FNZ09mMHhIZnZ0VldmM3FuV1pXYXpOcVJYN1U0M3A5Qnc2UjRRY2ZLV21iWHBTM2J5aVY5Uy9kXHJcbiAgTEN2di82eGlnNWRrOGVLUFpPNzhENlZTKzFkVlZTMDEyMnFWWU5kSXEraytGT2tycnNuSlRGR2szQ2x0aXN3N3RVR2MxRGRpRk5DbVxyXG4gIHMxOGxKcUFqbmZoTGxoSVk1amQ2Mi9ZUmNaKzBZZk5qZlpIb0FTSHNUWTFLY1BSb2EybFhRcVZFTEpzTnE1eWdaT1drVzVoTnh5Tm9cclxuICAwbllnS051MWJ4Mk5EWFlPT3pYU2dkQ2t0WFZJdWg1VWcraTFSbm1aMnJIbFQ5MG9MOTB3VmxiZGU1NGMrZU9Ga3RPeTBWNzN3b2V1XHJcbiAgbHdFVFQ3RG5OZjdNSDVqSWp4MFhmYzl3a2NjdnordEJSSVpNTzkvRVhnQWVibjJOa2lqSDhpUG4vdUFTSTRMU3FRK0xSWk9NS1JOblxyXG4gIEtiZkN3a1BTNkhPQ1MzaGVNczQxYVQrdmYrUWJhL1JNcWZyb1pUK3Z6d3pYNys0R2Y3bE5NcEE2SU1xaXJvMTNMYmZ6cGF2bGcvbnpcclxuICBKRE8xUXc2ZHZKOGgwN0FGYlJ3dXYreDhROUx4SXlEVDdzQzVBTVFQUEhCc29rNTNDTWdmQ08xbDJZVFgvVi8xVmljQTUwSjk2aEp2XHJcbiAgYlhWOHRpZmkweHNFQWhucWhmQ2dBMTNNKzlMTHZobGZ5QTk3aFh3Y2NOSG5mRjBZZTZYdkNmNHJBcUxmaEFMRFlsOGhXWGJtb09ScVxyXG4gIHliNjUrWWxUbUg4Q1RiVWI5TmN6a1pzRHpidXEzUHBLOC9uYnVka1Z6dzd4VU0rU3IwY0lQVisvV0kyanFMWVZzYWxwLzQrOXR3Q3NcclxuICA0dWo2LzA5SVFoSTh1THQ3MFZLOFFrdUYrbE4zZDMvcUxkVGQzZDNkSFdpaGhRSkZpcnQ3SUFTaWhQQ2Z6NWs5OSs2OTNPQjkzdWY5XHJcbiAgdmY4dmJIWjJkM1oyNys3c09YTjAxQWFDQndtam94cXQzRWpZSFNmbmtkWVBuUnZUamhPdG1aK2RqMkhscEM4MHhmenlTWjlwbmJwZFxyXG4gIGovTU1KS2pQUHozSGxaZWx0SlhLbVptU25wNnFSS2hTcFF5ZDFHalM1Q21TODAxMHJneGIwRi83VnhMc2N4OGMxMWc1NlhPM0dkczJcclxuICBzd29DMHBwZ0VHL3VSblo2ejNwY0Qya3E5QVB2bnVVM2czMjRVUG9Odjh6KzluNVo1WmdRYW9obWc2NlcxVk8vazFhSDNlUU8rZVBNXHJcbiAgNGNFSUZBSlNrTE5DMDVZUWhaL3FLRExPVFJDNXZ6OGpyc01SRS9lK0lEcmxhM3FETkRZTlZDaGNpdmdJMDh0anh6RG1BVkh6aENwSlxyXG4gIGFyWTdRQmFOZXMxSlVwZktpaEdQU2IwcVcrV0w4MU5rL3ZkM3laZ25Cam1KNHc3NWR0Z0JNbjNDNzdKaTVWckoyNVR2cEl5TnNuck5cclxuICBCa2ZBaS9YSjhjbWhDU0hsQ2hjcjYzWTZ1aTVKYmw5QjBWWXBjbXNZQWVsbjZNNXBPUHk1TmRDZjdGclpvcTJrcUJxS3VLRTZYUTZYXHJcbiAgNXZ1ZkpUV2FkNUpHN1h0TDdUcTFwRjdkbXRLb2ZoMXAzTENlMUhQYnlTbmVVSithNU41MVNZcmtPOEpmNEpiTmpCeGNjMzVHRlgrdFxyXG4gIEVwaVB1ejVMaWJ2QjFJRHBKRG5SaG4zY2U0cXJtT1lXVjVSQzl3Zm1rcUlQdkVRV3pGc2dYMXhjVTBxVy95SEYwOStXYXEzNlJwZ3RcclxuICA2MnJ1T1dNWG9UOGdWZXpuaUxveEVWTFB3RVNLaS9MMGZaQ09IOE01NzBEVlVnNmN3elp6c0xET21tUE9ENzQvR2hNQjlic2RwNUhxXHJcbiAgbWxQTGdUNktLKytrTnk5V093Zy9HTFVsQXpaK095K0pYRmxFcEpjcFcwNldUL1NxMU1uditrU2FteWMrS1hObVRwTzY5V3JLeDIvZFxyXG4gIExWZGVjODUyQ2JZUmFSWThrclpIcEtscmhQMkpKOTlXRjlrUnBVU21HK09JRUdlMzVseGNYTzFZSWxBUFVNZk9UVTFOMVdsZ3JZMmRcclxuICBsVVNlZU1KTEduWmUvRHA4YjdabS85N0FmcjE4YnJCSEgyY20wOUt4UXhzSXdBNENxalRwTDVzMXRYc0EvOFVwZk1uOWpleWlFR3k0XHJcbiAgVmJmTU5UTGlyOG02MmJSV1RWbFR3ZWRjeWwwMXh4SGtWdXJOVk1HTmZKVklhcnRKbXZ1S0Q1aXl0MzNVMWc3TTBGRFhPdHAzUGRLVlxyXG4gIC9UcHNBL0ZyOVMxSFplTzJNWmpqOXFsMTJNNWFyQW54ZkYxL3JwMm4yNjdNTmZDOHF0TnBpUHJKRTFURmNSTFRrVmJEN3NIcWhpUFBcclxuICBXYU5pcUREM2VUZENudVpHNjdscU55aHlGQUtIaEdiTkdrdXQ0OTRKNnZySTdTYWFSdDF2czE0NDRsazNtci9VbGUwM2xsSHBnelRrXHJcbiAgS1U2eVFnMlE3a2FRNUVMU0lUTlBVTTlsVXFpSE5WVzNMei9peXRlNjQ3VEJVL2IxWm4xN255TUFOd3JaV2dua2lqSVBkdy91TDFPaVxyXG4gIFZuS1NIM21mWUNTYXlYanVhekpsMm5USnpmTXpvbVdrbDNWRWxlbFZ6MVNtQUVqN1RWUTNOaGZWclRzcEFqc096TVYwOHF6bmY4K1VcclxuICBxNDdHSnBmUlVUeTYvMkxYeHpJcVY1ZU5hMVpvMW1NNmFJb2pyc1dJRXc2TS9yRUxiQzdZck9vcFFISmtURkdPajBoS1JpVkpMaW1TXHJcbiAgak5RU0RVaERkY1Y4MDFVcVZwQjJiVnBLclJOZWwrUWE3U1J2emcvTHh6eDFZbDEwNzYwT3UwN0tPVW12Nmo2eGV1K3R4Zmw0Q01pYVxyXG4gIGhXN3c0dFlsR3haS2N2VllieHE4QlhIakRhTjQzcmV5dFVJRG1mdmE4WTU0ckhkTUxrdHFWcXNxNVNwV2xPVXJ2QjJRMzV0Y3RseEpcclxuICBRZTZtTXFudTkvSGJBZElJZ01IQlNHQW92QXQrZlNxL3MxeXExdUZ0Y3dick9vMGJTVVpueCtRY3djY3VBdXNoaXdPcVB3WXZQTU5SXHJcbiAgRHcrU28xOHM5TS9mTVhiZUMzRXN2Rk04NlVnSHo3TnJmc0RsZW94SjIzVEtaNFVuRTZneWFYREdWM2VxTnhveE5RQTFJdjNHMjBORVxyXG4gIFJqODJXTXRWM2FDTGMzSEthRG5ZU2I3dVhEUUJrOTY4MFBYWlU5MFIydDNxcEpFQ3FWcDJvOHo0N21IM0d6ZkxzNDljTGIrUFI3TDNcclxuICBSRHhNUE1NSUUxUWl3c2xqVlJyaWlhcy9iN3hiYnp0eXQzYVJIbEFWVVRiYkJvaS9qekRzT25aZjRYWFlQcklqTU5VdGswMEJPejgzXHJcbiAgTjA4REZoOTN6T1dLeTAvZHB2MVBQL3RKamo3S2JOVzdqNGtUWjBpWEh2OVNxV2JFejB5Y2x4ajB2WjJHTjRRRm9FZkhZenY3akhtQVxyXG4gIFdVc0NzY2lOeG4zK0pXOVBBRjRkUkY4TU5VYlp0aVA3V2NlV2pYQ3lySi9QUy9UQmRXeGorMUMzUkZmR093U3ZIMXczVlgzRitjRjVcclxuICA0Ykw3by85cWR6cEN0MVBLbHBlTlpBbDJaUmhLUlBVVnFxdVAxRzNiZnFLUTE5WDlsOVNyMzBES3V1RXU2ZytZaVB2cE1udnVRaWtZXHJcbiAgZnFtZXhmbE4rbDJvcy9UUnpwS3g3MFRiMWhXMS9CWFl4NGZzNTZjV3IzdTI0OEU1VEJPcnpNUHR3KzdSSXNROGZEM1JTWTlnSG13elxyXG4gIHdZOUNqNWNKOU5KSm10TUsvLzdSand4U1Y5Q21BeTZVR29QdWRRUmN4VkVGUnZVdFc0bzFSZ1lnWGF5ZS9vTXlEMURrbUNpRURPYUJcclxuICBnYlJtdTRQazczdWFic004WUJLc2s1d01rTGR1cFc0bk9jNVF4aTNGeGFTS3dkRUI1dXFKTDhrRk02dFdrdnIxcTB0S2Vyb1VPdWJSXHJcbiAgcUdGdE9mQzgrNlZEeHc1dVJKOGhhN00zU3E5cmZwRGozeWlSZzU3T2tmSUgzcjFrMUl1WHlzaDdCa3B1Y1ZyZC9SOWZKd2M4a1MzMVxyXG4gIEQ3bEZxblk1MGIzVGtUTENIUnY3N0NtNm52N2xBN0ppcHBOZTNVV1QzUHVIOGFSWHJTdnBtY0djL0c3WnVHcTJUUHQwbUM2Y3d6SnJcclxuICB5cCtTdlM1TDJsdy9RM3JmdjFLT2ZtV3o5SDV3bGFSM09FM3k4clpJazBFM3krSDNUNWZESGxsWTVyZzN0a3FEQmcyVktWVE5yQ0h0XHJcbiAgMnJhVTl1MWFTZmxLRlZRaVFUSkpUbk1ER25jNXBCRitPeEpMTWt6VjdZT0hybHkwU0ZZT2YwUm12bktjckIxK2w2VFBlVTJTMHl2SVxyXG4gIDJqbDQxZmxiYlhQNFRWSG03ZDRSa2dqMlJ0elJxY1AzWGJsQlo4M2t5N0dTNHMydUg2SEt3c1dYRnJDUGtOblg5d3VZRFJtWGdUcVNcclxuICBVSWVHSEZxN2dRaTJFZEtoNE81THVwT3NPZDc3ajJmWitiVG5WQlhNSUloZVRaRG5pRmV1Y29PUk1zbzhEanAwb0JxZnd3WnJDQ1JwXHJcbiAgUnNJd1FzeUkvNDAzdjlBeXhKUWxIdFFsTHNQS251aml2YlN0RkdMSHg0NzlPMFlhWVgvbHloVVR0bS93N2ZyejdWemJqakxEeEpKUFxyXG4gIEdEQVB1NDYxODlERHIrbTZjK0RXYXlubDdmamZmOC9SOVo1aW4zMFl6RHNtOXV2MjczT1hHRWpsc2lhSXg4SjNHZjgzaXRCMnFJZzNcclxuICB5bUVEMFhtNlVlcWF1YnJHMDRyY1YxU3p1QkRBeUVnN25QdGJ1SEdWS3dZTnNkYkZseU9FTm9RTTk1RnpITGRTMUZiWVB0WXZjZy9EXHJcbiAgVVc1R1JoaHlhYmw4ZFZ4M0dXMXJZNzY5VUptRitUVlliMW96MzBsRnM5VFlTKzRtZ2doemxzL3c5WU82ckZ4QnRqQnljeHU0N1pLaFxyXG4gIHR0TEJUOHUrdlFlby9XQ0xHMUpxNEx1clMzVHRtcSs4ci82Q1g1L25WRms2L2dQTnBjVHhwZ012OGUwSDEwQjExY3lORVAwMS9iWHNcclxuICBXSGliQ1A3SWZpM1pjYjhMSFRhWlVZa2ludi96RTJyNGJIWDR6Vm9UbUcxbDV0ZDN1ZEZsaVdNR2h3Y01JVWxtVHg2bERBVG5KZWdHXHJcbiAgckNRdkwwL2pUQmk1TWtmMzBySHZhZm43eTlObDRpdW55b1NuRDVadkxrbVRhVytmSjM4K05sQVdMbHFpbzJkakhqQUdKQXlZeGVZQ1xyXG4gIHh4eGNtZEgyMWkxdWRPcVliVnJaREduV3FJRlV5Q2d2YWFsbG5XU1NJa2MrdlZKYUgzR3pMRjY2VmlwVXJTZEhYZnV5ZEx0cnVZei9cclxuICA0VDBaTjI2Y2RMendNMlVjTmRyMGwzbWYzTEFld2w2ME5iMUIvNXVIQzB1TnR2MERockcvakxoN29LeVo0VlUxQTl5eG5oZS9yZXQyXHJcbiAgeDl6dUdPZ1Iyb1l0Rld1M1VHWnAyN1U3RE5KNkxKeGo1L0VvWVNwZlhsWlgxNERFaXNlL3ZrV2p6bWY5OXA1TStmUWVsWXk3REYwZ1xyXG4gIE1KSkszYytYYWROblMwbkxrK1NncHpaSzQ4WU4zU2k0UkxhVWJKV3lqbWxVcVZKSnlycDNpNHFNWjhTUWpxOFNLU1UvSjBleTFxeVZcclxuICBWVXVXeXJnL3hzcXM5NitWV1ovY0xBdmZQVTJaZDZXR25WUkNnWW13NXYwMDZYK2VrR3NPNDN2cncyN1FZRk5UWjhGRWlNWFI2WVFkXHJcbiAgMkE5RElaaVZiMDY5dFpnOExPaFgyUXYvbE9VVEhSRjN4MUJmc2J1NElFZVRMbUlZMStrRHREKzZ4YTJaSDJWTE1YbkszTGtqYnBkcVxyXG4gIDFTckxFM2RmcE16REVDYlVsT2ZQUjlVZEM3TEhBb2h6UE1HTlIvZnU3U1BIVUZHQzd0MFR4MmRRanlDK3NOUkIrNlFyS2ExOVFEM1FcclxuICBxbFdUeUxtY3h6bDJyRFRWV1dtd2RteHRlT1RSMTNVZHVjZCtzY2YzQk1TZTZMdko5bm53RW1HWEdFaXFST2NzM3hWMHJicFdxa0FOXHJcbiAgSEVvY1FmaGpwWjhvS2lYRHIzVU9FRDJjcEVaYzFremdROGYyU0pKSzlUb0dWU0NGdnEwSVlWWDRjcFNaT0Nsa25wK3ExU2E3eVd6Y1xyXG4gIFEzVy9ITE9aMUx5KzNwK2o1OGFWU2ROQlJsTzhWREJBMSsxeXRLb0lDSFpEV2lJZHVOWVAvdG01eS8vNlJKZ1hBNE55dzE2ZVFTUzFcclxuICBPVjNhSDNtYnRHemRVc3FpbTNDRUVUM3N0TDlueWQ4dkhTMU5lcDJvYmVBUlZxVVJha1BmbmkzOHd3NURlZjRJZk42OVY0c2UxNlBVXHJcbiAgRTFuNDY0czZEU3RscGhSVjFRRWJldHhIcEJQVUdGU1g0c0pjbllYT3c5czlJQTR3RDBhYUdObzE0RkZybzQ5ZjUwWnk1U1hWOVM2SVxyXG4gIE85aVVsUzByWHU2cGJxQnpIbXN2elNwdmtyR1BIcWdEQm5PVDNlS2tDRHBrVVg2eEVrVTRFQWJvTGE3TVBtTWUvSnpxVlN0S2FscUdcclxuICB0R25WVWhvMDd5d0gzdlNUMUR6cU9hblo3MHFwZjhDLzViRG5DMlQwa3lmSTZOZXYxemlNQWZmTWtkbnpGc3RIcDVlUm1tMEdSQmpIXHJcbiAgcEJkTzNvaTBVYW50NEV3SXV6SU54eWhnR0NQdTloTmRHZEUzaG1DQWNlNEphQXRHY3NSVHkzVU5FL2w1Nkw0Ulp0TE9NWkhPSno4c1xyXG4gIGkwZStMRDllejhSaTA1V3h3RWhtZm5HUHpQN2c2dXh1ZHl6UzdaYUgzYVlTU284Yng4dmdaL09rYnIwNityeVFSQ3JXcUMxYlhYL2FcclxuICA0dm9TbnhrU0NVK2N1MmU5ZlBFUytmSGFSakxwS2RkM2Y3clM3VUZwSk9yV0hyeFNaU2pZUjVpYWwzZW9ka2ozSW95SjVLNmRyNHlrXHJcbiAgZ2V2THBPN25SSTdSRjd6dHprbmxuWTkwMysxVWJZOXo5N3Z5VzVWQ1lDYXNXeDU2ZzY2NUpwY2xDOExLcWQvSThtK3VsZG16WmtxL1xyXG4gIFBsM2t0M0UrWDFnWUVGNElzQkZmWXhJR1VwOERqbHNkcElUU1lNUjIzMzI5azRGSkpmR2dIaW94Mmd3enB1clZNN2NoNUdGUW43a3lcclxuICB5cGZQaU53UDU0WFBHWkJBYmJZOTJEM0VyK1B2WTIvR2czUm83K2RlMnA1MzF5NHhFRTB4b29YSW4xSVFIQXRXakU2ek45TmxSZXBVXHJcbiAgOXdualBLR0VpRVZUdHVQUm9TbkczWGxsTkpEUXdXM2tZRHozRzhFYWhNcXVUcGh4RUIyTTVHSGVIUmp3VUdGeENsTmhFbkdPRkxKMlxyXG4gIEptbmJBM3NEQjYwZExiTVpWVjlWcXRQYU1SRWVaSkxHU3lqelVGZGpYOTB2a1lMNzBFNTFqT00wMzU1Yk5qZ3BKQXR2bS9UR1VudlFcclxuICBQVkt6cG1lT3VibEZrcDZlSXV0V0w1VnByeDBuVFFaY0pIVzdIYXY1b2ppUDFxeE4vcE1XaEwyTitweXJSeGJyM09EQmJ3aXV6NmhQXHJcbiAgSzdPdzByWGY1dC9Ncis3VWxOeHpuUFNCeldQdU4vYzY2UU1HNHRzaGhUeUFlWXg2NUNBM01yM1pqZlJ2MVgyb09ZZ3VyMVdybG81NlxyXG4gIDhRNkNGNEpKWThiTGZEZVNuVE4xcHZ3MWNhTHE5Qmt3UU9oZ0pJeVlZUkJ1bHhJK0dFcUtxNE1xcG5yVktsS2xZcVpVcWxSUjloL1FcclxuICBUMnJYcmllTkRydFROamMvUWJyOGU1ek0vdk03V1RkdnJDUEtBNlIrenhNMCtBOGMvM3FKVkt6WlhFYmNpd1F4UWhrSFJIamhEdyt0XHJcbiAgaG5IVTYzZEJSWlUySERHSGNmeDYvOEY2M29DYlIwU1lSbWxRdTlaZUJFemtnR0ZqSXN3a0xKVU11bitHWnUrZCtpRlNvTWd4cnhaS1xyXG4gIGNXcmxLaCtkN2hqNlIvL09hdVBPSVhiaysrdGJhc3hJcjN1V1M5TW1UYVJXamJyUytaUm5wYys1TDBxbEt0V2tydHZYdDM5ZnFWeWpcclxuICB1dFJ0V0YvUzNmUGs5ZkJMZUY4ekprNlNXWjhQbGJFUERKQ2lLUy9KeXIrL1U2Y0cxTG9ZMVRHb28yNGtjU1dSNHZRYjNMQUpvTVZ1XHJcbiAgNHRPYzBFZThYcHcrcm1wb2Q1R0NEYXMwa1NMem5SaTRybnF0dVhaUVpjMzY4azYzSitpTGJsL08xRTlsK2ZJVlVxZFdkYm42a2hQa1xyXG4gIHdQMkQvRmdCSUpRUXlURGhqQi85c3c5dlJ3TU9GcjMzOHpiV2VEejQwS3RhbjlUdU80SmRFOWcxVHcrOGs4TEhFb0VwZGNuTWE3RGZcclxuICBBUHp2MkRrR0VueGFwY0xhM05IOTdBNHNwbVJDNkhmRVk5Y1lTTW0yRW9qL2dlN3ZkbjdwT0NlU0c4aFFDWWo1MEtCQmh3cTF2YjdOXHJcbiAgajJ4QWtucnRzR1ovV2tVQ0IrMGFyT2w4RkgwbkRBNzR0ZHZXZE8ydXJJbjEzRFlqSU12UHc2akoxM2NkbXJRZ1d1WTBheWZhNXViOFxyXG4gIGpUNUszcFZoSHFqYVZIMjFZSng2aDVHMmcrdnhMM0plc1BDUGFVT1JZTWdsdEhHNTk5VENKbEpTdm80MFBPNUZhZHk0amtvaUJXNzBcclxuICB6WEF4ZCtNbVdmSTJvN2daNnFKTG03NjlxSXFOdit3andBM3B3NDhVMlFtSSszaFlHdTduSlI2VlBnNjUzcFg5YTZZcDFBZ2FST1kyXHJcbiAgT0EwWFREV2MwellWSE1qUEJjT0EwZURrNE9FWkQ0U0RPU1hTQno2b2Uwc0t2UldibmdGandPbUlaYXRqRmdTZzRvSkt0bEJjWnhsK1xyXG4gIElJeWtwVHZHVXJKVnlxVW1TODNxZFdYQU5WOUs5WDVYU0VtMWRuTGdFeHNrcTlFcFV1WFF4MVUvRHpQQXM0aitRaG44Y0dOYjlUZ2FcclxuICA0Q1FQaVBCWFZ6V1FPcDBPVllhUU0vUDdKUjg2S2FSOHcrNDFqWEhNL2VFcGxUaEF2K3QvVUNiMFB3MllTRHdqUVNMcGNQemRNc3R0XHJcbiAgejNTTFNTTXJaNCtyQnRQWTkrVGJaN005L2JPaHlrUTYzVHBQRGVjenYzL1NpZGZOWmVERHEyUmoyVWF5T3ZNQTZmL2dHc2tyMTF3YVxyXG4gIERiNWQ5cjFoaE5ScTJFQlZoc3IwM2Z0Qk9sa3dlNjZNZjNTd2ZIVzJHeUN0L0ZLeVp2K21DNmhjdjcwT25sQno0UWJPZ0FtN0NmMkdcclxuICA5T3MrZzYrUFVhclNzSXNibUUxaFUzTmJ3WHgwdzlYdDVhUVFQN2VJYUpZRE1qR1R5WmhqV1I4ZEk1dnlDeVMxekZhNTRlcFRKTTlKXHJcbiAgb3hEQ2VBWmgyeHpEQ00xYzRQRTQ1Mnk4QzczTy9zUVRCcXVxS2hGNkJQc1hteDEyQjdCcjIwZy9iS1EzNHAwSXhKa1lVZWVlS2NlclxyXG4gIGduYUc0Q2V5ZzhTdjQ5dXgvWWFzVlg3cThGMEZjNW1BSDMveXR0WkUyQ1VHa2x3UU83RlU2WENkeHhBcVlnaGxwQUY4MUtrb1VmWjFcclxuICBrcnduaDF1WEVJdWd5UlA5Zm94OEhsRWk1dytHRnJmZkRwRXloQ0pSNHFpYklKVzRuM3FESDRua25NVGpLcXZrdzBsNll0QjJxTXdjXHJcbiAgMFV5MlE1a01xblgzY1IzZTNTOVpaSFBjQjVXbStsOS9qcjh2cnBTa003OHhwV3VWQnAzVU9RQi8vQWI3T3FJWVVRTzUzNXBSVXhvZFxyXG4gIDg0SzBidGxDUi9Ic0JZc1dMWmFzSDY3VmxOZTA1ZHRrNWUwZnpPOEJ5cGFySXBQZXZsaWFEN3JhMTlEcmk4ejkvcUdJNm8rRWp4RUVcclxuICA5d2NEUVYyRjFORWlrRDZhT3dtRFl3RGJpRS9KN3BqTlYzZEo0NzVJT3JTdnU5ejJPZXFBd0FKTStpQkVpRGNLZ1FwakMrNnRqakJ3XHJcbiAgckdLTmVwSlJvWklrcFpTWGd5OS9XeG9kOVpCMEc3WkFsczMwdjZuL0RjT1ZXU0Rob0dKVTVoRVExODZuUGFubGtVN1NnSEZBYkVjOVxyXG4gIGlpT0RrenJlTEhFUzFIVXk1OE5yYzZaOSswd0R0azNpZ0hFd3c2Q1hOZ1lFZmV5L0I0a1lTV3YzMjJydk0wUStkdElIajdmL1RUNHdcclxuICA4SlYvSmJVc1g3UnlLVXlFMzgyejRCa1JSVDd0RTRJdVI2bzZqMk04eHdIdWVaS2tsTzBtSjc4cFRZOGNLb2ZkOWJ1K0l6NThGaFRHXHJcbiAgTVB3Sm8zK1grWi9mS25NL3UxWEdPT21FZDdCeCtUUlZad0V5SHFES0FzekJqMGZpeksrd2plQlFjcmdHZnFMMlpESW9IRHcwTmtUN1xyXG4gIERVRzROV1NyVy9OYmtQekpDcDM3NVlreWI5NDhhVkNubXV6YnJhMzAyTGRMaFBBTlBQQnNYUnNnM3ZmYys2SVNTc3BrS282SHFhR1lcclxuICB4OFBTZmlTQ0VmVldMV085NWtxRE1ZNTRadkhqVHo2d3NEUVE2UTc0VGRZRzlpdGpKdHpEenRwQldyZjJidkhXVHZ6YW50dW8wUVFwXHJcbiAgaXpDVG9XSHl4T2xTclZhSUR1d0NPblJvcWUrTVJKV2xZWmNZU0U2dUcxSGlRTDlkQkM4M2RpV3B4WnVsUWxxSzZ2elpSd1F4bmN1a1xyXG4gIEVFQzZjL29Hd1lVZWJzUDl4NDNVbHprVHNIWWQwcStDM2NFKzk0OThVR1Q4WkU5eVduazFFTE8vWXBBU3BXYnIvVFVabmM0Q1NDMGFcclxuICBDTm9JTXhFaXBOWHJ5cFZKRk1qK3VsMk9kU09zdjJOc0h4eFA0bEVHNTJLZ1o4NFBQRnJJdHNwdnRYWlorYlZqbE9WcVNiVmozbkZNXHJcbiAgdFk2VWQ0UTFMNC9VNlk0NHJGd2xPUlBmbFBVZi95dlNwa2FidTBmdjlkYWtabjlVT3AvNnJDc0cxM1Yzb0VHREIxL3JDSVlmNFRYcVxyXG4gIDR6NUVsVDc4ZlpKdTIwc2ZicGNET3UrV0tuMVEzYmZoanpsRzR4Z0xieHBwQStEaVNSazl1SHBVMVdqcVJwdUJTdE1CUnFJdHBKWlJcclxuICBOOU5rZ2kvY3BiRnZWSzFjU1JyVXJTMzdISG1OMUI5NGxSejJaTGJNbmpWZDR6MUczamRRMjJPQjZORXUrYkxDek1QS1NoUWRnVVRsXHJcbiAgZ3NvcXRWd2xaUXlGUy85YzlPRnBaYVJLK3lNcTlicjZjeW5JWGhtUk9LSnFLdjFoN25Fd0R2L3ZRendqeVd5OGowb2ZNL2pkYnVFWlxyXG4gIDlMam9IWG45M0RyMUY0eDhSWTY0WS9oc0dLSXhFU2JSbXYzTlE4cEVPcDc4aUN3ZDk1RStMeVExR0FnTDlXYVArMEVPZkdDKzdIdjlcclxuICBDT25ZbzZ0S2hVVnhuM1N5ZTFUVFhqNUdWbjF4Z2RwR2tFTHMrZW5Bd1JXVFV6TGNzMHoxV1I3Y0R1eDJxRHZWemRkdGt3SENiRWpkXHJcbiAgem4xVFpnY01CU21rU2JVdEdsQmJxVUthUFBmWU5mTGNjMFBsN1hlL2poREU0VCs5RWpPcWh1RDIzcSt6RXNxS0ZjdEhDSEFpMEFaWlxyXG4gIHNiY0gyZ25ucVRJYnl2YThzYXd1RElEWkNzdW0rc0RDMG1EbmNUOVdmdmE1OXlPL2tYMVczaEdlZjk1bkRiQUpxVXhkUnh2QTJ1blRcclxuICAyNnZ0MnJieEUzRk4vM3VXdTgvb043bzd3TjZ6dldCQ2YwYzdpZFNrSXNISjBqclR6c0hYM1p6aWcrbjhRM0NNbzd4UDQ0d0toaG9FXHJcbiAgb2ZrUnMrdU13VHdTN044WVRNTEVocmJreWtici9CKy9hRzEzd0kvUWcvMXVtMHk4UHFESkVleWlQRCtpMGdhQXIrT3ZSTm52NHgrcVxyXG4gIEo4cWtMVmt4NlhQSGJKckxpcjgrZGZlNVZwbUNxcVE0Z2ZOcEw5UU9zODVobThEdWdmcHErY1RQQXJ1Q1B4NWVrSkNhbnZXbGRMdm9cclxuICBFemR5cUMxYnRteVZ2UHdpSis1dWxLbFRwOHJxZDhnNFNsMlI1Z2Rkb1dVWWdTWkNqUHdPaDBnUkJuYUErK3QyQk1ldEd2TlBJMzNNXHJcbiAgVWVualppZDkzS05yWlVJT0pNL0Q3ckZzL0lkT0N0eXNaWVZyZ0cyWVI1c2h0OG1VZTVySnRGZlBsSzM1eFRxYTFmZnFtQVpNQk5YVlxyXG4gIDFxSVNTVXRLbGtxVkswdXpKbzJrU3I4ckphbnBJVktsOXhYS2xBaHlJd090SjNCRGxiZ1JKMUs1WVdkTlNsa2E4OERlQWVQKzhJd3lcclxuICBLazMwdk9ndG1mL1ZuV3YrZVAzNlJpWjFUUHVFYVY3dmlUQU9wTm5RdzlreHFMcXJ5MTRFVEtUUmZ0NkZtTGF4anhCYmhFcXJVYStUXHJcbiAgbEtsTWVQa2NHZlB1c0phOVQ3NDlob2xrTnVubW50VlFqYzhnWVNNZWpUeTMzbGVRT2NFOWQ1NjNxN2ZvOXpla1lNTUthWFRSZUdubVxyXG4gIHBKS2pYOTBxN2JwMmtTcTFhNnMwd2p2TnlWb25DMmZOa3IrZVBWeG12SGFjTEgyaHB6SjU5Y1JDQXAwOVFsV2ZwRjhIMk5ScUJpcGhcclxuICBKSDIrWWZXNjBvR1ZKelRyM2VCbjNaemZaT3FmWTZRb2I2TThmZjlsY3VBaEE5UmJpZmtuYkNUTnZWclpZTVNTaVp0QS9IR0QxVE9DXHJcbiAgbndpV0dOSGFlUDRGVDZCTGt3aG8wK3BDckptRG5IMWh4bElhK3ZiMUdUZW9EMkVQMzkvTzJrSHNITnJpUENRRHUyNzQrbGFQOVNzdlxyXG4gICthU1piZHI3aExXN2k2Wk5mRW9USnRaS2hKMWlJR1BjaUFCOTlxSWdONHVCRjYxL2ZTRWgramJJazJycG5ndVd6MGlUTVN1cXhOby9cclxuICA2dmk1ejR1WlJDWm9pQXlsSG83UnFDdXZMMGNKSnV2UXduNktEa3lOQ1VGbi9ta001NmlaY0xsbHJnaTh2V280NllQSytWa0x0SjZkXHJcbiAgSHk2elZIZFNCUDc5bEpuQWlkeGNGZXUxMTN1bm5ra2dsSFVKemlQeEliUFVWWEVTQ1B1ck9LTFlxUGZaS2czNDZzWndmTXdMN1RKRFxyXG4gIFlsSzVtdExoakZjbHZXeFpiWkZnb2MzdVM1NDFkNTRzZm4yd0c2M2pQZU9scTNYei85QUpzc0xTQi84MFpZbGJjcFpOMFVTTHpMWVlcclxuICBPZTdXcVlHRVI0ZVk1WmdIQk1EL2J1RFc3ajgyRkZKdE13R1dTaC9CY1VhWXFmUGVsN0czMXBWRkN4YnFQZ05LSVNLbFlTVGtPS3Z2XHJcbiAgQ0ZHMTZqV2x6OFBycFBhL1hwWFdSOTRtSFk2L3p6R21UNVdBMFNMRURJSUU4eUNyTGluZE55eWVwTWN0RlRwcXFqRHpZUDhYbDliVVxyXG4gIC9SRGErWi9ldUtHd3FLUUd6QUlnZGVDQnRjL3BUbG9Mb0RuT0VvR2JTTFRzRGhLMXc3S2JxRkM3dVRKQW1DSFNTSnVqYnRVTXZUL2RcclxuICBoZ09GeVBHT2lTd2EvWmFNZm1kWXkvNm4zYjQ0ekVSNHBndC9mZFd0KzJzeVJKNHY4OVd6djM3MzR5TFBuVFQ2NU5heTZQV0Mra09rXHJcbiAgOTkwcnBOczFQMG1YZlh0R0NFUGhwazJ5WWMxYW1UTW5zSVc1L2dBVEllVUpNU0dvclRRMnhOMFpmWG5XVjNmcVB2djl2dnVVa1gzSlxyXG4gIDFqdnpGOG1kK3E3dTc5UyttUnN3UmczZlEyKzdXTk9TQTRoMW90RTV4M3YwNktCRWsrbHA4WFJLQk00dmpjR0ExcTM5Q0oxcmJOcVVcclxuICBGN25XOWp5anFPT0pmcFFCZ08xZGg3b01tS2xycWlzd2R1d1VYWU13QXlnTmRsNGlGRy94ZGlNajhMUTMrYTlwVGpwTWtyWWRmS3pJXHJcbiAgbnFCaVJaOEZldTVjSC93YWo1MWlJQjI2K2JEMm5VUG95M0ZGUExBS0N3dlZDMmRkYnI0ZXhmV1BnMnIvQ0tBdXZYcXE2NGhCc2tLMlxyXG4gIHZmM0RsejBvUUJCOTBYZlFZSi83eDZRL1pNbE5UZWVIK3dwTVRxUHR1RTFUNzFSdlM3Um0wQTRIdEt3YldxWU4xaXNtZmFFdXZJQkpcclxuICBnU0Q2MkQrMHZ2dEhBNXluWmJjMDNQYzBZVkloUnRNd2ord2xreVZuaWVYeDhYVThIQk9xMjA0V2pIeGVaMHdrUm1YZStDK2xXZk5XXHJcbiAgVXFOeE80MDRUVThySzhXRm0yWFdyRGt5K2k2MzcrKzNkWjd6WmdkY29YcGthNGQ3d0xPTTh0enZIOVNZbXBsZkRKV3F6ZkhGdCt1UlxyXG4gIFF1UUFXVHQzbERKU2ROUlIyNGVQOTBEaXFOL3RCTWQ4bmc1bDVoV1o4V0JicWJuMlc1a3pZNWFzWHVudFVVZ2NadTlBOGlpVFhFWTZcclxuICBkdTRnalFiZkpCMkdMWmFNTG1jTDgxMGdXVEMvQlJsejYzVS9SaGIvL3JiVTdYcTBucGUzWm9FU3NOV3VEdFAwR3ZQQW13b21BZkVNXHJcbiAgTXcvVVZnTnVHaTV0SGZPWStQeEorUVdTVVJudkpMTjFtTlJSWEpDckRoRCt0NFhnZitvMnUvOHg3T0gxWUpLQTUwRGc0b0YzakpmdlxyXG4gIHJtdXBVdFdoRDgzUjV6VHl6V0VOQjV4Mis4b3dFOEYrRVdZb0U5KzZ6QTBlS21sOXRnR01oZFFtUEYvQWV5Q0xiNWt5S1ZMLy9ERXFcclxuICBtVFJyNndaTlZhc3FrY2hidjE2K1BqZEp4ajgwUUpaL2RxNHNlTGFyYWhGZzBDcjF1OTlZdC9OUnlqeVkxOTJZeSt4dkg5RDJpLzU2XHJcbiAgVW5LWGpKZVZpeGZKNTU4OEtrTnZ2MVR1dXVjRlBRWWdndE9tKzdnd1F6eHhKY0VocWRzaDJoakpUZlVVRDRoOUlnYVVDQk1tK09tMVxyXG4gIC9iVzJ5dXJWbGtReUZ0d2ZzVS9VTTRMT3VyVE12TUR1UDh3UW1SNlh1VUdzalozdEhPRzJ3bXQ3QmtTT2d6bXo1cXZiL09LbHEzUjdcclxuICBUMkZxc1huenQ0Mi9BVHZGUU1Mb1ZtUEhxYTN0bWJES3pjMlZnb0lTU1dKeWd3QVdmQlMyZitCVlJIME1kN2dMMjJPdFZMOWowQjUvXHJcbiAgSU5aQk1kaldmYnJwL3JxRkVicnFYZ1BpeDhRM2xPMWZ6VGI3Uzc0alhKd1hhVXhYdmd3ektDblpyRXdNMTEzbS9NQ0FEclBEeFpIZ1xyXG4gIE8ycHEvYUJkZll4dXRjR04vRm1ZTjVwSmVuU25XNkN6V28vNmRwNWIxanZKbzJuL2k2VEpnSXVsS2drSEhXcWY5TDYwTytzZHFWVXRcclxuICAwekhlSWltYjZsL1JKc2Q4LzNJajBwVmZYYVQya0JZSFg2UHRBUDVPZWU4cUxlTmJ6NXdQKzE3MmhSM1dhLzA4ckxOaldHM1VsWExpXHJcbiAgRytkcnBMRGVpOTZYcjBkaHlaZzNWRlZsdGcrWis1bHN5Q3VVcVZPbnhUQU1KRktRbEpJc3pWczIwMVFtakJCSjVrZDdWRjN5QjVNTVxyXG4gIGVlSUVnWU5Zb1o1aDBpVFFxTytaN3JjOHJlVk9KeitzMGtZODh6ajR2dW1hdXR5WVI3UE8vV2YvZHY4Z3FkNXhTRWJibzIvVGtUZ1RcclxuICBRSmtVQWxMU3l5dkJWQVEvTWZvYi80ZXdtL2NCRTJuUzd5eVo4cTVQZ0huSVE3UGx0L3NQVW9tYTU4SHpHdkhtc05vd0M5bFNrTWN6XHJcbiAgNDFsV2I5bEgvbmpxZUdVaXpDblBQT3pORDd4RXNoempVSHNJeklPQVFzZFFtaDE0cVQ3cmZVNXo3OEpkdzZMVlV6cWNLeHZYK2ZrbVxyXG4gIHNHWUVyMStXT3FrWUEvaU1sdzZUNVorZXJRTTA1Zy9oWE5URmY3OS9sWlNyMnNoSkt2MVU5YmsxUDB0R3ZucUxiQzBvVUtOOWg2NmRcclxuICBsQUNlY2ZxUUdOWEluRGwrbE1zamdzRGVOc3ozalhnWU1lN1ZxMU5DZzNtVU9IdkVaTkFJZ1h2NGJaVHJXeUdpSERaQWh3RUI3eDBRXHJcbiAgVTJNaVJ0UkxnOVU1OTV4akkvZjAwY2MveUMwMys5VDAvdnpFOTFZYTdMZmJ1bjQ5OHZpSnJGdS9RU1pObUNyai81b2g3VHUxMFRuaFxyXG4gIDl3WnNicENScFVTazd6UUR1ZkdHODNTOWNXTTBLZUsyMlBiclFBS0JUcFZQVDVHZTdiMjZpZ3ljd05zLzNFRlh3U1o4Q25zTzRRN29cclxuICBXL1JrT3ZySEZpdjZNbm12akVCeklObU5qdkMrVXJoOXBBeG5mM3JWK3I0ZUo3dTFiejE2SGdaMk01NlRvNHU1TWlnenh6UjFVRjlSXHJcbiAgVXhHY3lwOHlaVkNYSkVudDlvTWprMFZsTnRySEJ3WGE5UlJXOWt4RWkwN2sxTW1idUova05HbDMrc3ZTb1UxTERiampKYW14czZoWVxyXG4gIDVrNGFMa21MUHBPU2xZR3R4OVdmODcxUDBZNHZQNUh4TFErOTBXMzdxVXM1VHJSNTUxT2Uxb3lycEdzbjhXS3J3L0cwNHNJaTMvMjdcclxuICBrYlE2RkZ1SU9NbGxtRFFMY204VmpYOWNScjkwdm14YXMwSUtIRlBGUUc2QW1UUnUxRmlsbUMydFQ1R3VUdXBJUCtrWGRmRUVTQXdRXHJcbiAgcVphSFhLUEVCWlVLRXduTi9PcSs0S3BlalZXcGZudEpaWUlveHpCNFZvQnpPWWJCbkRuSVVkM0FWRnJ1MDMvMjEzY2MzTEwxa0p1bFxyXG4gIFFhK1RWTVd6YWRXOHlFaWRPQVFGUDRTTDJJWCsyMkQzdHBQM1Y2NTZRK2w0MGdOT3F2QTVqbkJQSHZXUVR4TURFOEh1TWUrblo2VC9cclxuICByWCtVbS9INVhWdDVkdTJPdlZNOXpuaXVlR2JsTEordXo3VEY0R3Yxc3VhOHdNYjhuNTdTOHNMZlhwRU5UbUt1aWVIY3ZRUDY3ZUVQXHJcbiAgelpMR3JWcEpoY3hNUGEvRXZYZnNKSVViY21UTnN1V3llTTVjV2Z6eFdUTG43Vk9rZVBrWTE4NUFsVHo4REkvdVc2bmZRYVk4NmIvQlxyXG4gIHp6NStSRktTazNXdThXclZxc2crbmR2SW80OHgwUEo0NklGcllsUTllRnVGWXlrTVJwaFhyY3FTUm8zcUJIdGpzWm5KK3gyb1oray9cclxuICA0Z0VSaHBoZmR1a3AycVlSNWRMd3dZZmZSZTZOZHUwK1BDTklET3FZK29kNlNDd21OWGpHdFhPZG9MUnJZRDhDU3hZdWt5M3VONTkwXHJcbiAga3M5TmxsYldSOW52S1R5ZDlKSlRJdXcwQXlIN0t2aHJWbHhEMi8zOVNiSmh3d2JWalpja0pVZG1WZlA1cjZJU0NHb2hBMFpxM3liTVxyXG4gIHhLY3lVZWdQQ1YzTUZTTk13QzM4UTIxa3dFMDRQYk9lOTJ0MzlYeUExUDVheHBBSFlwZ0l4YUFNdkJyTnJaMFV3bHdaR0IzcmRUcytcclxuICB4bml1NXdYLzJBZGp3WFVYd3ptcXEwVy92NmJCV043bDFkZnk2MmdKTUs4SGJydmVZOHFCdG10MGtCcW5mU05OdWh5b2JyNk1VNHEzXHJcbiAgYkpWTm0vSjFVcUpGMzVERGlqYWMxTkxwY0tuVjhWQ3BVTE81dXdlZkd5ZjRHWHA4OXJmM2FwbFVJOWc5L0d5UHdLdXVHdmM3VDMzMVxyXG4gIDhiVGlPdmpxWjcyNm4vejYxczJ5ZnYxNjJaSlNvcGxsTVpBamZUUnAxRXhhRExsTkZxeGNFMG1lcU1GajdoaHpZK2V1bmk4OUwzcEhcclxuICA5OC8rL2hHcDdwakhvdEZNbTlwWEpjMG1BeTd3SStOS05YVUUzV0xRNVZwMy9hS0p5aWlRTmxUOTBxYS9FTk5CZWQrVGJwLzkwMVBuXHJcbiAgdG9SeG1MRWNHUE1BNlZYY2FNeCsrUDhXY0xzN2VjdjliL3hKSnI5RFRqUFBSSDdGME82QVRXVGlHNWU0WnpsU2puMXRjeElNQlFiUVxyXG4gIFl0QVZrcjE0a3BhN25mdUtrREVYRjNmUVBFaTNyNm9zOTN3QkRpZEZ1ZXQxL2c2Y1RXRDZDeVo4SjhsdFRwSDlIMW9uYmZmWlI2clhcclxuICBxeXNsYVRpNU9JRW5tZVNoSWlzWExwS3NsU3RsenZ2bnlhbzNmR0FtMTBHTnRmN24yMlRGd2dWeTJkVm55eUZERHBMWFg3MWJYbjN0XHJcbiAgVTFtWGxTM3Q0cWFJN2RpeGxYejYrYzhSd294ZDVLWmJIZytPeGdMaVc4K052bWZPOUVISThUandnRjY2cGg1VHk1WkdnSW5OQ0hzMVxyXG4gIGxaYWppbU8xbkhSQ081VHRIbGx2RDNlRTNIYVpGcGMxOTgwYVpyS3JodlR3ZFZuWHJsMWRYbjM1STZsUXNaeDA3Um1sZitYTHB3ZWxcclxuICBQWVBseEZxM1BuRTZrNTFtSUFmMDk2TkRnKy96OFQwL3RCMFVDNXpZU3Q2bnpFcmxaTnlhYWpwWE5RZlZrRzd6b2NOSXRINlNwS1pYXHJcbiAgZG4vZGh2dGZGTmd0WXFnaFJGdTNRMHV3bjdtcjJTQ1EwSmdTaWVCMEdrNjNmKzJzWDl4ZjdCOEhhWDBRdzRSMGw3dUhjcGs2UFN2QlxyXG4gIGd4dFhrRHlSdEJRSHlySUpIOFVZei8xOStpVXZhNkZqSElqVGpwRTVKb0w5bzNHZnM2UlIzM04wVkVaVnEwc1pmL25NSnQxMUlkOFZcclxuICA4R29zYlZYWDFGMmJ2VW5UcHpNMWdPNkh3anVzVzVzbHkxNTN2OFB0TGNyTmxzcjEyc3VTMzk5UW5mTWMxVHY3ODFuaklRUHhScDJIXHJcbiAgN1lPNVBSVHVzQmxBQ1J3a1pVbTM4OTZXTmEvMGRLT211WnB0bHdTR1BDUHJLSjA3T21tcTR5azZWem5TQmVvT1VMZkxFRFhLdG5RalxyXG4gIDNBbzFtOHJYVnpMOXJoN1NrVy9qM3FjcnNRTG84L0VxV2piQkc5WFhUUDlGOXh2ellNM3l4MVAvMHVNd2liSHZEbXRKZG9IRy9jN2NcclxuICBobm1VbExqUnBsNHJ1T0F1d2orbHZiUHNObmF5Z1U0blB5VGpYMllxQUpGK2pvbU1mdFRQQ3o3Z1J1SkN2THFoZjFDRzBXYTZmamp0XHJcbiAgNDF1VkdhQWFudmZUMC9wTVNSVTA3OGNudkNyTHZSK2tjOHJjQW03bmxKbFh2WkxyeTIyRzNLcXV2SVVOanBSbXA3d2p6WnMxazB5eVxyXG4gIEw1ZE5reEkzMGtXOVJmK1lOMk9tVEp3NFViTEdQUzl6UHI1QnhqMXlrQ3lhTzF2S1oxYVdoblc4Z2Z4a04wSW02V0hUMEd5QUVFTERcclxuICByVGRmcU5zUWZvaWt4VGFFOGMyM3YwYWtCVCtLandWU2pMVkpQWlpFOVpZc1hhbXhHZFJsd2lyVy9mcDVUNmQ0bEpTVTZQMFk0UVpoXHJcbiAgWWw0YXdzZElrUjQreDlwSmRMM3RZWFZvZXQ3eFk4ajRrQ0xObXZ1NEZ0cEZaUmQyVTk1VFlQdkJTeTRSZHBxQjlPam5FeUR1RURFZlxyXG4gIEFWbFVpN1dEbGMvd0hKRUo5NmxqN3J1K3ZGYkx1UEw2T2JWQmtwU3Q1T2ZwOEUwR0JEdllNaWlORFBaVnFORlU1LzFndTFMZDlzSzhcclxuICBIMERUdWJ1S0dKR1ptUzhzZVhoWTJWM0JyZElyMTlMTXMweXNoR2VKRDBZVXFkZjllRmsyN2dOcStmcHU4YVExU1lPcktqZm82RVplXHJcbiAgZjZvRXNuVDhoenEzQmNaaEQ5KytCL1hyNlNqTkwzK3EybWlkVzF1N3ZsYVNkRC8vWFdseitSaXBWS1dxWkdTVTFSRWZLY3l6czdObFxyXG4gIHdZSUZNdmJPbHJMaTh5QnF2VXl5SStEWGE4NGhmNzdJcXFuZmFnNHdjaENSVW1LTyt1TURVdDMvS1gydS9sSGFhSnFTSkkxYTN6TG1cclxuICBicGsyZGJxc1hydE9KMGNpelFnZVZ1REEvZmVYdXBlN1R1a2FudmJ4elJIcEl3eXVDVUZxYzlSdGJ1M25KUWZzTTZCV1NVb3I3NGpoXHJcbiAgbzFwZU8rczNaUmpUSUdTT2FFSGdzSUVVNWF4UkpqSC9zNXMzd1RjeG5tOGplZWpQUnNISGxYY08xQXd2ZXhONzNQWk9uTlR0bkJma1xyXG4gIDEvc0hhYm4zMVorckpBS3phSHYwVU0weUhDN2paRkN0eFg3Nm5QdGU5NTBPY2loWGJ6TkFPcHp3Z0RKOTFGZktTTnhnd0UvNDVmcVhcclxuICBrd2FSUXBpWWF2WjNEMm1aWXpoRmJHMzJMK2w1NVhCcDFzYU5lQXVMcEV4Nm1oUzUrMVppa3A4dkcxZXY5a0dsYmlIcC9NRUg3U2RaXHJcbiAgR3l6TGhJY0Yyc1VUOThHSDlKR2hqZ0VZZytqZXJWMWtRaWJEdUhFKzM5YU1HZk1qOWNLd05rMTFCRkZOWk93KzlaUWpsTWhTOTk3N1xyXG4gIFh0UjlkOXo1YkF6Uk41ZzNGWkh1SElkSi9US2NHSmp0TXdCcmkyc3dqVEt3ODZQWDJmRkxwNjVkWi9wMEJ1RWluM3p5Z3daUXpsdXdcclxuICBYSStQR2VNem51OG9nKzZ1Z3B4ZXdiaDFHK3cwQTlreFloOENXL3ZXem5ZU1NKR20yWWFEaCtzZ0x2dHRnZ2w5L0FkemZ2Z3E1SFBhXHJcbiAgSk9tVmFyT2gyMzYvQVVMUFBuOCtTMEhPS3AwckhXWUIxaThZU3kydGc4OTZiaEIxRGhFRllTYWl4YUNNeExFSnJ5dTNTWm5ZRDhyTFxyXG4gIEozN2lWa21PaVp6Z3EzS0tnYnFyWnNxU1A5NVU5MXBBVHFCR2ZjNlJxazI2dXVOMnZ4VEp1dnVDSm1oRSt2RFhEdVp1eHpWWHozYXZcclxuICB4UjBnU0d2VjFPODA3cVByOVpPazNXbXY2c3NrbGhON3lLYU51YkorL1FhMzNpaUxuOTlQbWc5a0xoRmEwQXZwR29NK0RBb0poQ1NKXHJcbiAgTGMzenl2M0g1UmtWSDZxcnBjOTFrVFdqSDVlWk0yZEswZFppS1pOU1JxZFZUWGZpSXhNbzlicGhwR1NjOHFOUForSFFjdkIxRWVsRFxyXG4gIFo3dHpoTWlZeFl6UFBlUEF6UmpHUWN3SFdQMzM5OG9jd0piQ1hLbFMzMGx6RHRvNTNmMUEyQTY2YTVLcVlpZ1RnVjA0OTZkMWhTVmxcclxuICBLOEE4MkErVWVmaWZGeUJTS0JWV2ZjYzE5eTUyNjdvN2NRTE13SmhwbTJPR2FzQWhUQmp3N0ZTeWM4U2VaMWE3NDJETk13ZHo3bkxtXHJcbiAgY3lwWkk1Rk1lTVhuVTROSlRIejlZblduaHZuQVVNaXF5M3RGOHNoMGtyRU5GbUFpelFkZEpldXpWa21yaTMrWGJxZmVMeTE3SEM3MVxyXG4gIEd6U1FKTWRJQ2gyaExYQjl6d2dMOGttelpuNnFCZ09xS1VPVWlIcEFFUCthT0NOQ01LbHJVN2NhakVHMENRTG00Z2s0NTFMbjdYZStcclxuICBpbUZPcFFIbWN0T041K2w1bExlbnhpTFNIZUovM3JuSFNiTDdyZXhqMlI2NHY0c3VQQ0ZTai9PTm9mbDdMNDA4SjhaV3g0aWVlK2t6XHJcbiAgeVhUU1U5dU9yU05NRktjYmdOWUF6Ti9CZExRN2k2NUJ5dmhFMHdydk1nT3BWYkZjVU5vUmt0UjkxLzNYeUZiemhORGNUUTZrS3plWVxyXG4gIDRUeTVMRzI3eXU2L3BodFIrRzMvSjBxSW8vQU1nQVNLbEwxTElkNVl6QTN1ajJzS0JyZVB6VExKWmJYTS9nZ1QwYkpidVRVZVYzWWNcclxuICArMGRkM0ZsZG1aa0hjMVpNanh4ajhmZEN1MGthZVU3V1hhUVBEU1FjL2Fwc1dESlJkZEMrUHZEbk5lbC9nU1BxRTl3SFBWeWxBekw3XHJcbiAgQm9mc2ovdnIxN1U2REZibXQybjFQTWRrSmtpdnk3NlE1cTJjWkZUQnZ3ZWVhbDd1SnBrNWU0NzhOclNOekhuU016QUQwcFIzSkhEUFxyXG4gIHdUR1JhTXIySlBudXVnWlN2bVpUeVZ6N3JVeWJQbFAxbkVXYlN4eXozK3JlV1JtcFc2ZW1OR25hVkJxZitxNm1vUEIzNUdFRXBjRytcclxuICBKK3Zhd0NnVzZXUGppdG11enExNkRreWs3ajVIeUlEYmZwZDVQNU5GMkt1ckNqZDZZeUlNd1d3ZFZScDJqS2l4YWxTUXhWOE9HMVNWXHJcbiAgVVRTWSs5TXowdTVZenp6eTEzbGovWTdnZitsL0IzYjVYclp6QW9rZWlYbVorZVY5U3ZTcEJvTXdvenB6bW9kVldVd1R6YnpwTUk2OFxyXG4gIHJDVXk2ZTJyMUxnTy92N3dSazFRaWEwcUxDa3VHLytKTWlFWXpNSmZYMVlwaEdYdUQ0K3FKTUpGMStYa1MzR1ZEdEw5MWtWU28wWk5cclxuICBxVks1c3FTbnA0dVRTeUxFNWVIN25wY1Z5MWRGQ0QyRUZNSWVKdnpoOHNBQjdudHdzSDNiWXdLVHB5VE9GTXMxSUt3UWFtWUFSTElJXHJcbiAgWHlNTUl0ZVpOYkMwNHdhTzB4N3QxcTFiTThJUTJMKzljNm1IdEFTc2pkajZPOThySm83L1c3SnlDcVJIcDZZeU1DN3hwTUVra0IxTlxyXG4gIFI3dXpNTm85TTBGS2sxMW1JTGpsUnJDRDM0M1loLzBEdlV2WndDdkE1ajJQTWFBSDdXd3B5b3MwbVliNmlnM2RFUkI0T3hnY1VDSWJcclxuICBISy9XekQxTVZ5YkpXNzc3UU95RS9MVUx0ZXdKTW5tMW1KQ0c4L1JFajZBdXEyeEg5R0V5ZUY5dFdoMTFHTUQrb1hYczNPQWNXMkFjXHJcbiAgN01PSVRud0hnWU9WRzNaeEJMR0wxcUNPdndkM0RjYzhHTldSVWdVVlZuWWdmV2hiMnB5dkJ6aW5RYytUWmVYa0w1UXBKbGR2TDgwdlxyXG4gIEdDNTE2dFRSYXJ4QVJod2F3WjZiSjhrVjNQNFZ2K3Q1cEhEUktIeUhMWnNMWk02MzkydUwvQ2N4SXE2NlU1L3NMWk1uL3kzNWhadWxcclxuICBmSHFxcEpWUGRlL05NYytLRmFWOHR3dWxxUGtKVWx5NGtWTWkwZ2ZNWThISUYzV0VXcUYyQzVuOTdZTmUrbkNWWmdScUsySjlJRVltXHJcbiAgbFZScDdHZTFSQ1VJWm4vM3FPcmpZUjZvcTRDcXNZTFJNMGJ6WDk4YzF2REF1N3dLa0NsY2UxM3U1KzJHZVdSVXJhZGx2V2dDc0RmeFxyXG4gIGtmOTU3UEs5bFZJWnhzQzhNK3ZtL1NtdDNYT2M4Y2xRcllzOTVJOG5qM01NeGtzVDQ1OCtOcWZMMmMvTHNqOC9VQ2JUL3JpN2RDWkNcclxuICB5akNJQ3JXYUs1T1k4dTQxRVNtRVMrSWR4M1pSZnJZNmFCQkFDSkJDVE5WRnFoUGQ3enBqaGM1blM1TWhEMHFuVHAwa3MycFYxMEJaXHJcbiAgVldPQlYxLytSQjU2NEFYSjI1QWQ3SWt5QnBNb0RGZGRjWm9TMkJ1ZFZNQitHMkdIZ2ZvSlhIN1pxVXFnNHdrNDI1YlNIYyt2MHVZTFxyXG4gIEo2cWJ5SEk3ZjlVcUJqV2xTd1RVMjFuR1lUQkR1aUhjQnRQd2hqNzM3ZUpkSjFHQjQ0NGFJRjI2ZDlSeUdPSG51VGZSTDRpbVg1L0FcclxuICBrTDRiREtRNDZNL3h2OXB0MjY1Z2pRR2RLVWFMazFNbEthTmF4SDJYQ2t3bVF6M1BTRGlYayt4MmttUnJLQnV2QnlWYndrVmZRSi9QXHJcbiAgV3FXWm9FcTVhbzFkMmJkQlZDN2x6Q1k5Z2hmbXovTlNDRVcvRGNFdktTbnlra2d3VFNjTXdlZjQwU3A2cGkvNkRXSS8yTGY0OTljZFxyXG4gIEE1cXNDMWxybVJORUQ5QzJMcjVNNVBtQ2tjOXE4S0RmNTRoaTluSzNZb1BNdTI1a3QyQ3NNZ3h5WDIzT0M2TDA5Ujc5S2Mwdi9sMmFcclxuICBObTJpTmhHMGd6dzV1djJDdjMrVHFlOWVLc1hMZnRkb2M2WVM1ZDdIUEhXVXo0T2w4RFBLWlM1K1crY1VaN3BYK0h4K2dSTlJuUVNTXHJcbiAgV2FtYXREcnJvNGlVQWNQam9rMzN2MFE5dmxCZE5SbHdYaVRYVWUzMkIydmdIZ3pEYkIvVm12ZlMrMVFtNGhpQ0FjTXNqTUxuUXZQN1xyXG4gIFVMOTBPdW1oaU9xSzQzKzhPNndsdjZkS284NnFxdW43NzI5OVpZZnRNUS8yYkx2M3Z4TzdkSytsVklRQkwvN2RlN3gxUGY5VitmUDVcclxuICBNM1hPRThCK0pKS0ZZeitwaERxMjdiRjNSZ3pxQk1yaUFZY1VRdGJxdnorNHdVbUpRMVFLZ2JGc2RkZERCY2s3bVB2RDR4R213dnZuXHJcbiAgZklCNmkzSzFadnRwbVFwSU4zWE8vRTM2MzdkUzJyWHpLa3BBUC8zdWh6SFNlYjh6NVlldmZvNm9zZUtKSzJEN2xkYytWZFVWeEpEdFxyXG4gIE1LRm0yOVExUnNUajJ3Q2ZmL0ZMNUR5T0o2cVRubDVXZnZqeGR6M1dzMmRIcVZXcnVwWkx5NHZGZ2kzRHJzbXlJMXh6elptNjVoeUlcclxuICB2SjNEOW5ISERrcVlYVGlNY1g5TWxNZWZmbCthTmEwdiszVHJvT2VIZjdPdDR4bkgzbUlrZUdLQnZBUTV4bmFaZ1d6TlNKVjlxc2VtXHJcbiAgTkVuY3U1T1VnZUE5bE9KR0lybEpwRER4cWNkOUJEcm4rSVcvaUVrVjY1QzN4YmVsQkViaHRnUENxZEJOdHYxaVJKdzA2VVIwVTVmWlxyXG4gIEIvT3pGdXYrOUNvUUc4YzRtdmFRdkRXSVlIWXVLMTgySmtMRU9lV0t0ZHVvNFp6Uk1yRWZKRGhNcjR3OXhzNE56bkVMLzFCZnNZL1lcclxuICBEekx1Vm5Rak91d2ZHczBkMVBkSVV0VVZjMzRRUEdqN0FQZnZxL3I2SktQYnRIS09NcEdjNWRPa3hhQ3JIVkhlTDNLY1paM1VrY1pOXHJcbiAgbTBxbGl1VjFwT2Rid2lkOHZ2ejU3SEdTdG5HMnp2T0JuUU1tb3JFZmVyNGJyZnk3dW93ZlA5NUpMeVdhSlFCV1VLMXFwbFNwV2sxNlxyXG4gIDNMRlUxczM5UFNKeHRBMFlTVXBhZVNjNWRZMk1SRW5HU0dzNER6QUZMb0ZqSm5IRU13NUZrQWtYS1lQYjREaGxHRWJMd1ZmSHFLNVVcclxuICBqKytJNDZxL2Y5UWZsdG1rcXhTc0Q0dms5bXM5MklyZDg3OEhPMzN2cFZUcWZOcGp5bVNabDcxaXphYktpQW1zSFB2Y0tYb2NnL3FrXHJcbiAgVjg0cWFMRHZDVHBRZ1VHd0x6ZHJVVVFLd2JVYlpvQXRhOFpuUTZYRndWZnJmckl6YTd5SUE1NWE5QUdBQ2t2VldBNGtGMFcxRmIxQlxyXG4gIC8zMDB1WGljdER6aVZtbldyb05VcXVtWi9xTFo4K1RJWTY2VXI3OGRyUVRlaUtGTnpXcEEvV0xFRnFNNWh2VXcxcXhacDdZRW0xcVpcclxuICA2TzR3T0E5VjBhKy9UVkM3Q3RlZ2ZqeG9tM29QUFBpS3BoaWhEblZMazBJNE5tclVYOW8rZFJPMUdZL3g0MzIwTytCYWdIYVFmbUlqXHJcbiAgNGJmRnhQRlRaUHpVQmJMdlBzMmx4NzdiQmdmYWVhV2R2emRRdVpJUHYwZ1V0TGxMRENRMzI2c1RSdjYyL1p1MWJvUU5CTUsyZFV1aFxyXG4gIDVHOHRweUt4b2t6MHNrV2JmSzc2dk5YemhPeWVkckpHb0llL0dOY2hvNHpENE1xNm1hVGVXeGpSUVRqNmZOMjgwZTVESVhjVEVlWklcclxuICBGTlN3dHJTb2Yvakhmd3lNVmthQ3FOWHVFRmsrOFdPdGlxc3M3ZXBDaFdCaDNtZjJMWElTeU9vWlA2bTlZdEdvVjJUSjJIZTFCbitNXHJcbiAgNFZSdDBzMUpIOC9KZ2hIUGhDTHU5WXE2dGhWQmtadnoxcm43SDZPSkV5ZStTZlJxVUMrbzF1dXl6Nlhhb1k5S2g2TnVranExYTBweVxyXG4gIGFySVVGbS9WM0ZSWkd6YkppbFdySlhmQmIxSzBhcExNK2RyUFA4N0pDNTd1S2hudW85cmtKQTdVWG9DTXVTMWJ0cFR1dHk5eWpPTU9cclxuICBxZHFpdDQ0c2xYbTQ2eUYxelAzcENWMURMQ0EwVENmTEdyc0hJQ09zZVY1eGl6Q0JGSjFhMTRtLzg4ZTVlbmNwZytDZ2ZaN1VJUTRCXHJcbiAgUmxLMlhHVlZYZjFHZW81Yi9JajIxd2NPam5oY3BXZHVHelRHZFZqMkNxeXgzVm4yQW5hcXFWSXFsVWxKbGJXemYzZlA4alpaT3Q1SlxyXG4gIHZnNHdpWEV2bktYUGZOV3NQOUp6Wm42M3BOczVMOHVVOTY1VlprRXFHU2F4SW5zdm1RS1FJckRmOWJ0aHVPYlBnbUUwTytBeU4vam9cclxuICBvNHdHUmtKMkJzcGhOVlptNHk2U1VyWmNSSlcxTm9penNwdGRWWlFwOWV2WGsyYXQyK2xBQlR6NXlNc3lhY3BzeDBoR3lldXZmNnFEXHJcbiAgb0RBUlJFSmhCQTJCSm0ySkJRYkd3NkxETTlKOVB3c0RKblRyTFJkcUhBaElOQ0kzQnRhekJ4bS9QWUd2b1BiRnhHK0Mrb0Q3b2k0TFxyXG4gIERNcjJKNElkZ3lIYWIremF0WjA4K2RUYm9mTmlyemZ1ajcvazBTZmZkV091RXJub3ZHT2s1MzVkWTY1aDZxcEVzSHFzRTAwQnZLc2dcclxuICB2eDFZbE1DbXNzc1N5TTdCUDR5Y25Cd2JkRG9reVpaQ1Q2eEk2bWNvR3hqUVNhQm9qOUR5VnZuRmlHc1licDhTWkY5V0EzcFE1bCs1XHJcbiAgbXMxVUNtRzdjcU91N2ppSkV3a09KSUNSODZnY3RNRTJjR1VOSHRTeVkyQjEycXJoUEcvOUVxbmY3VjhheWF1bitocCt6UiszRVBmQlxyXG4gIDBzaUo1elUxeG9SNU04NzFCdWJ3TlJ4TUFpSDJnMGhmUEtTcVlrUVA2dmhmNnhiM256VDIySUtZZ3BiZ1BsL0ZINS96L1lPT2tQL3FcclxuICBwSkkrc254MWptTUk1ZDFIV3Q5MTVuVDN3aDFqY3RXd2ZZMTRlTERNKy80K3FWT3ZyaFF2L2xsV2YzNmVMRnUyVkZZNzVxTHFMMWVuXHJcbiAgUnZXcTByRmpSNmx4em1pTlZFZU5BWWhzWHpiQkV5UEFKRi9ZUFF4Nk93N280R0VhK2V1WDZiNnc5TEg4cnk5MGpYMEw0S3BMSFlpYVxyXG4gIDJUc0FqR1RJTTFtU1V5aXF1cXJSdXErT3FnZmRsMmh1QjM5bHUvNXVnd2JDeTU1Z0w3YTFVNmZIVldvejVDWTFrb1A2M1k1UktRVEdcclxuICB1M0NVajhMR0xqTHhrL3Nib0lwQ25XVlNDSTRNWkFCQW5iVm85SnZTK3ZBYlZjMklkRUdtNUlxMW04dkt2NzlYYVFTbXczbnEwdXVrXHJcbiAgVGFDcUs0ZWE3WWhKb3MrMjErTTV5NlpwSDlURWlnNTVkUTZXdXNlOUpzMWRQMjdkMlJPNEpOZEJIM3IwZGZsMXpEUjU3cVZQNUtwclxyXG4gIHlON3JnZjBVSWduUnYrdnU1K1h1TzN5d2FSZ1Fid2d5aEhKbU1DOTZHQXNXTEkxSUNOU2hUVk45eFdPLy9hSXhHaEQzMGlRUURQSmdcclxuICAwRUg3YVYwV203d0t5YVEwVUkvZllzUWR5Y01ZR3NmQ0RHSGt6NlBsakl2dmw0MGI4MktDQXdGMVM0TzFEYXpla2lYWWZQY01KTENrXHJcbiAgdS9FODQ3SDdER1FuZWpsVHVOcHJZQ1k2b3BBNWNYT3VWNEV4RjdlM1dZUWJTNUtpSEZKU2VGS3FpQkRoWUUvMGdQK3Jsbm95K25xOVxyXG4gIGVya3E5WDJBbkN1WGRjektkMkluS2F5WTRacEswRWF3RDBNMXRnOExIdlFJRE9TNkkxaW9uK1JuQ2NTdjNzL0dSdnZUZFI5MkZBODdcclxuICBCM0RFL1V0TzFheXpSSjZ6YVB6SEF2ZXl0V3IwZFpBMGtWUXVoUnRYcVJxTHpNS2NiNmpaZHBEN2lQdnJkTDJ0RHIxZTJsNDVVZHBlXHJcbiAgUFVXNkhuK1hlc0hBUEhqbTNOZTZkZG15YXNWeUdmUDhxVEx6ajg4a3kyM0RPRkpTa3RVVk1TT2p2RlE1ZllTbW5jZk9BU0FDWEsyZVxyXG4gIEkwWUFld2dMRWdkTUJJYXhhTlRyS2ozMHVlWnJHWG5mL3BKZXVhNGVJejBKRElGUmJjME9CMnVaZkZVcWZUallyMkIvbUpIVXJGUm1cclxuICA4WlQzcnBjMmVGb0ZxRnkvbmF5WituT3dCZnpaMFNleGkrQkVXLzVKN09GMWR1cTB1RXA0WmNFNFlCTFRNYWc3dEhOTVl1S2JsK3MrXHJcbiAgbUVEWmpYT1hFK3lwVTlrcU01a2hmNzE2Z2I2cmNrNktoeUY0WnNFY0xmMmxJR2UxbEsvZVNMY0JVZ21HYzc0aitvaXBzVERLWjdsdFxyXG4gIDFMYTQ2QzhqN1k4RFVrbXREb2RxWHlVeGFYVTM0R2wwd1NnNTRPTG5SUlAvdUJIbWttVnI1TDMzdjVPRmkxZkxiOFA5N0hla0xoOGRcclxuICB1TytlZXNyaE9vOVFtSGhDTE4vLzREc3RzLyswVTMxTVJ4alVnY2tZWXlDVXdHSWx3dUE0OWhiaUs4endIaWJHWVdDUUI3aTBVc2ZxXHJcbiAgMGI3RmVTUkMrRlhGM3ljZ0UvRHZ2LzRwOXo3d2loeDY3R1Z5K3FtSHlaR0hKUGF5Q3NNWWo2MFR0YjJuNE5tWGhsMW1JTmRjZW9hdVxyXG4gIDAxUENITm85SG50Q3dicEtXckVVaEd3dUJTVXBialR0NHpwODVIbVNGRzVZNmFxSEg2MHYrd0JDRUQ3bUVaVWFnalBkTm5wWnl1VGRcclxuICB5Y1AyNFlBRTRpV1RwTWkwdE1tQk9vVjliTE5va2JJclZISFN5cXEvdjlWTjBwbHpCVktESktXa1NHVWkwTFVxZTZQbks5d0tBenFKXHJcbiAgNDdLWFRGTDFWZmJpaWY2bys2UDNySXNiMTdnUFp1dldZcFZBbWpsaVRlYmJhdVRBaXJTRksvSllOWjZYclVEMGJwTGFQdnhzaHJxcFxyXG4gIGYyWjhNVlFsaEhKVkd6dXA0WDdIL0ppSDJrbGMzYytYVnExYWFUcDRKLzI2ZS9MdmlYSytZOWo1K2ZtdVF5UUZBWWxibkxoZVVicmVcclxuICA1a2R2Uk9EUEgvNjBJd3grVkduU0Jtb3JScDRySm4vbGVGeXlNaEhRWUw5VG5IVDBoQjZEMkpBcWcvdExyMWhkaVpBbFJqU1FYb2JiXHJcbiAgTjVWVisrQ1lNWks1czZZMVRFN3o3c2xJSDZhNnF0R2VlU1k4T0Y4ZndhNWl0MC8wMkxSNnZzeis3dkVkTHRUYkJydDU3WjA2TFZRQlxyXG4gIGhyRHNyOCsxM1BhWW9jcE1zQ1BOL2ZGSnY4OHhreCtmUEs4dVNTaEpOOE54QmdncnB2aDUwWGxudUFERFRFemFZRjhseDhSeGV2SHZcclxuICAyWHRwVVlZNW1CcXJqUHUyckV5aVR6OXhsLysrbU1kZmp3Y0RIZ1ozS1IzT2tFT2U5YXFsclhrYnBVS2xTckord3lZNTY2Sjc1TjgzXHJcbiAgUHFhamNBc2dYTFJvdWZiVitMZ0djeXRsbWxtYmtUQU1pQ2tTaUJGVmlMM2xqZ3JEam1OWDZkQ2hoVzd2aUJDSEdRZExhVWtZRFdGcVxyXG4gIENlSVoxUGcvSjhsdDk3NGlkOTN6bEpvS2Jyam1kT25VSmVxRVlMQ3N1eFlEWTFKTXZIb3VhNTFQZXJzcFVGSHZLYmovTlhIVGVZRGRcclxuICBsa0RxbDdQR0VuVnhKdzJVSkVsYWpjYVNsQlp3N054MWtTajBTTUpFZWxjQ2VBSWRRT3ZRRWQwNnZucHdQbDRrTVcyNU1uTTErL293XHJcbiAgRHRlNVhGbm5jWGJISXUzck9iNlRBeEk2TWlNZVVrakZPbTBqYWR1SmFsODY3b09nZmdCL3FycnRNbmtPNnFzcURSeVJkL3VZOW5YYlxyXG4gIEJJcEVoWDh2bWU1akl2YURPVXFXL1BtdTFPOXhnanZpNjloOVlVQkg2aWphNUZNV1pNMzdJeG9qUXkyM2FuZk1QYTRla3NraWpkR29cclxuICAzZGxQOWs4Ykcyb2NMRldyVnRYUkZLTTgzb0NablFvS043dVBjYXVrcEtaSTlXclZwZForUGpNb2lEQ09JZDZHWVlHQ2xSM3pZclRKXHJcbiAgeURJOEpleXNMKytXeWU5Y3BjVEdKb1pTeWNOdGs5S2VFVEhicERhQkdjejYrZ0YzZy81RzhMeHExTzlzWlNRVmE3ZVU2dVZsUHZwNFxyXG4gIFl4cUpFSGx2dXdML3lIWUx4alNtZm5LVC9IeFhkNW4wNXBVN1hFWTlOcWgwWnJLYjk3TERVMElWNm5VNU1pS0ZMUG5EejcyQksrNFNcclxuICBucTFqMGlwZFZKREZXNHVMTkxFbGtoOHhJakFFYThhWUI5S0ZTUjQrRURHcXhtSzZCTXBBdmJFY2N3RFdoMGlOWStxdExNY3dwbjl5XHJcbiAgaTJvQ3NPZXRuYzErL3pDd2lReCtKazhhMXFzcmRXdlhsaFVyMThxREQ3MHE1MXg4ajJNZ1d5UnJsWjgrQUdEVENNT0lKcW9WaUxoSlxyXG4gIExBYUlOQktJbGFsamswZUZFU2JtWmlBSDIvUEVDb05aKzBpME9HbHk0cGdVd0xYRDU5azJFdGU5RDc0cUM1ZXZrL3VHWGhDeE01Y0dcclxuICA4NGhLUy9OaEVmYWJKd1JKSi9Hb0JOV0MvRjZUSnlkT1FiS3I0RzFOQ3lMZ3c5aGxCdEsvbDlmMy9UVm0reHk2Y1NYSCtYSVdha3hCXHJcbiAgcS9xMVpYT2VZemp1THRTZE5vQk5Md3BoU0t0b2NSOU9NZ2xVV01IL0VMU0Mvak5pVHBuNUQwekZROUpFbXh1RGVTOEFCRXhUdUVjWVxyXG4gIGdLc1pLclBvbkIrdXFLbmJWOHpVTXBJTE9ZTW9ROUQxdWl6dVhDdWp2aW9wZHBMSDBrbXU3Rjhtd1lPa2d0QzZDbCszVnZ0RFpPSElcclxuICA1NFBFaVQ3N2JxN0dxWEE0V25mYzh5ZXE4YnhxODE2YUZudlp1UGQ5UzBFVlJuSE1RYzNFVXV3cTR0azZXQk1aVHZycWNQWjdVcjl1XHJcbiAgWGQxbWQrQnhxNUlIMnpXcVY1Y3RtZTNVZGhPQk93RHo0TVBQYk5ZejRzYUx6Y3BHbDBnbDZxSGo2bEErOXJVdGF2TllNUElsSlVhMFxyXG4gIERkUFlVckJKQ1F5ajJkVXpmTURhbHVKQ2xVSmdHb3hveWxWcm9IV1phVzl0bmpTMWR4S1dQZ3oreUM2QUUzYjVKQTlqSEwvYzFVT1pcclxuICB3dlNQNzVYQ3JHaitvZTBoWjlHOENET1o4TnBaZTQyUjdHeDFHQWZxUWtEaVNaZ0ppUmZKMWtzak1JUVo0MFkyYkg3d2xVN2E5aXFnXHJcbiAgaW5WYXFlVFJ4a2tvTUJzWWhHY1dYaEtaL05ibE92MXpSSTNsanBFYVI1a01haXkzQVBYTWNtWDZONE1sZzNudDJSenF6Skd1NEg1YVxyXG4gIDlIWHRYeVROTHgwcmpmLzFvbVJXcVNKMTY5V1RaU3V5NUk4Ly81WnpMNzFYUHZqb0IwbDJUTzZGWUphOU1GRGRlS08zNkxTMzhUQWJcclxuICBDR3NJdGpHVU1PS0p1NTJ6cmR3UUJlZXdnTFZ1WkE0ekd6Z2dsckdFRVcvdlNFOHBJL2M5K0pwODhNVnZjdFNoZmVUSlI2K1hiajFqXHJcbiAgOHcwbWdsMnpTcUJxczk5czBlSnBnY0hiVkZyeGFXRDJObmFaZ1J4dzJBRnk3Yjk5Q29SRXNJNmVWTFJSOHBLU2xZR2tNWjJ0VGkyS1xyXG4gIDExV1VnVmhXV0l6bTZaWDh6SU9jWDdaeXJZQVk4c2N0MXFnaHN1MlBhZjRzS0tRcnd6eVVnVkJldTBBbEh6Wkk0aGhsQU1HNWtiSmJcclxuICB1UXZpZ2VVMzNJUFB5MUdtc1hFRmJuYmVOZGlPQmFkNHVJMHFEYjBiTDB2QmVpYWlpa0t2eVgrM2tMcTlTZjhMVlgxVnRVbDNOekliXHJcbiAgRlZKZkJaWGNmOUt0YzIyWXlNYVYwNlhqU1phUjFOZkxtdnQ3eEhVWUtKTUxqckZNKy9nR3lkNndTVktaa01ydGdVMlQxd3BnKzZoWVxyXG4gIHNaeTBPdjhIVlNtZ1dnQjRYakZkTFl3QlhUYnBVd0FwTGNJRUF2VlZhb2JydkZ1M0t1T0FpRlJ3eElXQVF0RHN3RXVVcVRKSkZNQnBcclxuICBvRnoxUnNvMEFLTmdHL2thK3A1Niszd2tFdFF0aWVCL3BmKzdROWhqMkExQTZHZDkrMmlFY1JSa0paNWNhR2V4YXZLdjJzNWZiNTYvXHJcbiAgVnhqSmRxdUdEaUw1WlMrYXBNekViQ0VBWm9KTlpCck1vbHQvdlJsVmM3bDkyZTZkZWVraVZvMlY1ZDV2OXRLL1plbWY3MnQ3dkcrWVxyXG4gIERNbENyVjlVeGIzY2dVRkdCU2ROVnF6YlRsV3dHNWVUc3lwSnBST0NWcHNQdWs3dG9HRWEwUEx3VzZXY2svcHR6dlFLblU2WHJqZE9cclxuICBsM1lkTzBuTk92VmtmZlltZWVhRmorU2tjMXovYk5OY1J2eGdIbDRlTUFSbUZTd05IRy9idHBtdWtSS01BSWNCODJBL2F4YUlQZXRFXHJcbiAgS2h0QTNVcVZLbWdkQ1BYVUlOVjVva0E3ZzdHaVNSUCtscG16RnNvdDk3d2tmYnUzbHVPT0dpaHQydmx2WjJmQU5iY0g1amNCblRyNVxyXG4gIGpPZnhxcTNkUldabU1MOU9ISFpMaGNVMGlxWEQ5MlJjZUVtSkFmSUxjaVVsblJ0d3gySmNlSWtMU2RJb2FROS9ialFIbG9IOWpoUXJcclxuICBnZlZsWGR4L1J2OXNlZDA1TzdaRVBMQlkxTER1Z0dkV3NNdisrS1lvdTBMNTZrMGxWNlVRVXBpMDFjaGJtQThmdzhabGpva0UxNDR5XHJcbiAgSVg4L2xSc3dBa2hTOVJWQmIzVTZINkhxSytJbC9EbkJOVUxub2I1aXFWamZmV2dZMFBXSVZsUjQ1dUdOaWNscEZTVExNUkovdnA0dVxyXG4gIDlYdWNwSVo5Y2xrQjV2OEFXc1A5YVRyZ0l2ZlI5bE1ET2NrUU9jZVFWalpaZWwzOGdlWWRnOEV5WFM5bzNPOGNaU0lHR3pVaWZaZ3RcclxuICBoRFdaV2JtR3FTY2dNbFdiOTNhRXlERVh4d1RRbFJNWEFxRkN1dGhjc0ZHWkJ0T3AybTJVYkM3VWZXWThYNXN2VGFjNnFRTWdmYlE2XHJcbiAgMUtjc0I2RmIzekYycVhJc0lPNFErc2x2WGIzSGpDTWVLLy82V1JuSmpDL3UzSmFKZ0YyNDcrMVdEUTVDNkNlOTVTY1lLMVBXSnpGdFxyXG4gIGQ0eGpISTZaRUdRSWs4aktsYVl3QXM4cytxdVhITXpCQ0oweUUvZU9xZHYxN0pmVTRVVWxqdG0vT2tiUlg1S1NVelF6TmYzRXB3ZnlcclxuICA1NlZYcVNzMUhjTkFrcTFZejd2R0F0UlcyYTdQbTdlV3V0cHprdnMvNC9QYmd4eHRycDdiVDMrdGU5cDMwdjM2S1dyTHEreWtrcVZMXHJcbiAgVjhuUHY0eVZVODY5UTI0ZitxemNlOC9Ma3VaSUNjUWNWMTRqclBHVFIzSDhtV2ZmMHpYcDJHMWZQRGlmL1hhTU5kbHpFNEc2VElSRlxyXG4gIEhRaDArN2kwOUlrdy9lK1pjc3ZRcCtYNjI1K1FwczBieWtOM1hDekZib0FkWmdpbDVlQUt3MkpLN0R4elk3YnRidDI4M1lROFdjQWtcclxuICBrVDBGcVZzU1liY1lpS0YzaytCbEJaMG5qQWt6NThqV29oS2R1WTYwR1BpWEszakJXaCsxbGI4cG54ZkxONEkzaHdmYmJyRzJiUjNBXHJcbiAgRTBYVVhkU0hDZUhoNVVydU9reXBDVkNSRkJmZ21ZV2F5MGU4UndpMU5oQWwyN2xyNTBmbUtRSE1WYUhHZDFmUHN2cEc0Qyt1WUFJZVxyXG4gIEQzUkV2czNDSEIvYjRoR3RDMkFjMFgzQk90UWVJMzhrRHc0UmgwRkJqMGFyeU9SM0xuVi9IU055ZFZGbnpmN20za2dUZklEa3ZzS2dcclxuICBQWFg2VkoyUXlzQ2NIcG1WcTBodWNZWiswT1p3QUJiKzlySVNBejUrcmxWYzZHZUtJeDNLYnc4Y3FBUUY2UU1pQ0ZvZGRvUGJOMEErXHJcbiAgdnloVEt0UnFxb3lBVVN0TXcyNjFTcE91RWRmdHBlTStFdUplWUJxMTJqSXZmV0E4ZDFKSFdHVTEzWldaVVRCcnBpTWt1Z2VFZm54cFxyXG4gIDJJa3FpUUJCUnpyNGVWaFhKZlQvSkJZTWYwMG12SDdPZjRTSldNQmZwNU1ma2JXQlRRUm1BSGh2Sm5tc1lTWkJoM3JkamxWbXdqNFdcclxuICBzR0xTVjdKeDFWd3BXTGZVRFFDTzk3Tkhidlg5Q1kwQ3RreFNvQUNZaTlsQkNFQzFBWWFIZDNTaHp6SGJKWkt2Z1FCWDB1M00rWTQwXHJcbiAgT3d4K1VESHhJOXppL3FmWDdpUjloODZXT3ZWcVM5MTZEV1R0MmcxeXg5MHZ5TTIzUHlXbk9tWXljZHdVR1QxNm9oSnp2SVVTWmFJZFxyXG4gIGZFamZDSUZsYmZOL2hNSDVIQXZYSzIzT2Rlb2FZY2JGRllUUERXUDB5REZ5NjdCbjVOUHYvbkJqNTJTNTg1YUxaTkQrUGFWVFYzOGVcclxuICBiVVVkQUdLWlh5SVlnd0NjYTRHVUJvdUhzU2xvOTVZRVVxV0tWNW5GWTQ4WXlMZGYveENVRWlNNTNkczRLbFVrQ3AxVUl1S25zOVVPXHJcbiAgRWpXbVcyZFBERWRBUXdUV2cyMi9MMzg5ZWE4Y2NWUWlueVRscWpiMGJzTHVIQUlUa1h5b2FWSHcvSWxwVDh0SmtydDZuaHV0cDZ2OVxyXG4gIFkyTXdWM3ZGV3ExVStrQ2k4V1RjTGJRYmxNMTlOM3ZwWkMyVFIydkQ0b251bnZBVzhiV0FsZXd2Nml1eTlpSUZtQlNoOXhHNkwwMFBcclxuICBNZk1YS1ZzdTAwZWdjM1p3cjJRY3RxekRHQ1ZiSG5xVFArNFduVURMWWZ5emZzYTZGSXdlQVRMU3kwcWx5djdqd2FEWnBMK2ZWOElBXHJcbiAgQWVERGg1SFU2ZVJuTnFQOTFzd0g0UWdFcnJzd2l2bS9QQmZZZUVUMnUrSXpsVHdBVWdnZ29CT0dnL29LeVhEQnI2L3EzYlU1OG1hWlxyXG4gICsrTlRVcTFWWHlWZ0FPTTU1Mm5VK2RTZkkycXM2cTE5RGk4Ti90d2UvTS9lTFVESTUvMzByRW9IaGRuUkhFMy9KRlpOR2lHakh6K2tcclxuICBkQ2F5azc5bHU5WGN3UTRuM3EvUHVGSzlOcHB6REJqalVHbkVNWXZXM2ZyUHI5YXNwKzRyV0w5TU10eUFpL2NHZU45TW05dGt3TG02XHJcbiAgRCtiVDVZem5Jcll3MUpuc0k0aVViOXNrWm9EVFJYSkttbVpjWHFQenpaQ0xMVjh3c0xjK3dyOWZNN1lEcEJINmU0VmFMV1RUbWpreFxyXG4gIGdZalFocmsvUGlaZG5UVFM2SmducEVLbENsS2hmQVVseGdzV0xKYzdIbmhObm4vcEUvbitxNStscktPbEZTdkcwcEkrZmJwb3NrU0lcclxuICBMV0M5VXZOZHhRTGliM1dpakNEeFU4WmdiWVE1VVhRMmh2RWJibmxTeWxmcEluYysvS2JtQWJ6bjF2UGtqdHN1bEx6Q2FIL21PbVFlXHJcbiAgdGppU25YNzVjUWovdHFYTC9LeWN6WnBHNTF2Wkd6RDM1WGpzRVFQeENQM29vSmlXSEl4U0N2ekR5aXNzQ0NTQXFBMEVydzRENHJHZVxyXG4gIDZ3aGt4SUFPWXA2blZ0Qi90cDl5aG1NWWxES3FOaEtDRWYwQmdndUR3S0tBNkhyYUhKeW9vQjIvemQveXRacDdLU1pTeGM4d1dMRmVcclxuICBlMGt1RzNSS1R2RWxEN2RSTHJOK1pHUFRLaWQxYVNuNFEvdTZlUHNIZWJoSTRhNHFyQVYvcXByTVY5VXpGS2l2V0JqNWx5bWJJU3YvXHJcbiAgL3RydDljZXRGbk4rckhPU0I4VGRraVVxWElWVXg2QlJYeG1TU0lVY29GaTJTTnQvejlhSnZHYTVrYURaZkhBOVpsVElSNDA5eW5UYlxyXG4gIEJSdWlRVWdRREd3ZWdMblZ6VWdLb1duVTd5eDFDelc3UnVHR1ZicS85V0gvMXVoMHZNbHNiQVVqUjMyRmpVVFZWeGpQZzJOclo0L2FcclxuICB4bmhleGtrdHBTTDYwM1lMeS8vNlVtWjkvVkN3OVovRGhvVnpTbWNpWUE5L0Z5QitCbHNUS016enpCSEdzWGJPNklnMGdockxCN0Y2XHJcbiAgRjkveTFja2RoMlE0VkdaOGZwZlU3M0c4TWc4Q0MyRXdmengxYk1CTXZLb0xodFM0NzltUzVyNXRqZkZ5NTlKUEdFU1ZiQ2wwZzRjb1xyXG4gIE1hL1d3dmRKc2pNQStwc2Z5TGtCa1pOQ2FBLzNkendVUWZCcHF2czYzMDJXdTIrdDIvMHM2ZDZ6aHpSdjJVS3FWTTJVRFRsNTh1NTdcclxuICAzOGk5ajcwdng1eHd2ZHgyeDdNeUpwUXBBNitxOEh6ZUVPMnlxZDRlR0FiRTE1aUlFZVRTSkFJTTF1VE5BcHpEd3NST1o1eHp1NXgwXHJcbiAgeXZVeTdON1g1Y21uWHBXcnJqeFg3cmpoSExuMXhuUFZRRTY3Wmw4QmJIY0p2S3IyRm15TzlMMk54RTlpTnhuSW9BSDdTTk9Xc1RuK1xyXG4gIG8zQk1ZRXNacWVRWUZteWtUTGxVblZTS3pnVk12V1RiRkVqYVpzQ0Fyc2RjRHdvVDFnakN1MXdaR3dFZ3dSNXhKVEVWWEJ0TUlBVnNcclxuICBIaERmTTQyaEFGZHdHemFGYldvNUgzdGgxWW4vMkZJRWc3UDc4WXZaUC9LY3RKRldvYVlhRlhGSHhmNVJCZnVITmFEdzUzakdRYjR1XHJcbiAgTnBOaTgzM3BYMUt2akZIdktrZjU5ZVBSanl6VVZOYTgwYXEyMHZLY1VSSDFsVlhKWDdkSXZydXFvaFBueTdpUGVLdVVoRlJZNWRJclxyXG4gIHlPcHBQNmh0QitaanFnUUN2QUNlY2hqa3pmNnhZTVR6dWdZUUMxUlVJSHZ4Wk4wbUdybk9Qa2ZJSWlkaExCNzladVFlNkd3d2lKbGZcclxuICBQK0RxOVl1b3cyWjhZWk5aZWZWVm96Nm5xdnJLMnJXbzlRMEx0NTJGYmh1RW5zbnVBT0k5OVdOdk8vcWZBRXhreWdmWDdCRVQyVzRWXHJcbiAgZDNCTGtiY3R0aGx5czBvWm1VMjYrZHhpRGpBTzlxVmtWTkpVN1RDVkdaL2ZxZnNBSTM5akZyeEwwaEQxdlBoOTNhWnQzai81NFhMWFxyXG4gIHpJOUlyUUFKeGFRVW9JTVJWNSsrWGIvblNXNXd0Sy9XRFVzZ2ZQM3pmbjVTV3V0VUF3Yi82NnJxVEpvK3oxVzFGcjExZ0ZOdXlOdlNcclxuICAvSUtmcFVHREJrR1FtMnU3ZmkwWk9MQ0hqQjB6UlZWYk45ejhoTnh5MjlQeXk0Z0pVcXRhWlduWXNJNU9KUXVNZ01mREdBZjYvaWdUXHJcbiAgMlJhY1Q5NHNNUHlIMzl5MW5wSVR6N2hkZnZyeGQwbDEwc2FEZDEraTdyaDNEYjFZZXV4blFjVWVKaUhFZyt2bDVmdTRtTzBoZk85N1xyXG4gIHk3NnhNOENlbWdpN3hVQUdIanhRampnaUd0eVZDR1dTbzF4K2M5bHFFUW5FNGdCMDhpZ0h1b2szZkhueVRCUzY3em9Cb0k2Nnh5M2hcclxuICBjbEFMTVZrUHVaRXE4NVpUOXU2N3ZyM3kxWDNzUjRVYXpkd3FlcDRISjFvcEtiRFRiQld5K09iWTNPZGFKM1JPc0F1WS9ZT1pGQm5GXHJcbiAgRTRHT2FvYzhRaDdSODBqZlhpYkZHelJKYVk5cVNrSGJXczNYVmViaHlxaXRjQWV1cW5ZUXdQR2t5RWhNa2VCNWtDd1BrRU1IaEFYUFxyXG4gIDVKcWRwV2E3UWVpRnBGeU5KbDVuN1U0ejZVTnpsZmxtRkVZSVNHMGZSc1c2clZVYVllSW84aUExT2VBaUtlL2FtL1BERStvQnhFTE9cclxuICBML084QTQzN25PSHVhYk9YVW9Kck5HN1NiRDY5QWJVVmZZQnBjVG1FTkFpMmJFNmNkaUo4ajdzRGlQYllGNDZYNGlCSDB2OFVsdjd4XHJcbiAgbWN6KzdyRi9qSW0wTzNhb01DOEx6QUVET3JZbHM0TVFWNFJ0cjFuSDNzc1hCL0VpekgrREJJRTAwdUlRYjRRMzJ5SnExMVZUZkVaa1xyXG4gIDJvQzVSQWRBaWNlbm05eGdoTlFtM0NWOWpBRUtVeTJFbVFlbzZpUVFYTnk5K2pYSlNZVTIwT0NyVEhLRHpreVZ0T243dVU3S0Ixdm1cclxuICBmeUhGVzB0a2MxR1JOSExNNGNaclRwRTNYN3RiYnIveGJEbnhoRVBreWFkZmt5SjM3S0ZIWDVBSEgzOVhQdi80ZTFubWlEZUVPdXFtXHJcbiAgRzBWR1JycXNXcDBsNmVscFVxT0cvelloMXZHTWhCeFY1MTE0cDd6eXhsY3llTWo1Y3ZpL3JuQ2ZVNGtjZC93Z2VlVGVTK1dOVisrVVxyXG4gIGZicEhuUWZDNEYyRkpZU0prMmJHTUFTTDdkZ2JNSytwcG50SmxkVzBpVStHdVdKRjJMNjdtd3drakY0Tm9oK2hKOW11UTZRVktVR3dcclxuICB4Z3Z6R0lINlkybVZ2TjFEYzJBRmhOa1RkZzhmclI3ZE5zVFRjUHVUdjI2SmVtS0I5Q29rMndzcVdxVmdNN1lCeXU1dWd6cXF5bkZsXHJcbiAgQWcxSm5ZNGI4S2JsMHlRSEYxNjNQM0ttTzhIL1JyK2trTk1yT0U2ZUtBaStKbGJVUFI1V0h4c0xZajViZURieE1VWHNIK3dOVGlFNFxyXG4gIHNCb3FMSFRLYnArM2RVU1BlN1ZWMlA0UmpLTDFlSkplQStuRFBtbE1JRFZhOXBCQmorU3BLNlYrdkc3ZjR0L2ZER3A0WkRicUdqR0NcclxuICAycWdSdlRWTW91bUE4OTBvYzBTRU1kWnFQMGo2My9DTGprWlJiMlJVcXVsR29ndVVRUUFJMWpvbmFlR3B3NGlXV3lOVExGSUhTZmV3XHJcbiAgTzJCOFJYMkZCQUttZjNxSHREN3NPaTJybTdCREpITkFHUG83ZHg4UTY5bmZQaXhaTTdZZnNQV2Z3dHp2bjFSVldxbllpZDliV2hYZVxyXG4gIHc0YWxmdnJYekViZW95aHNCMWt3OGhYSmFIRndYU2I3b2cwa2lvMnVud0xzVXJ6ZmRYTUQyNGFyZ0kyaUlIdUZ2NTc3NHoyM2ZMd0lcclxuICArN0FEd2xnQWZhbGl2YmJSZ2FPRFNrUjZzaCswQUw3OW1pMzdheG9kSFVhV1NSWW1Qdk1IZlI4dnlsMnZLbDBjV3hyc2U0cnV6NTM2XHJcbiAgdnF4ZHUxWWFOYW9yQnd6b0loZGY2dWNRNmRDNXJkeDFoNWNBSHJqdkt2bnEvY2VrZHUycTh1YjdQOHJCaDU4bm4zdzJYSDc4WmF5TVxyXG4gIEh1RnpXaGt3aHVPbFZWQlFLSk1uejFMQy91elRiOHVyYjM2dEVnYjJESllCZzgrVlRSczNhZDNQMzMxRXIzUFlJYjFrOEVFOXBYYjlcclxuICB1dHVWWEZxR291Q3B0MC9uMWpIMWs0TzR1QjJCV1VqQnZ2djZHQzZUUlA0TXB2b0ZIVHQ2aDZBR0RlSTlXbmNQNWxFYjc2cTgyd3dFXHJcbiAgZDFDd2VuVTBVdFJRN0VhL0d6WkhSNS9weVo2d1JJTUlYUSt3eURhSFNHQ1IyMStZWTNwM1Z5Zm9iSkcxUWJmOVRneC9wcXRQU2E4Y1xyXG4gIFRDRGxwSkNxUG02RHlIS2Z4dDBqekt3aURRZnRLYkVQZHVHKzZ6ZXdoYmdSUmVROFc3dmZXWkFqeVNsNFVEanBwV3lHRXUvS21rV1lcclxuICA2clRGb29mZGFHMjkyajlJSzQ5eGtwMWszUFVNSm9DcmovMGpITzFOekFld1dvenExN21SR0I4V0l6SStyREN5cG4rdDZkbUJwVEhwXHJcbiAgZk9xejZnRmp5SW9iQWNKVWlESTN6eGsvQzZOSXRtTUMyRk1nSkkzN25pWE5CMTNwaWNyOFA3VXVJMVV6bkNOMU1BMHh4bG5kRHFRWFxyXG4gIDFCOUZPcCtKUjZ2RHI5UDhTdFhiQmlvUFIrUUE3YVNrbFhQUEtUcFQ1VDhCaVBYY0g3WWRnZjVQWXVsZjc1UXVoZXdoVmt6R2hpYXlcclxuICBhWldQVlVCZGlPU1FYcVcyRGhEb1dNc21mS3BNaFdNNWp1SEFlRXl0V0ZKU3JHVVl3OHd2N3BJbFk5K1Q5TUR1Ui8rdFZMOTloR2xBXHJcbiAgNkExa01WanYra25rMjNQWFllQkU0S3BLdks0L2FyNDZCM29ybnBnNjU4N1dMVzQva2tpMHo1c0tDKy9HUEw1dmQyVE5talZTc1h5cVxyXG4gIFhIek9FWEw2NlVkRkNIRjhOUHJBZy92SlFRZjBsTk5PT2tpT0hqSklYbnpsWFRmeS8xdk91T0R1Q0ZOZ1NhL1lXWjU3OFdNWmROaDVcclxuICA4dlo3MzhsSnA5NGdkejM0dW93YU5jRXh0aEs1OUpJejVaS0x6cEN2UG5oTVhudmxUbm5nM3N2bG9FTUhCbGZaT2N4S2tQRFJVS3NXXHJcbiAgemtXSkpibDRUSm5pbzhzWktBSXo2RGR0V2wrYU45L1d0S0FtaEQxRVFaQ0VNcForN29rRUVqUzBLWC9iSUo3a01sdWx2RHZNNkxlY1xyXG4gIGV5Z3JWb2U5SHZ4NUZvWHUyL0g3dGtWQTFDUEgzVHFtdmw5N3dzODg2bEdiZ3JyZTZ1RWtuUnpISTFMUStycHl5K2JjYkNmcSsraHpcclxuICBEMWR3LzMwZ2xOK01BZHR1SVkwSllqL0FYa0ZLRTlxdEVzeSs1eEY3TXNiem5LRGRzTzJIMzFCU1hPU2ttTDgwTmlTalNuMVZ6MVZxXHJcbiAgRUJLSFhkdjIwVEZIQ0I5V3VQV285NG9mTWRpb0libG1SejJQanhZYkJ4SHVyWWZjRnJrMVZobFZQVkZBUDEzWkVRVlF6WTBFOGJ6Q1xyXG4gIGRvT0VRZWRCeGJGeXlyY1I5OXhxTGZ0SXNTUDZSa1JnSkJDai9BMHIxRmdPVXN2RnVrM0NMS3llRVNxYm9qWm1rQkdQQkx0MkJSQnBcclxuICBQL1h4ZnhmV1R2dnpINU5DYkREUzh0QnJwWEJqbGo3MzJkOCtvdEhuNithTjFXUE5EcmhFR1FWTVA2MkNqNVZRTHl2M25zSk9ERXdpXHJcbiAgaGlxU0dRd0JBeUVZampwWHVCdlErWGdDb1A1a3NNUUF6c2Q1SmFsMzFyeWZIdGNCUy9XVy9yMERHQWNCcmRhM0ZmcDlCa3Z3NHhnMFxyXG4gIElZWGtmM082Wkdkbk80WXdRSHJ1RnpzWlU2Sm9kSUlJTDd2aVRMbncvT1BsMnk5ZWtBZnZ1a3BXclBMOXpSZ0R6S1ZCL1ZweXpGR0hcclxuICBhUDRvVXYwY2MvU0I4c0lUMThuOWQxK3V5d1AzWGlFREIvWGJxNm9tdzZwVnV4NTdoUHR5R05XclZZblllY0tZUDMvUDUwWTN4aEdzXHJcbiAgSXRodEJtSnVYWE5tTHBRZTliMlIxRkM4TlZrS2c5RXYra0ZET0FMVlFCeEhXdVZva0VwWkN5SzBHNDNjY014WTNaZmRuL1RLZGR4SFxyXG4gIEVnM1hMOWdZdGFFbzBYTnI1aHJSWHg2Y0ZOT1MyeCtacDhUdEo0MjdIU1lIVnRRK0U1em42dXM2dEhoak42bXMyL2tjV0pGakJpdTdcclxuICB0ZnZQcUF3ajVsWkdIUHBHL0hGVVJEQVJOc3RWYStoRzVCWGNCNHFiWUxTT2p5UEI0TzA5YSt6dStKdTNacDZVQ2J5dXlBQkFhYitMXHJcbiAgM3RCdDNIWlpVQ3NrSlpkMURDRDJuZUZTYlNuWGcwc3BDR0pFY3RxYzc2VUlOYWE3QlE4YkNBeHFLa2FpQ25lZXFrZ2M4ZEdNeGlFUVxyXG4gIC81R1M3aDBla0dJWTVaSnlBNElHR3ZYMmt4K1ppbk1MenlHTTBEM3RMaURTczc5OU5OajY3OEw2aFdPM0w0WHM1dTluWmtnOTEvVXpcclxuICBpSDMxVm4zOGdSQkl2VDc3dTBlMFhMNldqNHJtM1dBSE5PbURkOFpNbTZpcDdGYVN5NlpIK2dNZ3p4dlF0RVh1dXpFYm0vVVA4KzRqXHJcbiAgOXhZZWsrdmNZQXBFaUZQUWN0aDdDOWpSRGN1bWF0cWlCZlBteVZweVpMbHJoQTNqRmxRWGo0VUxsOFdrV20vWG9iV3FubGlNTWJ6N1xyXG4gIDlnTnkyT0ErY3VGNXg4b0Y1eHdqdDl4d2prYUpKNmR0bTZUUmtPc1lEWklQSGxsY2YzMTJySG9uRWNJMkQxTkJHYkREL0JOWXVYSmJcclxuICB1cnVyU0hVTUZaQVNQNHpkWmlDSERlb2xEUU1EemZyMXNTSC9WWkkzdWc3aUdVZGVRWW5VckJacm5LVnNSdlFJNkVSV3g1WEQxU09JXHJcbiAgYWNOdllLd25SVHBub0VLeUtQYkk5TG11WHZuQVhUYlNnSzc0NDdjam16SHd4emV1OEVuS0ZOdlVjYnQ4TmYxalJ2SW8vQW4ybDduUFxyXG4gIFdUTXE4MVB3QW5mVVYzQ010SFpFNzQ4TkJDOHZ0WUVFeHdHSkV4bUpBUXlMK01QYjhhaFJFNVdBSDNtV3F4elZRUnRtZjNOZkpJZ1FcclxuICBKb3ZVUWZaZ0RLdjJrVU13MWp2bVFkUTRETUhpUG1CWU9oMnhBOFJsclNNMGEyZDdyekJHc0tpc0lBRE1EV0l3ZFZhOXJqN3FIVlF2XHJcbiAgSi9OUmVjRklrRVFNZVd1OGlpTFpBazlCNlBmdkNjeEc4OStJUmIrOXUzMHBCT3pnT1NRNlhLbHVhMVV0NFEzSHUwTHlOME82TW52M1xyXG4gIDdPdTE3ckUrS1NsWjM4V3FxVDhFZ1ljRE5JWWtqT0pBRlFsRHlabzdSbTJPU0RpZXdUaUpKZWc3T01vZ1pjUUdFN3JCb1NQK1NNN2tcclxuICBhaU42blZ4d2R0ZllFRTFUZ0QzT3dQZEZLaFgyRmJ0QlRObnkxYVV3UDE4YU5hZ2xnd2QyalZIWnhBZlZHY2ptQ3lEZWxxN2RKcGtxXHJcbiAgRFZHaVcvcER0Nmp3Tld2V0t5T3g2Ty9TRUc0Skl6ZXA1Y01NSlQvZk95enNiY1JINSs4T3JJMzQxTzY3elVDNjlPd2lKNTV3c0pZblxyXG4gIC9EazE1dW1zTFN3blJRRURBZGtiYzNVZGlhZUlZTnVYa3hMa3g5cm1XR1NUZ3QrSWZ5NnFRbElrU1pycmFNYUdvcU4wUTFEV0ZhbExcclxuICBRaCtLNjdITWdRN0twSmFOT1NzS3Y1Y0VpdkZBRldibitEVi9FN2RTTFdKRWQzRFh4UTBacnhlTTZKeGlYbDd4WjV0T21BTlJMeTJSXHJcbiAgdWQvY291dmlvaTArQTY5YlVob3p3VlcwaFRKT1lxQmRQTWRBVk5YblI0am1qa2tLR0Z3dU9SWWVaY0w0aUNxSGFMQWdRVlJ0MmwwWlxyXG4gIHpwclp2eW16UVBYRzNCSUdDTk9tbGJNMUlaL3B5VEdnWnpuR3c2V1JaR3AzUEVUM1YycmcxV2ZGZ1lwc2I0SFIvZEx4YndWYi8rOGlcclxuICArcVk5VURkdFdFekFxK3MzODZNRzJ6Q3F0RDAwczF5Z3drU0Z4ZmZDTzFFSkpKQSsyQ2FidHFrY0dhd3hZUEVNeVRHY29IOEE0a0JRXHJcbiAgWWFFR1l5SHpMOEEraUlvU2QzZVA2TjFtQjlKSUlsU3UzOEgxbTNVcTJUQjQycFN6VVk0NWVuKzFiNEFTUndnZzRHWUhJYzFJSW5COFxyXG4gIHc0YU5PbmtVVTlrbUFsSkFhWkpNYWRqWldmL0M4U2pieTV1MXQ3QzkrVWwyRlRZUmw5bGRETHZOUUVDaEkxVEZDWmhiMlpKTk1jUTlcclxuICBMYzJQekMxNUlyQ1pDSDFBb1pIM0pEVzBSY0ZlanZtMVg2S3JJcDI1TUVtanphTndCNFBqcENmeHNIMnMvVUcvOG1XMWZ5alk5bGREXHJcbiAgellRNkNmZGczYThuMk9JK2t0QWtVM2hmQVZSUWFpQ25yaTVXSlVuVlFKV0N6TGZNdWU3VlJSd01JZGhFYlpURUF3d2YxbktTTk56dlxyXG4gIFRMZEtVdW1qZWppSTBJRTA3ZUVYeklSUk1YQnRJTkhVMmVmSVFOWG1QajQxNk50N2NBaXVhUjVYT3JKMGkvMUd5NW0wY29yUDVNcnpcclxuICBXZWNJMDZiVmM2Vkd5NzQ2ZHdTcVBMTHVJbUdZOUpFZkpKbUVtTUZRd0RvM2lqVlVheDVpcGc2Y3J3Zy9nejBBby90MXM3ZWRUT2kvXHJcbiAgQ1V2R3Y3RmpZL291UGcvaW93d2x1THlIQURNbzBNQmRET21mNlpvWkNnRVNDd0dqWVpnNks0L3BFeHlxT01KdTk0T3pCMHpFYms4SFxyXG4gIEkyNmJKUy9MRzQrcHd3REZTeWJZODZJU2loL2tlWHRJUnBWNlhyMFYrZWJjdCt6YXdQVjkwUXY3UzRVS2FYTG8vbEhiUnhtdDU4RThcclxuICBHVFpuaHNGbU56UXdlVlJwNk5xMWJZd2swNzc5anZOYzdTejY5WXUxMS96VHlNM2R2cFMxSzdDMlRKVmwyQ01HQWl4VFJuS1NEOVZMXHJcbiAgS2JOVmlpWDJJallwZTZ3TkpGWW1BRDd4WVdpdkZSUHNBbW92Y1BENXJ2anYwN25ISXNsMXZDcEJPWXlncGNoS0c0aEFreTg2cUJFeVxyXG4gIHRtcE1QU1dzYnJ0Z3d5clgzMTBoZEN5OHNYN0JPTWxaT2xreW5kUkJxaFEvdjRlSFBRbHNFejcvRlJ2aGhpajdiVnd0OFJEREdFemtcclxuICB1eDNUbys0cnhBT0xSQUNRMzNEd3orSS8zdEE0Rno1ZTdoT3ZLNEJSSDFoYW1leUZFM1ROaDQrTHRFa2ZCRW9DVDBRR3FBR1dhMVp2XHJcbiAgMlZ0alBveW9vTjVDcHc3V0w1aWdLaTBxd25TUVZ0Q3Rtd3FzZWl2UEFDMzl1Qm5TQWZOTitCLzFmd2U0RnU5UWpRVjI4RnppRDVzNlxyXG4gIHNXSkQ3NUFSbGhaeWxubGlhd2xOK2FhUUdsSURZN28xVmpGZ0pyeEhYTkx4bXJJeElreUY2WlZOTldaU3JNNy80MkE1NXJCN3FLZFZcclxuICBHREUzUzlicytScHdXTEpOREZDU0ZQMStwOHllTzBVdVB2ZElHVEFvZHZCa1NEU3hFN01iN2l5d2xaaWJMTkpJdFdxSmFNZi9EbVJrXHJcbiAgSkhDRDMwMlk3U00rSjlZZU1aQWhCL2VVbGtGRWV0UHk2ejN6S0hFdk9xbGNUQURiaG16L1F2elVzMXFLZEp4dy8xRzN3aDFCVCtBUFxyXG4gIGJZVFA5dVc4TEs5RHg4N0FBcnpCMlJIWlNIVmZpSjd0UzB6dnFZaHBOd3kzUDNTb2ltYmk5YnMwaU5HQldmMFN3NTlJbWc5RjVCclJcclxuICBCdFVJR1dxZjNGd3g5K0tLcXI1eW8zUHliUlhrckF3MUUvMTlNSFdNNkRhNURNRDlVZHR6d0kzV1RyT1BIWlE0a1pkWkhVR1NJdytrXHJcbiAgeVljNGhHSG5WWE9NdzVKR0ZtLzI2aVlqSUNIaE0veHpQTnlPU29HWGw3dEp2dzVBREU2Q00vWUt0cGJzdVN2ai8xWnNYT21ENzhLRFxyXG4gIGx1S0NXR21rYkhrLzJSdTV5M2gvTnUwMEtITGZEMUs2Zno4ZVRNc004TjZEcWVBZ2dVTkZHSGdwaHBHYVhrbVdqbnZQbGNqQ0VMYWJcclxuICBSdDk1ZnZZeW1mTjliSG9aTzdwbXJSK0FObTNwdit0ZFFldldPMytPdWNuV3JCbGt6ZmhmaXRRRUtWdDJGNmtweWZvZXlJNGN4aDR4XHJcbiAga1AwRzlKYWpqeDZrNVpYTGxzcVdyVzVrbTFTaWFweFFDaWIxeEdJekpRM3U1VWZMNFVoMWo5QUo0WEo0dHlKMmgyNEZsRE5HK3ZBSFxyXG4gIDRxcXprV2lmK3hDcW1USE9iMGVxYUhXMmJIKzBqRmRLUER6VDhzYzlmQW9UQXpNSVJoQ3U1alpzUXFwS2Raa2N4bTJybWl3Sys2aU5cclxuICAwZm1VMkZHWU53c29MZ2tDT1lOOUdyd1lHTmxKdHg2Qk84eUlFMFpSeGpGNHk1cXNOZ2gzRE9KQW9HVThjMWp4MXhmQlBDU01Za09PXHJcbiAgQmc2bVQ4Y2RPY3hNcWphTFZWTlo1N09JOVFwMW85bVFZNS9Obm1QcjFyMm5ELzZ2d0c0OG4wM0xUVlhybm4xS3FzYmRxQkc4VGY5QVxyXG4gIFZZc05NcFpBQUNSNFhNNXhwTEI4Y2VZZW5CNU1QMDIvMS9jWXZxOVFtU0o5aTRuZlFPa0RyY1JZOTkwMXNuTGxRcm5qcGd0azNib29cclxuICBJOXRaVktvVWIzL2RGdkVFbDZEQy94ZFFtblBCcm1EQndxaDJJSXc5WWlCZ2M3SHZTTXVXTEpPcVpRdVZpWlNrWmVyRVJZWXRXc2VSXHJcbiAgM2hEVHNPbHRqY0J0QzBpMVZvZ3U0Ym9VMWRBUzNoY3FCL3NqZThLSERGYmZyU3dZa1JHUUFZK1JtQk5EN1VkaU9OeXVxT3V1cUMzQVxyXG4gIHcyL2JYMTF2ODF2ZGRtaVhEekFNbm8wN2dNRXhmSVlSYkVXQ3BzeFRnbWR2cWtWRDVVQUZoZHN6cU9pWWxGVkJYUldQOVNHZmZxS1BcclxuICBGYUUyemEwM0RGT05tSHBNazJTR2dOc25vQmtXVXkyYUYxZmhobTJEVXZjYXpLYnlmd1J4cjEvQmpKRFJBNzRRaWNlS1lmV3g0RDNhXHJcbiAgdDd0TmRnQytBOWRVT0RscW9tc0QxR1BZTjJLeGJXMFlUZnluc2piTFN4L0VmY1FiY25jR08yTzB0dG43YXRUd2tzZnV4R2I4TjZKMlxyXG4gIDdXMDlNWGNWR3dOSHFIanNNUU1CbTRPK1Y2RTRTeXFub1lObjZsSy9EMWhuc0ZGTEdPRlVCekdJNjBEaFRWOTJqQ3FVYXltbVJrenZcclxuICBReGxqY0lROGNpaGFSL1c1Z1l1bko0d2NZeTcxa0Z0dXVFa0hvdFBqZGprd2daVW5yUDdZdGpVTU1jZTNZU3h4aURuTVJ1bjFVVjBwXHJcbiAgU3FtU1VjVlBjMHVNU1FUdVpWazZtQWloRGIvQUVIREZCSm9lUHdRL3A0dUhqVW9Cc1FlbGdlajlNT0xiM0p2UW1Kdi80L0NwZmp4d1xyXG4gIGFUWlB0MDByNTdyWDd0OTdQTk1IU0N2a1A4T0xMaDR3RHFSWGpibUtVMG5Hd1BWSEpoZnoyYk1aWklUNlh4eklSZWZoKzNyKzhrbVNcclxuICBscG9zOTkxK21lNjFLV3gzQmFYTjdSRVBFaWt5ZytFL2dmQThKSG41Tm9uZTdpTStkWDFwYU5ac3ovTmhsU3NYb29VaDdERURPYkJ2XHJcbiAgcDhnTjV1VnRVZ2trbzh4bXQ5WmRpdlFnY3RPSWF4UlJnaHVEUk1RdjBUNklYU21FRWtUb3NxN0RGVjA1MkVRMktCTm1GS0Y2eEdVWVxyXG4gIHdtZURwUGdodm9OblFxSDlGT09xQmJLSWxtSVEyVFJwUlRjQ3NCSHNLRzEvSEVxaC94RVZsYWtzRk81QlFTUU1pVnYwTUNKUDhrU0ZcclxuICAzWlpyajJobUVDYldZYys3K0laTnNyRlJzRVhEYi9jRy9uOUVzWXZQS1pJSjJ3SDFsUUVqdXhuUlRRb09nNWlOL0t6RmtwSHBCeDhFXHJcbiAgdWZMK3VieFBMZUtaak9zQVdqYWcvb3dGL2NMM0RUejBFb0ZnVjVPU3dmcjNqNUNDZ2dMSldyOUc5dW5lVVVqNTBhQis2Zm1kekpVM1xyXG4gIERLYThEYXQzTFJWN0lpeGZ2am9TTndJczFtTnZZUDI2S0swcmw1RXU2OVp2a0huem9pN0FZLytNVlZudkNQdkVwWUtmUG1PK0xGa1NcclxuICBuWUpoYjJKeEtlM3VNUU01NE5BRE5PUWZ6Sm5qUmpLdWYxUk55WS8wN1FyUXE0Q2FtV3RteEVYVFFlZndDRjZ1MW5MbEhYNFhWdDhNXHJcbiAgbzNUY3lFazdPanZ1dU51TTJtTmlqMFhTT09qMVFrdk1kaFFxNXV0dTZ2aDlrWUx1OThVd1luOXRnZ29KOThVaThuRzRsYVV2S1kyQlxyXG4gIDJJeVA2K2I5SG1uYXBDOUZTRFVYUlhqRGwwMFNNY0FvbU9NZG1MRzFTb09PT2wrNmdYbEJFc0dpbzBrdC9rL0JzY2lnOUg4SDl0WXlcclxuICBBc25EUE96TW5oV0dmVXN3ZFRMdnhyeCtoODN1M1JtajU5MHp6NzBCUmtFcWRsT0ZGaGR1akFTN0FteHNnQ0RmS0lNaVEyK2dPblVYXHJcbiAgMCt1NWZrdzZFeHhoYk1LMFdiTm11YjY4UmFXUDNMejhoRjVXeEhXRUVRN09BeE1tVEpQKy9icXBhZ3B2SWpMdWJnOUVyaHUyNXdwclxyXG4gIG5razJvMkNIRGhiZnNuT29tbGxabGk2TkV1Yk9uWDFhcEoyRnVTK2Jpeksyb2ZpWWxOSlVUN3NLbUhDaWVkSDMybGRsTm8vNnlhdFZcclxuICBBa2tKck9pYkhIK0lpVjUwdTRsdTNnYStlaXdTN1F2dlZHSVhydVRMNGI4Z1FxUmpWdzYrWk9sS1FPU1lLeVFhalFIcVJGVTJiRVdsXHJcbiAgQnAxWHBGUm9yZEE2RHFYc05xVEU1WlNLaFNPUlFZZFNMeXkzTHU5RS9hM3JaMnV6cGo3Y3ROWm5XL1h3OVpFY2JNNE9RNVZHUHBnS1xyXG4gIDlRU0xHZDd0RmpNeW83cHM1a3d4d3ptd1VXblpDckZlTEJ1V3hNN2VGanRlZGZlSUdzMHVzTGRoalBIL05lekU4eUx2RmJDME1RYmVcclxuICBFK240OGJBeU4rMUdmYzl3MGdtWkJKWkgrZ3plVlh3aEd3TWpmR3JBNkdNWWtidVAzR0FTTjlSYVNLVEVnb1FkTnNnYnQzN0JXTzFQXHJcbiAgOFFpUGR3aHVoVm10ZU8xQVRaaFl0bXlxWEhMRjZWTGVFZXEvLy9ZZVVtSE1ucjFJbVVZODQ0akhtalhyMUtVWEtXVkhkWGQwSE5BV1xyXG4gIGkwVzFNL1BoOXM3ak55YVNrTUNjdVlzbHpmM09uWUZkSTM0K2tGNjlvbDV2ZHAyLy9vcDFjTmxkYk41Y25OQ1dzbGUrcXNNUDZobEpcclxuICBLVUJhRS9MdzQ5RmpTSWw3TUg2MHMyM1BqKzZKT3hiWmpOMVBWRFdJR2dJZGdpcHhMUVFJSDR6V1NNWG9HejRoS1B1NGxEZ0V4emF0XHJcbiAgaVJKaVRRc1NFTy9vOUx6V0lHc3JCNGhzaHZkSHkxbElCMjY3eGVCLyt4M0FIV2FLWGFEWmdSMklLUWtqWHZvbzNMeFp0cGIxaG1yY1xyXG4gIGZ5MWRlemdiTDlIdnlha1p3dlN6QkpINStVWWdFcFgxZCtWbCtSR05NUU9hNWs0cjFXNnBVLzJDRGN1bWFSeU1HZEZ4bXpZVlJaZ3dcclxuICBnSXExVzJoVU13aTdpb0pvUU9mZVI0eks3djhRU0ZVU205d3ppdHcxQzVVWkZHU3ZqTVJVTFJyMWh0cEtVRmZ4WFhFK3NUNlZHM1RRXHJcbiAgdnBKcmc0UHlWVFc5ZTVpSldMd0pIbG1XMVlEY1dTYVpGR1F2ZDVKRkgyRWVkbzZ6R0lnUHNTK0FlOW4wOGRGT0VsaW9TUS8zN2RGeFxyXG4gIHU4Ri9hOWY2ZnJROXhtQjVwc0k1c2VJQm93ckR0eFhmZzJNUnpnMDExekdCUkhPeTd3eGFLUDBNMDRPZGgyWGpMVzNTcDcyRlJMbTZcclxuICA5c29WZSsvZlc0NDkxcnZ6NXVUa1NHR2hrekJDejMxcnlmWWZqRDhhWDRkdDJ4Y3FSMWJ1WHd4UnNMckFsU09iNGYySlFXWlo4eUl4XHJcbiAgRjFxd2JWQmlMR3pVRnNtN1ZRcUlRdDhHY2JjVnUrbTNUT1VBMkdQMmkxUjg5aDFzMjBBa09vQTlVOEw3cldDUlZ5djVGTnEvYVRuc1xyXG4gIFFtbE9ES2daQ1BBemRSWWZPd3hFWjV4engwZzdZaUNZa09BLzV2aXdQRmJWVy9SV2QxQ0lFcy9OaktRMjZyVlJKNUtMZFExTnNlSEFcclxuICB2TnlnU2pCbkJjaGZIM2grN1NXRU14Ly90eUtsUW5tcDIrV0lZR3Z2UUZPUUJQT3JaQVIySzJhU0JMeFgzaG52ZzNlS216ZnZyV0tkXHJcbiAgbHZwKzFia2tjSDlHYmJWMjNoakpYN2RVK3dVTWhYY1pEa3BrVUFIQ1RJVzVkUXpwVlJ4VGNvTSszTS9EOFVmVzM3a1BHQWtxckZXclxyXG4gIFZrbHU3aHI1K3NQSDlSZ3dGVXFZU2RoSXU3U1JQYWhlUFZPbEExQmFlZy9PTHlyYXJHMnpzTTJzZzIzYUpIQWNDTko2Sk1MMjhrNkZcclxuICA3eEYxR3BxWm9zRHphMjloNW5aU3h1OHBXb2ZtTXpIc3RhL0tIdHZLTld0bDJZb1ZidlFiMkNjY3NqZjR6TEdHR0lsaEI0aTFFY1FoXHJcbiAgS1dobk8xVTQ1ZytIS3dWbFhmRm5heENKVFRsY0x3NXhoNGlQaUsvTjNPZFJSSTlXYWRSTmRmemsxOW9XMFhwWk9pTWhxVDMyY3lPeFxyXG4gIGJUMDErS2lSSmpKZGUzYldscFhqSlB2WHU3V01pMk42V3FxcUVERm1FL1ZPUlJnSXRpZEdoeVVoYnpnK2FFczdBYXEzRE93UjZaVzBcclxuICBiTVRBRWhHU2tBK2lwSXdoN3Njdi9QVlZqWkMzVVNyRXlhTE1nWlZoT3RYS3kveWFRVXFUekNaZDNUR2Z5dHV5OEdaa1JnMnBld01RXHJcbiAgNXJLVi96a2J5OTVBOHdNdmtBbzFkejFJYm1ld2F1cFAwckRYaVlGRUVjMmZCbklYL2FtSzhteW1Fb1lBdXZkYXU5TmdkY2RlTytzM1xyXG4gIFdUdm5kMzJYOUozVjAzNVNqeXVEZFFINnlZWWdIZ2hWVlkyQVFTQ2xtdVNidmNRbjVMUjUvTU5NaERMU0VEYVE5ZE8rbG5uemZQRGpcclxuICBnSVA2U3A4K1haU280NG83SnBoS05oR284K0JEcndaYlVYejA4USs2RGpPZTBnQ1JOMEpQSE1pTUdkdW1saUVKWWhpMHl6M3VDRWdLXHJcbiAga3liN0xOVjRldUVRRURzL2Urbk14eEJtUWlaNUdGbzVBdCtraVZjbC94WklXcmJlRXl3TkRPaDE2dnhES2l5QWE3WjFwcHlObTJJZVxyXG4gIFJVckl3d2RFa3g3R0lvNGVlWVIySmp3ZWdHUGJabHNOem5BcnN6TnZENnFtQ2RkejVhamZPd2RpRjJ3azVycG91YVg4c1cwQjA4UStcclxuICBZaWthcWpiMWlRb1RRUTNTd1VSUzhiQUVpK3NYalpldDJmTms4NVNsWnZIZUFBREVwVWxFUVZTWFpQWHcrMlhHbjE5S2F0a3ltc3FrXHJcbiAgc0hpekZEdENnSTBobTVrTkhjaU9tdWFrRFNRSzdCczZNMkVBUGw0a0JKaElkSEt1Q21wd1p6NFFScG1NVUVHbEJoMDFzUjB3NlFNZ1xyXG4gIERma2dTdit6VEQwRm96RTFDTXpIbUVaV3JqUTFHd2h6UENqY2lSc1dlVlZGZUhLaXZRRUljNFA5amcrMi9qdVJYdEdDV1hjUnBmUWpcclxuICBRRFlCc001SmtMd2ptTGg2SFliTzJiQjJlWGxMTTJQT0VRUUY0bW1GK2lzbnNGMDE2bk82OWdWVFFZWWxEZTBqYmdHazJ3SDBxZkFjXHJcbiAgSVdUekRUTU5MNlVtYVY5a0VJTUV0UDY3cXlRdkw5ZDlyNFVSNllPcEl5Q2NFT3J2dmc4U2lZWVFtWkh2ejc4VFp0bUYwSEt1RWQ5NFxyXG4gIDI0RWhFWU1walc2RUdRMkl6MUtiQ05ERXpwMml3Yko0ZkJsMmhybVZCanNYRzRYWlVaaGhFZXlOaElyRndZUlVGZUtpME1GZVl5Q0hcclxuICBEK29sVFpwRlA0QVlYaHIzRnNLcXAyMHo5TzRPZlBzRkdnVG95NlQ2TUwydUVUd1Bmeno4MTFhV0NqN1lWSGovZUM4SGhmZFhydThOXHJcbiAgVnN5d1pvaG5qRmFmTlRtbkxPOFVZSTZFK0xnWXpjTHJZTVo3blFza2ZGRzNrWnhXUWNwVnFpNXJQcjlBRm4xenUveisxZzB5OWE4ZlxyXG4gIFpkUEs2VTQ2OGUweGlLUTc0M20wM2trMFd4WjhyeEpJNGFhMU9ocWtTV1krQkhaTmM3bk1ZTGE1NEpvUTluaFh6SndsVTNRdUUxTkpcclxuICBvYzhtWVdLMUZyMWk1bkdvMSsxb1hadlVVYXZEUWR1TXJ6elJJa2RXZjVWZWdFM1F4VHpZZXhzVnEvdVA2djhTeUdjR1ZrMzdSZGQ0XHJcbiAgV2RYdWNMQXNHdjIyemlnSnlPZUdoRUZHQVZOTE1oaXIzLzA0SFFqWW9JS1U2NW9MTFJoTXNKNysyVkR0QzdhRVFkK3hwS2tHR0lWSlxyXG4gIEpLUm9wNnZaN0lTWmxkSmw1YXJsa3BwYVJyNTYvMUdWUGlEU3Buc1BFK3d3ekMwWE5WVjhIek9FejQwZnVSdW9RM3hHT1AvVjNreUFcclxuICBtS2l0V01ZUjg3RW5CUE82RzB6YVNBUmpKS1g5MWwzQjFPbmUzdnVQMlVCQXR6NDlJbmFRZUJRV2VVSWV6c1ZqaUpVYWR2d0FQVnk5XHJcbiAgVXFwYWJBSE1BNElKWXJMMUpqalBHRTA4SU9DUllNVzQ4NktKRTVNaTBrZWxldTMxbzRpdEhIdGlkQjUweDFRV3VrNGRPc3djSUpGa1xyXG4gIGlnN2twY3FhYTdZSGY3MlUyVy9LOU9jT2tiVnJWc3ZxTlZteUtlUm1tSktlTEVtYnQwUzhzWXJkNkFPSEJ1d1pmUHlBWklxTStOWUZcclxuICBrZ21qVWo3cW5HVlQxUTVpbzBxSUFZeVg3ZkJJczdvakdoaFptU0NLd0RESEJZTWpJbFBldTA2bWZ3cEJpWTR5d2JSUFBLRXlpUVZpXHJcbiAgUlJrQ2xEWEgzMGR1TUZQZ3hwWGJldG5zTGFER3lxaFZlZ3pCL3lTYUgzelpYcmQva08rcTVTRlhhYmxXdS8xMVBmK1g1eDJ6M3pjeVxyXG4gIHhTM3Z3VHpxc3VhUUxiZGZoT2tUSzJMcXFobGYzS05ya3o0QWZZVDZNNys4SnpMUVlFMS80Umo5S2o1Z2tJR0w3NFBSZHVpdHJRKy9cclxuICBWYWEvZVlia2JOd29USW8yOE9Bb016TDdCV2pSSXVvK0RDREFHZWxwRVVJOGNBY0VzN1NSdnUwblBpTXJLN3ZVZW1ITW5yTkltUTR1XHJcbiAgcm9CenRuY2VOSU5zd1dGbUZpN241U2YyK2d3RFE3MmhZY002a2ZQRDdRQ2I5MlRSNGoyM0phNTBrcEpLVHduY2pQY2FBd0hxUHVwcFxyXG4gIGx5ZXdBVGJtYkpJcXFZVXhrZDJSbUpCdDFFN2JRYlRKQUg2ODRSTW9lbWkwcmRaTGlrUmRiNXQzS3hZUTBiU0tvZWhwVFdFQ0FTODlcclxuICA0QWd3RStHdWdBbDAvRHpvU0NUam5QU0MwVGo4bzVMVUF3djdCMHRtNCs0UjI4eDNWMlhLZDFkV2tha3paa25XMm5XeU1iZFFYYWZEXHJcbiAgWnpNUFNJbDdwY3lQWUQ2eWRPNzVYdzlUdFFXMkU5SzN0eHB5VzF6d3BHZCtiUUoxbFRGTlBHM3FkVHMyVUdORlAyalVjVXhYaStlV1xyXG4gIHFpNENobEN2MnpIU29OZkp1ZzNZeC90RjByQjlCb2dVa3NlcXY3OFA5bmlFVTQ3blp5Y09YdHBkb01acU5laUdZT3UvQzhUTDdHMzdcclxuICB4Nnh2SHBMVWNuN3daR3plZ2drWC8vNk90QmgwbVRJRXZLa0FVdy96cnNKOXlnWURPRWxRdCtXaDErbmFHRWE3bzRjNTZlYkh5Q0REXHJcbiAgTXc5TDJSNlYwRzJiZmhiTk9PQ3Z4RHd5TXU5OU43cGVJaldyVjVHckxqbFY5d1BVVGFhQ0F2WHFSbWN2QmZjLzhMSWVnNEFtSXVDMlxyXG4gIEg4U3Z3ekFDSEc0alVUMWcrMXNHekl3NGs1MEZOaFVHZG1IWXRjdGx4R1ptU0FTN2RqekRpQWZ6bm9CR2pzbnNLWmF0OEE1R3pZSUpcclxuICBCTVBZcXd3a09hV01GRnRQRFhrajVCVzRFY1FXWWorQ3J1bFdpYWEzalVHNEY4Y2dlb0NJV0xhanFROTJBWEh0RjI2TWlvWmhoTk55XHJcbiAgbEFhYk95TjcwUVJkRXQxNm1kVFl6b0ZuVmp4alE1MjBKWCtqTXBHc3R3YkpELyt1SjZQdTIwKyt2em9hVDBIYjZtemwzbHpaakJTVlxyXG4gIE9nejMzM08xbkhubU1aSWFQSHJxbHJoNldWbFprdi9qbGFveXE5WGhFTjBmVnVzWkFiSFJvN255YmxnOFdaYU4vMWcvZm44c2tDQWNcclxuICBNN0d5b1dEamFsZjNFMW55eHp2QkhzOGthcldQVlYyaHNtcDN6RkE5VnIyOHpEZXBCSU05eDZvN3BsS1U2NTB1TE41Z2I0SlJmdFhXXHJcbiAgdThiNC8yazBHWGpXWHBjK3dwait5VEQzekc5M2t1QXdKK2xjcnZ1WTRBdWIzOXBwMytjakNmSWVTTU1QbzdmM05jOUpLMndyUTRBeFxyXG4gIHVIcElKUzBPdVZxWnlIUW5oZElQMmg0VmxUcWJERGhmMTZCdWw2Tmx5UmpmSDVCdXNkOHhCVUc5cnNkRWJDRWxxOFpLMXF6aE1uLytcclxuICBBZzJzTzJoQU56bGtjT3hnQTZJWlpnUmhFRndZSnFieGhKVWdQenVYTlV2OFhPSUFnM2JUT0FJWjM1YUIvZGdZRXQxUGFmZzFhT3V2XHJcbiAgaVRNaTA0SGIrZWFKMWIvL2p0VmxWdGNrQzdQblRKemtYZUJ0ZThaTWIveWZraUJ1WmxjeGZacVhWaE9sUk5tckRHVHdnZEY0a0REZ1xyXG4gIEpYa2xhWEcyQ0JCTGFzT3BRM1lIcWVXalVhbzJGd0ZnQ2syUDhQVkM1WWlMWjFKRStpRFlFWU5peE1BYkQzYzYwOEFhakludzhZVVRcclxuICBFUnFZVlEyZ3dzcDBrZ2pyY0paZVEwcEdSUm4zN0RFeVlkS2tNQStPb0VIdDJvNndwa2hhUnFvODgrZ044dmtuejhqZmYzNGsweWQ4XHJcbiAgS3RkYzR3aFIzUnJ5MWpzUHlwYmdKNlU0aG81aE1YZlRSc2RzS25wbTRCWWtJQU1mZFdFd3NSQXdsK2FpUEtaQ0hTQVZhcmVVckxsL1xyXG4gIGFPQlp6WUI1cUFUaGpsa0tiL1RuN1k0Wkp2MXZHcTdFaU9ONGpKbmtzWGEyOStTQmlDRjVVR2R0cmpTRlllQVZWcXY5Z2FGQVEvL0RcclxuICB3K2syOWhZWTVUZnNma2F3OVQrUHRDcFZwTTJRVy9hNjlCSEc2cWsvQlNWUit3ZlAzdXdZMlN2blp5Q0o4TDRzUFkxTko0enR3MDl2XHJcbiAgMjk5Smd5dGswbHRYdUVIQ3Arb1d6UG5LZUJ4allIWkNpelpmTU9JRjNZZUdBVWNJbS8ralJ1dUJFV2xreGhmRDNHREdTN256UGp4UFxyXG4gIDMzYjFhbFhrNmt0UGxMUE9QajZHTUVNUWpaQW5JdWdIRFBRcVlld2dwUkY4dytiQUdHeEc0VENZbHBZb2JnSVZhY2UzRlV1ZndzQmdcclxuICBINzVlOUp6RU1NTGVaWjgyVWlWdTZ0dFlUNnp0dytvdVdPRG4zekVieHo2QmVzbTJqUm51VHViaWVCQkVXTnFUMktzTXBGdHZid2VKXHJcbiAgVHhPVlVyYXMrRWxXdDZXSUtURXpFRHJDSFpNZ2NkZXdPUlNQUVRDYk1hU3dMM3BDdU02dUVlVEJmVU5veTVSTjMyNXlQL3VKTUJHelxyXG4gIGdXQXdMTTFGR1FNNjZjMVZoWldVcE9zd1JnNXRJaU52YnlUam56dFdVc3NtUzNKcXNtTVNUc0p3NWJMcHFicHNMdmhiempyM2FQbnVcclxuICB5eGZrbTgrZmw2Yk5tNnF4alBrUkdqWHpUUExUejMrVzZqV3F5YnpwWCtrOXdvU1MzTEo2OVdyWk5NWjd0YlFaY3BzYU10Y0dVK1BpXHJcbiAgZlZXL3g3OGlha2ViRU1wR25ndUd2NkFNTlhlTmY0NFdNTVprVVJBS0NKSkc1cnVMVVFaYjNQTzM1SDFWR25aVVZSYVNSN2dQVUpkOVxyXG4gIFdiTkdLVk5aK3VmSHVuLzl2TzBUZ2owRm8vM0dBMDRQdHY1bjBlYUlvZjhJODRCUkkzVUFtRE9ZL3NsUXRYL0FMRXpxQUVnaXM3OStcclxuICBRQnIxT1VPbWYzYVhxN09mcWlpQlRnam0wSERmazZUenFZODdSdUx6UktrYWkzWmNIOEY1Uk4zQVhmZGhtNlZtbTRGYXoxU2ZhMllPXHJcbiAgajhSRG1mU3g1dlYrc25UcGNrMEFtclZ1blZ4ejNmbnl6bnZmNkxIU0VHOFVKaEljaGpOcXRCL0F4VXNGM2J2N3VXY2c3aG5wNmRzY1xyXG4gIE56UnFWRmRXcjFrWFEzQjNKQkV3dWllZW83UTJ3d2pYeWM3T2lUQWI5cE9LWlh2TUp3eXJaODhoUDBnNWIrbFo3RHA3MDRqKzQwL2VcclxuICBUcGtJZTVXQkFNZ0RzUWlteVFJWmFhbFNJVFd4TzFseW5PZlNEbFZiY2RBbzhGTGdvOEszRzBrU3dOVUpwQkRtUTRjWWxxOFpuY3B5XHJcbiAgQTk1UUNZQStsL3BJSHlrWlZhU0lrYnNiVGV2RVVBbXVpZzBFeVlONXhUY3ZIU1ZUM2poSGZycXhvVnVpb21FWjkrd3NveTZSNVdOK1xyXG4gIGUwOXlzLy9TQmRBaDZDUTg1eTVkQ0hxTXhlT1BlQjMvdXgvOUtCZGZkRUtFWE9kdHl0TjRIQUlsVlFKeDl4ejJBcHZ4bVJzVk9nWkFcclxuICAyZ3NJZ0FGUG5MYU9tRUJ3VUVlQlRjRUVSVXBrU2txVXlOVHRmSVNPVktkOU9sUU42WFc2SHFVekZVS2tzaGRQOFJKTElIa0E2bTVhXHJcbiAgczBEYWR1cy9IOElXUnRXVyt6bW1FZzFjM051QVlMYzk4bmFwMjMxd3NPZC9CditFNFR3ZU1KSzJqcEdneG1xckROd3pFcGhMOW94dlxyXG4gIDFqYzc0Q0xkbDltc3A5by82TCs4SzFBaGNNdEdWV1ZnaWdGQW44QURyMWluWnZhTUFza1VyeThDVXVkOC8yalVVQjU4Q25qcFZROXlcclxuICBYRldyVmQrTm9oZEkvcVpjUGZ6T3kzZkxoeDk5THkrODlKRWVOeHg0Z1BjU3JGKy90dnd4Wm5JTUlZYVlQdlR3YTdxbVh2aVlZZmlJXHJcbiAgcU9kai9mcTF0RzZpZXZPYzlGRXpTT1BPY1Vid0kwY21qaXJuT0VicWpoMWFhbm9VMnV6YXRWMXdOREhzbXF4bnpWNG9XMEtKSjRteVxyXG4gIEQwLyt0ajFZTzB1Q0hGbzRFSUQ0dVV2QzE5dFQ1T1lYU09QRzhXbjRQZlk2QXhseVNDOXBFT2RlaHA0U05VV3FJN0tHU1Byd1BVQThcclxuICBpUTRUUk9JZEFQTnpoSmxCSXFSWDlzWjJYSDlSWVdrRXRqc1BCckU5NExsRS9lekZmMFd5Q3VQM25raUZoZHFLZVo1L3ZxV0ZUSHpsXHJcbiAgWlBuN3U2ZGpVbWNYRmZqbmdRY0tqS05nNHlUNS9xc1g1Zk12dlB1bGdRbi82YkF3RXZMY21LN1RNUFNPWjdUVDNIRDl1VTRhUEZnNlxyXG4gIHdtU0N0MHlHZ0w4ZjZTblZhOVdUVENjMWJRbXV6OGVQQVIxc1hERXJvczVpLy9vRjQ3MnUyeEVWODVpRG1VQnNZQVl3RDk0RERJRnRcclxuICBVMjJ3YmFDdXpjU1lWcW1HSTFCZThsajQyK3VxeGpJbTErNVliQ01qZFRyYjlDQzMxdWI4YUpyNHZRbVlTT2VUbjVJYTdmY045dnhuXHJcbiAgMFh6UUpkTHlrQ3YvTWRWVjdZNkg2RHA3WVZTMWl2b3FlOUZrSFNTQU9hTStVbDlwbUF3cVNONlp2UXU4N0JyMU9VMk41N3hmNGtFNFxyXG4gIHpyczEyMGYvRzM2V2hTTmZpcWl2a0ZhSk95RWxEakVkamZ0N2V3Z0RKZ05laFRPL0dDcnozajlQMW1ldmxuTGxNK1Qwa3c5ekRLV21cclxuICBISC9jd1pLN0lWcVhmbTZSMVNRZC9QNkhiUWNWTmpjSWRmYy84R3d0aDRINmhlK0JaVlFncGNTRGMvRmM3Tldyczlaak96NHBZVHp3XHJcbiAgU0FvVFp3enA4YXFwTUdpVEJiUnEyVmpUanRnMjZxMjBzb2tDakxlRlhkT3krSnBxN08rcGN5THRtVkYvVW1BWDJSc296UmkvMXhsSVxyXG4gIDl6NDlaTWlRQTdRTU9ZZlA0aFdVdnlWVmRhV0c0dnpZNkhSRFBGUFlNYXpMdTNQTEpFdjU2bDZQYTBGdE93TzhUNEROMk9lTjh6c0hcclxuICBtRWVWaGw2RlZhVlJWNm1zMHNlMkdINTdhNW42MWhtcWtrSTl4VHFzbm1KQnluais2V0hLUE9nTWRKWjRFWlRaeGNKNjRUYXRtOHEwXHJcbiAgd01nRmh0NTJzYTd0T0pQZ1AvTG96VnJlVXJoWjFxeGNLdE5mT1ZHOXNNSjJFQ1NRYXMxN3FjZFZXcVZhWXBNOGtaYkVtQUtBY0RDU1xyXG4gIGhMbXNtT3pWRFNheHdFeHF0eCtrbzlPYzVUTjFKT3ZWSmYwbHJYSXRaUTZWNnJWMUJHdG9qRFRDeUpneSs2Wjk3RWZKbGdZZWZidE5cclxuICB5YnEzQWZIdWZzN2JVcTNOanFPSTl5WmFIWGF0dEJ4ODlUL0dQR0FJMVpyM1ZEZmVxczA5Z3pUMTFiSUpuMG1EWGlmcCswRWRoU1JDXHJcbiAgZ0NlU0NNd0ZaczlTc1ZZTFpTS292MUJQL1hyZkFjbzRlTzhOOXp0RjI2UXZORC9vOGtnV0Evb0JUQVRRanhhT2ZFSExxLzcrMWtrclxyXG4gIHJoKzA2aStwS1dXa2ZNRUNXVEJyck5TcFZVdWFONjBuWjV4NWpOYjc3UE9mWXlMSjZlZm5ubjFNaEdqR2Z3dWtOdW5tUnY1Mi9QWmJcclxuICB2VFFWQnFvY3ZvVmhibUIxeXNtSHk1L2p0cDJmaHBrSW1RZmtzY2Zmakh3MzY3TnpYTHZiZnNzY1o3SDhXMXliQmVQNHRPblI3ekFlXHJcbiAgMERVajluYU93V3NWZG14QVR3UjdKaDNhdDRpMGIyN0ZhN1AyUEJoM3hZbzFldS94ejk2dzF4a0l3TXZBMFVoSDdJTG10NVpJV2tsdVxyXG4gIFpNNEJZQUZHRUt1Q2tBR1hlYjUzRnA1MTRJWGw5ZiswWlVpckdHdjh4bEM4UGVTc21PNUdadEg4K2laOW9MNHEycGg0cGp6Y2VLUE1cclxuICBvMHZFQTh1cnNGeG51N09qakx5am5Zd1kxbGFOM295V2JNUlVvM0kxWlJTbW5qSVYxUm1uSHhucHhLeHgrYk50Z3dVNk1XS2kwelJvXHJcbiAgRU90OHdNZGlIVFF0cmF4Y2ROR0o4dWNmYit0MjhlWVNXVHhqa3NqVVYzVGJBQkdZOWRXOXNtajBHeklkZFZaZzVEU0NBT0hBaUk1MFxyXG4gIHBxb3BSenpJeVVYUW8wa2ZKRkJFU2lGdE8wd1oyd2RwU2d3d0RpUVBZeHljdDNUY3A2ckdzbGdSc0dibWIwNHFyS2tHWEVBQ3huOEtcclxuICBFUEdlNTMvb1JzdW5CWHYrV2JRNDVBcHBkdUJGL3hqekNBTTMzalpEYmd6VVdMSHFxOVYvdkxxKzllRmUzVm11Um1ObEdzc2RjekdHXHJcbiAgdjlGOUwwZ3NNQkg2UUozT2gwbmRyajQ0ZFBIdmI3dDNTSXhIUmQwT0o4SDBOcEQrMm9mYUhPbWxXczEwNEpibG41NHZFNTQ1UXBZdlxyXG4gIFg2TE00L1huYjVOeEU2TFpZb25tUHVqQWFCeVVxYXp1dmU5RjZkWnRXeFhSQng5NUYzQytqekJCTm9UMzN4NE1ySzY3OWl4ZGg0RU5cclxuICA0cDEzdjVhZVFmUTI1eHgxcEI4RUo4SzQ4ZFBrbFZjL0RiWThEaDNjZHhzWDR6RDZ1VGJEUkRoOGI2eExVNWVGRWFZRDFsYTREZHUzXHJcbiAgYXJXMzNTYnlOdHRWVEpvMFErbHNhUVA3ZjRhQnBHQlRTSEpFcUVSakZWaUt0cVpFMGlRQXRSY2tRRm9RRGI2enlBL21HRWRzTnRVTFxyXG4gIDZxdkNPS0svZmNuR3M2S055LzFjNHdaVVZNd0pVamFPR1JuQ1hsaS8zZHREcHI1em9VeDU2M3daZWRjK011YWg2SWdDNlFLUVpnVGpcclxuICBONHhqeWRLZjVaZmhZMk02QmJCdDZ4Z0g3TDl2cEd3ZzBBbjg4Y2NrT1hoUWIvbHRWRFQvbHRXTmI3ZEQxNDd5Njg4dmFyblkvZHc1XHJcbiAgcytiS2loR1A2cmIrZk1ma1VXTVpNNDR5anFqa2tWbytNeUtkcVVxcnVFZzZubkNmTWdSdkJ6bmMxZThudno5eHJNei81UVdWQXNsMFxyXG4gIDdLVUwzdzVTQmpBMTF1K1BIeHRSWTdHdnh3V3Z5ZFNQYnRNNjRjUjBwQmYvcHdBeHh4VzE0OG4zUzBxNUhmdmk3dzRxTjJrbG5VOTdcclxuICBURm9jZlBrL3lqekN4bk9EWjl6ZWpkY1l5Y1JQSDhoc2ZjUU51bS9wdUkrVmFkalQxamFjRkVtTURtdjZBRkxsOGdtZmFqK2dYSy83XHJcbiAgc2JKaTRwY2FUTnAwNEFXNjN4dlYrOHU4bjU4T1d2SlkvUHViT2tCWk5XZU1CcmJXcUY1TlhuemlldWs5b0pjOGVOODFPZ2lpMzc3K1xyXG4gIHh1Y3hjM3RzeU5ra1R6MzlqdXpuQmtwTTdCUS9DcjdyRHUrU1RFWmNCazJKWUlNcHZnZks4ZDhGWUI4TWhuclI3eWN4UWUvVXFaVmNcclxuICBlODJaeW13NHo5b2pENVdkdXoyRXIwODVIRm0rSTRUUHRkOEViTTFnRWJScjYxWDJwVWtOdTRKcFU3MVVOVER3ZG92SFA4SkFqam1pXHJcbiAgdnhxc2d1blNuZVRCRElWbHBBenVRRHRBNFM1SUlDQ2pxaWQ0V3dvM1JVWkVFYmpMNWE3eER5QXROTXRaYWJCcll4aTNyNG01TXRMalxyXG4gIFhIbVQ4bGZMK0tjUGxPa2ZYQzR6UDdsQ3ByMTNpV09ZL2hpU0Jnc3cxUlJBd3NDbVlTK2VCVDJvNWF3eFdDZTBqczg2L3VPZ1kyRGtcclxuICB3d09GektEeE9XcnNnOFFIbnJyV3dYcjIyMWNHSDlwUEhIL1huNWVUczFIbVBCUVk0cFBLcUJvTEFtRDVyNEFsVjRRNG1ENGRvTkxDXHJcbiAgalJmQVBDaWJKQUpnR0ZVYWRaSUZJMStXbFk0UWNZeHpZQklEYmg2dVJNMllDZWZzZThLTnEyWjhQTlF4SFhPNWR0ZDJ4NDF4Mkd4NFxyXG4gIC94UWc2cTBQKzdjTXVudXFOT3p6cjJEdm5pTzlXalhwY05JOTB2dnliNlNsa3o3K0U1SUhNRVlTWmhvbWZjejc1TVlOek5OQm5qY2NcclxuICBIbG9PdmthTjdMd3pqamNkY0s1S0hqQ0tPVDg4S1NQdmRjUi82bys2cmUyNFk4c2MwMkU3SEt2VHVOODVzbnI2THpxWW93OEJZb3BTXHJcbiAgVnd5WHBSK2VKWXZuVGxldnZiZGZIaW9ERHg0Z2Q3aCtmZDBORHl2eHBvL0dTOUtIdU1FUnFobjZNa2tJN2RzQTlnMmgwaTF4QTFWalxyXG4gIEFHR1Flb1ArLy93TEgrZ3hrMExpd1RGckw4cGtFdE9xYjc4YkZSeVB3czR0RFhiTVZFekE3dld0dDcvUzljNm9zT3ljK1Bac1BUNndcclxuICBmWmg2Ylc5Z3BaTm1lQkxRbWtUNFJ4aEloNjZkNUsxWDdwQm1UZXNyc1dKdXFmU3M4WkpXSm1yazlpb3MvNUxDTVFnUkpINS9EdkVIXHJcbiAgZ20xSHdjUHpxNXNOcEh3Tno0MExOeEI0RXpvM05Mb0ZTQitvbnBSNU9PU3U5Y2JwemN0K2w4bXZueVZqbnpoRXhqeCtrSXg1N0FBWlxyXG4gIC85cXBFYU0zS2ltWUJIWU5GcVNNRXJld2psZFA0YWxoTDk4NkEvN2s4YUJEME5ucHpMZmRlbEhDanMvSDl0dHZYdkpZbW1BVXczVndcclxuICBZZVFEdXZPdTU0SzlJclZyVkpGNjlXcnFPNEhuelYrNFVHYmMyMEtxMVlzR0U4SkVBSE44cUZ0eStMRzVKVnhIcFlzUTg0Q1p0SXZrXHJcbiAgV0pvaVRmcWZvNm9RQTR6STdCL0dUS1k2d3BiUmZGQXR1d3pHOURGUG42SlNyQ1ZYQkRuTFlpWEVmd0lRK1BiSDNxdlNRcWRUSGxJR1xyXG4gIHNEdW8yYW1QZERyMUVkbi9saitsemVFMy9rY1loNWZxU3BjKzJoeDFxKzZiOWV0N2xldDFQMFptZi91bzlnR09rMEVaOVJXWVArSWxcclxuICBIVFRCUklqZEltY1c4OFB3OHJHWGdJZ3hmY1p3M1VaaVhmanJ5OEtVQVF3K1VHR0IxZE4va21YTGw2c2JlZU5HZGVTQk95K1JBUWY1XHJcbiAgMkpEaHJvK3VYek02OGswYzVnWTNCaHMwa1QrSzQ5aEh3aUNvTFh2RFJvM3A0RnVLSDJTQm4zOFpvK3NMenYrWHRzRmkzMTBZNFhQdFxyXG4gIFc4TlpKUkZPT3ZIUW9PUlJxVkxwYzd2SGcyOHg3RG5KdmV5N25lbDFTNE14RE5vTHIyRzJ3SUlId3d4cmR6RjZWT0xBYU1NL3drQkFcclxuICB6NzY5VkJ4RmZVWGtQdk1hVnkrZjdEMlAzTDd3WkUxaDc2bHRwSWlkaFRLRXJlNURXQ0I1UWY2ZTNOQ2tUenRDeGJwdEpHL2RFaW1mXHJcbiAgTTBrbXZYRzJ6UGp3YXBuNTZVMHlmOXlYRWVtaVNtYlZpRVJoMGdXTWdnVzFsSGxPNVFmbGVPalVtdTVsczloSGs2aEQwNGs1enZxYlxyXG4gIGIzK1ZlKzcxcWljRDU1eHcwcldSYyt2WGk0Mld4NURPc1dlZWZVL1hZWmZCVTA0N1NxNXpJbmp0dWpVbDFmMnVndnhDbVRkdnZzeDRcclxuICB2SzlVck5kV0NjR0NrUy9wMm41NFJKM2xpQVlNZ0FYZ2ZRUERDRE1QWXlaTHhyNnZobkRLWU9XVTczV0VhOFo0OWpNaU5tYUNVYmVuXHJcbiAgazBMR3ZYQ083alBKbzNiblF5TzJrTWc4N1A4d0lQWklDNjBPdlVZWkFNeUVwZm5nc3lXdFdqUXJRQmdWNnRXWHRzZmVGS25iN2N6WFxyXG4gIHBkWGdxLzVqRXNlc2J4NkpURjJMQ3RDWWhvKzk4ZElIOXBENVR2ckFJNUxqS3lkL0kyMENabDhobVB2R0pKYzZuUTdWVEFSSUdTd3JcclxuICBwM3lyREtOTnNLM3FLdmN1VGRMd3RnKy9YYWxlTzNXVEJ0bGpuOVZjVnBVcmxaUDkrM1dSZFRuUmZFOGpmaDB2azUxa3NXTGxXdm5WXHJcbiAgRFlaU25UUVJCdjJmQ1pyb3cwWWtEWGdoSFRsa2YxVmYyYmNTRDFSZndMNjFSQWlmVzdGaStVamQwYU5MbjhDSys3RnZMeWRuVTh4MlxyXG4gIEl0amM1ZFI1NU5IWHQyRjJiNy96ZFZEYVBteXEzZmhuWWJCN09Qb29iNzhwcmQ2dTRLK0pNeU91d29ud2p6RVFzRS9INWhwVUNCbktcclxuICBXcC9yUnUyNXNpWHdHdy9QZngwTnZ0dTYvZXk4TmtTTmdkOFp6b2RWVGoyeFlpdVhEOUoxeENPdGFLVlVtUG1NRkUxNVRmTC9lbDZtXHJcbiAgZnZ1MGJDbndMcm5vRk0xVEN1RnBVOVk2S2NtTGRUK0dZY0FzNkJSMFB2UzJWbzRITDVoakxOYnBFdFd6ZmF4UlQyMU9NT25NeFJlZVxyXG4gIG9NZHBJOUZJWStBQlo4bkZGNTI0elRIcXYvZnBMekw0a0Q1U3l6RVJubElaOTJmUi9JV3kvb2VoMHJCVlZ3MFVaRzZJK2I4OHErY29cclxuICBjWUQ0QjFLSE1RSDAyb25VV0JOZXUwaWoxLzNzZzBnYUkyVG1sL2ZwTVFpUFQ2M2hYWFlCQk91dlZ5K1NqQmFEYXVXdDlwSWZVc2p3XHJcbiAgdTN3d1dnWEgzRUZ5MlhRM0tJaSs1LzhFakptd2REbjFaVG5nbG5FUkpoRmUrbDA3VXRvZmMzZWs3bitLY1JpSVhXSWlxQm51MlpxZFxyXG4gIEtrYjZPUElXWmVqVGYzbTljcE1CNStqeFZkTisxdU84RDRZWWxBSGJ6SG0rM3hXZmFCMFloekdTNlovZEVkazJJSkVha0R3c0VIWFNcclxuICBuWTFselpvMVVyZE9EWG50Mlp1bC84QmVFV0pOM3ozaGVDK1pubmpDWU8ybjlFM0RIVTVxTmtMN3c0K0pwemJnT09vckpOWDQ3NGp0XHJcbiAgbGkwOVU3UnZMZHkrZ1gxMkx2T0g3N3V2ajVaUHBGSzY2KzdudGE3VnR6YTVqNisramo2RGVEejIyQnNSYVFnbm1YUFBPZFl4RGErNlxyXG4gIDJwU2J0ODBBc0RTY2NjWlJ1clp2T3J5MmUrSjVFRE9EL1REUjc5MVZiSGFqLzRNT2lwMC9Kb3gvbElFVUovblJPZ05aTmFadk5FTm9cclxuICBtTGpIRW5vLzV0MFIzRG5CYVdiMDFYeFlzVTBwU0ZKWGRrdTJGQzcxUnJFeUJWbFNac0tqTXYyTmMyWG1CK2ZMcEU5dmtUOG5qcGZsXHJcbiAgcTFmSTJnM3JaTjJHYkJWbVdERDRGUlZzVVkrUm43OS9UdktML3RZbFhqVkZCN0lQWThnUkE3VmMyc3ZqR0FzdjNCZ0p3VWp4c003SlxyXG4gIFltMkhZWjBIZlNkUnRQYXhBYzVoZE1jTWE0eENXS3lEZ1N1dk9FM091K0JFWlNLdFdqZlJkd1BtejV2dG1NWnpranZ1SmFuU09DckNcclxuICBSOVJWSVVLaGFpekhFTFRzR0VGWWpZWEtpaGlITmJOK0M2U01BZEx2Mzkvck1Sd3B1QnhTQnZYL2VQSUVKVnd3bWV5RmsyU2ZZNjlmXHJcbiAgTXRJeERyT1B3R1R3eUZveHlic000OTIxSmRHYyt2OGhoQmxLZVBsUE00d3dwbjF5UjRUNHd3aWFEangzRyttai9mRjN5dXdQLzUyMVxyXG4gIDFYMWh4bFFpVENDUU5FMzZzRzhRRlZZNFg1dEtoZTdENER4Y3VFMFNSVUsxcFY3WG8yWEplNmZMMkZ2cnl1SWxTeVcxYktxODk5b2RcclxuICA3cjFYaXNra1MvODk3dGhCVXFHQ3Q5ODljTi9WdWpiY2RzdUYybS9weXppTGhMK0JsVTVpQWV6TFdyZEJSL2pVQzRQdDJiTVg2anFlXHJcbiAgOEllQmhFOGRXN3doT2pFVnV1WG1DNEtTWjFCbUFPYytEai9NOTlkRXVNMGR0L3hYQk9UeEhFdzZPT3hRemt0QXVPSVF2dmZXclgxZlxyXG4gIHN6WmdTRVlQVEYzOTVGUGU2M0pQTU1WSmh6d0pTNU9TQ01sRGI3dlk5N0ovQUFUanRHdlRWSDRmOVpkMjdKeWNYS2xmTlZrSzArcElcclxuICBTbG9GOTl5MnFQU0J4eFNUMERDU0lENEJ6eWM2TmRzc2ljdU85N21GY3Y2NnhWSnV5MW9wbTFGUjUyQ3VXR2FqVkVndWtObS92U1liXHJcbiAgNXY4aUt4MngyN2h5bXF6OTYwdFpNLzBYUjdCOUIwekMxemhBY1g2eEkwenVMdDI3eE5NMk5UbEZqZHhGaFpPbFFrYXFUSnEySVBMQ1xyXG4gIHdsaTBhTG1PRE93RloyZHZsRm16RnVqK1JOR2JIM3o0WGNUSXhYRThUdzRONlg0QisybVBZMXdUSStEWGJvUVR2cjUxY1pnUExvZHNcclxuICBoNi9IK2MyYk5kQjlITU5nYVNPWWp6NzZRV3JYcWlidE83U1VDUk9teS80RHUwdjJ4anhaN3o3RzdPVnpwY1NOT2dxV2paY044MzZYXHJcbiAgaWsxNlNmbnFqV1hScU5mVmpiZEdtNEdxQjBkbkRtTmdQMlhxa0Q1bTlkL2ZTOVA5TDFSbU1lMFRUNHlJaEVhdGdvcXd6ZUhNODU0a1xyXG4gIGkwYS9KWTM3bmlGVDN2MTNRUHlTTkhsZjYyUHZxcng0NUFzRkdUV2JwN1EvOW5iNTgvbXpwRW0vTXgwaEs2dXF6clFLVlYwNVZ0WHhcclxuICBmeG5UUGthdGRJdCtEMTZ5dTExVDVQLzErcVhTNy9ydmxDa2dNYmJyUG1EeHQvY2VWUWN2TUpqQ3VPZE9ENXdadksyQzgzaG5MTHl2XHJcbiAgUmIrL0xaUGV1bHk2bi9lcW5qL0RNWlAxQy85UzVqSHkzb0g2UGxCWG1hM0RxN0tTWk5QWEYwaCtYcTZzWEwxYUtsWW9MOGNmdWI5Y1xyXG4gIGR0WFoycGVCOVdHQy90cTJhYWJ4RjIrKzlhVkdaOXN4QmtPUTFETmRmN1dCVWJqdnczU1ltUkJ2eE1HSDlKWDc3bjhwNWpqZ3ZES09cclxuICBhR2V2ejVIVFR4dWkzMEg0K3pDUUhoNVBMOVJzQkNybUJqRVVpZW9TMUV2S0VCZ04zemRwVHhMVlN3VHEyL2RzNXhLamhRMkYzOUkrXHJcbiAgc0YrVWhqZmN1VndYdEcvbjdicDJiZHFBeUhOdlJnZlFoQ1JLZnJncmVNblJuVi9jUVBRTTkvdzZkNDZHT0lUeGowb2djTnJCQi9WUVxyXG4gIDVtRThkczZjYU9RMDhRSWdITDlST1cyekpPWE1sMlNkMmRzaHhKeFRwTWp0M3l4bHBVRFNTalpJU3RFNjJUTC9LOWs4NzJ2SldUaEdcclxuICBzaWErSTBucnArdmN6ZlArK0VqZGlERjJrK2E4VEdGeFpLUmRwbHlxTG1HVUxaOHF5ZW5KUW5iYkg3NS9SZmJ0MVVYeThpYksyMjk4XHJcbiAgSmtjZmU0aGNkT0VKUWMxWThGSWgxamFDSVVJVmljQmVkanorZGZ3aGtYcXM2VkFFTU1XREVRVWpHejRFRWxTR0o3a0JHUGxJWjBBYlxyXG4gIFRMRnBJeENEMlVFWWZiRWU3anFDb1crZkxscWYvYmdrMW10UVYwNDdkWWdHWFRIRFltNGV6Q1RiL2Y0OFdmcU9UenlvS2l5MzJQd1FcclxuICBNQStBZW90MEo2aXdsdjMxdWFxMThNSlJZN29iQWZlNDZDMU53RmU3d3lBOUI0bUNrU3ZNd0tTUUVYY1BEQWdZOXBXUnNzOTViNlJiXHJcbiAgUUNIUjBCQkp2TFBtLy9DVTd2di9FWXN5U2NuS1BGSUROL21maCswblI3L29YYjFOalRYaWpXRU5TZTFEK2RkN0RuQ013RDlmbTFIVFxyXG4gIHBBOHIxKzV3U0tTT0liTnBEMVZmOGM0Tk5nWEFsRHVieXV4WGo1T0ZDeGZJa2lYTEhCR3JLMGNlMWxmNjlPK2g5WmpDMWFRSUNPaDlcclxuICA5L2g1U3VpREhUcTBpSkV3dm5TREpmb3ZmZlNtRzg4TDlrWnh6bm0zcWRvTDhPMkZ6dzNqdEZOOW1oanFQUEJnYk53VFlEL0xwWmVjXHJcbiAgclBlQnNaMTFkSGdXQzJ3dUFFYkM3NkV1OXhpVy91UEJ3QTJncXJyNUpoK1o3NjhoOHQ3NzMrcmFmc3YyY1BUUlBwOFo5d3ZzbXJhT1xyXG4gIGp6cTNYRmg3Z29JZzZlU1paL3I0bjNpZ1d2OUhHUWpvM21kZitlWDdaeU92cEVLRkRGazk2U05aUGZFRFdUOW51S3ljOEs2c20vV1RcclxuICBaUDM5bnF5ZDhxNHNtUENwckp6em02eWMrTGFzbnZDcXBDMzlXdEtYZkNWSjh6K1h2Qmx1bWZLZWJKenlnYXdhOTQ0cytQVUZXVGh6XHJcbiAgaXF4eW8vQTFXZXRrM2ZxMWJpUzlRZkkzRjBtdVc5U3V2c1h4SU1mQkNvcVpJWnlQelluNWVac2p5L2lSYjBYVVVkZ3p6TlgyN2RmdVxyXG4gIGtxVUxsOG9wcHg4bFR6ejVkc0s1a2VOaEhaSVJnSlhqWWFsSnlLVmp4L3NubUtuTVp2K0N3UkFMMGkvT2pRNzN4UWIxYTJzZUhkUGJcclxuICBobUdkZEo5OVd1dDF1SWJORVdESEFIRWtmQVFONjlXUUcyODhYMnJYcmlZcGpxaGduTnk2cFVSMTJNc2Y3eEpSWXpIbnVTRjM5UUpsXHJcbiAgQU9SSElwTXVqQVRNL2VscHFkUFJmeFNMeDd3blM5eG8xcXUzZkdRNmhBcW5oYkF0aFAwRGJoNGhJKzg3V0NyV2JpNTFXM1hQbXU0WVxyXG4gIFI5TUJaK3N4UExEYU9JbGs1cWQzYWJzZ2ErN1lvUFIvRXpEV2R1NlpHRm9NdWpSZ0JKN3dmM2w1UTNYaHpjeVEyYWl4aGp5N1dvOXZcclxuICBLUzdVZDRDOWhFRldtSEZZZWU1UFQwVVNLcHJ4dkU2bndXNndWMU5hSDNGVFZQM2xVUFRUVlpLVHZWN1dyOCtXdFBTeWt1b0daK2VkXHJcbiAgZVpSTW5ibFF6bkxFaHdITzlHQldPL0RhNjU4SlU2MUMrR2ZPbkM4VC9vb0dFNElqQW5VUU5JTW84Y3N1OVpIdmhwZGZ2TVAzNmFBZlxyXG4gIHh4UHd1Kzk1UWR1Mk9peFhYQjZkWThUQWZyNGp6bi8wc1RlMFB0Sit2MzdidXF4aUh3R2NBeVBoOTFDZjc3TTBCZ1pRWHdGVVZRVDJcclxuICBjUTZnbld1dVBqT3l2U044K2FWWEYrSnNBRXppc3JXQmJ6bTgzaFA4OUVOaTI1Tmg1Y3FzZjU2QmdGNEQrOGpCZ1pwbTA2WjhTVTlKXHJcbiAgbGdycDZaSVJCTDRRTjRFbmt5RWtkTWppbFN0bDBZb1ZzbUxOU3NuYXNGYldiY3FSTE1jazFtVnYwcmxIM09CTG1RSW9VRFhVRnNuUFxyXG4gIGRaelI3YVJkSkl2VXRHUmRIenk0cnp6eDFPMHljY0lIRVh0R20wNVJ0N3B3UXJQWjg1Zkt2RVVydEhQWkNLVTB4Qi9qbk5KZVlPZE9cclxuICByZlU0WXJNQlQ0NTQvUHU2Mkx3K0hUdEc1MUkyY0kyd2dmM2xWejRKU2g2SXpIUmM2akdpaXgrbDBIbGhGR0RCa2xWeXl5MFh5a2R2XHJcbiAgM1NkMTZ0VlVZeHhnaXMrWnMyYkpqR0hOSlBlcnkzUWZzeEx5aml5UkpiRXlMUTY2VENyWGI2ZGw3Q0ZWbS9WUXdrL1Vlak4zRE1rQ1xyXG4gIENjYWtFR2FPcEEyVFFpd3VoS2x4SVl5dGpuK2cycnJwM3hjVWJGZ3RBMjhaTHI4TTgvRW9yWSsrUlphTy9WRExwT3RZdnlCeGZxUC9cclxuICAxN0g0ai9jaXpBTUpEclVUREdERDBtbktCQ2czSFhDT0REajk5c1d2bnBiWjBtSkJabjM5b0RJVjB1dmJkMmFNZzU1QU5sNWpIT0h2XHJcbiAgMEVES2t6SXBmblM3Y05Uck12N1crckpzMlRJM2dNdFcxZEs3cjk2cGc3Rk4rWnZsc01IOXRLOFRxeFRHc0R1ZlZmc2MvZStycjMrTlxyXG4gIDJBZEEvTGRUcldadnFWbzFtckdiNHl3R3ZyMTRBczVJM3dnemF4YVlXRHhRZmVFR3pQbFhYWG02dG9VVW9xcnlPSkIzanV0YXU5UmxcclxuICArZkduMzJQdUp4NUlJSmJEaTNiSmwyVnQrUE8ydlZZaW1GdHgvRURTWURUSW5zVXhnY1N5SnhnM1laclVxeE03SlhFWXZOZC8xQWJDXHJcbiAgb3pFOUhick9DODQrUXI3N2NZd2JxVGppNzE1Y2dTUDI2WUVxQ2VKUC9JVEdVRGhwWVhPUkw2Y0VkZ3BVVVZzY3g3QWx6WjJYN0JnUlxyXG4gIHk1WXQyRUpTSk5YeG85U3lLVUpDd242OWU4Z2J6dytWZjUxd3VKeDJ5aEI1NGJrN05OWEEwY2NjSk5WckpYNG9KR3l6RjhGOUkyb1BcclxuICBHTkJEalhFbVZkanZDZVB4Sjk2Uzc3OGZwVFlHem1ITnlDQlIzU3BWS3VwenFWV3ptbDZMT2hCNlJNNzRRQ282MkVMdXdkVkRjbm5mXHJcbiAgaWJ6aEVRZnQwSWJkRi83ZjRlT2ZmdmF6WTY1SmVveDZaNTF6aStxVkFlZnlvZkw3TUJ4T25UWlhEWUgxR3RXVEx1MmJ5dzgvamRIcFxyXG4gIGNubjZSWnVMSlcvVFJyV05wR1JObDNwTjIwbWxqc2VvTk1KU3MrMUFYWk5uaVpReDJFT1laN3RTNEQyRjduekJMODlMVzBmd0ZveDRcclxuICBXV003Mmg4N1ZOYk5IeTkvZjNpekRMeDV1SXg3NFd6SGRIcEtoK1B2VW9KSW05WGFIcGd5NXJHamlwc1B1cndNT1oybXZIZWpOT2g1XHJcbiAgbk00THo1d2xhUldxNld5U2VJMVIvcitDT2Q4L3Fjd0JqSDc0S0xWMUFKN2JJZmRQVXdZOTdvVXo1Vi8zRGw4NTRvMWg5WENEN24valxyXG4gIGo4b29TS3ZmNDRKWFplSElWNVJCd0RoZzd0U0JDZUhOOWN1d1h0TDNXdSswRVBHNGl1TW11VzhPbERtL3ZTMHJWcXpVYis0eU44aXFcclxuICBYYk9LWEhITnVkcHZpVUU2Nzl6anREOWVjTkV3ZWNsSkRZQmplQW5CRlBoT3Z2eDZoTng1aHgrWUFJNFAvL2xWWFhNY04vTnduNmJjXHJcbiAgdVZNck5TUlRCMmtERzBjWXVNcnlyZHYzUlQ2blBuMjJKYng5K25TUnp6Ny9SUWtoM3lEZkJOOXZvdS9Xdm11T2NWMmpiY3pTRjc2L1xyXG4gIGVIQVB5NWF1MHJxb3RyR1BzZzl3M3BJbEszVC9qbUQzRkxhanNJLzF4RWxPT25mUHcrZ0E2eDQ5ZGoyK0pBeHNRbmZmKzZKY2ZkVVpcclxuICBwZjQrdERML0VRbkUwSzEzVDdueWtoTTBVK3l3WVpkSS9ibzFwQVFiaFZzSWJJTlg2QTI1enNxYWZTVnVwRkxrSkFwVVVTbU9HRUxRXHJcbiAgdGtiRFJoUXBxVnZseWNkdWxFdk9PMUZIUHhxUDhlMEwwcjEzTjAwOUVCN0JiQS8yWW5rQmRCS3diTmxxM2MrKzBrQ0hOcEhaUU5rbVxyXG4gIGZZa0hJNUh3dFRpM05GZEZSa2JVU1pSWmt6Wk9QZjBHWlFTTWJIalI0WHZZM3pHSE93TWJTSGcvc09zREdPU1NKU3NqSTcrK0Irem5cclxuICB4UFNCMHFSeFhVblBjRnpadllkOHgreFhybDRyOHhZdWtwR3YzeVNUN213anl6K0k1aFZpOHFITVJ2dm82TFc0Y0pPVUxaZXBhaStrXHJcbiAga016R1hhVG5wZThwQVNNNVg2TytwMnU1YXRQdUVZa0VnKzV2RC9vZ0xWUXd3KzlDV3VrdjlYdWRtakwrNVF1MFhLbHU2NGc5Wk1PaVxyXG4gIHlVcjQwaXBXVTNmaFRZSDc3Ly9ybVAwdDZWQTh3WjN4NlYzUysrclB0UHpCcVVseStCTyt2NDI0ZTRBY2RPY0VtVDVoVkcxVVYzMy9cclxuICAvYTArYjhvOFc1NGgvS0RWb2RkR3BJK3lGWDBRTGt6ZE1Xd3RsNFpsVCs0am8zOGZLNnRXclpIbWpvQWVldkIrcnAra3l4dHZQaFRVXHJcbiAgY0tQWGNWUDFHMkxoV3pUVWRBT25OMSsvVjlXdjRONjdyOVMxd1lpVjViNDYxRWt4WWRDUEdiQVJIOEozYzB0Z1Z3Z0Rva2ZTUlB1R1xyXG4gIFRlMFRocW1zOEVqa1c2QXQvMDNBR3JZRngrejNXRjNLOGQ5VkdEWUxJYm1wN25CU0Z6QUp4TTRqOC9hT1lIWVV3TFdCZmIrc21ja1JcclxuICBMQWppUk1JUzNPN2lrNDkvREVxbDQ1MzN2djVuR1FnL0x2NEJYM25kK1hMZ1FmdkpEVGRlS01OdU9WK2VlL1oyZWZpQmE2Ui92NjV5XHJcbiAgMC9Ybnk1MURMNWFMemo5VzdyLzdNcm50NWd0MG10Wm5uNzVGWG5ucFRubjV4YnZrK1dlSHljdE9zdmhyMURzUjJ3VU1vMDNyeGpJa1xyXG4gIFNJQVdmckYwdGc0ZFd1cTJQZlR0Z1hxTVRPeEYyV1F2bk5zdThINklSL2hsaHUwUml4ZXYyT2IzQStZb3dBdkRRQjBML29tSDVZT3lcclxuICBEeXUrUFZ3SmtTbysvL3huOWNZSWR4N3V4NkxVMlk4YTY2T1BmOUJ0QSsweG05dlhYejRqbDExeFQ3QlhwRWF0Nm5LWEd4bmVmLzkxXHJcbiAgamhta3F5TUUzeFozazUrelZoWXZuT05HZGt0azNxdkh5WUwzenBmTUxVdWxlTlZrTjJLOXcwa2hQbjNNM0orZVVlSUV4angxWW1RVVxyXG4gIHUyTGlWNUpjdHB3eUJXRHFLMVJjd3pHb08wbUY4cWlIajlSeTJUSWwyZGhEVEdVejU0ZW5wYjZUUkFpSVd6ZlBwLzlHTjc5KzRaNG5cclxuICBqL3R2Qm9TLzVXQlBjSGtlZUYrQlgrN3NMOTNQZjAzS1ZhMG4zMTNmVHBsRXd6WmRaazkrOXpwVlY2RWlKQTdIeWtZaXljYWJYcm1XXHJcbiAgTXVKcVFkWmVVRDZJSThIekttenJ5SDlqZjVrNXJLbE1uZnkzVHRGUW8xb1Y2ZEc5cmJ6MitnUGJwT1FCZkVQMkhSbnV1dWQ1WFRNMVxyXG4gIHF4RmtRN2hNL05PQUE4NktUQWdGT0U0LzVsdXc3eUxSTjAwOW5FTnNRSFg5djcyMEZnWURNN0tFYzV6NnR0NWVTaEg3UGRoSnFFczVcclxuICAwZlVOeGhwcXUyK0pqQktBQVczNG5KMUpZV0oybE8rKzl4UEFjZTN3MnRBa2tGTHdUTnRUV0RyN2M4NzJtWkpCZUNaSEpKUng0NmYrXHJcbiAgc3lvc1lLSVd5M2gzUVZSWnRpOW5VNzRjZWRSQjBxTm5aODB4OCtTVHQwcnZQdDJsZklYeWN0SXBRNlJmL3g3U2M5OTlwRXZYOXRLcFxyXG4gIGMydnAwTEdWZE42bmpWdmFTdldhMGJRbFlORWl6MzFwbDQ3REdwQjdud2hUWFA2NE5oM0ZqaVVDZFY1NitXTjFpN05wSWFuUHl5cGZcclxuICBMcVBVYzJtWDM5V3NtZi80S0lORUhZejd3eXVFYytqRWs2Zk0wazRXM3pZZk9rbmEyRy9QRE9abWRndEFwOEYxbUdONGRoSE5HMjRIXHJcbiAgMjFKaFFhSHU0MTcyNlhhYzNIcnpoWHFNWi9QeEp6OHFFOUxKZE55OWNFM3FzcTdnbmhzenJpVW5iWlYyN1Z1NGQ5RkpObTNjS0t1elxyXG4gIE5zZ1dOM0xhdW1XcnZzT055LzZXd21VVHBHajVCS25aNzBwcHNPOEpzbnE2WTJoMVdqdHBvYkV5bFBiSDNhR0VDcGRmbU1yV0xjVTZcclxuICBId2hsMUY4enYzeEFCdHo0ZzR4N0Fha21TWHBjK0txTWVmcGtMWGM0K2VIMG1SL2VtSmRScTBWcWszNW55Tnp2bjlSWWtIcGRoMGpXXHJcbiAgM0RGU21MTkdnK2lJeE42d1pLckdqZnkvaGhXVHZwV20rNStyNWVtZjNDRXREcnRHa3BQTEtzT3QxWGFneHFJZ3FjRUllcDl5Kyt6UFxyXG4gIGJ4M1lFbW1QNXp2UzFTRWVxdHQ1TDhtb2h3Nlg5TXg2dW4vdUQwOXBab2pHN3BsK2ZYazlaVERZcjViOTlZVktoc1Q2VkhUdmNPMUxcclxuICBBMlhsancvSndnVUxkSDc5TlBkOUZoWnZsbTgrZmxTeWM0dWtiWnVtYXRzejBLK1BQZVlnbFRiNGJtendROWs4ckw3KzVsY1o2a2JsXHJcbiAgcUtzTUF3ODhXd250WXRmWGNhOWxrR1huQXNyMmJaTkQ2aFFuZlYvdEdFRVlSbFRwdi9SMzZpYjY1a2tEWk1ldHpTVDNEKyt4ZUtCMlxyXG4gIGV2cVpkd1gzZTd5dlNDSFBPVnlMdHNQM0dBYS9BeFUwMTBIRHdLUlZsU3FWbC9MbE0vUjdmdjJOTDBvOU53d2tFTnJnTy9YMzZiOVJcclxuICA3Q0ZvTTR3Mm1Ib0wrclV6N1c0UE45endzQ3hkdmtZZWVRaTNldytZUnRuQXU0dFpGZTkvNE9WL1hvV0ZmN2NoTjllbk1TRDRCL0JRXHJcbiAgZUFIZ29ndWlickxoL1R1TEVTTjloK0E4TzVjMTZobXd2VWpSTUQ3NTlDZjlJUERPc0xhWTlZd1hzcjM3WW1URWlJUGpwQjZoTGt0cFxyXG4gIG9EMFd2RlFZeVNRU096bmZ2RmM0enZhb1ViRkdZL2JaSkZKangwNlJldlg4ckdzR1JoQ2t5VWFrWi8rakQxOGZFYTNyMUtraGk1ZXNcclxuICAxUHZndytBYWRoKzB4MmhwN0o5L3k3bm4va3NhTjZxbkJPSDFsNFpKd3dhZVFPUEVnRXF4b0hDekxGcTZ4a2xjaTJYNjgwZks2T3RxXHJcbiAgU2thSmY4ZDRXa0hJSUZZazc0TXd6ZnppUHNsZU5FbWFEanhQVms3NVFhVU5ET0plbFRWQ0pSTEtBMjhobHNTbmYrOTcreC9sUnR6bFxyXG4gIDFWMDlMMzVUcy8wdS9PME5xZC9qV05tY215MGJGdnVjWXBVYnRKY0N4MUQrWHdHL0Y4bWpUbWZ2MVRiMnlSTWRvYjlOSjkyQ2VmQThcclxuICBZUWFvb3BoQ0dPWXgrdTFoTGRmTS9EV3lIelZpMyt1LzAzZkJ0TEk4ZDFOZFFRQW85NzdtYTFrMTlTY05Ia1FOeVhXTHA3NHA2MTRiXHJcbiAgTEtQK0hDOExGaTJVcklLTmNva2oySWNmMWxkdXZ1RUMrV25VWk8yN1lUVU1SSlY5aWVJYVlCaERRM04yaE12MGE3Wm56dlEyQW9naFxyXG4gIDdjVERHQVJCZlcrOWZxK1d3OEIxMTRnbi9aMVU4TFFYajErQ1ROZ3NFRVlJZkduU0FJR0wzQXVCajF6ZjdvRjlpZTdSUUFwM3c2Q0RcclxuICA5blBmVGUwWWI3VGJiOXQyL3BKRU1BbUVsQy9BdmxFTEdyVGZaL2RpMHM2ZWdKVDFyUjBURDhNOFF3R3BaRmF1K2c5NFlXSEFNcGlPXHJcbiAgam9ucmQ0UnBvUWU5TXhqUTN4dkpzSGZZQXkwb0xOSXluY1E2MVk1UXAzYjF5UG1zZVZuZHUwVW5yYkYxUEhoNWRvM2VRVXBxcnB1YlxyXG4gIDZ3T1Q0a0U3TE5RQnBkMGZoQjNZY2VzODhlQ0ZZZ2duUlVLNERwNHgrUVVGMHFON2U3MGVXWkp2RHo0QWNMcjc0TWgwQ2hnWmh2WEZcclxuICBrOTErUHE3d2RKM2RlbldUTHo1OFZNNC85MWc1L2JURHBWNkRPcHAxR1JwU1ZMUlYxcTNQa2V6MTYyVHVWM2ZMdk5kUGxGWU5NcFVCXHJcbiAgVkc3UVFVZ2ZEakhEalpSNU1SWU1mOUZKRUg5RVZGbTQrVkpHQlFPenFOR21ud3k0WllUYVEyampYMjl2MWYxNVdVdlZNMnYxOU9FeVxyXG4gIDg2c0hwVzYzSTFXZHRYQ0U5L1ZQcjFSRE5xN1ljUi83YndlTUE1anFqdTJlbDcyblpkSzhoSm1ITW9sVGh5cnpnT2tlLytZVzNZL2RcclxuICBvOHNaVDJ1NWNrT3ZYa1ZxVXduRFBkTTI3bnphd0R2TDVrN1BudjZ0Rkl4N1ZsYXRXaVYvVFo2aU9kTXFabGFTSHo1NVVobzFxUzhOXHJcbiAgR3plSUVLdFZxOVpLYmZmTnhJTUJtekVUY0pjck0zSys4UVlmMXdITENSTmZVbjJ3VGJ3VjMwU2dvWXFBZmNRMGhaSG9XeVFvMGI0dFxyXG4gIFJ1VjJ2WGh3TFlna1lCSXJKUGxFc1NMQXZsT20zT1U4Rm42YjJUVVN3UVpwekZsdURHZVZJN2dHMmh4MlIrbm5HNHcrQUdnVE1FY1lcclxuICB1dzlnYTNVR2NGTEpuZ0J0RFNyckUrSVNSNGE5UlkzRy9PTU1KTXkxVEswVGh0Mkl2U1JEb3ZRZTI0ZC9hRWdRZ0xaUUN3SGEzbGxZXHJcbiAgWGM0bnhpTHN3c3MrUk5udGdicU0rQTNNWXhEK1hmRUlKMXJiWGowN25valJRUGp4SUVQczUvakdJSnJXVURiVmk1MmNYemt1ZXlqdFxyXG4gIElvNEMzZ1VwSkt3emNvejJ3dGZsV01ldUhlWGtFdytUczg0NFJxNi85blRYa1MrVU9uVnJhRzlLVDArUnpZNmJyRm0zM28yWVZzbndcclxuICAxMitSR1M4ZEp4bTVjNVNJUWJncTFHcXVaYngrQUdXSUdFQU5RN241Z1pmSUI2Y2tSUmdLVEFRYzkzcVJmSFY1QThsZHMwaTlpYllVXHJcbiAgNWlsaHpXemNXZXJ2ZTRLc211dzlrbEJwRWRDSWhQTy9EZVQ3bXYzZEU4bzQrUDBRZW42ak1aSlB6OHVVTmtOdWlqQVBwSTBqN3h3K1xyXG4gIGUxVEFQSVk4dlVyUGdYbWdsbXA2NEVYNmRXUXZucXpuRUxNRHM4WWU4dEZwU1RwdGNKOXJ2cEpWNHorVUJrMWJ5NFJuVDVScG96NVZcclxuICBnckhGdmRQTXpNcnk4VHYzUysvOWUydmFERUEvZ0lDOS80Ri8zc0Qyc1k1UDdXSFNCeElCa2pKOU5oR3M3OFhuZjd0dDJOTXFkZEErXHJcbiAgMzJDaWJ3VUdFM2FUeGJzcFVUMlNqQUxzSlBSeFJ1eDhPL0d1ODREN0lXTTI5Wmh5bDduSGFSTlg0ZTJOOUUzNk9PVGdQbnJQZ0RaWVxyXG4gIDdKNTJWZ0lCbkdQbmhuK1h0VzAyMU1ZNzRkRzFJendmaEJpUVJTUU1tN0tYUWJFTk5QOXhCbUt6ZkFIYzkwQ1lDQklvWkFpUG5OSDlcclxuICA3d29RUDNISHMzdzF0R1dFa1U1Z0Q1LzFqa0E5enFjVFd3UjRYbDYrN3JNMEFvbkFlU3pZS1FEMWJZbUhkUUFNM3dicVRabmlwWUZFXHJcbiAgNEhpNEF4clloNjZWbkVHVUt3YjVoUXpzTXpVWEVnblAvNHN2ZlJwdUVNOGs0bUhYUlQwR2tFcllabi9ydHEzY2FERkpicm5oYkRubFxyXG4gIGxDRlN0MjRkZGNOV0R6bzNpdHkwY1pQa2JNaVczMSsrUXZMR1B5OUwzamxkMXY5d3ExU3UyMGJtTzRrQmhvSUt5NWhJUm1ZZGRVZnRcclxuICBjdVpUdXArUk5vUVRKZ0pESVFZQlNlVHJLeHRMNGR5ZjFvVkg1eW5wNWFWV3AwTlV2UVhTS2xhWDJoMEgvYTlTYWMzOTZUbWRxS3ZsXHJcbiAgSWQ0VEtpeUZvRmJpR2ZTKzZqT3AzZUVnR2Z2c2FaSXpmM1RoZ0p0K2xqL2U4Y3dERldCKzlnb2hkUXpNZzJlS1l3TURlbFJUcEl1eFxyXG4gIFo4NFV0djF1K0ZubWZYMlhqTHU5dWF6NTR5VVorZVJwc2lrbnh4Rktkdy9OR3NqTjE1MHJ4eHg5Z1BUb0c1MVFDS0pGSUN6ZjFlV1hcclxuICBiUnVndC8vQW5uck1pQnZsOHkvNFYwVHF3R2tqREk0YklJUUREanc3Y3E1aDVDK3YrYlhyYzlnaUVuMVRmUHQ4OHh5anpsdHZlMmtrXHJcbiAgSGd4T2tYaTRMdTJGcng4UDdnTUhBZXF4V0NvVDFIWnNsd2JzRnVaWmFlZUc2KytNOUFIc25FUy9GOWk5NDdJUFNxdTNLMWdXRE40dFxyXG4gICtoM2dFR1JZdW5SVlpCSzdmOXlJVGdSbnJWcmVSMytqRzlFZ1ZyTGdsb3JvUzhBYTI0Q0haVVFNTWNyMjd5eEdqLzVMZnlqbjBRNXJcclxuICBQQWZJYVVYWmpFMWNaM3R0SXdZaUpuYnE1S080T1k4cEwybVR6bFBhK1p4bmNSdUFVUi8xV3JSb3ZFMk1SNkw3b0Q2ZUZxVVJjbXVQXHJcbiAgNjVCaUdYV1U0ZlBQZjRuOFp0cTF1Z2JPUVV3bmdBdC85dk11SEtyMkYyQnRzbCtOZTI5K29YbDY4RjdqR0cyeHYxclZ5dnI3UnY4K1xyXG4gIFVhL0Zma1lpcDU1eXVKUk5TM2NNZkxNTTZOTkpsaXh6SStDc0RWNDM3aW9WT1laU1dGUXMyZTc5YjlxMFVSUHNyWjN5bGFRa2w1SFVcclxuICBUUXRrL2ZKNVVyUGpvYkx3VjU5M2lYeGJHTmlSTU9aOC83Z3MrZU45TmFyVG1LWTlPZFlSUnJkOGUwdnZqT1RDckEydGo3MHpuUkgzXHJcbiAgcUVlTzFKVGxUS083ZE94SHNtcks5eHFZU0FxUC8zWnNXalZQbGszNFFwcnRmNjY2SnZON0Z2NzZ1aklPSEJGZ0pBdC9mVTBPZjN5QlxyXG4gIHh0bGcvNmpkdU8yR1R1ZThYaDdtYTh5RHBJN2ZYZGRLR3ZjL1M1bkhCQ2ZScFdSVTFETDFTRkcveUQzYjNCWFRKTDE4SlpueDdoVlNcclxuICB1T2gzalNKZnZYaU94bDVWenF5a1JQT0tTMCtTVHZ1MGswc3VQVVVKRlFPVVgzNFpxKzhleHcvbTNxWnNoTmo2bjQyUTJRWVl4OGVOXHJcbiAgZVM5bVh4Z01adExUeXVveENHSDN3RWdkQnRldzlsRXBKOG9RUy92MFlkS2VMMSt4Ums0OElWWUZZNkFkYkJGZG5QUy9lWE94bmdOQlxyXG4gIFQzUnZnR3ZuNVJmS2NjY04wbTJ1UTU2cDhQY1ZEK2lFNWFLaUh0K1BNVE8yUzd0V1BPd2MrNTVWUmRldm04eVlPVjlhTlBjYUIyRHJcclxuICArTzkrZDNEc2taZW9DbXZZMEV2OURnY0dEQVpVNVMrKy9MR1cvM0VKeEZ4b2dUME1ZR2sxd2xnVEpCa0VScWgzQllrTTZSakQ3Ym84XHJcbiAgZExBakxzM0xzT0FlenFVKys2d2RXOGVET3ZZaUFmV3dIelJwa3ZpRmh1OERSbXFTU3p4c2tuemFzOTlsTG4yRzhQMVJybDQ5TStiNVxyXG4gIGZmTFJZN3EyYXg3Z1Jvbmg0K1hMbDlOdGp2L3kweXN5WjA0MFpRbGdQMjBDMnFjdTEwT2l3YnVFY25wNldlblN2Yk9jYzg3eDh1elRcclxuICB0OHZaWngzalJwdWQ1ZnJyem5MU2l3L2VMSGJNWk5YcU5aS2J2MUhtLy9tSlRQam1SU216N0hlWjk4cUprcG5wMjJjRURpQjRnKzZlXHJcbiAgS09zV1RKQVJjWklJQlBhSVoxWklmcEZVSnNzc3g0NTVhWU44Zm1GTkpiYTQrYlk0OUNvbmpid29Dd0tKQkpDNjQ3OEpUTG8xNDh2N1xyXG4gIHBVS3RadEtrLzVtNmI5UkRRNVFRbUhSbGFlMjkzY2RKSWFjbVNkMlczYk9hSDNOdjVURHpTS3RZUTc2Nm9xRk80cVdTaHp1V25sblhcclxuICB6ekNJQ2l4Z0lpWFQzcElONDErVGNVK2ZJTm5MNThpSzFWbksvRk5Ta3JXdkRyMzVYSlVXMXF6M2MxMFlMTHN6Qk5VTXkyRlkzK0s0XHJcbiAgSGJ2VGxZOFBqTS94OVFIN0gzMzh6WWc2Q0R0Qm9uckEraXQ5TlI2MFkvZks0QStEZHlKWUc2all1blh6ZGtHUVNKMWtkYmtmYkRNdlxyXG4gIHZQaGh6SFZLZzhWdFVOZmE0Snp3OXM3TWdmNTRnaHg1RmpTSnF5N3RBVk9yMC9hTzdtMW53TmQzL2ZYbjZ2czJHTDFHeXhQTzNmZVBcclxuICBNeEFRSnBUMkFQRUtBdnhnMjBkSDJ4TmNmSkdmaWhSWFhHdlhIakpsb2pWQm1NZ25ncjBFdXk4anpteHZ6elpqNStGK1NLQVQ5U0d3XHJcbiAgZURzbFF2ZytjTTBOMjA3Q29BMjdsL0N6RElOcnYvalNSMXFtRGd4cFpDaUJJbnBzMUZqMmNYSnR0ZzNvZzM4ZVBsYU9PSHlBWG11aVxyXG4gIGt4RGZmYzlISTlNMjhTM0VrSEIrK0R6ODZiR3g4SnhKQ3ZmdGQ3OUp4L1l0SFBNNFdrNDkrWEFaL2V1YlRscEtsMnN2TzFsT09uR3dcclxuICBwS1NXa2JUMFZNMG1rTFMxMkZIMExUSno2cCt5Tm51TmpIdjdHdm5yNWJPbEpHdW1sR3hZSkNYNTYyWHFXNWM1eHBBamVldVd4cWl6XHJcbiAgc0lsQUZEdWNlSzlzTGxPK0dpbmdhMVNReFVjKzUrZkNuL2lHajVkb3V2OTVVcS9uOFpFWUVVc2VDSEFGWGpEU3EwYitreUQ5Q3ZlT1xyXG4gIFNxcEt3NDdTNW9qcmRmOE10Mi82cDNkSm4ydS8wT2w4cVFPejlCS1hJLzV1bXlCQm1BV3BYcEJDWUI3L2VndHlqLzNvZkozM0EzZmRcclxuICBQeDQ3VnBrQTZpcG1HR3pRN1VnWjkrQkEyVGptR1prMVo2NnNXTGxHM2J1TEFuN0txbkxWU3ZMcCt3L0pwVmVjSlQ5ODk4STJLWGJDXHJcbiAgZmNmeVUvSGV6ZU1xRWVFbmJVblh3TTZYQ0dZYmViQVVBelo0K0JIL2p1ejdpZ2Yzd0xYdEd3SDIzWWVCRk1DM1FmNHQxRXVvaXhQVlxyXG4gIE05ZzNiOS9WK2VjZHI5Y3g5VmRwc08rYXVselA2ckp0djJGbjRqK3V1T0kwWFhNUG5NZjNsOGorY2VBQlBvYUhrSUE5QmM0T0lMMXNcclxuICBhc1JsRjVnRWdpZnRuK09pczZqK1J4aElHR1NsQk5nVURHU1ZCZmJDREtVUnk5SmdMbkltYWNCSTdHWFNsclZ2TDNGN1FQWEZPZUg2XHJcbiAgckRIQUljcVhCb0lOOFFRaldIQkg5eC8vZTBHWXFZUmg5OEtvbmpva1FiUmdLZ09UMVZBSHFROG1Gbjhjd3lVVFRkazFjUkFJWHorelxyXG4gIFNxVkkwcmlyWE9mOVBmUTdUY1ZBN2g5ODkrMStEQndqdFlIZFA4ZjRmWHc4N051bld5ZHAxYUt4L0RYNmJlblRxNXZVcjFkSDUxcmhcclxuICBIa2s5VTVDN1diYTQ3WUtzUlRMMjlTdGw0Ujl2eXR5Zm5wUTVQeitqbytaREg1bWo3WDUrVVMwbHBuaG5RVHgxWk8yMld4NytiM25tXHJcbiAgeUtTR016L3cwc2crcHo4bW41eGJXWStYTFo4cG1ZMzNrZm5EWDVMbGYzMGxtL084YlF5M1lrYjlKR1VzMlZJc1M1MUU5RTloemN6ZlxyXG4gIFpKNlRoQmI4K3Jwa1ZLMm45MnplWndRRmpucmthRTBXMmZib1c1U3hmSDJWOTc3RDNrTTltT2VhdjcvTGcxa3dNZFFYbDNxcGx1MUZcclxuICB2NytyaktWV2g0TjAzby9wSHcrVlNvNHh3VHdXdm5tYTVJOS9VY2JldTUrc21EWkNscXh3RE5hNmhSTnoyclpwTEFNSDlwQ0hIcnhXXHJcbiAgbWpXdUwxazUrZnJPc0UxQ29DanpMbm1IOWs2UjZzUFpIYVpPblJPcEM0eXdzUTFqcWxpcFFtUmZHRllmYWV2Zi96NUh0K1Byc1kra1xyXG4gIGd6c0M5ZXg3UXowZXRxMGFJTDc4RGd6L2ZNT295NWgwYlh2MkNOcHNHYml6a2xrQ3VrVnkwMFMveDRBQjNXeU0xR094MzhwNlo2UVBcclxuICBFSTVBQnpabGJldlczajVzTmhiTDZzdWdkVSt4Wk1VYTdSNHdMNk1mTnY4S1FETVJwaXYvRVFZU2ZwbDRKUUVqTkFBWFZJTzUxZ0VMXHJcbiAgNU50WmVJSThQdUpweEE5bkg0QllBck5GaElsZklwQmpoM3VNSi9MczY5WExSNmNuUWxqTkUvNk5wU0dleWNSZnowQmIxSDNsMVUrMFxyXG4gIERwMG8zbDJQRVFQelJFK2JObGZyb0JJTHQ4VSs4MzZodkg1OXpqYlNoQm5iQVJOT1djZG5IMzdvSm0yMENYbG9jQXhieUIraGhIVzhcclxuICBjNjdOeDhOOUUzbk1zNEZBM1hQWEZYTHpkV2ZLRlplZEl1ZWNlWXhtUzA1MmtvbW0weStickFTbGVIT0pwTG95bVAzbEhmTFptY2xTXHJcbiAgcldpQlZFZ3UxRkU1Z0xqaXZqcjh6Z0VhSjNHODJ5NUpMbDhOcG9FMGdrb0xVSjk5VExSVXQ4dmg3Z01vMGRFK0VlMkFHSlF5eVNsU1xyXG4gIHY4Y3hrcjM0YjFreTlrTlZkUzF5ekc1M0FSTlkvTWY3eXJBbzEyamRWNXJ0Zjc0UUNHblIzMHpmU3l3TE9jTDZYUDJwMW9OUmtNcitcclxuICBzRWZuS1pOWk91NVR2ZitHKzUwc0EyNy9veHlwVEg2K3ZhZTJSUTR4bU92c2J4NVdxY3pVVnZrVFg1UE5rMTZUeVU4TmthVkxsbWg2XHJcbiAgZFVhT203ZUlwZzg2NnFnRE5PUHNzVWNmSkljZDNGZCsvdUZsMlppVEsvZmVjMVhrM1lkaDc0ODE3ejQ4WHpqN2VNZTg2MFVoUXlzd1xyXG4gIDZRSWl6VHc0OFlpUEM0a0h5UTdEd0xaaDBrZ1lYSi83NWh2aC9zZ2JseWdOUEtDZUVYVVdBbVVUcWE4SWtnUFdOdTIrOGVZWFVxNWNcclxuICBodTR2RGFqc3dNU0pNeUxmRHMvbXdBTjZhWm4yZUdZN0E0di9zUHJHS0o1Ny9nTmRFMXNDYUJPUWxtVlA4YnFUdG1BSzVNY3oraEoyXHJcbiAgMDU3dm1DanhINFovM0lnT3dvWnlic21NU3ZIN0FDTmNJN3hNQnJPckJpRTQvd24vT2tSZkdweVM4eW0zYWVOSGRNKy84S0VTMXZBRVxyXG4gIExZbkFQWEdjYzNtQjNCTy9vMG1UK2pIN1NvUDl4dkR2VEFUNzdhZ0wvR3hvM3VBZDN6WjFyQzRMM2lBRVEvRnlNWGdiU0xpSVBwbDdcclxuICBIRGl3NXpadGNULzN1ZytUWEVRWXhTSHErWGtGa1h2RTBJNU5BeTg0cEpFWnN4WkVvdHR4ZFNRQ21BNmJrWkdtejVycjBENkdQVkowXHJcbiAgODF5T1BYYVFHbGx4ZitRWTk0MTZidnFNZVdxd1pBVFl0bDFMT2V5dy9qSjM3aEs1M2pHdVRlNGUrdTdYUlZxMWJDSUh1WTl0K3JSNVxyXG4gIGFyaE1LaWFwSnFQdU1ySXVlNE1iMFc2UmxETEpNbmY0SzdKbTVCTTY3V3JXN3kvSTc2OWM0YTZDdXNjbkIvejI5b0Z1aUp3a0E4NjRcclxuICBmWEdUSTRaV1poOEdlUGJWNlhTSTFHZzdRS28xNjZHai8zSTFtc2k4bjU1UklnOXhKNnN3SHcvcUpVRG1XZ3pjVE1SRWZNbXFhYi9JXHJcbiAgNnVsKzdwSTFicDJ6WXBhVXE5cEFNK1NXY1ZMTmxxSUN5V3pVU1lNYWNTZkdDQTZvUCtuMXkyWFp1RStjdERCSW1oMXd2bFJ4OVdBY1xyXG4gIFRKeUZheTNxS2liU1l0K0U1MDR1V0R0dlFzcmhqeTJRcWsyNjZ2M2pSWVVLQzBiRTlzTGZYcE9lNTcwa21lbkZtdElrZCtGWXljdmRcclxuICBKS3ZYckZHWFU4YUtQUCtxMVNyTCtXY2NKbGRmZlpaakFGM2RlK2toL2ZwMGxTYk5Ha3JEaG5WMDlQcGE0R2hoZll4M2l3TUl3WGxMXHJcbiAgbDZ6VWZRenFHTWxESERtT3ZZSCtrcGFXcG80djF0YzR6cXlZRm1tTytpWGNEKzM0b1lmMGxadHVPbCszalJBYStnNDhJM0krMXpyNlxyXG4gIHVDdGo4bW9aK002NWIvcDYzNzVkSTg0aFllRGVIeDcwN0FoOWVudDdKTmZsZDNQdkxELzkvSWNhc3NPL0pReWpLUnpudWZPOXNZOW5cclxuICBIRzVyUjdEb2MyRDF3MnRyaStmR051dUREL1lacS9jRXR6bW1EaVBDL1RpYzhRTGF4L3M5LzhKaG10dkw4QitSUUl3UUE5S0tnUEMrXHJcbiAgMHJBemRlS0JSeERnWER2Zk9EamxYcEU1ajdmL0V1MWNjbUhaQytPQldudjJNcmNINnRtMVM0UGRCKzY4dEwwOTJHOEMxQ1VkUTN6d1xyXG4gIDA2MjNYS2dKRnNNSXQ4djVOMTd2VTJKUXhpMzVxbXNmMEczQVBxS0N6WWlPbEVMNkNRQ0RzMmRCOGtYbW5DWTZQZHcreHlkTW1LYk1cclxuICBDUlVpSFpzMmVRNFFDTGJ4ZmdHa240ZlovVDV1bW56MHdXT1M2eGpHR2FjZkpZYzRvdkw1QncvcUI3ZzFwWXhPOGdXUVNqWVhiWkVrXHJcbiAgeHk5VG5jU3lPbXU5ZkhORGUxbXpacEdrdVRxb3RENCt2WXdzK1A1dVNTL3ZwTEUvbnBPbmoweHFpRXRyLzlOdm40L0VBajQ2TTBNbFxyXG4gIGt2VUxKK25vbitTTWJZNjhTZWIvL0x3YndkOGhjNzU1VktaL2VxZldCZFZiN2ljdEJsMmlhakRVU2N4UjB1clFxNlROa0J0VTVkUnNcclxuICAvL00wZlVyVGdlY284eWxmM2FlemdXR29YWVBsMDd1VW1QZSs5Z3ZwZGNXSHlqaklxdnZSR2VrcWNlQzJqSkVjakx4anYzejJ0VDd1XHJcbiAgM25Ta2pPbWYzNk9HODYzRkJYTG9CUS9JNm8vTzFlMjFzMzZWeG8wYXk4dzN6NVZSTDEwcFJZVUZzaWxubytSc3lsT3B6ajA2blpXeVxyXG4gIHI1TTJTSTQ1NUxqREpTMmpuTjRINytUYklNMDRFaXN3MVNUSGVLZVV3L0VZWkpDQVFJZEJIVlE2RFB5TUFUQndnTGh0M2Z5M3ZtL3lcclxuICAwU1g2WHBBK3Jrc1Fld0U0ejZRVHlpQ1J0TUl4R3lsemZWeUlFNEhnWmZzVzdUZFp1NldCNDNZTzRKa2dTY1F6dWpBd05sdTdQRWNXXHJcbiAgMjZhdG5YWGY1VHhnNThhdjV3WmFHMkpUd1BidWFXZHhUOUEyTnF0NGV5eE1ldmJzUmVyQ0g4Wi9SQUlCakZieC84YWd6SXVnZzlub1xyXG4gIG1MTHRveXV3Tm56K3hYRFpOODV2Zkh1d3pvc1BPSE5vbUFUQVlxNnFYSXNYUktSMW9paGFBL1gzZHg4SDUrSjl3SWRHSitDZTdTTUxcclxuICAzMnM4N0xkWUhhNUhMcHhFK2xrNkJpNnk1TjB4OThoRTdkcytmaGYxNHpzT0h4TWZDOTVmR3pmbXFTOTN2QlRFTnFvcVJtMzhEbFI5XHJcbiAgNGVkT0daVUZuUWk5SzhiMGZFZmN1M2RycjNWNEJ0aExHQXhNbXo1WDk5bUNtRy9CVEZVeUswbFRKN0ZoZEx2azRwTWk5ODc1OWg2WVxyXG4gIHRaTHNxZnoreHg2NVFmNTl3eU1hTlYrU2xDd3Z2WGluU2g5TlhYc1ZLMWFTczg0NFVxWk1tUzBiYy9KMFA2T2Y0cEt0amlBNGFsbThcclxuICBWZEpjbjNjREpTa0tMTU5GanVDaUJvT1FqMzFuYUdiT21CZWtYZWNlT1MxN0g1dFc5OEJybEdHWVZPSWVuS1pGSWJnTzExL1dSTHpqXHJcbiAgOGtwd1l2NkdWYkp3K0V1eWFjMUNXVEh4YTFrMzUzZFo0eVNSTmJOR09RbGx0TXo1N2pIWnVHeW1CdlhsTEo4cEpZVzVrbEd0b2RUclxyXG4gIGZwUktPMFRWNDEyMlllbFVsVFp3MFczUTZ3VHA3cVFIcHV4bHdxenh6NTZjdjNybXFOUzJ4OTJWaWhTeWFjbGtHWE5QTDFrMDRSdGxcclxuICBrQlZxTlpMNVk3NlFKVXVYU29yakR1ekx6czUydnpkUENncHhTUERQL0tvclRuVy91NnhjZXVtcFVpMnpvaHg0VUc5TjJ3OTQ5a2dOXHJcbiAgUm9oNEQ3alo4ODdITzhidmJRTFBSTjRuK3phVEVkdjFCd3NPaEVqZTk4REw4dW9yZDJzL3BiNTl4NkIrNHdQbDA0OGYxekx2K0lhYlxyXG4gIEg1TlhYNDVPQkdiWHRyN0xkbncveHZVM0xIMmc3ckx0TURqR3RRM1lLQko5WDlSRHlzZDc4VGMzUUdKSzUybE95ZzJmYThBUmhFSFVcclxuICBsVmVjcnNlUjVGNTU5VlBONzdVOW9MNGE1RWJ1WE12dWkrdFo4Q1hiU09sOEV6dUNQVXY3THVQWE5nakQ3c3UydllNOXdUTXZmS0F1XHJcbiAgdWs4L2VZczY3Z0NlR1hNcnJWbXpYa2FOL2t2ZWZ1ZnJHR1A5ZjR5QmhPTWJqSEdFWDM0aVpnSitjT2NaTjk0WitQTzlIWVN5TFhoY1xyXG4gIFdNSkN1OWIybUFld2x3VXdHa0ljT2MrWWh6R1Qwc0M1cTFldlV3OEdESGJFcVl6K2ZWTENjK3hhcUpSWUUrT0JNMERMRmw3OVllRGVcclxuICBxUXY0K0lrS3hTQm85d2s0eml4dmFXbXB1dC9Pc1Rxc1lWSk1yOHVITXVTSUFYTFJKWGRHVWlSdy9DMG5wbHQ5eE5rL3hrNldndzcwXHJcbiAgZWx3SUNITXVZMWpuSG1pZlNIZ1lOczhHRVI4MUI0d0tSc09rVmp3dmpsR1hWTjM4THU2SnhITE1sMEE3ZkFSMFh1Sk1rTWlXTDEralxyXG4gIDZwT0tsU3FxaW94VU9FTnZQRWVtemZUenN6UnFYRmRPUDJXSUduSHozRWZ1ZUlxMkNXTWhCcVhJTVJha2xyUU01b3BKbHB5TkcyWG1cclxuICB1Ri9TNWptQ1BPK2J1NlY2OFRKcGlERi8yUVJaT2Y1aitlUFZxMlhwajQvSWhqOWZsZVFxamFWaWNxRlVhOWxIYW5RK1hOVlJ0VHNkXHJcbiAgSWxXYmRwT2FqaUZVYjkwM3doaFFmWkZBMG0vM2x5cmxVNlI4NDMzVlJUZDM3U0psR09QY1FxSkh6b1U1d0RSUWJhMGYrZkM2M3g0NFxyXG4gIE5HUEZuKy9KcHF3RnFjVWJsOHFTMGEvTDN4OE5sVVZqUHBEaTRrSkpkL2ZQQ0RCNytTSXB5TTlUeHBHYW1pd0ZlWnVscnV2VGJkbzBcclxuICBkOC9oY0VsT1NaSFhucnRGR2pacEtMZTYwZm9ISDMwdlJ4MTFvRXFEZ1A0S29VNUV3Sm56bXRFNzd3azFGVTRnUE9QWlRoSmxvSUx6XHJcbiAgaHRWbEd6ZFozaTlMMVdwVlpOQ2czcEhqNXYxSFA3ZHZQTnpuYlIvdDR4TEs0Q3g4SEhmWmJsM2E2ajY3MS9nMkFNZmlHUTk1Nk9MclxyXG4gIEFkTExvNUxOZEF3V2hzRDlqeHc1d2RYZDFodnFIVWNrWVI2QWE2RENOZWJCdmR0M0VRK2pVMXlmZnNpek1kdUhuYmN6ekNPc3ZxSU5cclxuICB6ck5yY3YvWVo3Z0diVktQSkxVbm4zU1lIdDhUbkhqaU5kTERmWnNubjN5WU9rcmcxbzE2blBMeTVhdmxndysvbHdrVFkyZVBUSEppXHJcbiAgWnBTZC9JTWdqNHlKV3hqQ2JEcEhlMUJraGJXWGRPbmxkOHRUVDl5czVYQ2RuY1d3TzU1ekhldkNoT2RDTUJrRjdHeWJxR01zRjVTMVxyXG4gIHg5cVlSMm50V0VvVm14bU1jd3lKenVFNG5jVGlUMENpK3dkSUdIaFpjUTh3SndoNi9JZEV4K2YrWUVoNGhzVi9iT0g3Z1ZoRG5HblhcclxuICA2bkFjN3ppYnQyRzQyK2FqQ0I4M29OckRIc085dzRRWUZlSHV6UDNoMnN0RVYyVDd4Y2h2RGdqMi9Hd04rSzEybitqTWE3aDc1empiXHJcbiAgcE1BZ3I5R25uLzBrQnczc0xnOC83ZzNjcEt1LytwSVQ1ZWVSRStXV29VOHFZK3ZYcDR2c3QyOG5mUWM0YURCOURFekZtQXZieVNsSlxyXG4gIHN0bEpMV1ZUeTZqaFBvenk2UldsVE1VNmtyTjZnZVRuZWE5QlpzOWswcSswc21uNk8xS1NVeEZhSkNrNVNVZGtNSEx5SHBVa3BVcnVcclxuICB4bXdwbDVIdXBJSkN4N2lZN0N4SlIzR0d6TXBWbmRTM1dwbGNzbXN2TldXTDFpR0lyN0N3UkprRktqcVlIbVc4MWNoK0RHaWxSczJxXHJcbiAgMHFwNUkwbHhIL2Z4UncyUXRoM2FiUE04a1RCeG1PQXN1N0k5WDBBZDI3WXlzRzFnYlRFckpYRUg5dDVBdUU2NFgxWEs3Q25YT0ltU1xyXG4gIGZkUW5JYWVsd0FCNEFab2t3Y1JQMS96N0lWVjFoWEhyN1UvS25jUDhuQ2ZjRDlKSGZCMWdmY1VRdngwR1RqRTJKL211QUZVdGpqZTBcclxuICBUYlpybXhlOU5DQzloTk9wMnoyeHB2ZEJsM1lFM0l4dHdpdzdON3cyd0hoUkt6TmdzL25mZHhla3FML1lEU0xQY2RJUzZZeklHb0kwXHJcbiAgaDlNQTE0SHB0dTF3cEFab2hzSDM5QitCcGdzUFFEcGtRS2MxUWxROVNCa0N3dk9QaCt2c0xHeFVZWjA5Zkg3UG5oMjB6YkFiOGZaQVxyXG4gIHBLckI3c1Urck8zZEc2TStHL2tCNmhvU1RhOEp3c3pEa0toOUFpN3AxS2VjZkxpbW5hZFR4ZWNPNHY3d2FDT2xneUhjRnZkakhsaUxcclxuICBGdnNvYzM0WGFqYkFjWmdIK3lnUERPN2YyZ2ovSHBnSDE4T3d6L0Z3QXNpWnN4WkUzcjI1SFhJdWRWYzdKa01kZTAvTWxXMGZDc3pEXHJcbiAga205Q2RHQWU3RWVGQmZNZ0xvVzZ2ZmZiUno3OGJMaGtyYytXN0t3L1ZFLytxeHNrM1BmUXEzTEF3QjV5NTlCTFpPZ3Q1MHRmeDFSZ1xyXG4gIEhMMTZkNUg2OVdwS0Vpb3YxL3VSVXBnQ21TVXZXSy9QV2lkckYwNlRJc2M4Y0U5ZzJldytva0kzK3MvTzNxQkpCcGN2SmRwNXVXUzVcclxuICB1cXRXcnBKMTY5ZTVEeTFQTmhkc2tHVFhia0ZCZ1NQZVc1MEU0VjJWbVhHejBDMjB2OEl4anhUSFdNbzRKbEZjVk9na2lXSzlkb0ZqXHJcbiAgRkNtT3NaVmpHbWJIUERnbjN4MHJWNzZjbk9Za2pIUE9QRnB0Y2tNRzkzSDdNalRnYy9XNjJGZ04xTVRveHhtTThmN0o1d1o0NWp3L1xyXG4gIHdETW5TdHFrUVh1WEhEL3MwSDY2YlRwdzNvMFJSSHRQOXM3b1AyR0NscFRhUVhMV2o0MjhRNDZIbVFmN09OZmlMN282S1NPUlhZTVJcclxuICBQelRBN3JjMDIwZjQyanZDcmpBUCtyQmRPNXhCWW52TXcrcWpRaWRyQmNEdEY5ZDZ3TDFXcng2bEI5c0RhV1NBL1Q3VEROZzJFZ2N3XHJcbiAgTHpXYnUyTlBzSHJsV2gxc1hIbjVhU3AxNkw3VlB1WU5Kc1czRzNibk5mekhHQWlkTWt4OHJHeHV1K0Y5Y01BdzBGbnVDaXhJaDhBZlxyXG4gIFFHZUhnd0xUajlvSFl0Y3NEZkZFbmJiNENPeCs3YU9LQjhlQnRZOElpS3NybVcvRGswNFp3dlZ0S1Eya1ppRU5PL01EQU9vaXVvZEJcclxuICBlNHlLN1Q3eFRJdUhHVTJQQ2liaVlzUjY1ZFgzYVJsd0xzYzVueksvKzVYWFBnMk9Sbyt6SDJDL01YQU1JSUlETzk4K05DYjVRVkl4XHJcbiAgSnJJK08wZEhlMFlZVUpQWXVVT09HQmg1SHVRN1lrUU5ZNmN1SDVlSjBOWTJvMVdJenJNdmZTdzNEWDBhTVVGR0RIOWQ5KysvZjA5WlxyXG4gIHZHeTFSdHZ1NjVqSlRkZWZyUzZmTEJkZDhDOGwwTTFhTmxKbWd5V0ZaYXU3SU5jZ0pjdG1KNzA2UVVHS2xUbVVxRm9rdjNDejJsNjJcclxuICBsQ1JwcEQzSEVSZ3daRzl4NDQ5Q3h4aVFVaHdyMGJhY2pLSDd0bUM3Q1VCYUZ4Z0hnWll3RGhoS3d3WjExSFkwZHNTcmFxYzQrdWdEXHJcbiAgbkdTVElhZWVkcFF3cDRzOUs5NkJFUmRTM0tCT3hIYkYremQzVm5zMjFuZHh1U1pUTnVwRndQUGxHTkhaQUNtZGJXdVg0MlBHVHRGdFxyXG4gIHptZk5jUVB0ODE3c09pQjhISENmZUVDaXpvMi83ekR3bHNMdGwwU2owSWRFZGVKaHoySnZnUHN5R0FQZVVkc1EwdlhyTjJnOUhGQzRcclxuICBIencydytvdTN1V09nUG9LU1FmZzhRVndYd2E4QTlybEhXR2JzSHZhRzcvN0hpZmw4ZjVxT3VrV3JRVXcyb2RtZ3NtakVnVXEvc2RzXHJcbiAgSUlBUmozV3FuMzRlSTEzY0NDVHN0b3Z1dTJPUWY0bUhaUTkveElnL0l3UnBaNEdFWWNGT1BKam16UnZHdElsS2pZOXNSKzY4R0lwUlxyXG4gIGUrR0d4NGVKYllYNnRHWEVNOXhKd3VEM1FnaTVQaXFuMDkxb1pFY09BWnpUdlhzSDJaQ3pVUm1GWFNNTXJnZHg1VDR3ZHFFdXdvWmdcclxuICArY1VNbkVlSHErWTZCQVFYOVJHL0pYeS9qRjV3Y09CODJxU0xRTWc3ZFd5bHh6RzBreFlmT3dYWFkvVElSMlhlT1B3MkEyMjgvT29uXHJcbiAga2R4akxNYTRLZWZsRmFnMHd1UmhHT1M1djQ4KytrSGpTODQ5NXppMWMvQmNXWmlnaVBZb013VXk4N25UQmxIUGg3cFJNb2I5Q3gzQlxyXG4gIFJ4MUtoNy91MnJPMUxsNW8vUWFlb1ZPaGZ2aitJM3AvcUVDSWlLYk14d2FqUktKQ2JYVG5QUy9xQUFXcHVGclZLdkxHYS9kcXpORHhcclxuICBSL2FYV1hPWHl1b1ZxMVFIakRTQnlvazI5RE55QmNpL3NRQ1NSOXBCamxNa1NPL2lpMDZRL1owa3hIT0VZV0R6eVY3UEJHQjE1VGduXHJcbiAgSlZ4OTVabHkzSEVIUzZ2V1RXWDVzcldPcUdkSi83N2Q1TFdYNzVKSEg3bGV4bzM3VzZiT1hLamVneE1tVEplWFg3eEQrd2o5a2VkQlxyXG4gIG1haHd2UEhvYXl6OFJ2YXo1cGtBNnZJOFdWT1h5Y1JPUGNXclBhd09nRkV4QXFXLzhIMENqbU5jNVh2aWQ5RlBjT3M4K2lpdm5qV21cclxuICB3WE9sZlk2M2JkdGNkZWtHNnJDTlRjRDY1VWtuSGhwSlZtcGdQd1piN2gxWGNqejVhRE1NNnNRVFRlNHgvanRKQktMS2tYeEtnN1ZOXHJcbiAgV3hET3I3OFp1VlB0OG0xWTVuSHFzM0JQM0R0dGxqWlpWVHpvSCthOWlOMkpOZStOS1hoUGRNL0w3Z1V0aHJXOU0vZTNQWkNBOGg3WFxyXG4gIEo1QStVVG1qSFNDTkNhbzA2TitpUlN2a3V1c2ZWaFZ0UFA1akVnZ2d5TTFnbytmd2o1OC9QenFIK0ErT3NSaTJSK0JMQXpuK0RXR0NcclxuICBEeGlaMVEzU2kreE0yNlF1QUpaTkdKc0RVMjF5NzV3ZkRvUU1nNDdJWXRmZ0hwQkU2SlIwaUVTZ1RWUkFQWHQwMVBNczdpUVJhTWRjXHJcbiAgTUtsREFGVThZREJrNTBXUGJSSDA0ZmJNT0lyb0RTQUNCQ3NhdUFlTTVUdzd6dVArQ291S0lpbXh3OCtQNHdmdXY2ODgrL3o3YWdnRlxyXG4gIDRkL082QVl3WVJjMkw4RHpJU2lTRDhHMnJVK3dqMjFHWUVoTFBIOW1XME9sUlIwbUg0S2c0ZVZpZGJISHZQVDhNTzM4TmV2NCtiUk5cclxuICBJbm5pcWJkVnpkS2srY0g2ZTZqUE1SWUdCdXpqT011WkY5d3A3ZHg5SFhiNEFYTGRkZWM1eG5TSnZQdjJRL0xPV3c4NXh2U1lmUFRlXHJcbiAgNC9LZUt3OFpQRURhdEdncWd3L3BMdy9kZjUxYzR4aEMxODV0WFArcUtlWExsWmM3N254ZWwxZGYrMXpWaEsrK2VLZGViOEdjN3pYVlxyXG4gIHkwc3ZmeWgzM3ZXTXZQRENCMUxMUFo4UlA3MFNrUXdISDNhaC9zN1JveWRxaWhuS1o1eDFrOTQzeDNtMlNOUlB1dC9GTVJha05SZ0VcclxuICBkWGdtMkwrb0M3NzU5bGZkUjRiczhIc3BET1U4UWpKbkh6RS9nUG80WlBSd2d4cmEvM3ZxSEIySmhvTjhZYzRjQTBpVWd3YWZ2ODFVXHJcbiAgdE9DZ0EvZlR0ckY5QU56QURYYVBEQVlnWWdacmQzdXdkNzh6NFBzckRmcHNnZ0VlWlFZNjFxNzlodTNCcEJVRHY0bmY2OS9YemtXSlxyXG4gIG13Um8zNlhaalFueUJiUUgvci8yN2dSK3UycmNILzhPb1V3VklVTWR3akZFblJ5RWltYk5NcFJVcEZBVW9ZSG1TVWxKU0pvNW9wUktcclxuICBnNlRoYVRDZGlvNUtTY2lzSHcxS0dVb3EvLzFlOS9kelArdlozZFAzZVI0Ti9ELzM2Mzd0dmRkZTgxNXJYV3RkMTdXdWxmcWFHL2pNXHJcbiAgcDc1WXJyVHNZcXJKQ3RSa3pkNFBxdy9uL0F6Q2ZTWkVCNFd2RzI3M3ZuYXJoVzFRdjVzRThZOXZaMWF1QVdpTTNQRHNvM0hTVFhjUVxyXG4gIDZ2ZmR4anBwdnZqVFlYSkNJZ3dLeHgra2dUQWNWeDlvVlNOcFd4WDQyTm1uMHZYTGpUQ1RmQU1id2lxbzl1Tzk5T3JPaW45ZDEzL3FcclxuICBMLzZ3RnVwOEpkOUIvTlh2OFZJSjVBSnhzTUVGM3QvVk5sb3JwT1JEV082dWRmcjJuaWdEZ3NURWZMZHorejRJaU1ISVArL3J3Y0NxXHJcbiAgSkVCYzZyeEM2c1N1VzNGOXV4M0U1YThHWHYzZnEzT2lQUk9XazB2ZGRmYzlMVUhadHJoMzQxVzMxN1VEbWJaWjVBQnR2bEpXNzZ5ZVxyXG4gIHFETG5HeVF2dE9hd2RsSS9xV01iQURkdFY3ZnN5K1hnTUdWVTNrSDFsM3J3cmd1cndRemdxYmVrSjU1dXYzejlHOTlYMklnSUhKaUlcclxuICBFQ1RYZlVRWVpZUzcyNVdMay9UcU9BRFJSbGpId2VtZ2FUTkJ5am9Pby94MTMrVTVkVEFxL253ZmZuQWFUSTZaRXdwTThoRHljY0MrXHJcbiAgeXU3emZMZWdUZ1A3aXVMTDNNTDg4LzFYYzBmYmpxKzYvSlRtcVU5N1VobEh0R05qencwMy9LSDVXTHZLUDZDdDkwRzRUMWNnNlNUZFxyXG4gICs2ajkxVzVwY0lIS213NTZjVjNhUHdVc0E0VDRzL3BJbkVsekdCTHVjLzl6U3I4emdjRXV1MXN0NlFjaFJoWEZZUStNS3d4clVIbXZcclxuICBvZmpyTEZoSVpnU0RJRzZiL1hSS2pUM2hhMUFISnN6MHpzQ3IzSFdaRThZMTl3aE9qc3dFZVRHZ3BmeUloK2RBdU80M3F0UHhIdkd3XHJcbiAgUEU3akYwYzZxUGNQYTJlLzBuRWVCTHhoL2ZlWEZkaFh6N2l3dUVjNC82NHROMmorMys5dUtLdVJRUjJjbTkzdTRlVUczUDJ4WnJMeVxyXG4gIFFEeklwcVJwRUh2SzAxY29mdVJkV1E4OVpOY3kyUDM5anN2N1lmSy84L2JMN3ZWOHgxKyszMXowbmVPSytYSVFqd0UwSzV1VTdjakRcclxuICA5aWdDNXd5a0tRY1F1cXNQZlNEdThvSjRLT2ZOdDl4YStreStoVDBXMHRsK08rZko5K0x5THVXUWZ1b24xenE5d0k3eUx2SHd2YjUvXHJcbiAgMlkvS2ZVMElnSit2bkhwZTgvMTJoZUk3ZTdiUnJQc3RRaUQ5c1RlcGhYY1JRVG0rZjkwMnU1aGQ0akVkMU5xSXNQenl3dzBmU2wrNVxyXG4gIGNvL05GdzNNWUJMaVVTTnh1dGJQeVJQV0srVDluT0wybG5pc3Rzb3Jtb2UzRXp4YW5iZ1dwNTdXNDJaUVpqanlxSjdwOW50am52dVdcclxuICBnSUFHSGNSMmpnNFQ1TDBLcXh0U09zdDBJQzREb1VFODhYR2pJdWNvVGp0b0lRMWdGSVNqdzUxNC9BM3Fac05ZV3ZWZ1d5T05qLzhNXHJcbiAgZU9MUTBPcnlkZUVkdjY3NG5ZaFZGM1crMVU5WU9kMTR0OXhpZzc2N01JTTZIRGV5ZzRUZFlidk55a290UjNPQ2dhRCtQdEpjY1dwQVxyXG4gIEJISGtQWGp2T2RvaXdwQ0o0Sys3OTZmb1VPZk52Y0VZeUtqc0h6SkFjY2MyazRiN3JrbHZnelBVWmVQUG4ybUcydjJ4ajNsVS94MmNcclxuICBkKzdSSmMzTHZuZGlzMFdiSHdUYkNpVkVKZitIUFdMSk1vZ08rL05EamRYMTZmK3hjZ212L05oTVdGTWhOT3JSVEYvNjNXK0ZvR0F4XHJcbiAgZVdlZ1NCMnFHek5EN2dzdCtMZytpNGlxdFRpVXorWlpTRjl4dGVvTklSSUh2MWhaTlJBSnAxaUdiVkxueVlURGUvdEJzTWZFQVdiTFxyXG4gIGlKanlKRDNJZTVDbXVyUjN3YjIvc2xDZzZJSnFORnRQMkhVaHNqV0VoYTYySWFPaWswRDR1ZzNVNkw3TDZpSHVLMHh0d2h5RURLQUpcclxuICBIMDFDb0hvK0hXVDEwVVZrVlVGWWdITURkcDhqUjY5NHhYLzFOVk5wajVGUFdlbFEzeCt1c1RyUGZjdkNnczNmc1ZzUkJFSStVQVlQXHJcbiAgcU8vckQ0c1haNkNlam9GRkt4QWFXWTY2cEwwalBvMWQvS3p0RW82S3N6NHNaUmlTTDFmOFlab1dlZFlwRXU4bzhJdmxFb0UrSURDWlxyXG4gIFVkUkllb0hCOHdYdERIeFVHb2t6cVAxNnB5TVQwRVZ1SXQrcFgrREhVblg3ZHBhSHdPbEk4ejM2eGMzdGY1NTVUam8vbDN6M3l2NUpcclxuICBrMVloVkVaanJOTDcxRWZnR1pKVzhwbjg1VG41WWZxQ1lLL1d1NmZBUUFaU2Z5OWFYd1N0dmlzMjVmVUc1WmFRMCtJVEQzZXc1eWhHXHJcbiAgK0pJSDc0U3ROY2NDYmFVMjVXQVRtazZVY2d4RHlxeDlxT2NnZFFJL3ZmYlh6YlBiNzg5djZrazk4R04zOTdZZmVHc1JOSDlndS8yYlxyXG4gIGRhY0diQVArbythZnJ4OUgwcUZKUmNFZzlWZkQzaHZ0REVzcGFXUnZEWFRydm43dXBnUGNVbmVJaDRFRjhiZWF0MWVBM09PV20yYktcclxuICBMYnZ4aUgvM1BROXA5dHg5cStJV3JMM3VWczEyN2ZlaExwdStmZlk1MzdrWFljaTNKRGdtRTNNdWh0WHBwQkErK2U4aTN3Rzd4b1F3XHJcbiAgR0JVR0NKcHJrK2VCOXJ2TmV6ZWV5dk5rZXo5TUVnZHBad2JKaTgzTXlwN3hhMDRSOXRWNTV4eFYyT0RhdmI3blc1RHBISG4wU1lWRlxyXG4gIE9nejNxUllXTFBDNDNnNXhNR3k2OTlmZ1hNMnlNa0RrUGN3Ly95UExIb0E4VHdKYUQ0akljOXVCd3NBdFBnMVpXbW1zWmxlVElPbWVcclxuICBkLzRsUlZzb2ViYUtXcXBkNVlqWFNtb1FNUUFmQTVzTCswUTRvSEdSWTJLN29NbmlUNXZHNm9PVzBOWHRjcEwyVWhmaW81V2pRd2tEXHJcbiAgR1JBQytUV28zUHlIbm9WYUxDMm51c1gwQzdnK3RSMzRkQ2phT0lnSW9maG1tKzlTTkVIaVIrTUZhZEF1WXFDUytSTHYvTldBT09wNFxyXG4gIGFRZVIxUkJTZXZhZG1ZZTRjMG9ta2dGS1dUYllZUFhTb1JFRWJKWEZuN042ODhIdE4yc2UwODd1Q2ZUNXNUSml0REVEQ3lKaGY4eWJcclxuICBObmhOYzhQMWZ5aW1NTVFoVGpOQmVYTFB2enI2NHgvL1ZJZ2VQNzZMa3l3UktMTXVMQzFwNVAvMWRoWEVQUkFtWmMzL3BuYUNZNVorXHJcbiAgd29sbkY3WXBoUVpuZjB1WEJkTmJiKzJGWDJuRmw1WDJxTzY4MjdmTkc2VUZxK0ZYdm1LcFl0K00reGJ2WEw4WW43U25nT0JYL1NHbVxyXG4gIFdFemFoRFROVEswU0h6TFY1bExuZTdWRWRQMDNybGEwR3BXWm0zS0VDSGxPKzRLMEZXdy9wa3RBR1lOOEd4RFA1dS9jdmRteUpSN09cclxuICAxL0h1VzkvNWZ2UGh2ZDVUNGcyZThlelhsTldVZUtUei9tMzNMeXVobU1nSVRNUzBMZWZWQk05YXZHZExySVlTcWdQZkRSanJyUE00XHJcbiAgQ3VNSVFmSjl6QmUrMnU5ZldIRXJUMWxlR0laNmtsSGo3TGE5S1BNMjc5MmsxTmNrK2Z6c1ozdFd0bVAwVVRqNWtuZmhFdytPQ21nblxyXG4gIGRYM1BMblpwaWZveTdXVFE2WTNHRCtNWE5XdjdoQnpuUVA1eFo3VVhEcHU1cDg1cjdmV1ArNTZBS0hRcXA3N1hLVlFRNGpIb1BZeFRcclxuICB1UjBFOFc3MDVqVUw2eVF6ZnpPMyt2US8ya24xaHFGUmlBMGFTMVdhTmxSSzVVOG5IeVhZTWtnUVVGR1JCZVhRZWRLUlU4YkFNM2VkXHJcbiAgeXlyRjgxLy9jdnRRdjN0TnFha0dnK0pkdkNXYVZIYVpkREdRMjRkaEZsWDdjWjg2SitRMVMvOUZHNDg2U2tmd2psb3Q0Z0hjenp6clxyXG4gIFcwWFlUSHZNZTNuQjRvaGRMRzdSbW5Mdk95TWVCcUJUVGp1LzJiQWRHT1hYYy96NGY2R2RjUm1JRER3R0lHbDVyMTVDUEVJWWFKQmdcclxuICAxeUhxMUpDcFZlS3BteUh2dEdOdkk1bXlHWVIyYUFrU0ZYSUROT0tCb0pLdGlOL2ZaRUIrM05mRUE3Qmxhdm1LM2UvaWdLZE5UUWl1XHJcbiAgK2ZFdld3SzNTdUg1TTUrZWZQLzlycnRMWGJwWEI0VGVzRmc3QVFoUnNhclRibGRkK1JYRkNzS1QybG14OHRvdG5MTG4reUllL0N0UFxyXG4gIE5vQ1o0SFFIZmM4VUFsaVpWWmMyaHFuZjlDZjFaeFZuODVpOEJvVDlPVHlLeVppWHZmTE56UVhuSHQxc3RORmFKWDI3NGJVaGVRcXdcclxuICA4NmdoZTUvdmFLVVhXMXFRTnVZS3lydmU2N2RwUGpTQXZTVnY0cyszU1IwTUF6TXNhWnRnc0ZVbmcyQmNNSk9YeG5iYjltUklVRnU0XHJcbiAgSGdWbHJ3a0piZ2NEb2RUUWpSR1RtRml2aGVkUmtzaDRxSDVTYnJBeFdIdk8remtCOXRVRmJSOTkzWHFybEQwZnZlLzB5eUtqY3U3NVxyXG4gIGNjZC9yYWlPMS9zL1p0NzdDbys0N3drSTFJWFB2ZXdvUU8zV3ZZZjRtUlNKTjhzOThXRlJBRllPVFI2RHV6VFltSWtaNTJId1FYVU1cclxuICBOcDV5TG9MR3Q4YnF5NVZaZFRwR0YrSzM2dkV1NzhVRHc0aWk5L1UvY045TlEveTFIeGdVYi9abFlHZGwwS09tOTRMbnp4VDBpUXVCXHJcbiAgY01VNnRHZkE3Sy8rUmpSdjRnZWN6MHhZbndZZmYyZWQ4NTMrakpKYmwwRHdmL0FuZHl6bUdLU1IrSHduN3d5Q1ZpN09RRUNnWHZMeVxyXG4gIERRdFI0aS8vVHg5eVhOa291ZTY2SzVadllRa3VIT0lodmFjK3RYZXdHTm1FcTNjR2lKeHpMMTE4ZWVsSmw4d3NkU21QNnRGbXk2Um5cclxuICBOWmo4K3lPeWVlZXZmR1FIQmk1eHl4OGlBTXloM0hqVEg4dmtZWkYyd0E3UlNMMTRaam5YYWtCYzdCRVo3TDBMNFpESHhkczZqYjBxXHJcbiAgNWRuM0kwZVVleXVoMWR1MktLenk4Qzl1TzZLcGM5Tjh3OGF5RWRXK0pDQjc4SjNKbGF5bUE4UWpOcGFzT3AveTlCV2J1KzY0dk04NlxyXG4gIHNncXcya0s4QXZXZmVrbVo1RGZFTEhqOSt1OHY4aWI1NU5kMXdRVWUwN2RTRVNoRGwxaUlqLzlCWUxJRUQ3OStQNHg0VUtWZmJ0a1hcclxuICBsM3ZwREl0ekZOanllc1hMbDVwNm1sWGduZzJCazBBZHFEdjFsQ3VOcnE1WkZCcDZlVCtuV0xWZHBWUDkyYjRsbkxnTk5LL1l6N01pXHJcbiAgWjBHQ3FyMzJXOFAzN0FFaGVmVDlRMEJrUW9YVjk0OTczS1A3N0pUNnZWbGxCamR1UG5UZVRZSnVtRHB1eENQdi9POXVaNGQ1Tnd3YVxyXG4gIEx6OFpuSDFNRFUrbkVoY01pNE5mZnVSQnh4YUhSa0sxMTNNM25PZjRjNjB4S0kzYXI2djA2dkpDNHF6TkVpQWdYWDltY0NlMHN5SG1cclxuICAzc0U3TTkyWVZRQit1S1hqOGZPSVJ6NmlORHh1bnVkdEIwQURpWHVEMi9PZnQzaC9ZT0hHSHhhZGhvcHZUTUdCdTNwS0ozbFN1MkxpXHJcbiAgNzh3enYxbFdJYis5N29ibXhVcy9yN0Ntc0twZTlwSVhGdUpCVFptTXdReFEyYkgxUG5IUWgwcFlzMmY3TEpJdnhFUmNrQUVxQTFQWlxyXG4gIFhYNzdIZVZlUFJva1RUYXNxRTVyVjB2eTF2MWJnZnFXcVh1emZDd2o1VUk4TG03YnRycjB6bTUzNVZkMzZwQ2J0R0wyWktHRkZpanVcclxuICA2b21NSVlURGZnekVRWHJTb3RXbUxBaU1nVmZaYzV5Qjhuc25EaXEyTVV1QlJRa2hIdUt5bVJUQlc2QmRFV0dmbU9VS2w1VUhVQ0M0XHJcbiAgNSs5WGxra1NpQjhyam1weHdBM1VmNzd0SU9JQjl0MGdXc3AxWGZzOWZhdEJ4Q1B0V0Z5ZTB6WTgxK0NIdThIUE8vN0c0WngyY3NNdlxyXG4gIFl2NjZLVHQ4MDRFMG1kZ0I3YXVXbjB3SHlTc1pESTB0N2Nha0p4c1RLZWhrazYzOG1nQmtUOVhzUWx4SHQ5OUcrNklrc05wcXJ5emZcclxuICB3WjQzeWtMWVdJeEsxZ3BPVnJ1OUo2M1hoUHhoOXc4QlNTTnd6YjJCNHpPSEhWODJHOVh2VmFhQndUM01EaHNMRDlvQWI2QXlRMGpjXHJcbiAgb0lIcm9OekVXNzhiQkRhVnhHWHpJS3F0S3BPZkRCNjBoZ2FkZys3anAzRW5qZXdMR1ZZbS9uVG1oRXNhZy9McE9lV0loVTcrQi9uYlxyXG4gICtyMzdGcDU3bnFIMjYrcjBTRmZ4dWVLclAvSlJMMjUybjFLNTVGYXpDckFGZFVZcnJXT1BQYU9mWjNXa0RJZ0hHRlFkVkZVMGJxYjhcclxuICB1SklaWUxGWkpUbE1pdHdJUDFtWi9BMUUvQzYvM0l1TDhGSVlSTUE3aElTSjdoQVBxQzJxVWtjVVhobTFoMmUyOFdBOWhhMzJ6R2UvXHJcbiAgcHNRbG4rUVVHN1oxSnkycm53eW80YjlMOTViMjNnQnUxbTRqcFBpVlN4aHBNTnZQT2pHLzR0Y1JEejNzaEQ1aDBLYmY4SVpWeXlvV1xyXG4gIFcvUG1tMjhyK3dkWVBFMmJFcGJNN1U5dFBxVng1dGUvVmQ1WlBZVDFZdUExZUduRGthL2xPNmJkWUpWRmt5YmZFdmhGeEJaLzVxSkZcclxuICBGc2dBSkRrWlFwVkJYNzRmK3ZBWE5UZisvbHRsZGhwTk1DYjQ2NDJBcVhNeXZUUE91TERrTTNLUUdzbWYxUkJJbDduM3QxVVRrMERmXHJcbiAgcE9wOVcwdlFiMndKWU1yajM0WFZ0TlVUQWt0WklQSzJZWkRmbExHN0czNVNLSXVUQjFrSjhHMEg1V3M2aUxvdjRoSElwellOaVg5T1xyXG4gIGlRY1lSeDNveFNveEdZY3lYSDdGTmUyS1o5bHl0YkthNWVDb2xuZ2dhRDNiZ0NZUkNNaEQrbHBvOXprT2JwZjFnZVVTSUJhQnhnSWFcclxuICArLzZkWGVYVGhVMkRsdURaUzBIYkFEU0FmSlNrTnc3WnFVdklGQmdJdWNtYnEzMEx3MkFqbEViQlg4S0ErMkdReDd4UEdpR0V3K0FJXHJcbiAgMDd6WHlMdWdhZFV0TTFQek5YUXdmc1RqVHh2cC9IT1BManp1UUg3c1RnYURxUE9qclJyVlR3WVZmbWpzaU10ZmVXZ1lnZWZhSDltRlxyXG4gIGIyNDJSbUNZVHA1cklFekNlVWVkRkpaWThyWGwyUjl2bVpBNXoyYnQwc05hOHZ6ZTkyeGN3dGhYUVRoTnRpRnZCUGNtR3h0c3VGMnpcclxuICB5YVk3OWZOY3R4WGFZTUNxZ1gwRDNqSHY4b2xQZmJHOFArbmtjL3ZmR2Fnazg2TnNXZW13UTZWT3NlOW9tU20vZkVIQ09oQktmQVoxXHJcbiAgWUhiRkxKdS9LRE1rVE5RNytZZmtON3VMeFEvaXhiYkNYalRBRzZSalROT01OUEh4aDNoWWVXRDUvZUlYMTVWOGtXWGtZRGhJR2FVWFxyXG4gIERiTXp6dnhHVVYydXdWL3lFRmFQUWY3Q0RwRUJmcG1sUWFCcCtRbFhiODdyZ21ZU1A5b2crTGF4ZGpFZGhNVTdEdXBCUFpHUDVYNTJcclxuICBFSXNNR1p1d1gwR2NVQnVqaExqUEtmYlorOUF5K0d1ek5xRlM4a0FnVEJDc1BpS3JEWHJFZ3dxMXFRSEdWMitzdnQ4SVNDeE9nc0VPXHJcbiAgMHVDaHZuZDhhcUNScE1GT0J4L2QvM1A5c0pseDZERGN6RjVpZE03enBFZytkT1RFTGM1UmpjbEdLTy81VHhpbzc3dmdudmU1SDNhQVxyXG4gIHZuY09hWExGbTNmTjBiTTF1SGRoUldMQXJTR3ZNNlpNdVNRTUkzYzFFYUhOcE54WUVtYmhTN3pnMmNXU0wxVldCQk9zeU9wNllaZkxcclxuICBjL0tWcXpSaWhWY2JDUEhUY2VJbkhkYmZmVHFWNTZ1dU9MWGNnK1UyWWdIOEhQenBZL3ZoNHNhaU1lMCttL0dpT21vUXNwUzN5bGxvXHJcbiAgd2NjMkwzM3BDOHRwZkNFd2cvN3lUV0FlR1lJQmwrbHJiTHRBdWxSUWFWeXByM3pMT2orMUd6Lys0cy9rS3ZJNy92amgxNzAvMXBzNlxyXG4gIHI4MkkySjBPL0FFVE13eDZFbXEvcGkydmNNRE1TOG9CM0ZkZTdSM05CVk5FZ0lMSXNjZjFWcFU1M2dBUXdMQXhoVTM0UjdjRGYrNkRcclxuICB3NDdvbmVYTnZkNE1OMGh6a2FBWTZ5WmxBNFI2SE1TdFhvUTU2dWlaaGo5cnNCbFhuNThSQWlzdmsycGxBdi81ZG9HVno2UXd3Y2tSXHJcbiAgRm9UdlFBVzRCcll1bUZETkxYeTRUZGZVWTlOTjEydisxQklPaWdBT2hqUEpvVkdaTTFOcS9LVmR3ZmEwc2ZRcXJEWHZIM24vc0xBQVxyXG4gIEwxYWpSTm1pQ2VUdnczZnZYN2pFYzVxcnAwNitnOWxoWS8zakh1ZWpQNlUvKy9QeFhjVnBpVzlsRWJkY2h5SDVzQlNYajdBTS9JVXpcclxuICBnQnVzaHNVaGZsMUdPQkNIc3Rwd2hoK2QrQVBQM2lldGhJT2tYVU5INDI2bEpiNG5QSDdCdmxaUjdWZisxRWZ0aGpESlcrMW1CZWNzXHJcbiAgWkEwTTJ3YnZHOHhpbzFtVHVBamNZNjRFb2NiU3F1UGpML2ZLaE9Cd00xQmk2K0RGZTgvTllJc1ZaQ2UwanNwZDNTV3NQM2QrdVh0MlxyXG4gIDc0cDk0dDZmc04vcGVYbWYrcGUyODFxNEVWWlRvU1NIczQvRGFzWG1LdVdqemtrMlFCbEFIckF1YXhtU2VxWm1ubnpUckxxcjdXenFcclxuICBDL3VGYXV4ODdYdXNNTi9RN0pzLzMwT2R5UXQzVi9XUSttTG1oTWJnRzkrNFdsK1YxenZzS3UrVkoyMkJ3SnNoVWtSRU96S3BRZEFZXHJcbiAgTU9RWG1CaEJPRkxITlhiWWZ2TytHNkovMmVVL0txcTU4Z1hxakVBM2lpUEJ4bS81WUZuRkpLdzhLVU4zWUJXZW5PRnJYL3RHeVVmS1xyXG4gIHJCNXFwRXpxbmgvOWtySUFmMTIvb0EyYXhlZmJnclRrNTYxdjdjbDV1cUJ0UnJHQmYzNXBVa0lkeHlnSUV5TGxuN0p5MzJEOTFjdDNcclxuICBSZ0RIUVZoMWtQaTYxOEN6MVdyWGZYYXh3aXFibHpYRXN4Wjdhdk9NWno2dFRKQVFEcks2WC83cXVuYkNlV0U1WjZlR0NVeVBmZVdyXHJcbiAgSUNEV0hnKzkvd2lJRCt5SVJLcWw3bFdtYXdaNHlQM0NDeS9ZbDQ4RWFiQ1RJbnRDWElWTkF3NlNmdDZOaXo4ZjN4VXYzWUFpak9lWVxyXG4gIDNoZ0daZUkzblY5bmRRNjR3ZDVNZlJCUE5uRkxNK0VDejNWK0U3ZS9KVGJpZ1VnYTJMdCs1WVdsVFVRQ0ljZERKaVA0ZlR0N3J2MDVcclxuICBzR2F4WjY3U0hIWGtYaVVPRm9PdDNPUXAzOHUxUzVBTWRwdHN1bU96K0RObU5XM05MQXd0SHJOeDlwSElCckF5ZFQ2V2tzVmwrVzRGXHJcbiAgWXVDVXpyYmJIMUFJbExyMURLNyszSklQNmRodHJqeUU2OW1KVHhOcHc0MTJLSUxtREhKV0c1ODU5RXZGcjhQRHhCSERoWVRlNHNKV1xyXG4gIElKOVI3cStkK2MzbS9QTXZLWG5Lbi9hWjhLbHpCRWc0ZjNHSVM3bXNSazZja25GNHgrLzFOOXhjQktUS21RR1Z1M3BrTzR3LzJtTHFcclxuICAwVHZQeXN1UGRIUG9Gb0YzNnI0TXZDM3hTUHZtM3pzcnU2eCsrQXZxZnFDZXJMNmNHRW5iemVyL2tNOThxV2duZG9tSFZXZ3Q0NURPXHJcbiAgSU9JQjNsSEFNRmdweHlGdG5hKzZ5c3orSE1pbk9rMVp5WGhHOVVmRXV3aVlxNGxQd2c1RFBSRExGLy9UR1p5RjhlYy80ZVB1Ty8vM1xyXG4gIGdMMWFYZFNxdTRralY1TUE3VHlJdTlXZTgyL21GRmFNVDE1NG9XYU5kbkxrcUdPbWtJd1JqM2prdzhzbXpnc3YvTjRzcXJ0a1k0eXhcclxuICA5b2hHVmlBOXJkYjdqWVVGdGZWS0RRL3lNYUMrWDNQMTNpd0JOUGp1K1JlVFFCckNtczI1K2pCVS91cDMzT29PTlF6eGkwM0J4RVBrXHJcbiAgS3R3MUxQRnFsTU1nYkJDejJNSTZveUhXZndjQmk0bS9Pby8xZlJDM1hNT3pUejNYWVBiOGpIWm1TQWhMazhUZ0MzVWU0YTkvdXJSZlxyXG4gIEpvMU9PYzFVNm5LbUUycWswaGJIaC9kOFQzbXUyVjV2YTVmUDNtT1B4ZFNNc0xWMVlZZzdyTk1PN082VFh0eUJXNTBQUWw2b1dRSUdcclxuICAzVGUrWWRXeTRUQjQ5OVo3OXp1dHEvUm9ZREVMSWo3NXNJSndYb202d3l2bXIvNWJLV0J2cFc2VGw0U0hKN1FEZlgxb0duZitzUXBpXHJcbiAgNWJuMmJ6Q0VsTitLSXUrdFNzQm1UekF3ZXljdmpEc0s0dy9jc2F4Z243MjNLVmYrcEsxTThRY2YydW1nNG00bmYxUmZLUmxZc2RUK1xyXG4gIElNUkRmdkpuUWJ2K0pvRTgwUFNKUDg4SGZIUzdxYmN6NFIzMm0yOFhXYUgrTUE1WVlDblRKREJCUXhTbFYyT1M4UEtVTWc2Nng4YWRcclxuICBEaEt1anNzRUp0YXVhL2ZZT3BzVDdOUEdwMjB0OHRRbkZ1dm9KdFJrZnE5dEoxcVVadXloNmhvTlJjUm5JdXdyckw2LzNYOHJFS2huXHJcbiAgRnJuMzkyRkgzUU5CWXU0bnhiTHRESXFRaUpaVTRzVHZFKzg2NjZ4UTJHazMzM3hyV1FYVWFRMkQ5OWdVWmgyME1Gb3lYdHlFUGUzMFxyXG4gIEM4cUhsODlCUEY3K0RHaGcxc1dIWjJ3OXkvZEI2WHVPdW5EQ2doM0xpT0lnL3pwZzNhaVRidGV2OUduVmlEc3dhTlQ1VUhkbUl3U2tcclxuICBWUDNFWStaTGpaVFFXU2NHL3Ewc21VMG5vQVB2ekg2ZjlaOXJ6S0pxNlpwdm44NGlUYk5RcXljc0NuN3lwM0ZFZGRROTRYTUlXZkxOXHJcbiAgSGJLSks4K0pFOHRLblN6enNpV2JOMis4UXhrRWxRTUxDdVFEeTB2blduM0s2QitXcEwrNEZoMnk0UlFMVEZqQ2J2c0NNb3MyS0NrZlxyXG4gIERhcG8rOWxCVDhoT0VLMU9zYnRBR0hHRUFMam5YL3VnbkdDVndvMEdvT3RxYmY2OFcyQ0J4L1REeGNJQ3RvN1Z6cDEvLzN1WnRYcGZcclxuICB0eGw1b2ZrSUNPYXFyM2xIYzJ5NzByRUJNSkIzTnJKcVZWMzVVVDhoSG1CbFpTTHcwWTk4b0R3SDNuZmJtanptZTNkQmpSbEIxUTZwXHJcbiAgT2lOYyt1Y2d2eFFHdEx2TXl2bVJIaTVEdm5rWEpoUGl4RUp6Zmt6QzhPOWFxNmdQQTMvcXkvazFDUnQzNnQ0NWdYQVVScTArQXVaclxyXG4gIFBHTTVkdFdiNXdTcnJMeFpXVU84ZjV1M2xNMkR4cWJmWDM5VFdlMS85V3NYbHRWSGJXSGFTdGJrRTVlZ3QvcXdXZHA3Smx6K2N2OFNcclxuICBrSHhBMS9yK2MyM25qd0V6SFNRVlc5L1gvaWRGVHdYeHNNSWJUVmhYMEptc2F0WmYvelhGclR0NERnTS9URWF3MTI4WnFNR2I0YXc2XHJcbiAgSmFDMElhemU5VjVEM0RxWXpwek9IVGFUOUFjaCtjMEFnM1VTbVVPM3N3WTZaT0pIZ0xCa3VuN2RHOEJkRTNmU3F2MVMwN1MzNDVoMlxyXG4gIDhLWXhwVTRSWnJNWHM4WUlKelZPQTd2QkJwVFJUSVlLcnJqWTlFa1prN1o5RExHRTZqc2pIaUFmL3R4cVhYdnBjeE1XaExQeTh3MnlcclxuICBFU3FERlgvK0Jsc0RxeFZqOW5xa2JrQityU2oyMi9mOWZYY3JCNFArdU5rd09RbDFXMW9zNHJWQ3NLSmk1ZFRnaUQzZ2ZBZkVDQ0V5XHJcbiAgT09Bcnk1KzZFTWE5c21aU0FRZ0w0c0ZZSmswazdvVXd0WjMvaGh0dm1VWE9rYkRVZ1cyT1pIVWdJRkNuSWxxM3JYUGJRZmg1UzZ4VFxyXG4gIENQMUJCMzZ3dENXQ2VPWlFXQWZvRWc4cnlTOGZmMkF4dzZOK1RMcit0MjMvKys3enZpbGZQZkJMd3dlYms2WVZLeEQ1enRwQ0RXN0tcclxuICBUcllrenZ4cFVhVmNYVkRDRUdiR2pJdUtlWTJ3dWpiWTREWDlUY00xNUllSkhMQ0IwNG9ReEFIZTUzNFlyTkpwRTlvMEs4L2FHK0FZXHJcbiAgV0ZIL3ZlMkxnOVQzdTVDV2I1QTRjQldFRCtxNDV5YnhzUFA4dkhhMXp5VE83MzkzUS90TkZpdkVnM3E5ZytCTWhLKzZ1c2NCQ095ZFxyXG4gIHV2VzJ2MHc5bVdTcFpmSWRMSzM3ZVFVQ0RIWGx3eDMzcFROTG82TnpUS1pnYVo4QkFPcDdxQW5LcE9qRjhaVFNRTVVsRGczYWZvek1cclxuICBkaklUck5NYUJuNE1PRFE3YUVxSTE0Qk5JR3cyeFY2UkJqTXNMdTdlRzNqKytNYy9sL0tuQTRVZzFlQS83LzFweExnRzNYVHcwYzNrXHJcbiAgYVdUeEZ6VkJJRXlzTzV1NjVNZUtoZkFiTkhRRHVRNUtqZ0xTWU5Qc2ZEdWhXMExCN0FFM3BrSFVaejJUYzArNDY1QWpxelYxUzBQSlxyXG4gIFFJMzloZjBIMHJZNnlEZldpV3pHczFGTC9ZQ3IyWGZNeVFSTWcwaG4zZlhlMDY0NjNsTENNbC9ENktPNERFd3NBaHRvRUJqZkd5RktcclxuICAyeUhYZU5TajUyc2VQblhjTVhmaDFBVzFXV1p1eUlRczlWbkN4Ui9HYzFlV3RCVXovVk5PT2E5c2tQTU10QXVsZFhOYm54UUNxR29pXHJcbiAgR0ZpRUlSaEpTOW02UklPN2V0Y0dQRk1teUh0elFidmp3eE1Ybmt6SlRuUHRacDhQYjFPSXRQU1ZRNTZaV2FtSkI0T041RTFXSGZ3aFxyXG4gIGFQQ09MZmNvNXRWcnYvWUZlSytlblRZSTRqM2lxQlBMWnMwYXlrSDJGTmFrTmlaLy9FdW5objVPOXFSYzNvTXc2WmRkSkI1LzlTTmNcclxuICBoT3llQnhFUDhFNjc0QTlSOTF5RCt6alUrMTVxSW1RMURwTVFqLzMyTzdMWmVlZWVjVVZsa2E1dmJDSVd4RDFJdnVjVXJCeGJSenl1XHJcbiAgSmY2cnZXYlpJdGM2NE9QL1U3UXYyYjNTcG51eWpwa2d6K3NwaktocC9jT1Y2UllxdlhmZi93UkVkblJ3QTUyOUF4RW1NdUxGSm9zUFxyXG4gIHJVSmQ2L3VFN1RhRWNlZ0owMmV1TU5KSWFXVzROOEQ4MTFMUDY2ZFRwemNNL0ppNWlWUER4bGF4N0VzYU1Dd083dzJVejM3MmY1U0dcclxuICA1SG5oaFJjcUc3K1dhdk14Q09MeVQwZXFZVWUvV1dFTmRTdmVDTkxOWWhFN003eDB4TUM5Z1NpMmdMeEhCQTBnZFNQbWp3RFhiRnU5XHJcbiAgOGNlYTZNb3JMVk0wb05wMk5lV3pwME9PYlhWVE8xdE92QWpQMmkzeDROZDNUTnppMVdFY24wbHpqbnZxRUtJVXdLeUptU0F3UjhFc1xyXG4gIGhiRDhha2QzM1A2My9pQ3NBN2huYjhvbXZEKzIzMGQrZjl4T0doelZTOHNwZ20vcHVRSS8yb002TTFqRW1LZVp2MnYra0hQN2JUQzBcclxuICBVc2xnRWo5V29lSlc5NTdsMHlESk9HUk90RXgrdFp2a0EvRmdwTkYrRUxQdVAvKzVkODU5ekdRa0huNVo4MzNySnV1VURZcFlmZHk4XHJcbiAgVzZDTkkzMHBZU2cyM0hQM1BZV1ZrenEycXBHSDQ3NjRmOTh2K0I3cWdEL3dqbi83U0Q3OXFaMkxXMENCeEtyRmUva0VFeEFiQi9OY1xyXG4gIGc1Vms4WHIzdENsYmNXbVRkUjRDNzBBYmpXRk9hWTFpWFVGMldQT3ZUdmlkWkdEZXUvVXpLTjhoSHRQRkpaZGNXZGh6MHM0cW95WWVcclxuICB0WHVnZk9QeU9RNVl6RGc3aG43dHd4SEszMjVYamxUVnNkNU1EaGhycldGUHp3K3YvbGw3RitHNXpaLzZyM3Vya29mZXYwSjA4SEZvXHJcbiAgQVlHbHM5a0VyTmZPcmdKODJPRHdxYU5TUVZpVk8zMFlzbVlLelh5MDk3Nm5aN2JCa2h2eWJoSVltT3U4R09UeWJKWS9LcC9lR1JTOFxyXG4gIDkvZnM0Q1NEVk53R0llNzgxekRJRFFKL0xNUzZJdGpCb0hMVzluZEFXZ1lGOVZRREcwaGpKMUExdUVVQWJsTWZ0enJ2dEx3TXN2WVdcclxuICBnSENsRTdjelhkY2N0d3ZlWVNHNUpzMjZVNW5aVXJkbDk2aCs3NCtYbS9NVHpCaVY3Ny8vdThjR2NFK2J6TlZNM2VEdE9GY0VTVHlwXHJcbiAgNzl5ckszR3lqSnQ3MTBIL3BFL3VncDBaOThTcFhST011aWV2Q3NpdjVNZUpoNG0vQnYrcEcrWEplKzRwdS9EMDlLTVJoWjBJM01VWlxyXG4gIGsvaXd4NTZIRkRZVXhZYXQzNzFoNlFuaTR0ZDM0TC9HK3o2d1gvOWRZTExGN1NNZHRoWGJZd1RBNHF2TGJwTm10MXpBdjNpcEhTdUxcclxuICBEYm54TjhpL1ZYN1J1bXJmWVYvTyt1MTd1N1c3aUo5b245V2dJbXhsT0FxR3lrRXdJWm91eUQ2MjdSeUlOUTd5My8wbXM0TW81cGprXHJcbiAgWGRUMkhVSnpaWGozbG04cWNpVG0rV3RZU2ROK25RbVRVcXNUQklRUVhjMDhBRllnUUNBV3RrZFdGWmxadU9vNHVjZVB6Z3dGZEV3clxyXG4gIGh1a2dLcjNycjc5YW1SRkxrd3pFM2cweUVFUkVwNnM3UXRJYkJFUUM1SXQvMTh5VXNKaUVoMkZ4Y0kvL2hNVmpKa3gzUHloY3d2Z2pcclxuICBObENuUFNnTVgza1BLVnM5T0FSMW51UUY2MnVGbGdoMFZ5TGcyNjMvcG0zN1JGL1ltT3lvNDdmL2dZYVBlTTBDODYzQkFQcnFsdWdZXHJcbiAgek92NDNadDlreUVnYko1VG4rbkVucE1PSVNtSTl5dFROcm1zZ0xEbG1JcjQ0aGUvV2pwa0RpWXlzQ0JJbWYxRDd2M0ZXK2MzOVVmMVxyXG4gIG1zQ1JsaExGaTE5UHVkT1F3ckp5ei80VTdTbXN0Si85N05kOXk3dFdJVjg2L3N4bWw1MjNMSk1ONmZtRzJFeEpNK241UnNxUXZDVS9cclxuICBOS3NjdHVXZDhpQkt3b2pyS1U5OVloa2NheFlROC9kdjNYeVhJcDlqeEREZ2oxVUlabXFrVmNNa2dNbjJvNC9hdS9RSlljbU5xRDUzXHJcbiAgQnpYNTZoNFREVllKdzJRU05ubXk1dnZvdG4xbEZadDZId1N6WkhXS05VaU5QRzNoVjcvNlhSdW1aL1c1aS9nUnAzdGcwQkpiMHRpQlxyXG4gIERUZ01OazVTRWlGOFoxSW40UTNxb3c2WkdvYlV6VENpTU1oZG1LUTdKMkRxeCtyalYrMktlODAxbGk4Y0NHMFBtNTJDaDQyeU5aeFFcclxuICB5QXJBajMveTYvWkpQeU04MXlMRjB0UG9oUHQ5QlFJSGYzS25VbEZRTjc1NnhwQjc3MnQzd3FmNG54NytVUVlXSHkxcDR0VUR0Z1YwXHJcbiAgWnl5aklIemljYzFmL0pCM3crQjlmVVdVK01kK2lubUdMdUlYQzh5cW9vNS9VRnJkTlBoSkJ4dm0zOEJPT0V3clNiMW80RTVXN1BvL1xyXG4gICtjUlBsSmx0OEtJWFBhYy9jS1FPZ3FTdmZuUHZZS1JkZDk2aU9mSGtjNXJWVm45bi93QW9JQXREM0JPUFBBenFnSVNja0x6eEkzN2hcclxuICBEWURaUjVUM1Y3VXJwaDArZEdEeGswN0s1SG5pNXEvYkJyTWFKZ3Q1ZmxzdmhPRmtkallNZXM4VWlKV1dlM3Nld09GYjRyUVBBekVXXHJcbiAgTCtVSDJvRE13RWlialRYdS92S1R2QU0zWmZkWHg5Z0tkaWhueGNGZGVtR1RLV2ZDR2lSV1gzUExadWZkRDI3MmJPT2tDaDBJWTJaS1xyXG4gIGpUditRWHFJQnphazFVTjI4NzlubTMxTDJ0MjY1eittZGNUakNsYlNvM1oyeXl0TEFNTEVwTWNnMktXZE9Qa2w3SzJmSFJvM0RQRUhcclxuICBhVC9xSHJybDZFTGVoTWx1Y01jZkJOMlRFY2VoMXJ5YUZOSWVsOGRKRU5WZFpJRDFnUU0rdW0waEdqUXFUWGl3U0x1d0Y2eG5va2lvXHJcbiAgckQ1Y3Mvcm9rWTRIeEFxRVFETjhTY2g5UFVNZGRnOTEyRWtoZkwyeDBPd25qVDlYczZMNnVVNnppMTU4M3l2YUpqa1hKSEdJMng5R1xyXG4gIHhWSDdNMXVtTWZXblAvMjFMNXdmRkpZYkJZQkhQT0lSWlpaZUw2MEhoVWsrd1lBVGxoM1k0NURWVkVCcnltQk96b0RWSms3Q2J0cE1cclxuICBOdGZWOFZ1SlpPYU1yL3IwUlJjcGJwODYrTmhtdzQyMkwvcjlDQ0w0WHY0R0toQkdYVEVyWWJPaURYanhDL0d2VThuL3ZDMXgwc2gxXHJcbiAgc0x4ekVCUWV2Rms0UCtJMHM1ZFg3eE9QUE1zblZ0UEZGLytnckZyTU5ya2p4Z1l6bmNwelBUT214Uk96RnpvWHdrN21RYUFxci9GTFxyXG4gIDFzSy9lNE0wNGtJbWMrT050eFFCT21HbGZGQkRSVnkwTC82VE41RC8xS1c0VC83S2pES1lXekdFNWVrZE9RNU5IZUdzRUJNZWR0cmxcclxuICBreTNoUGE2VWI3T3BmVGZ5aE9mdWRFRGZScDVycUYvMUY0NkF0TEFGN1JGQlVHaVIxVWhiRW0vNkNaaDBETE5PR3oveEwreDN2M2ZsXHJcbiAgdmZJU0lFNVdrQVorTXFFb2hJeGFlWWhYWGZobmZPRG1PcDN4UWhqZjJWa2hXSkRQZSs0em1qWFhmRldmcUUwbkh1VU5VVUNNeURxRFxyXG4gIFFjUmlPdkdQQXRWZGVNRVN6KzZmSklwZFNCWkRjWWxNME1vL01DbTY3YmEvVkx2UmpXYzBQYTArVEtDTU1WcmYvWENnMURESVRocC9cclxuICA3djFWNHFCN25UeldYZXV3MDRGQlk1Tk4xbWxPT1hWRzJRa3VmaENYQnVxYXhrYllWQnVRR3dSaHNDZGNyN2ppbWxrNlZEcHY0aDBFXHJcbiAgN2tuYndFZVRpem9zclpkUllibGJpa2FEcThhZ01KNnBjeEl1c3hpYk5NVXhLSDdFSS9JTlFHZ0lFYkVXOGJHejl3RFNRUTFDMkZqaVxyXG4gIE5ZQ3hOVVVUcXRzcERGVGNycjdtNTgzRDUzMVlHVVE4R3lSMEt1eE5SQzdudEFqcmJ6QkJ5RUpRL0duRHRSWFhMTG5rYzB1NnRNUmNcclxuICBreWEvU2R2VlFPcHFwYVFOR2V5Vm55eE8vdDI3ZWtkbVl1TmRadFRNUG5pUGVBVGtHZEhrU2x5UGJHZDV0N2ZFUTJlTWFYeDdCYnlUXHJcbiAgdG1zZ255RWF2ai8rdlBjSVBlTGgzbUJLQVFIYjl0VFR6aS9FUTl1cTQxRk9HbW03N3JSRnFUZnYwaGJseTBxSWFaYzZEQ0RtM0ZKSFxyXG4gIGlkZEJWb1A4Zy9yRmVzT3F3ZzR1MzZyTjc2aStJaDdodm5qc0djVUlvaklQbTJsYklUbFV6RGVSbjB4YS9CZGQ5TW1sbmdiQiszenZcclxuICBqQTltM05UUTB4NkdvUmFjOCtlVVFudU9HR2cwd1JDdi9JNFQzQWVEOW4wZ1JuWFlicDZTeHB5QzZ1Nk1kc0pDa1VLZkxac1VEenVoXHJcbiAgeU9vKzl2SFBGL1lyU3hvMVdHcVlLUk94NnJEYW9McUxpRmlCZU81TlZCOHdCTVFIVm9scEhQaVRCaUQ4MlJpNTAvaWpmYkxWMWgvdVxyXG4gIHo1TDRwNFhESlBGMFlIYXRFVERYSUE2Tk9oM045WlpiYnUwVEZvUWgrUnNHNzN4NE0xN2hFYVpGRjMxSzJWMkxmeHNObWxIeGVBZktcclxuICBLVDltcmE0d0xHenlIbi9BcjJjQy91NnFBc3hrYWJ3bFhQejdEOHBiMG9CczlwSVhHNDJZbHlZSURYUUVuUmE3eGIyNElXV3pJbkVBXHJcbiAgVk1EUEtpdS92Sit1YXpxUU90dm1BeDl0OXB3NmNUR2RMSW9Bbm1udTBIeERmRzV0VndUY3BMWGVhMWNxY1dWRkFsUnBEVWppcW1laVxyXG4gIC9MbDM3ZDc3WTFuVTdKaHJmL2FiWW9XZ05xMk5lQmpRbERmaEVZMlh2dVNGcFcwbXJrQ2U1SUcyaS9aTHBWMWVoVTBjNnR3NURkaUhcclxuICAvQXBqWXJIR0dzczFLNjY0ekN6eHFUTVdoQTE0TzM3dzdWT3V2YmJnM1l6ekx5bEVkOUNxdzk4S0kvRUprL3dOR3NqSVg3SnFVMlo3XHJcbiAgQ2xMSFZzNmpFSCtJaDcxWHJPNE9Bbi82blVPVTVNTTNrNjlUVHp1dlhlSGUzS1p6NzNZS3lxTHVoSGZOZDBiZ2JYQzF5MzRZNFFIalxyXG4gIGpMZDEzUkxhQjk1Ui9aNTBaN2g4NUJ1b3kxeUQ3ak1rNzNPS2xhYzJEajduT1l1VlBvL3RldkVsVnhSMThyUE8rblpaUWRjd09WRytcclxuICBuLzI4eDhaLzJFTWYwMDRRN0V5MytrQkFZZytydDJKNXdCQVF5SWNHbTczWTNrRThWS2FQYVZETmZXYXUrY2lPUjYwLytLU1FwbzJGXHJcbiAgWmpwWUFPSUVjZVdBcXd5cXd3YlhHdkxQbjNqWllMSlU5UnppWVFhRjFUUXNucVREUDRHbE1HWUpadHpjZGM3c3g2aVJjQUYxWG9vQlxyXG4gIENCZDMvMjZhZFJoWGFRM3pDOXo4djk0MlBJT1VUbWh6MnRsbjl3N21xY0dmYjRUMTRjeUJmQ3QvRzl4MjNQa1Q3VEo2NXU3MVFHZktcclxuICBlZWJDTURHQzE2L0o3dEVTRWZWcTVWbWIwNjgzRkJvY1YxNzE3YzFuajlxN0NIMUQ2RUFuL1UwN1F6WkluL2JWQzh2NUlkNkptN2tTXHJcbiAgN0NueGU1YlBHc2w3L3ZhaUlBeGRkeXZHR3I2ZGRpVGVwSlUwRUZnbVVLaVh5cFA2LzhUSFAxVGlZU2Fld29KTmgxaDFJU3pLNTJvd1xyXG4gIENONnh4ZTdOa1VlZFZHYnA1SW5ZUEZrQmdUMDNoTTYwcHVJRzJCWXJ0blhON2VNSDdsRGFpeFZFQmp2dVhXSUQzajMrOFk4cjdWczdcclxuICB3NjVNT3hKMkZQSXQrRE9yZitFU1BYdGpnOENkaHBDNDVTUHRVajZIc2E1QUd1cklIL0k5Zjl0T05McDdMZ1pCdUh5dnhLSE11UmVYXHJcbiAgYno4Skp0bDEzbjJXMWlDaVBWMWs0K0NUMmdua2JTMmhlR0xiM2sxSTlRdVRMc29JeHBrYWxDbStjc3A1TGRHWXAzbjhRbzl0L3ZKWFxyXG4gIEt3MlRROFNEMzVtckQ1am5IMysvY2liejYzNkdpalJieHI3SWN4cHpLblRZUGNUL2RHRVZncUlLbXpnTytOam55Z3dqejducTJMUVRcclxuICBKb0V3QlBVUnBxWVJpZ2RiZ0hyb01BZ2JNSjlPcmhJM3dzbWFmMXJESUlob0pjODF1QTFDaEtUa0p3YkFjWU5CNHNWT29kSkpVOFZHXHJcbiAgUVNZaUl0aXRvZHpnV3pIUmJjWVp0MVBhMmVUbC8zZHl1YS9oUFlKaFExc2d2SUZSK3RMR20xYmV1ZzBFd3B0OGZQbWtzNXVQZjJ5SFxyXG4gIFdmSWdQSk1qWkRMY2ZSUHhnczJDWnFtQURmUFh2OTdSUDZzaG5aeDhwRmJGaGJ4RGlMQ1ZFcDlCZmNaNUY1ZVpIemYrMGdha25meDRcclxuICBWOThIOGRzRmZ3Y2Q5UG5tMXBiQVdqa0VTUU93SWF5QUVQQXVwTTF2SFRaSVhyb3crYkg2ckpHOE1iMWhwVEFLOGd6QzFQZUQwSzBUXHJcbiAgSUY5RVVFZUY4VTRmcGNyY0xVZmVEOE5wYlZ0Y2Q5MlZTam14NUxScGt6aHhxQy9HSDZtcnp3NGNsMjNpbEc4ZWRKOWhrTnZzWUw1NVxyXG4gIFgxaUdmV3pXK1I4OWY5dU83Mm1lOElRRm1rMDJXcnM1b3AxdzVCeWZ3RWJUN1Q2d2FmTytiVC9hUGoya2VjTGpGMjV1K29QOUhvZ0dcclxuICBwUUhIYnN4S1FCNVFLeENVZmJzZFB0WlhyVE1MMEJucUdXSDN2cDR0TXdsZ3NKMHVuR0RHQkFkaHNaUG9ORFRtSVNEeDAxYXdrNXBPXHJcbiAgZnRJYkJZT3lRUTdQMVJrQjFEMHppL0puR2tNNncrTGl6cDhHZjNHYmR2M3N0TUhrcXd0YVBreG9lRy8yemorVlU0UnNXQmhFZyswb1xyXG4gIDVyWnQwQk9HMzJIK3VaVnY4K3FYbG1Xdzc2RHgrVmJDNUxzRjd2M3gyTmRiYitWaWFaVGczMEJydjRjT295NjZZUXh1M0JFU3orN0ZcclxuICByM05oYjJJTjBtUjY1ZktiOU1NRTdtbGZJU0lNNTVreGhwWGxPeUFDMkYzS2JPT2ZNdmxiV1hpdlREU3FIdk9ZK1lzcXE3RDVxOWN1XHJcbiAgOGs2ZXNQWGN5NFA0bjdqd2dpVnV6Nm5QMUsycmdjNTVOTTU5eDJiaFR4NXEvNEc5UExUVWp2L3lXY1hVdlRvU25qK3JMVVF2Mm5EZVxyXG4gIG1XelVVUDRYTHJWZXNkY1ZGckR2VGJQcDNCa1hsWHdQR3J5RXMzTHVJcXVwMmxKMkRlSGt6UldrVmQ5MzRaMDRoVkVIMm9ZcnRXZHRcclxuICBlMUFZc0p2ZDRNNy9LdTFBTDd6Njg1d3h3MzhVbUIwaVFNWTJBeHdRckVzVENuRjk5bk5mYWZNM21keWpDM0pBS3gvbEV4NzdqOWFuXHJcbiAgOFlTTTBjWmhiR0RtZ0hJMjBad2dzbytGbi9qNHN0OXB3WVdvWVArdHJON1piVHY5OUF1SzdLb0dPZVVCQjM2MmJRdTN0YXZ6QlpzYlxyXG4gIGJqUlpzUHBBUE82OStvRFJhN243QWZYUmx2bFFHczB1dTMycWY2OVI1RjduQ1RaNzIrdjZqWE02Y01pVGhoRzdNK0dQU2tjYVZpTWJcclxuICB2bW1ORXJmblNkS285eWpnendzWFRCcUhwV2FkWmgxdVZCeFlKbmFaeHcrVjB5Q3JqUzRNR2dUV0JPSkpDOXdQU29mL296LzdsWElmXHJcbiAgditCKzBBQUVWaWUwa0t5KzJCUUs4cDJkVTI3SlgwTmNPVzBRSVFFSFpBRy9WcXhXS1U2dGxFOTdTZEkrZ3EzZXZXRS9YLzdlNC9XYVxyXG4gIEZPUVVQeXU4dEtXVVY1aEZuOTZ6UkNxY2ZHWUc2dHRRVlk1Y0pLWlJWbDdwNVVVb256TFZvRTFsZ0lhazVjcXZ3VU0rcFZQWEo4Z1BcclxuICA0dXRmWkdJL1A3YzUvWlNEbS9QYitxenJlKzk5RGl2eHFlZTRCWW5EK3pOT08yU1c5OXJLR1dmMmpQZDF3NEg2Nmg1TTVTcXVkMjI1XHJcbiAgd2IzeUM5SkxQZGIxV2Q5M2tYZnlvSjQ5dTNkbDBtWlFtS0RMaWtrYnNOb1ZydHNtQmtGYTJHcTEzeWhGbURRTXFwdGgrSEpMakdwb1xyXG4gIEUxYXQ0aEEvRldGUUxzODVQNlNXRGM0SjlwN3FLL2ZjZFZkWmZWRG5ScVNzb3BpNDZXTEZkaktJcFptVENCLzZVRndXaE1Pa1lWYWlcclxuICBFVmhWUDZCWVdJRUdrOGF5ODY2ZkxHYW9hN2RoOTRDTjB0MUpQUWtTajQrWmo1ekdheWN6b1JQaFpkSWkxSnhFV0ZqbkV6elg5MVk5XHJcbiAgMjdiTHhtR0lYK0NmT2lNekZVSGk3MkpRZWpUSm9nTS9MQnp0dHBnZDUwYzk0S21UTXd3TFkyQXlhR2w4Tm1nUmpEN2tJZk1VOHhmRFxyXG4gIE90MUxsbmxUODcyTGorL1hNMUNOWkFrVW04dTU2NFBDOG8rUS9QYVhNOHJxRGhCTWJNS1VrODJmL2ZaNVgzTm0yeFowREFQanNMd0hcclxuICBacGRXTEFzODdqSE5WVC84YVhQRzE3N1psdms1WlJWcG44ZWtZTVRSZ1ZzMFhxeHNRZm9oRkJDVzVEQTQ1dUIzdjcreHNBY2g0VUJPXHJcbiAgMG1HNS8rNzNOeFU1MTZneStqN3lZK2M1OEplNmtpL3R3a0EyQ0w0bFcwbUoyOUc3aUtjNkg1WmUzV1lEZnJWYjdYZFFPTE4vTXFua1xyXG4gIHJiNGEvR0xpYUJDU1h2MCtZZXYyTlF6ZFBScnlZaVV1M0NUaEJ5RnhEZ3JmZFp2ZE5JYkI2bVBYdG8vTTF4S2xSODMzaUdiQjludXBcclxuICBkK1pzc0h5cGozY0gvVk5PK2tRcDkvRmZQcWRkM1MvUy9PS1hFYTRqSHJTMDdyMzYrUG9aaHo2d1dGakJvWWVmVUxSeWdBRzhMRDgxXHJcbiAgaXR6aktVWkZrU0F3WnBUWlI0cS82YUFYLzZYdGNybG5xZGV5T1EyVG5Tb2R6ZXpTcVhWMDNMR2x4cVhSaTdQSGR0R1k4K3llbTM5WVxyXG4gIFpzUGlpbEF6L3UzRXpUTzREZ3JMTFdITWpoMXk0OENxT3E1QjRTeHg3UzJJZVhJRFUvamVYZFpVRUZiSTVaZjN6STJycTUxM2VtZFpcclxuICBPaHVVdTZxKzhNNjN2NkYwSE1TQVRTMHNKcHAzVm4rSWtUb2hURGRnMW1tNng1cTUrSklmOU05ZHh4Zm5UOW1vR0I5NnlLN04zWGZkXHJcbiAgWFhZTDAyekNYbG4wbWFzMEs3VHZsV0hCQlI1N0w4MDBnN3I0RUNYM1pvTFN3aXBMWFFhL2FRZlJLNi84YVRrRlVIb0xQM0doa2o0WVxyXG4gIHFMVVBrd3ZoL1ZPUHJ2NzEvaFpJRzlseHA0T0tiVEh5R1JhTythWFJsenJRSnBYUnM1V01zcTI5NXF1S083OWRJQnpLcTc0aTlCVmVcclxuICBlaWVjZUZaaFd4bTRzRkM2U0o2d2RJUXhlYUt0K1BPZi83YmZKZ2ZCa2JuMUJFUWNyZ2dSL3Z1Z2NOS2lIdXVkKys3MStCUE9LdjF5XHJcbiAgR0pJRzl0NzFMVUhOTTZpclFYWFRoVUUxUi9XU0d5V2NldGZHV0dJZ3ZKOEVnd1RuYk9OWnJYcjJ2WUlRRDVNdGZXNXV3TDZQTXRUZlxyXG4gIDg0L21ydmFQRFdlU3NPN2FLeFNaWUZlT3RmNGJWaXVUSGhaNVdkNTk0c0pQYnY1d3N5TjByYjVvWGMwMDd4N1lxYjdIN2xzOU1GY2dcclxuICBacklaN0NDTmllMGpBMVB0MXIySHd3NDdvZG15WFZwUEY0NXlYR2Z0V1czNWRLKzBPTktCdXVrT1F2emcxVWNtVWJ1VDI5U254dzBDXHJcbiAgSGoyWkFUL0NnWHNtT0ZqUE5MTVloNlRuYXI4SWZqYis2N0IwK1l1Z3VRNmJtZlNnY09rTS9BSCtPNEcrTUtObVdBaU1qVTN4SXg3d1xyXG4gIDdEN0M5R0Z4OEhQYzhXYzJQNzc2akZuQ0JsaG1Pb2c4WTVNNTUvdjFiM3hmMlV1eDQ0ZmUzai9MWkZoZHpFMmtiaGkyTTlCUmhyRENcclxuICBJMjlSVHdaN3hDM25vQ1JQcVh1d2VyRUpjaEQ0aXd6a3dBTzJMMjJ1L21iNjFWcnJidFVjK3VsZEI1WlhtN0JLVFppQVgyZmVZRnNNXHJcbiAgQ3BkeURZSzRtS0xQaXJGR041eTRXWFZHOUswS0YzL21vcTNiNEozbXd2SlBVd3Q3eHJra3poam5iaUtDSlRNb3J6V1llRm0rOWROdFxyXG4gIE45cWtDYU9CSGNGM0RNVHV1dzFXTis3Q2dCMzdYbW5EZFh1c241bEpzZE85NjJkMllmV3h5eFQ3eXByaGtlMHFoTWFjaVExdFB4eUdcclxuICA3b0QvemZQL3B6bjlqQXVhajMzOEMrMnErMW5ORlQvSTVtSmtpTHdQT1owMTFHWGZPN0ZveFQ0Z0NRalVGUnJOSFVpajZkNVRWU1FFXHJcbiAgQ3VwMzAwRTZUc0s3UXU0SFhjZUJQNVZOL2JZYkgyaWdHdXFvdVBCNENRcnJjRkEvajhzTGYvSFBXbXhVWEllRk01REVrQjhrYkZoaFxyXG4gIGc4SjUvNFlOUHRDYzgvVWp5a3krVHJPK0RvSnZEdm51OWJON2UwR0dzYllDd3RiTjM3RmI4NTF2ZnFISVNzaXVsTk05QTNISlF3MHNcclxuICBML0ZhN2U2NzM1Rmx0eTRldkwwYkNEOFFyRDYrTWtKcE5xa2VmRGYvR2orNDhpZEY3dlhyMy95dTdPakZOcURFUUtQbitoditVRFp6XHJcbiAgL2VJWDF6VmJ2ZXROeGI4OHBiMkx5NGJMRE40aEdsQVRsQzZVQ2VFd2E4NGhYalhoZ01jdHRFeVJuWXlLWXhCU1orUENMYm5rZjVaZFxyXG4gIDYvRWI5Mkhoc09waUVzUkVDT3ZaaWdrM29SZlducHJCeENQMWxXc2duSjMrdTdYZk0va1locnozZmFMVm1QaThJN2ZvSHVNN0R0UzJcclxuICBzMGZKOTQ2NXBEcVA0NTduQkk5b0owaldDOWhYajN6a3c5dFYwelBheWVldnltU3VzQkRiL05WNFU3dlMzdVk5R3plYnZXUFg1cWMvXHJcbiAgL1czYlo1ZG92bmZwajlvM1ZzblJ2SnFWZ0x5NTdWUEhmb0dtMWdOTUM2dUdMTWMwZVRuenVQMmdPa2ZOUnRGUWxscXl0N0Z3d1hhcFxyXG4gIFh5OVZhUzdsbU5ucElPWVJ6QTdGbCtWd0dsdjNxcFBXNlE2QzkxUURFNWRyZmEvek1PcVhNZzZDd1lwZm1oVFlVV1pZTkc1aWZUZDVcclxuICBHaGErbTIrTkNTOGJJWW1XVnhmMkduRDNUNzNMdzdMTDlnNkZHZ1R1TzJ5M1dkK2NlY0paVmY3a3A3OHNkcUxzVzNqdjFqM3J4elg0XHJcbiAgc3hwNzdndldMaXdvbllxYkRwYjM1UnlPWDE1WHlySElreDVmWmxZMWFNcFpwVXFmSCt3VWt3czJnRUQrRFFvUkZvS0poL2JHQk1uR1xyXG4gIFU4TE5sZHZ2NGJ4eWhJQ1pkQUpRcGxMKzlPZS9OSmRkZmszYnlhNHFCZzJ4M1d3cVkzN2VpbzNjQTl1TzZxLzlFZS9hWXYweW1EMzlcclxuICBhVDB0TlVlNU9vRHBrSU4zNlEyV2IzMXRhVVBadGYrL0YxMVIyRmk2cTdaTkJaTWZZUWZWT2RNdFc3NXJ6M0x2UFN1clFWaGI3OS8yXHJcbiAgbzRVRmRjYnBQUUxUaFhvcWhnVmZ1MUxKQTZSdEt0T3d5UUlJRzlUN1FlcDRCa0U0aWlZVUVZUmJlZVdYRnpmbmlMaktKNEkwQ040clxyXG4gIFcvejUxL2QxT3grR3M4NzZWa25UcHNRWEwvMkMwc2JVc1QrSXg3bjkwOUc2d3JxeThSaHdGcHdyRDhJbi91UzlCcmRKMHhpRmFGNEJcclxuICBsVjBFK2V4ei9yZDU2bE9lV0RnQjluMTBWd3ZISDN0QWMrcnA1emNubjNKKzg1clZYdEgyTDVhY28za1Z0ZDFaUTUzODVZUEsyQUVQXHJcbiAgMkJVSW1GRlowa05OcGV2R1VkOVRBZjdZL2pQUFdoN1hpSWJoYTJkK3ExbHpqZDRPOUc1akhPVTJDdDF3VHQ0elc0SGFmVnhjM2dmeFxyXG4gIFR6MVFaeHdYM2p2c0s1cFl0ZC9FT1NwYzNzVXZaSFk4YlBia20yRS9SWXVxL29iandDL0RpbTk4L2FyOU1GWmhlT1hKRHorVHJFcEFcclxuICBHS1pJcnI3NjU0VkZzdGNlVzVkT1huZmN1aTZBT3JUQnJWNnQxVERieGsrdWVjcFdKbm51MXExN0hZOUFNMUNITmdwU0ZZMGw0dFQxXHJcbiAgTUlpblZ0VWQ1bisrUjcrNDJXV25MZnBzM3k2U040b0xiSXQxODZ0K3Q5N3F6ZjNCb2daL0JnNzV4aGFyTVVuK0llbTVSdmtseitQQVxyXG4gIEgwTE9KRWNkWmpyaG9mYXJ2QlJtMWx6alZWTXUvRGtVYTdpeHhocWYvdlN4emRidHhDanRYTDFFOWhlM1lLKzIzWnBZSUdDakxBSlBcclxuICBCdzlwVngrR2UzcFRWdHNtbUZTZlRXWllUdWhpOWRXV2JmYlorNzNOVzk2MlU5dk9iMmtKNlJJdHdibTAvYTZtVTJLNTk3NlBqVFpjXHJcbiAgcy9uaU1mdE5QVDJBVnlDZ0dHWUNFT3J0dVY2RjFQZk1OTWMvbkhmK0pmYzZ2VzRTU1BkSFAvcEYyNkY3NTY2YjdSTm1wbkhtcWxGSVxyXG4gIDIrcGdsTzBmRUU4ZDNzNWdibVpxL3R5WlBySGlxc3ZRaFprenphQ0VBODhHT2liREUvK2dPTGpsbExodVdjUmxGanJJTkw1d0xOMWlcclxuICBENWs5SmI5bDF0NitPL2E0cnpYL2FBbFlOMDExa3drQW1NVlRRdUJ1NW54OEcxKytYUmZjMy8ydU54WGpkVFRWNURQZk45K2NMTXJ5XHJcbiAgbTBEWiswRkM5MEE0UWxBRWxORGYzcGZVazFYTnB1MHFCUXVMc05TZUhYRVM3dXVBQ0wweTQydmJZRVlUQ1JDSzdJMVFIK0x5RFFEN1xyXG4gIG83YnFMSzJUMjdMLzhZOS9Lbkg3OCsvdkZFWGg1ZHZ6SUFodkphWHN3Sjl5aUZ1WnVlZTZ5bXJ2YUY3Vmx2UElJL1lzNW5xNkVCZU5cclxuICBHd2M0UVdSdzNGM0Y4YWo1NXl0N29YSldmQTMrMkx1eXF6OHE2aWxMMnVXb2NsaTVzY0YyOWRYWDl0UE5Dc1R6S1BDVGROZ0h3MzZpXHJcbiAgMnN6Tk93b2pzNTVqY1crUWU2U2N3cVM5dUZvMXBGOWpzUzIzM09EanFBZmhwUy90SFNWZ3RtOC9FSk05ZGR3bWJ0cGRUVXdtRmN5UFxyXG4gIGd6aTE0NndHMkVHek1pYXpVdC9kVmNKODdVVG4wd2Z2WE1hY0M3L3gvYll0cmQxODRkZ1p6Znp6UGE2ZFVDQWM5eVllMnBkVkxNNVFcclxuICA4SUJlZ1FCejIvdnZ0MjI1cnl1K2JtejEvV1p2MzdXWXNRanFkOU5CWmg1Sk0vR011NDREZjhDdmsrZ01SZ2xmWTFSY2RacEIvV3pIXHJcbiAgN2lDQlpWQ0hkMVZHR2tzSWlJWStLbTErRGFJRTkvWDNHQWZhT1Z1OGU2OVpoT0hTenlvRzdKaG1oWGdVQ01Fdm5QSFpjaStmOWpDa1xyXG4gIHJBYVZnejU1VE5HeWl1QjlYSGtHSWZsSzV3ZlBWakJZUVdSWmpGR2FtUnQ4YlVvMGlDMjU1SE9hUno5cS9uSklGV0luUE5hV3prcTlcclxuICB1YXVKTmdyVVNFMEtzdEpJWGdhVlIzN3RLcmF5R1ZmZWxNMnNGN0g4VGp0SVV0TzFtc3B4eCtQQ0I3Vy91czRtQ2E4T3JTak5qdm52XHJcbiAgdVErWGVRQS9DQVRyMUVtRGJNdXh5SVRvQnN5dXRlQmhFRmZpU0R1dTIvTjBWaDYxMWhWbEY2dlY3b3FxanB2UUg0R1pUdjhaQllTd1xyXG4gIFRJRGFlOU1acTNUN1NueFBFMUpITVhSQi9rYjdpbGJXalBNdWFWY2ZTelhISFg5dTg3U25QbUhLQ3UrOUNZaVZmajBoaEFjOEFhay9cclxuICBkQzFJcml0LzFnOC8wejh3VWpkTVkyVWNFbGQ5aGE1YjBxdnZSNkdPeDZ6YytlUHV6ejduTzBXbVVadFFHWVk2RHNDT3lZRSt3YVI1XHJcbiAgSWVCMzJsc2czTGowSWZXZU5PMkI2SjJmUEpxdDVmVEhCYWMyTjNvRy90MGIrSTg0ZFBmbUhXOS9RM0VmQlA3SVVweWh3U1MxbVdJR1xyXG4gIHhPVDk1bHR1YmY3N3hVc1VUUjc0L0JkT0w4ZTllcC9CK0lFRWVkWVJVeDlycmZtcS9zWld5TGN3NGJEaU5aRGFJN1h2ZmtjMXIyNVhcclxuICBvSU5NeU5Td1FRNUxwZjVlTmJDRC9xdHRCNk8rdWJ5bDdtcC9pVzlVV0g2c3loeXd4VjhkcG5jL25uaUF5WkdWSndVTmNzV2s2ZjJvXHJcbiAgOUtIclIzbXd3R3JiY2luanVMaHFKRjVodSswK2JvUFNIdFpIcGd1c0syMkg1QUlCV1hYVlY1YmpocCs0OEVKRkthTnJiZGQrbTkvOVxyXG4gIDlzTG1MWnZ1V0xZRjNINEhoWVlmdFVSbjN1YTJQL0U3ZU5kNVdORTErSHBBUTZYakZ3TEttaGxyM1JIcWUvNDNmc3ZNUS80UkR4OXJcclxuICA5bURSTml2RVQ1MDREY2FWcVF6SUR2WkpJSnc4czVWRWtPaWUyUTJuMXFXeHBVeUQ0RDNFajVsd3dxbWpjZUVEL3RLQnNIZFN2ekFxXHJcbiAgdkhmMVFDeWUyUFlhMVRHOEMvRUF6Lzc1UmhvcG9qcnFtL0UvNDV5anl2V2VlM3J6SHl3eHlEZFo3N1VybDFtL1BQTDN1WFpWNnQ1N1xyXG4gIC80YysvRVZsbjRUN0UwK2NkZGZ3UHh2cURqdFErcTlZYnVOeUJhMUhIczN5YW50YXloUFEyTU4rWXM1azFaVmZVZXByR1BHUWpyOHlcclxuICBPc3BYM0YxNUJjTGgreHRJNjNScUpCNzEyTjBBeVIyR2hZWDRDZkhJWmtML21lSEhFdy8rN2ZraDFNK2t5enQvOTZNUXRwVzZBR0dVXHJcbiAgeDNrcGlSKzQvZndYbzQrNXJWR25uZjZRTk9yZDYzWGFVQk90T1FIQnVYYVRIU1R6dHBNTHJIdG1Vb3hIWGVJQlJ4MnhaMUdidHpxaFxyXG4gIHdQUHRiLytvZWNJVEh0TVNqMXZhdDdNU2pjQ2tiaEFlOENzUXdEZG5oaHBzZm5JMlJUNUlQbEQwdHNGSHhST05aZFJKR3Rnd2ZQeWdcclxuICBZNW9QdlA4dC9UaVNacDZIWGNlaDl1OURrMk80aCtuR3g3UTJsbElkdm5ZYkZ6NSs2bVYzTUNxc0RoSlRJUGtPNm9kNUMzc0dzckxKXHJcbiAgdTBIQXdxZ3R5NmFUTWRCb0p6WkI0NlRBZ21QUENmc0lzRE9vTDliMTR0NE0zc21DekRwNHJvbW1lK2VMa3dGa1FBQnNPNnlvd040TlxyXG4gIEhkQU1yeGFLdzUrbmpQbGhYNWtsMTBpY3J0S3EyMUxkdHVwMzJGaS9hbWZkdE1SR0NjMXJDQWNwTXpWVjhvTEVLeTJyR045cUZQaXJcclxuICA2NkdHdUx3YmxoL3BXaUgrdi85M1kxL21WSU1HM1UwM0lTYVRFWTlSOThQeUVFUmxtTCtjc3lLY3dVOFpFc2NrY1FVMTYrcHJaMzZqXHJcbiAgQ04rNzhlU2JBdU9NTzJ5L1daR2QxVWNEekFrZTJhNCs2RXRaQ1R4azNvY1ZOaW5pK3RDSFBxUzU4Ky8zM2dEbzJPbVA3Yjl0MlRoNVxyXG4gIDJ1a1h0TzNpeWMxdmZuTjljOGwzTDIvYksvOU9IcHgxOWJGR095Wjg3YXVESjNRUENnSUNkckxHeUZqOVVlb1BYcnZYOTlCOW5nN0NcclxuICBENjBiQjlRTnBjNUhmVDhLM1hpWTQyQmhOaHNPNVhsVUJ3MXNoSnVWbHp3OGI0UGdmUWFXMm14RXpSWWJGYjVHWGM4YXFVRjZIQWpKXHJcbiAgelNwcmN4cmlxU0hPN29iRFVSQ2UycTFCL0NNZjNxYTRFWUliUkxvc08vVisxVlhYdHU3L1dRYWFJSFZuMTNzMHEyNXNKekMwcGJBSFxyXG4gIEFyTTRoeFVGd3diY3dDeGVQWXVmYkloZE1Pa0VlZi9WcjMyakNLbmYwcTRlSnFsL213K3AvZktidHNQVUNUZEhFOVBHcXIvMU1PUjdcclxuICBKMC8yd05BYWpBWmZNQ3BQZFhrZ2ZvVmZldW5udFFUVy9wclJHLzBTUjUyWFFmZWo0Z0JXaTk4L3RTRzJXM1p0UGQraTNnOHlEblc2XHJcbiAgYWZQajNDRHVjd01mYnVQYWJZbzdZeFZpNzRmSkQ1VndoNFlOd3ExL3VLaTByNFdmdkh5enh1ckxObi8rOHp6TnRULzdlZk9ESzMvY1xyXG4gIHZ2MUg4NUI1N2k2bTNHc0M4dTBManhtNkgrWUJyWVZWNC9mWDM5Uzg0UGs5QVd0bURHWVJ0UWtDeGVhVysxb2JwUHM4SFh4NTZteVNcclxuICBiMy9uKzBWN1JEd2FCV09Dck11bWthVFRUcG9PUC93bVB2c0Rvbk52b0hOZ1VONlBpcy91K0RvZVZ6Tmo5V0lsOElZM1RHYjVsM1ZhXHJcbiAgTWd4eDhFK3dEdGYrN05kRisydFVQcFJkR0x6cG1PUC80ckZmTFc3cWhKVlJzOUZCWUJtV09RMHp0TzlmZG5YenNwZStxSVR4MXhuc1xyXG4gIERZQVllcXkvOHpBSWEwUGE1cHU5cnN4MHNZejhFU0dEYWJUekVKTkwvKy9xNXBXdmFMOHZRbnpQUFgzYlZ5d0EwS2ZmYUtPMVNueGNcclxuICBYOUN1YUxURFY3VCtXZHJsYmhlNWc2WGt5VDk3Ry9JdG5HWklGMytaWlpaczYrU001azF2V3FPNCs5czVIUlpXdXhSdHpqNzNPK1dBXHJcbiAgS1dFUjMzWFhXV0ZzV2RVSlFhcVZVTDAvQWhBNnJDT3F3dHk5bCtkaDhCMkZGUisvN3RtOUFySUhpZ1RheGVLTEwxcmNCa0U2WGFTOFxyXG4gIGlLOFZpZktOS2xmaVNGc2NkdTg2Q2xiaW0yeThUcjljZGYxd3k3ZjQvREduTjJ1c01kb2NmWTFqMnZwSkhzUUo2aXgxNnhxTng0d0xcclxuICBFTGM1QlZOSzYyKzBRMkZkR2VvUkJScUI4N1EvRTFEMTNGMFpPQk9mZklRWnFOdHUrMnZ6cGczV2F0dmo2YzJQZjVLamErK2NDak16XHJcbiAgNU90ZXUxSTV6bmNZSGpRckVQQWhRcjNyKzdvaFVVdkQvNGJhRDNTZnA0UHVLZ1RycGpiemtiZ1pCTnhsNXkxbXlkTW94SitWQnh0S1xyXG4gIDJEQUdNRzdlUWU3SHhkZjFiOFp0MEphM2FEaU5paWZoci9yaHRjVWVFSC9DYXZ6UGZ2Wmk1ZENpNmRTZkdWM09KZ0Z4a1dQNWp6b0xcclxuICBaUkNTYjJ3dEF5V2l5Y3k2SGJSWFgzbHY2NkxqSUw3ZnQ0TThsVStyVzB0KzhvVnQyMjhhMkY5ajFwMTY2YTVjdWtnNTQ3L2VjNlBzXHJcbiAgQVVXQlR4MzBvYUllckc0VGJqcGdJUUN2MjhvVEJzV1RmTUM0TlBnMU84ZkN2UHlLYTRySmZldy8zd3JMMkNZMEdCVlBuUjd3RzdlWlxyXG4gIDk1TUp5Nk50RlNTOHdVcFoyYjFhZDUyWm15WUhJV1pLaEV0NEs5S2F0Y3VVQ09VQkxPVFpRZnA5a09kQlpwZG9YZFlIb2MwSklqZ1BcclxuICBBY0VTVTdaSFAycSs1czlUMzZxR01lWHVPMzlRMnR3VEYzbDFjOEdNbzVvZGR6bTg3YU8zTnRkZSs4dDIxZkhYSWtjMWdRb0kyeS8rXHJcbiAgem5GOVVjQWdQS2dJU0Q1RWtPZjZJdzd6RTNTZnA0TnhyQ3lzRUxNMXMzQXpna25UcXVPcnI2QnNaZVkwWmQ1aFhIejhRT0laZGo4cVxyXG4gIG5yeG41YlZla1dUNVB5NzhwdzcrWW1HOUJNelE1QlM0Njl1VjVKT2U5SVQrZ0RvSlFUSkR6d3l1bTM3eTVUMHpKR2QvL1lpeCtSdUZcclxuICBsRm1jUWRtejBYWWl4aE9QUFBya2NyWkRUbVMwZ1pQcEVyUFlPKzY0cyt3OFI2Z3BWc2dUbFU0ckZKamRQQVVwYXlCKzhweVlQdmZPXHJcbiAgM2htRC9paHJ1VjM0RnFsZjhUSGR2dFNTUGV2TENKUkowYmp2SlAxQnFQTmdWZHcxSkZtai9tN3U3VVNuTnMwdDhidWZ6dVk3TTM3RVxyXG4gIGdlS0JWYWVKVURCelkycXZYMCtDV3U2UjhOM3hCN2VDeGhray9kclBuSUxnbkxWZEsySzlhcDU1SDFia2lMNmRBOUJzRE8yQ0VvblRcclxuICBCcy84K3JlYWswNmVVU1pmbi83TUtjM1RuNzV3YzlubHJGa2dPbUxza1FNRTU1Q0RkeTZuVG83Q2c0cUFRR2I0a0ZVQUhQenBZNHZnXHJcbiAgRmVxUDFmMXd0VjJ0NldMUHZRNXQ0M3BYWVlWMHp3ZXByeG5RSUc3alVNY0IzWGpqWnNBYWR5Um5ONDc2WHVPaWJKQzRSeUYrc05WcVxyXG4gIHc0djVCcE4waWtIcENBZkMxdmVqd0ovT0d0UDM0bVZtbzlaMDRRYnFQM0c3VGxMV0J5TGtYenZDejBhZ0lPMUtHWlhKakpLTkxzUU1cclxuICAyeUp0YjVMeUpuNStVM2VCbWJJWk01blBvQk1OYTJDMzFySWpTUHJpeFVJY3Q3OG4zeWo1cU1NSGVaOTNrNkp1QjFDSFArNUxaelp2XHJcbiAgM25DTnFhZlJxTk5PbkRYeVB1L1lOUHZRMU5uMHM1UHZZWGhFdS9wQUlnejMxZ3ZScHBvNS9NOEt0dEdZNjZHTWRNbDNmOUFzdHVpaVxyXG4gIHpkZlB1cVM1OW1lL0tQYXZIdktRdjdYamdwaG1yajZZM3ZuMUwyWk1QUTNIZzBZR0V1Z2s0WjJhZVptTjJNMTV4KzEvNjd2ckZENllcclxuICBaL2MySStiRXROcXUxblNSZU5kYTY5WE5sMDg4YTZEV2hTdC9PckkwZFB4SjB1SkhXRE0wYkNlOGVqSVFib0c0bUFsbjRDKzJwZ1loXHJcbiAgNmZyTDAzWFgzZEQ4K0NlL0tQR1JJeUMyNjA5d2NFM2lzUGZBcWtyZWRBN2ZRQmsxMkhGbEcvUStaY28xZzMzcWJoQzRrNVZBOGJmeVxyXG4gIFpzM1paeDdlL3lieUNjcHJCUkY1Z0hnZjFzN1FxRFV1KzZwTitvZU9JY1MxT3ZIOWllUS9mOGZxZnVFTHB4Y0ZCck5YTWhWeUIyWDFcclxuICBIdUYwK0pSeVdta3M4cFFuRmhhY3N2TXo3cHVvRTk5Ty9ZZ3Y3UVhFWVVNZTB5WXc2cGphNUZ1YmNoVTIxN3dIRXg3cTZzUEFuekR4XHJcbiAgWDRldjQ4enpLUENqUFBVMTdZQnRNd2M1NVYzdmVOekpXVmVENUI3aVRSdE0zanhUT2lEZkF1eXNUVFpacDl6UEtWWmZjOHZtSjFObVxyXG4gIFNRejNWZ3EwclhxYWgrMkt1TzJiTldnVHpqajd5TkozMlZpekNyejk5bnVhSlYvMHpPWWIzN3k0SEVjd3p6ejNzUHplWW1iWWk3NTFcclxuICA3RVFLQlE4NkF1TEQ1Nk1CdGdJenhkeHRHalBRZ1RNdG5qVWw2SE9xbUtWZEtrU0Q5QmRtdXVnMXlrdGI0ckY4djlFTXVzcWZrd3laXHJcbiAgZy9BOFNWcjhtUFVSVm9aNGlFOWVJWEdIWlRFcVR1OE1rczVTZU4zclZpNDJpeEtHa05yOXVEcnd6cDgvZ25HcmtMdnV2cnZzR1FEdVxyXG4gIGhPc3h6NUJ2TWdqWVdnU2EvT1F2RDVCckNBbURpSU5NYUFUeVJKMVYrbzZjZmVaelZpOHpMTzdDczkva0hhR21PRytaTWtXeVVqc2dcclxuICB1eUx1VG1uay80TTdmcndvTHlRLzNtTUgxT1lhNWdaUzkwa2orVE9RM3ptbE1CSEJ0ZllzUC9KSnNjR2tBYS8rYjFPYVlIWTdPMnRGXHJcbiAgZStEUGFrSGNveURkcE5jbEhQNEJzelQyb0loN1dKeUlNOVlXSlFQb3h1T1p0bHpzczQwakhwQ3dhZVA2NzBvckxWT0V4YzdKeUw2UFxyXG4gIFVSQXU0YnZYcHozOXlXVXZqUGFSd1Q5V2N5ZUJPQkt1S3l5M1daa3d2dTREaHgxK1Fya1hibTRSajczYitJOXF4N2p3SDdSVGRVUFJcclxuICB3OWhmeXkrQ2ZmZmVwbGxoaFpjV00rNFhYZnlENWtNN3ZMMmRJRnpZUGwvUVRsUisxOHcvM3p6TjMrNjBucGxKUEhiZGVZdG0vVGRPXHJcbiAgZGpMaWc0NkZCVDZLeW1PUEI2Z3Zzb3ZEdlY0dTEwdElIN2RlY3M3dXlZWFFsWVgwM0diT251SSt5RzBTakl1TFlEcjdHeWFKcy9iSFxyXG4gIHhIUzBhcmgxVDV3YmhUb2U5NUVOY0pzMEw3NEQxTjhpYm1DMnplQWh6YUhhenlTZ2dFQXQ5a3ZISHRCblZTWmZybERmQjNHek44UnFcclxuICBDMy9ZckpvU2dBMktZUS9WeUVBQk1TTUMzSmtIV1d5eFJjbzU4VFZMS1cyd1RwODdOcHhWWmZJUnYwa2o3dE5oVDRFd1AyemJDcmxJXHJcbiAgbmlIeHhmQmowcHVrdnJ0eDVCcDRWcDV4dHVHZzN0T1Z1R0prMUQxd255NEx6SlY2cnNsazhsYS9tNDdNbzR1Y1ZmS1pRNCtmcFY3RlxyXG4gIDI5M2ZVUXZTNXdheTU0UGduT3BFeUlYVjRpQzV4MHYrK3dYTmR5ODZ2dHd2L3B3MTJ2dmptcTNmZTBDejZLSXNEWi9hM0hiYlRZVXRcclxuICBYSnQ0cHp6anBOQko5Nms4NkZZZ1lJYkQxSEk2bU01cmxtTW1kdWhoeC9mZHpaSXlpK0lXdGhJNHViRHVwTk1CYysvblgvRGR3bGJRXHJcbiAgZURJRHF4c3BvZDJhYTc2cVAxdmh4MHpGR1JQamtQZ1NKN0M5WkxiLzNlOWQyYng2U3IyV3Y2US9DdkVuUHV3c2NYNi83V0MwWE5aN1xyXG4gIDdVcDlTN1BlajRvcjc5VWI0c0hjZVBKSGFZQWE3cmo2OU41ZkhCa1E4MGVNWHI3TVVzVUFvT2Rqanp1anNKN2tyWjcxRFFPVjMvRHJcclxuICB6ZElYZitiVG1uZHR0WGN4T3BpNkZCZUNvQndNRzhLUHJ2bDVJY2lFb2d3b0FuVnRjZkFuWCtYYS9oMFI0QlJKbG5wdnVNSE8zYWFvXHJcbiAgMnlxL25lL2dGTCsxMTE1aGx2cDBMMDd0d3I2TXdIc1RIYk5iZVlPRVV6OVlqVlpJOGw3cWFDcStjZEQyblgzTlJwUjRoUlV2NVByS1xyXG4gIFZ5N2RyOWR4ZFp2MndjNFhvNVB5NFRseHlaOTdPNnpIN2JKT1hBaDB2Z2x3WTVCUTNOeCsrOXZyQ3d1UGl2UW84SnQ0WENIbS9BSHhcclxuICBZWC9LT3l1NURUYVkvTnp4ZW93dzhWcCt1ZDdFTVRhM2FDWlM1K2FQYkxIMmYwSEgydk9jNEMyYjd0aGMxaEpYUURneW5YbjR2SU9KXHJcbiAgQjZMeWpmUC9wNnpRdGV1Ly9PV3Z6ZlhYMzlaY2R2bFAyL3A4ZER0aCtVbnJmbHZ6MTl0bm5tVkRsdmJsTHgwNFV1dXFpOUhTMkFjd1xyXG4gIHR0dDIwMzREMFRBK3N0K1I1YjZlNFhIM1FZTzRCM1B5Y1Zkc2w0WDJvTlFOdDc0NkV0VXl0czRQc3lyZFBJeUN6aFAvVkhMaDZVOTdcclxuICA4aXhsU25xVGdGK0RFdjkyOW51T0ZrbmVqNHJMZTFCdnlwVm5ZY2hWUVB3Z3pqcWZYUWlQRFZYNzZ3Nk80VmVMMDRsMjhUZEplZG5TXHJcbiAgWWlDd052T1JjT3R2dU4wc25jUktGSXNFbENrYWRJT0FuWVIxWXpBaFBNYW1jVjQrdG1LOW94NS9IVkpIWU1OYTJIK1Erc1pLU1RrQlxyXG4gIHE5VTdkVVJBV3NjeEtlUkYrTFJ4ZTF6RW43aVNGai9qSUc4SkYyV0t1bjVvTnZXZTV5azc5RWVoamdzU1QrMW1zSWR3R0VZaDhYWGpcclxuICBaUUVncXhZVEJxQUU0L1MvU1hId3dWL3MxNCsyUjh1eWk5aHM0MDhlNHQ4bTNFbnFkaEpnWGRrL2xNRWE4WWlNYXRCdWMvajBwM1lxXHJcbiAgYmRWaFVsdTlaNS9tYlc5OVhUdWhza2ZwUDVvRFAzNWN1MXE2dGUzNzJMUXpWOVlPT2h0VXhsRjRVTEt3Z3BwRkJXbEVQbmI5OGVLT1xyXG4gIERlSE1FRWQ5QmwyLzB3R0IxTVVYTStnMnEycnZKTmRKMFBWckQ0S3psZW5JRStMWCtUYWdqZnY0NUJEdmZjL0cvWGdIMVJOTWtqODhcclxuICBidXFLNHNCMllnU3lXNC9UcVZ0K29mWWZONGg3ekZCa3Y4OTA2ck1MY2RVckd5cTZOdkVoSUNIMk9jSVlwRHR1ZHBZNmpQWGRQQnV3XHJcbiAgcFpPQk8ybk9idDZERTA4NnU1MjUvNjZzT0Y3NHdtZVh3VmZjM1hnWklXV1NmOUx2QWJRTnFTQW5ycFRGZC9mOXVhZitjeDJGaEEvNFxyXG4gIGoyWGErdDI0ZUFMc1JvZDNKZTJvaUl2VHVSNzEwUVYvdit2dWRvV3d6RlRJOFVoZkU3NXV4N2wzVExLOVRIVzU4NjUybXh0NHhKVFdcclxuICBWWmQxTlF3MnUxNTF4YW5sZnRYWGJOR2NmdXFuMm5aM1dVdUV6bXBPLytyNXplMjMvNlY1eWxNV0tpczhRbmNtZXNqOEdGaWNMaDdVXHJcbiAgQkFUcWoxdnpITTg3LytKeXloL1VmdXFOZWtIOWZycXdtV3VsRldjMTkrRWU2bWYzU2NmZ1A2bVFDaHZpTFpVUUxuSFhSSVFLNWJCZFxyXG4gIDNsM29kQVQxeVJ1ZU0vVSs4U1NmU2NPc21tNzVPTENDYTdZL0NNb00wNjFmZVREWWRnODBpbnNkWCtxMVZ1V2VHNkRsWkY4SWhBQk1cclxuICBGMmJSOWNwa2JzSXNtMklDSkcrSXVlTnl5VzVxUXBKdm11ZFI0RGUyc3lCdG9vN0w3Tlp1ZXl5eWNYRW1iYWpqaW52WGJWeDhZUFZuXHJcbiAgVmQ0TjU2cmR6cnBTR3IxNWNSRFNwaEJlTENCeFhYb3B3clJFZng5S1BXNGsvZHB0YnVCWi83bDY4L09mOTg2Vm1XU2dwbHp4d3grY1xyXG4gIFdpWXZDT3BoaDUvVUxMMzBjNXZ2WFdxdjBtK2JFNzU4WHR0WDV5M2ZOaHBiVmpObm5YbFkwZnFiTGg2VU1wQWF0U29wM3JrUHFPTTRcclxuICA3QVpQMVR2UFByQjdmSEt6VHVxOFdkcldjVXdYTkdaNlFybWU3U2dkUzdxZUkvUHdiUFd6MWxxdktqdVRvLzQ3U1pvMlU2Vk1JQXhaXHJcbiAgaUVidC9yTExmOVEzQ3VnWlFjQ2ZId2F6YS83NFo5NWltWmN0Mlk5YnZmUnFwTmVwSngzNG1FWklISUg0eFJlWUZUTG5NWXpRZENHUFxyXG4gIDR2em9BVWYzVGFxb0IrN1JocEdHdXZWTTdkbHMyZk5Qci8xVjBUcXI2MjEyZ0wwbnZlUWw5OVA1ajl1ek13a1FlSk1GTEREYWNLbGJcclxuICBCMEpKSTRkVCtXWllYbVEzM1B6VHR2TWZCU3N5Ry9jUXk5ajZzcW9sZ3dIaHBTMmR5eS8vY1ptMGpJc3ovbjBYNkY2OUEyVnprRmVlXHJcbiAgUjhFT2N3UGtMYmZjV2xUNGs0WXI0WDBtU0o3bmhIZ0FHVWZrVTh6WEFNS3AzTFE3clRSemdKUkIyUUZrNCtwa1V0Z3dlUEpwNS9jMlxyXG4gIEM3Yi9TUWpJNXorM1QyRjlXejN0dmMvaHpRZTMzN3dsdEE4djhzN2p2blJPczlCQ0QyOSs4OXNiMnJoNnNUMnBuWWh1OU9ZMXkwUnRcclxuICBkdkNnSnlBK1ZqMVFxR2hzQndQNVJSZGZVVlJDUVlQMTU1L2ZyZCs3VDFIRkJXN0hmZWxyeFdqYzdJQlFIUkV4MEZFbHhscHgva0s5XHJcbiAgeFAyZno1OWE3QzNKQTJLeTFGTFBLNmExSjltTElMOWtQT3hGQVRhS1BMTjljOWZmN3lweHBzTVFRdXBnVGdvY0JlSFZFZDY0ay9Qa1xyXG4gIGwrVmI3djRndmhOUE9xZWtFYmRCcUFkcHFzc3pabHpVTExEZ1k4c01QaUFuTURqVmZpZEJyYWpnK3NZM3J0YWZlVUlHSFBuWDBkVUZcclxuICB3dmZEcTY4dHA4dDVOdGdpOU5nU2FRTVBSQ2hUOHFkTlovQ252Mit3anRZZ04vWG9XdCtET0xKYVVoOXhId1ZuNGh0MG1RZFpoVUpBXHJcbiAgT3dpclYvWG1wTUM2ZlFHVzJiaEJtVjlwQytzUDRraGNkWnpPK2FlY01FbGUrVSs0THZHQTJKTHJQVStmZUFpWENVb0lpUTNMTmc3SFxyXG4gIHpYdlhxQVZIb1A2eEF6L1hEenVuOEMyMjNHcnZRanhxb2Zrb09LSjJ2NCs4djl5L1k0dTlpanJ1SC81d1c3djZ1TG81K0pEajJ2NTRcclxuICBZL1BpZGpYeWkxLzhwcXcrRm1yN0tBN0QrZWYyRG1pYkhUem9DUWhZZ2hrRU5VQi81NGZvUUlpSEQ1d09wdEdta2RwbjhPdnFHZkdJXHJcbiAgMzlsQmo0aDhyOCtYWDJlZEZjbzFqWm1lZUo3SklxU0RlSEJMSGtZQjhhQ2FhdVVVRUw2bVhPbWtPbjBhK0NSbFVXL3k5THpuUHFPZFxyXG4gIFBmWE9HeGVIc0ZmODRNZGw0MTN5TjBsZUVVbGhMN3p3dThVSW16QWdIblVpWDl4b2ZOQ2ttMFJRbWpURlMrM1lWUjRaT1RUREY2ZU9cclxuICBMbDZEcC9ML2JzcGduM3J4akhpd0ZaUmQrTUpuZ1BaY3Q0MS9KcVJsZ29NL256VGxYMTRDTTF3R0xETVlVVWM5NFlTdkZ6L0NKTy91XHJcbiAgYVJzNVA0VXczNnIwK2M5L1ZxbWZTY3JpTkQ5cHpUanY0aEp1NFNjdVdEVHI3SHkzVXBkWGNVbUhMU3g3cWRTcHRqNEt3dkVYUWlhOFxyXG4gIForN2dPVmRjQVBLS2NWREd5d2FvT3F1anhDdWVHMi84NDlTWko3TkhQTVNiKy9TaldJbU9XL2RhdjV0YldHS0pkUXJod0FOQVBNWVJcclxuICBFQ3ZHODg0NXFveHJWUFVkeWIzSUlrOW9mblROcjVycnJ2dGRjKzZNLzJzSjdsUExwTnErSTlCM1RqbnBFOVBTdXVyaVg0S0E2SkFuXHJcbiAgblh4dVh3NmcwZnFnT2xFR0NYREZKN2VSTHF3c2ZvTjB5a2s2M3lBSWUvUE50elV2Zi9tU0pmMjZzZGRYRFkzd2sxVlhhU1d2NDRCNFxyXG4gIGFOQjFua0ZZWlJHdjVUU0xxYzlhdkxjN2VGeDV2TE1pWWxJOXNxSEVmMzI3Z3ZEZU12Nk1NeTRzOS9QTys3RENCaHNIdTVtVnk4QXVcclxuICB2czhmYzJvWkxHaFdZVFVTUWhMODh1T3Y3cnZmWXhEeTNoVXhpYWFhWjJWTngxNTY2ZWNYb21HVkp0L2VoWGdBZjZtZmdEL3Z1Y21MXHJcbiAgODZTZDYrSFpPOGo3WVg4bnZOSEFjaysxL0tLTHJpaUUwcmRETkp4YkhiYVdXV0FHNnVRSHFOZW1MZnJUK3ZJKzVRaDd5dDlHTW14T1xyXG4gIHJDdnNrM0dvOHgrN1ZPTEZuc0h2cDdsa1JXTHlwVTc1ZDZiMjJtdS91bDhIdzhCdjh1aWY4Tm9VT1YwMkZucFhYOGRCSFBhR1VOTS9cclxuICA0c2lUQ2l0VTJIeHJFQSs1aHpSc3FBdmJjenBJK2NnT1h2Q0NaNWU0cFFIU1ord1U0azhlM0tlTWN3dHZmOGR1emZmYnRxc05aQVV5XHJcbiAgRG9jZnVsczVzNFpzNlBWdi9FQnp4R0c3RjQyNHUrKzZxOWwxanlQYXRvemQvWk55VmcxUUZxSGV6bHIxbkdET0diUVBFRkRyTmJoMlxyXG4gIDRjUFc3dGxYQUFZM1dsa0J2MlpOc3d2aGN6SWVwR0VOdWxyMkpoL2NCdVY5RU9UWlNnUU1TQ0Nlek1CdGJpTGFNY2dyeXlSeEc5aUZcclxuICBOeGlMazM5eFhmTGRLd3RCb3Fwb01CRFhxTFBXYTRqUFgxeit0TC93MHdrZ2svK0FhcXZWVHNvd0tXSVRUVGpBL3hiZTBicnVzMG51XHJcbiAgRTUvOFFyL2VYY0U5ZWNJTk45NWNqa25OKzBDWldVaU9qcjEzNCtyUldkSTJxRVk0aVQyQVNCcmdveEdFa0tobkNIc3VBeTN3WXo5TlxyXG4gIDhkdit3WGVreHc5WVBmeW5mdU5uVXRUeDVwdW16U3N2eE01YlpIdVRxTDd5enk5RmxzUWZlR2R5WjdXcEhMWHdleHh5a2lCZ3M5a2NcclxuICBGOVIxbHZpVVpickM0TVFEN21seVJmTU9FS2FvV2dmYWd2UnluVnZZcDQzdjZIYkNrWUY1c0pMdXJOaGh1N2VWaVJscy9kNzltak5PXHJcbiAgUDZTNTRvcWZ0djMzNm1iYkhUN1JUbGp1S2ZtUE9PNjViYnNuMy92SVB1L3JPY3dCSHZSYVdEVjhZTnBKbVNuNHVCbGNuRWVCeUFCK1xyXG4gIE9mNGxFTzZhc2RjSEg5WGhaZ2ZEZHFwM3RVUHFLOVNIWm8xRE4zeXVlTUFHcnV3R2pzWkluYzRvREN1N2ptbkFjUlZYa0VGb0hNaVlcclxuICB6THhaREFEcDFPaW1tZnpPN3Jlbzh5alA0b2hiNm12VVBZeDZOd3ExWDV2cW9nN0tyYjRTL0ZzTjE3dlFyUXFvaDhzejdUc0tFMWFJXHJcbiAgM2s4WDRoT1A3NjhkK0ZaV0dIWi9CMWhnMUhWVHg3MTh6OU04OTduL1VRYlNTZEFMMDRPVkVCWktWTHVoTG5PT0xaZ0VCbkhjQmVmS1xyXG4gIGJMelIydjA0dWxkdDY4MGJNaG5VNjNmVFFlSVlkcC9yMmVkOHB4dzVYYitiMDNHaUMvR3V0UEptaFYxbHJLZXlPMjV3WG5uRlpacHpcclxuICB6Kzd0Z2NPT1B1WUxYMjIyYnduS05kZjhzbDJOM05uc3QvOXh6USt1dktKWXh6Yk9nVW4wMTg4NGRLU0ptVW54TDBWQW9QdFJ1dzBoXHJcbiAgcUorMzNmNkFXZmFHd0p3MmpzU2ZVLzNpQm5pMTVBMUp3K3cwczlLVFRqNW5yUFhUSVBGbGdFeEhDNmhZemovL1RMYkdOZGY4dkFnZVxyXG4gIEo0RzR4UnVpWWViTHRsaTB3bWEzYm9TRmhQZk1vbkp0K2lKK29FNm4vbWF6QStHWnhXQkNJMlZMMndBRXpoa2VVWFUyVThZU3NISXlcclxuICBNTWJmT0dRbEI0bWZZTjhNUEdWSVhPNlZWMTZDT1MxalhiYTQxU1pOSVBuSVBkenl4eisxeEdiMEdSdEJ3bURoME42Qzd0Nlhidnd3XHJcbiAgYWRtU3Y1UWx6N2xhMmFuVG1lNXpqM2lrZlhldlVPY0RFbVp1NEdIenZyQVFqZXozR0FjV0FYN3p5eG5OazUvOGhOSk9kOXZqTSsycVxyXG4gIFlwc2lDNlA2dStZNjJ6UTc3N2hwTWMvL3VjLzM5b1VBNGZwZWUydzk5VFJuK0pjaklGQi9jRnBSQkxoQVF3aDFodG9PanhrZXdYdDNcclxuICBzSUk1YVNEZGxZZ3Jka25QQ3Vpc2pUVitvSjd0VEFJc0dvZmlHT1N4blBDQm1YZW10WlA0WThPblBzOWdIT3pPcnM5UG1KdVFyeHJkXHJcbiAgdWpkd3hBMVI5YTBNSlBqZzllYXh1UUZ4UWI0UlNCOVlvMFdJSWVtUkVWZ2xkRkdIQjg4cFo3NHh4Ri9pbTFPSWF4RFJpQnZVNzcyelxyXG4gIE1xTHA4K3BYdlhTcXJpYy9lejV0eXA0cWJEaHF4aXdiaUpkSkdHMVFPalliUHYvNXp5d3JrVW5MS2c1SVB1dHJrR2Z0UFBLazZhS09cclxuICAwMTRhaDB4QnlwWnJ2WitNY0I2QkJDcjZOcHZPTFRqemhud01FSkJKV0ZjLy91RlhpeGtpMkdXM2c1c1A3L1dlb2hUaExKTDNiUFB4XHJcbiAgWnVHRjV5dDFkTlRSSnpkM3RPM1ZHSUdGZXRDQkh5eGg1Z2IrSlFtSXhsRWY2cExHTU9yZUlJSEFVR1dkYWZwZzV2dlpSYzRRb1NOdVxyXG4gIGMxWWFicjJMdmo0WE80MTZPcHNOSVdGWjNXUkcyaUgvajI1WE9UVTBvbGh4blU3WkVEU0RKbllDY3djT1N3S3o4dFZmczJ3WlFBSnhcclxuICBPdXAzdXNJNW0rSUlBVUhlYUI2dHMvWUs1Vm5aUUw3ZEcvQU03SFR2b2E2M2Z6YllYYnZxcXA5T1BjMEszOWNBZWwrQnZHSFp0cDJuXHJcbiAgN1BaL21Bd3RzTUJqK3V5bjFCMVpEN2xiV0p5elUyY0pRNDVCdVNEZkErcDdxMGtzMUdEU2RCSi80Z25paGxoRUVEL1Q3NXl0UEdpaVxyXG4gIHBaMmxUM1JQRzRYNmZtNk1DelhzOTlpbG5jQWloUWJqU1lUbW4yaUpRR1JUZSs1MVdMdnFYYm9RYzkrWFJlWFRUdjlXTzZGY3JQbllcclxuICBnWjl2L25ibm5VVWdqOGlmOU9XRFNwaTVoWDhKTGF3dUxLc0phalA3Y3RVQXVFZTd4VDEzamNFVnV3SVJvZjdwWGNMbC9leWlsL2FsXHJcbiAgWldCSkk4UnFldmU3Tml3YjhKWjk1ZExsN1BLOFN6N3hxaDNjRk5iV09BaGpWa3dkV1J6MCtibjVHK0FKUnEvNzdmVWxEUU13RFl4SlxyXG4gIGdYV2wzbDc3MnBVS1MweVpQQlBjMmJUWUsyT3YwN3ZhRk9icVAybmQyUlFId2pCRTJKc2Q5OExTaUVwWllNRUZIbHUwaG53YitWQ21cclxuICAzUE16cDk5c0ZLaEpKaS9kZjQ0TCtHZUFyTzZvbzAvcTE3VTYyZllEYnkzcXJlNlZYVHZDb2lNZ2pSLzVLdUV2dmFyNHVlMjJ2eFJDXHJcbiAgazhGd0VwQkYwR2dEZlNkbm11YzU3ZGJWTTFtZmc1cklHWlArT0NSOEhVK3Uvb0I5bW8yVTNwbDQ1Y3lOU1pHd3VjOUtYMS9jZWFjdFxyXG4gIHlzVHQ3WnUvb2J3RCtiZENvY0VIeGhXVHpMa0ZkcTZjTG1qVk1RbmhnTmUwZVQ3NFV6dE5QZlhLb1gvZmROTWZpMVdJei83UDE1dVhcclxuICB2dVE1elFVWGZMZW9nOE9hN1lTTHNzcWszMk5TL0V1dVFBSURTV1lLZGNPcDNhRitwcFgxc2YyM0svZEIxLzkwMFd1TVBiMzA1Q054XHJcbiAgMXZuSy9haThqb1BCSWN0YXFPT0NMdThZUzh1MTlqTUp1dkVHTVRFaDM3R1pCTk1wUXpmdStwazExUnkzR21VSUZtNmQzd3c5ZGt6dlxyXG4gIGJQcmxPbnRNcGx2Ryt3c3ByMnRBL1pJRkF5c01LMlFXRGN6RzRlSjI5ZmJCSFRZdi9tdFcxZHhBOGxEbkovZjExWGRtZ3I5Mm13U0RcclxuICA0clI2SG5aWVd3OUlvVERUVzNsWVBjWXNUdUtFbkxCSnFhRlc5ZmErN245MW1Ma0I4VVZvSHJuSE9DTHltSFp5Y04ydnorL0xETmRlXHJcbiAgOXozTlYwODd1TnpibWIvZERwOXExbDdyRmUwcTVNem1wSytjVTl6ZnZ0bnJ5dEVDMCttRGsrSmZtb0Q0UUdiTVlYWEVtQ0RVc3BHNlxyXG4gIHdaZzlmL3dUeHhSTHNVSDNqSUxaUVMrTkhoRmh4VGZtUjhTWkswU0lYcnVSejB4bjF0TWxUcTRHOWQ5ZmYxTlp4bUtmTWJIeXphbEJcclxuICBxUFk3Q2NSZlkxVERKR0NsVm90RkJkTnR4RFZ4cU92S3JOZ3BpK1E2M0dqZlBmT1pUeXRhVEo3SElYSGwvdjVBeWhKQ21QeFF1ZFRlXHJcbiAgZ2tGNXJjczRpR2g0UDd2RXBJNjdtemE1bUZWUDdSNFE1bG9oVElySTQ3cnhKTzdCMSttenJDRGh1L2ZwS3prZnlEdncvcDlKUENCQ1xyXG4gIGM2eXJTVllmVExkZi9uOG5WMXFtUGZhNFB1eFFLWEtQUlo3ODJHYVpaVjdZdkh2ckR4ZFRSZHUrLzYxbDlUampuS05LbUxtTmYwa1dcclxuICBWbUM1Um5pODFGTFBMYzk0N0JxRlRvWEhIdHRWL0ZudWN6Y0EwVFgvOEw2SDl6Y2pZZE5ZUnMvSjhrL1lYaHhQS1lKZ0tyc1pOSG9kXHJcbiAgbzhlNnd1cVNSeHVZTkF5enpmcjlKRkFPV2tBMm1qblJEbWdYc1llRFAvNmQvNzJzdDBHcW5jMjY0cHZLMHltbnpKaEl4Vkw4WldCYVxyXG4gIC9yLzdaNU9BZk11bjR6VVJhSDdZdnFJNHdCMVlDcDFrdzF2Z2dCdmw5amQ0QVBWRGcrd1gyNEZYR3N5dHJMdnVpdTBzK1B2Rlg4MytcclxuICB5TFdHOW9CbGtmbzBnS3NML3ZMUE8vbjJUTjFWL0xXZllmOXUyTnE5ZGdNc0JtZXlwSDdrMXpFQXE2KytYR0ZqSmx6OEp5eC9jZjlWXHJcbiAgUzB5ZDY4MHNUZGhaM3F1YjVHVVMrSDQyVDFJd1NiM1ZhY21qdWplVDkwemU1bXdVYVdwSDJHZVRRRHlzUUx5bERXTmpyek5Qa2s3U1xyXG4gIGhMang3K3FRcUdVbU9FK25pNFR2M29kQTJOVDZwZzE2ZTEvQSs3eURPc3pjd2lNZnRYUnpWenZvKzFhVHNxOE8rOHh1ZlpZYnVjZXJcclxuICBXMEpLTGdsbm4vUHQ1dHByZjl0K3Y4V2EzZlk0cE5pRHN6R1k0UHo0NDJidWRadmJtRDBWaGdjUjhQcHBUQVE2VlJyS1E2ZUVjcUN4XHJcbiAgYURSQXhaWis5YTY3OTVhR2tFWTFKekJ6T3Vyb3I1UjcrejNFSjk0MFVCb2ZrTHdRR3RhTjJrcG9VcENkdlBVdDY1YjdPZzBEZWpwR1xyXG4gIDNBbFZwUmNWMzBNUE82RmN4eUhLQm9GNC9hMndRSnlwTSs3SzdDUzN1RTBYNmsrZTVaZWdVNXp5SHkycHdNd0xFTkJCb0lFa0xFMDFcclxuICBjSEpoa0RLSk4zVVAyYlU5Q2Vxd05PTUMya21nREVGWUpyVWJ0V0VycXNBZUR1OTlVNFRUUFZaV3dsbWRXbUc2VjY0NnJuRVFCOElEXHJcbiAgd21Zem9aM2o0dkZQZWR4YlpRU092cVVhTHR5a01GaUxCOXREbkt3bkorNWNJZGY2WFk2cm5nN0Nvb1hFRlFzSThxMHR4bVlkZU04dFxyXG4gIFpjcVpQM01UcTZ5eWVabTBhV2tHNEVrMHJnN1liOXR5Smc3MEpsSzl2VUhhSzY3SkJSZGUyYnp0cldzMlYvL29aK1diZ1A0L094WjJcclxuICBwNE4vZVFJQ1MzZU90clMwei8yWlgvOVd1WWMwS05CWkYxdTBaOThxOEY0SG1CTzhmZlBYTlh2dDNkdUpuZlRrd3c1MjZvSkp2MzZYXHJcbiAgUEJDUW14MU9COEpUUDNTbEh3NU1rNGhUL0xVdEtxc1A3dS9hY29QUzhXWVg4dTRmaEIxamtBdnFIZnZVUVZQdVNVRkxCcFJMV2pyVlxyXG4gIGM1LzdqTUtIenk3aTdFL2d4MW51cnBENm5IKytlNSs3bmsxNzhSdlU3V0FTUktCT1l5dnh4VHo2SUlpZkg5ZWFsUUtVQnNDcVVodWdcclxuICBMZmpOYi83ZnZmSTRYVWlEVE1ERUpla2xyNHN2enNyMFRNS1J2T1U1MStuc0s3S3IzR0J0NVM5czNPdjR1dGZhejNRZ2pIOVUxdXQ0XHJcbiAgRVV6MzJseXY3Y3dzZTl5QUxLYmVZRHczUU9OcWhpTWwybnRFZEpMOUhydTNFNFJzZ29ZTDI3WWV0V3Z0ZmExMTM5ZHMrLzRObXQvOVxyXG4gIC9xWnlWSzNqYUYrLzNzcnQrTFZJWVZuL00vRXZMUU9wVVRjTXFKL1pLbnJicHV1VmU5VGNVbGxqTWxqdi83SFBsazAzOVJuQmFZeHpcclxuICBndkF2ZS9lOXZIU3ZrTFFHdVUwSHpHTzhyRHB3cWc2ZmN3NENhUlVXMVJ5V01SQWZKUC9BelVCcHRnM1RsZk9NUStvSWIvdjV6MXU4XHJcbiAgRUJQUDlXQmhKcHJaZC8wT1V2YmFmLzErRkFiRk5TaWUzTHRDQk5Fek1VKzdFbG1vRUxVYmI4Uldtajd2djRhMHNHTnJLN1p4QjgvMVxyXG4gIHQ4OCtvR0g1blJRSXgvSlRZYUdPUjlrUVJxd1loTDkrTnp0cFFaME9wTzhNU3Q4MUt2L1ltcFFSb040Yk1yZEE0MnEzanNiVnVNR1hcclxuICBrZE52WHZENVBudlFFYzJISHJKcnVRZEM4MVZXZm5HejZOTVhhVlpkL1oxRkM4c0UwSEhOUnh6Mno1ZE8vRXZMUUdyb0ZPa2MzZWYvXHJcbiAgV3VwNS9YdXNDcnhYUEcvMnBGNjRSRHZqTy9Cei9jMUVnUDlieHpVNzZLWGZzeHJzVDNodXAzQWF1MWs1UTN2U012amxBQnV6MFZxV1xyXG4gIE15bDBFbkdGcnh6Zy94dklwWjg5RERwVmpNaUJ0TDQxMWVGbUJ5bWpGUkQyVTl6dXVPUE93cElKSW9lQ09hMWZaUVZuMzVQN2VJNVFcclxuICB1Y2RuLzEwWnNINzltOStYMDloU04wSEN1ODQzM3lPS29jR0FtaXFaa1hmMVB5dWZ4S08rdUlQSkNKUDJudk0rOS9KQ051WWdLR0Y2XHJcbiAgNXRKN1ZtOFhYbmpCc3BvWlp3RjNHSHpMeUVXQWtjdmNTN3Vibjd4ei8rbERqaXVuMVRIdUdMLytrd0xod0VaVUZ0OVRtOUsvYXRNdFxyXG4gIFNkL3hCcjI2Nk9XRkhiTjZVak1wUWhqRTYxNTgwazM2Y2EvekZGWXg2ODZKSTJxN2N3c2hIbFllWWZ1TUl4NVdFTi8reGpGOWRxYnhcclxuICA0b0Q5dHkzM3NNZGVSN2FyK29lMnE2UmxtbjMzTzdJb3hSZ25iRlNlMi9zOWh1SGZob0NBd2FNZW1IU1dkSXo2M24rZmZROHYvc3FoXHJcbiAgUW9zOXRaZzdxYzA4c0NpTEQvK0tkakNaWFloLzM0OGMxU3kzM05MOWZTSWF0Q3ZodEtzOEVmcWFuVzZ5eVRybGhEeUR3UGJiYlZiZVxyXG4gIDE0UHVKRWdIY2xVWDBVckRYdUdHNVdJRFkrMEhKdDI5UGdxSUI5dE9CbXhBUE1TdjdqT2c0S3Rub3h2WmhobHcvYzNtQk1xVHF3SFpcclxuICBkY2tYL1dkYnh3NGZ1NjRJaUZueHpZQ09MYWFET2xjNk1BQXlmMzNkZGRjM0RrQnk1b255eURQM0RJRFFFN3hmVnJTV0VQMWVPdit2XHJcbiAgS0c0NEE0UEpGQ3pFRUlmdWRYYVJkcUZlc2FqVXViSXhOV0pYdUhMWGd5elV4UFd5eTY4cHdtcmhZODNZZjFLSWs1RGNxb013OTdkdFxyXG4gICtzS0xtMHpJUkNLeUZtN3lZcmMwZGt1ZUp4WEkxOEIyMVgvQWFzTGVvclNydUxORnQreXlMNTdGelQxLzNmdTVCY2N2YjdYMWgwdDlcclxuICBJaDdZVnBPd2ZTNzczb25GNmdKRWFKN3Z3RExEajM3MHEyYnp6ZFlwR2xjbWdFd2t2Yklkano1NTBJZW1KYk9iRS96YnNMQUNEUVRTXHJcbiAgU0pneDMvWURQZjZpZ2FwbXM5ZzBGQUdyUVlEc29IN2ZqV3QyY2RycEZ6UXJydkRTb3R1ZEJsekhuWHpWdTlQcnZNNXVvMDhjdExQTVxyXG4gIGNtS1VqcnROUjRUTkFabUZYZWh6QStJSGFidkhQc2hSeERZUXJydk9pc1hkekZEOU8wd0xvVTY5MU5mL0h6T1JOZ1BmK3ZiM2k1VUFcclxuICBtd3RyOEVQV1ZRdnB1MUQzaU1sMDY5ZUt3MkNTNytQNzBmNnJ2eG5VMzI5V3Q5bFQwWVhFMTczUG1ldFFwem5JYjMwL3R5RE9WVmJlXHJcbiAgckgrbStTUUNjN2ptcXRQN0t0RldIa2hPK2p1MjN5NjdIZEhzdXZPbXpmKzJCSEdOdGQ1Vkppdk9mQ2UzalpYcSt3TC9WaXNRUU1IclxyXG4gIFdidUJ5VWZtemkzM1FFMDF6d1ozNm91Zk92allab1ZYOXpTQnVGdWltelVsek95QWVXV21Rc0s2QVBINTY4d2FEcGJXV211K3FqdzdcclxuICBQSVpaQ3N0OGcrL3NwcDA2aUdISG5DZk92WmI1ZU9kTWl2Z0hHeGF4T0dxM1NZR0ZRUXRGV0grcnVjQVpKTjdaWWF6KzRkWmIvMXhVXHJcbiAgZzVVejN5NTE3dnVRRTVBUjFBWVovOVdoM0hVNzltd1ZvVTRNUEd1c3NYemYybXI4bWdHRDJTcjJpUE1pZkZ2dTZsTjdNdk1YNTNUYlxyXG4gIGxOay90VnpoeEdsMmovV2FGWVU4dUxMVjlMT2Y5V3pCTVluamhFa3JwTWlvcGd2eEpnMWdGeTRXbjcxanNRQ1NKK3dkcTB4SW5pRHZcclxuICA1eWJJVXBkZmJ1UEc4VTFXSHBPbzZzSUp4eDNRdHYxZXZtakRNWXhZRTQ4UGJQZUpadi85dGk1eWpqWFdmbGZoWGxEdmZVSzcycHliXHJcbiAgY3NSSkVIYmN2eFY4REEwdDBJaDBzTndmODRYVHl6MTQxcmlBdnI1enQ1M2dGdWhzMGVxYUUvUWE4ajhLb1FDTkcrVFZmZmFrZU1ZQ1xyXG4gIGtDZURmUHhCOGpsZDlFNXdteFhpOGplRGcrUURkUGFZQUkrLzZZQUdsYkRNZmdmaWNNaVdla0NzQW1raW5JTVFnYk04MW9ObGZmMVhcclxuICBnanF5V2d4NmJhWjNqR3NOcXJiS3ozKzNIb1JSOTlob0VOa2U5MGsxcW1yWWk4TnlNUmFuOUF5YStvUjBrNy9rQWNzT0t3OWJqZHRXXHJcbiAgNzk2d3ZWNWFWaW54T3gwa0RYK1RPK2xiT1hQUHU5eW4vZHFUVkllbFdpMmM5M01iTDNucCttWEZNYW5NQS9iZVkrdFpiT0NkTytQaVxyXG4gIE5tOHppY0tPT3gvUzdMYkxab1YxK3RhMzdWeFk3SHZ2K1o3bW5udG1ybER1Uy94YkVoRFEwQXhZQVoxcERRbWN3NUI3eUZrRWx1UTdcclxuICBiTDlaT2FPYTZtTTZzdzlYKzU5ZGFOQUloU1ZyR24vY0EyNDBsOUlodkpPMmUyNTB3S2ViRnhaR2hUWGJnWVRuWnZtZjhrVTExU3d6XHJcbiAgYnBENzZhYkxHR09BclZMdmswaGNUcGVya2JUNGliSE1JUFdWSzdqUHN6MG9EM1FrcnlsL3QweFlUd1pweUlyQzFoWDFvVzVxYytxQlxyXG4gIGR3YjExRmR0U1pnTXh2dnBBcnRLT2h0dnZIWWhETzZsVDNzcDhYRnpiNExsR2l2S3ZiMHh2ZHpQTFpZVjJWM2FoaG01ZC9ZenVaSWhcclxuICBZc0c2Sjd0Syt4R083RSs0dVkzc01vZEpWeDg3ZmVqdHM3Q2ZWbGhwc3padk0vY283Ym5YVWMwNzMvN2F3djM0OUdlT0t4WWVEamw0XHJcbiAgbDJhUHRqeGQ4MHYzRmY1dENRaGdBNldqUW1aT1FDNUM1Z0EwYnNBN3MzN21BVDc3dVZQYWpuTjljWWMwM3JrQk13NUVTaU92NDB5blxyXG4gIGladDdsbEdsSFhlenlObnRFRGtTV0wxMDQvQWNMYTJBbTMveWsvczZ6NVBDckt1Ykp0Z0lKVDdsYzJCT2piZ0h5UjlDMzRXNnExbGNcclxuICBudk90WFJHdlBQOHpnVlZacDF2ZkIxaEpZRlk5Q05sTUNPcWdGdkpuZjQzM3JEMDc2VEZ4cy9Ya2ZrNEVyUHQ5NU1nU0J3RTV1SmRXXHJcbiAgVnVIT0Q4L0FEZDc3cnNrRHdtRVFueFBDa1RUejdONC9hWm5vdUtmTzZzcVVCL21kZXl5c3ROTlllWmpiQ1BGQUlpZVZleUFlSDk3clxyXG4gIHZWTlBUYlBoUmpzMEY1ejMyYWtuMy9ub2x0Z3ZXY3oxblB5VkdVVjdjdTg5dHk1eXl3dlArOXlVci9zZS85WUVCR3Fpa2Naa1g0U2xcclxuICA0WlBhMlY3OWp0RTZzSm5ya0lOM2JnNC84c1NpZHgxb21JY2ZQdGt1N25IQUxxT3BrczZuODh1RGhzOE4yOFo5NUJmQXZVYmNwd3NEXHJcbiAgc2JEZDhQSXhLRTdwK3RmNUdCUitPdWlXQmFqSnlzT2dkMkNGb1k3cWpXb0JGdGNnVmwyUXN4aHFTTXZmakQzMytUTm1hSitFQWFuN1xyXG4gIHpoL3FkNEhOampYK05MVzVzMGJrVHpIOEI4cVRldTF1U0xTM0E3RDBxSUtuN0lpVmsrZ2c0YnYxTWdrb2tKQnhhT3NmbWpveFU1bkVcclxuICBaUmJzWHR3Mk9BSnpLSGxQNVRuM1pCNEl4NlRISW5lUmVGS0dQQSs3ci8wekhaUjd4eFBJNzZTV3JxZURtbmdZWENjaEhsdTEzMnlmXHJcbiAgdmJmcFcwR2c4Zm1sWS9jdjkzRDRFYXhYM05Nc3Y5eFNoVkFmZU5Ebm16MTMzNnEwdngybmpvUzRmOUEwL3grWVI4UTNZdzk0S0FBQVxyXG4gIEFBQkpSVTVFcmtKZ2dnPT1cclxuICBcIlxyXG4gICAgICAgIGlkPVwiaW1hZ2UzMTc5XCJcclxuICAgICAgLz5cclxuICAgIDwvc3ZnPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBdmF0YXI7XHJcbiIsIi8qKlxyXG4gKiBDb250YWluZXJcclxuICogQGRlc2NyaXB0aW9uIE1haW4gQ29udGFpbmVyIGZvciB0aGUgQXBwXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgSGVhZCBmcm9tICdAL2NvbXBvbmVudHMvSGVhZCc7XHJcbmltcG9ydCBIZWFkZXIgZnJvbSAnQC9jb21wb25lbnRzL0hlYWRlcic7XHJcbmltcG9ydCBGb290ZXIgZnJvbSAnQC9jb21wb25lbnRzL0Zvb3Rlcic7XHJcblxyXG5leHBvcnQgY29uc3Qgc2l0ZVRpdGxlID0gJ0Egc2ltcGxlIE5leHQgMTAsIFRhaWx3aW5kIENTUyBhcHAgZGVwbG95ZWQgdG8gR2l0SHViIFByb2plY3QgcGFnZXMnO1xyXG5leHBvcnQgY29uc3QgcHJvZmlsZU5hbWUgPSAnZHRyby1kZXZ1ayc7XHJcbmV4cG9ydCBjb25zdCBkZXNjcmlwdGlvbiA9XHJcbiAgJ1RoaXMgZGVtbyBzaG93cyBhIHNpbXBsZSBOZXh0IDEwIGFwcCB3aXRoIHJvdXRpbmcgZGVwbG95ZWQgYXMgc3RhdGljIGh0bWwgdG8gR2l0SHViIFBhZ2VzLic7XHJcblxyXG5jb25zdCBDb250YWluZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgaWQ9XCJjb250YWluZXJcIiBjbGFzc05hbWU9XCJiZy1ncmF5LTMwMFwiPlxyXG4gICAgICA8SGVhZCB0aXRsZT17c2l0ZVRpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IC8+XHJcbiAgICAgIDxIZWFkZXIgY2FwdGlvbj17c2l0ZVRpdGxlfSBhdXRob3I9e3Byb2ZpbGVOYW1lfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IC8+XHJcbiAgICAgIDxtYWluXHJcbiAgICAgICAgaWQ9XCJtYWluLWNvbnRlbnRcIlxyXG4gICAgICAgIHJvbGU9XCJtYWluXCJcclxuICAgICAgICBhcmlhLWxhYmVsPVwibWFpbiBjb250ZW50IGFyZWEgZm9yIHRoZSBwYWdlXCJcclxuICAgICAgICBjbGFzc05hbWU9XCJmbGV4LTEgcC0zIG92ZXJmbG93LXktaGlkZGVuIGp1c3RpZnktY2VudGVyIFxyXG4gICAgICAgIG14LTIgc206bXktMTIgc206dGV4dC1zbVxyXG4gICAgICAgIG1kOm14LTggXHJcbiAgICAgICAgbGVhZGluZy1yZWxheGVkXHJcbiAgICAgICAgYmctd2hpdGUgdGV4dC1ncmF5LTcwMFwiXHJcbiAgICAgID5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgIDwvbWFpbj5cclxuICAgICAgPEZvb3RlciBjYXB0aW9uPXtzaXRlVGl0bGV9IGF1dGhvcj17cHJvZmlsZU5hbWV9IC8+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyO1xyXG5cclxuQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcclxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcclxufTtcclxuIiwiLyoqXHJcbiAqIFNpdGUgRm9vdGVyIENvbXBvbmVudFxyXG4gKiBAZGVzY3JpcHRpb24gZm9vdGVyIGVsZW1lbnRzIHRvIGJlIGluY2x1ZGVkIGhlcmVcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmNvbnN0IEZvb3RlciA9ICh7IGNhcHRpb24sIGF1dGhvciB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxmb290ZXJcclxuICAgICAgaWQ9XCJtYWluLWZvb3RlclwiXHJcbiAgICAgIHJvbGU9XCJjb250ZW50aW5mb1wiXHJcbiAgICAgIGFyaWEtbGFiZWw9XCJtYWluIGZvb3RlciBjb250ZW50IGluZm9cIlxyXG4gICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgcC0zXHJcbiAgICAgICAgICAgIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIHRleHQtY2VudGVyIFxyXG4gICAgICAgICAgICBiZy1ncmF5LTgwMCBcIlxyXG4gICAgPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtd2hpdGUgdGV4dC1zbSBtZDp0ZXh0LTF4bCBsZzp0ZXh0LTJ4bCBwLTNcIj5cclxuICAgICAgICA8cD57Y2FwdGlvbiB8fCAnJ308L3A+XHJcbiAgICAgICAgPHA+XHJcbiAgICAgICAgICBDb3B5cmlnaHQgPHNwYW4gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiAnJmNvcHk7JyB9fT48L3NwYW4+eycgJ31cclxuICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgIGhyZWY9XCJodHRwczovL3d3dy5naXRodWIuY29tL2R0cm8tZGV2dWtcIlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCIgZm9udC1zZW1pYm9sZFxyXG4gICAgICAgICAgICAgICAgdGV4dC15ZWxsb3ctNjAwIGRhcms6dGV4dC1pbmRpZ28tNDAwIFxyXG4gICAgICAgICAgICAgICAgaG92ZXI6dGV4dC15ZWxsb3ctMjAwIGRhcms6aG92ZXI6dGV4dC1waW5rLTQwMFwiXHJcbiAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICB7YXV0aG9yfVxyXG4gICAgICAgICAgPC9hPnsnICd9XHJcbiAgICAgICAgICAyMDIxXHJcbiAgICAgICAgPC9wPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZm9vdGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGb290ZXI7XHJcblxyXG5Gb290ZXIucHJvcFR5cGVzID0ge1xyXG4gIGNhcHRpb246IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxufTtcclxuIiwiLyoqXHJcbiAqIEhhbWJ1cmdlciBUb2dnbGUgQnV0dG9uIHdpdGggYW5pbWF0aW9uXHJcbiAqIEBkZXNjcmlwdGlvbiBUb2dnbGUgQnVyZ2VyIGJ1dHRvbiwgb3BlbiBhbmQgY2xvc2UgYW5pbWF0aW9ucyBhbmQgYXJpYSBzdXBwb3J0XHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBib29sLCBmdW5jIH0gZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG4vKipcclxuICogSGFtYnVyZ2VyIFRvZ2dsZSBCdXR0b25cclxuICogV2l0aCBhbmltYXRlZCBPcGVuIGFuZCBDbG9zZSwgYW5pbWF0aW9ucyBjb3VydGVzeSBvZiBKb2huc2h1LCBzZWUgcmVhZG1lIGZvciBhdHRyaWJ1dGlvbnNcclxuICogQHBhcmFtIHsqfSBwYXJhbTBcclxuICovXHJcbmNvbnN0IEhhbWJ1cmdlciA9ICh7IG9wZW4sIHNldE9wZW4sIC4uLnByb3BzIH0pID0+IHtcclxuICBjb25zdCBpc09wZW4gPSBvcGVuID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuICAvKipcclxuICAgKiBTaG93L0hpZGUgdGhlIE1lbnVcclxuICAgKi9cclxuICBjb25zdCBoYW5kbGVUb2dnbGVNZW51Q2xpY2sgPSAoZXZlbnQsIG9wZW4pID0+IHtcclxuICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcclxuICAgICAgcmV0dXJuOyAvLyBsZXQgdGhlIGJyb3dzZXIgZGVhbCB3aXRoIHRoZSBjbGljayBuYXRpdmVseVxyXG4gICAgfVxyXG5cclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgc2V0T3BlbihvcGVuKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGJ1dHRvblxyXG4gICAgICBjbGFzc05hbWU9e2BoYW1idXJnZXItLXNwcmluZy1yICR7b3BlbiA/ICdpcy1hY3RpdmUnIDogJyd9XHJcbiAgICAgICAgICAgIGgtMTAsIHctMTAgZmlsbC1jdXJyZW50XHJcbiAgICAgICAgICAgIHAtMSBtZDpwLTMgbWwtMyBtci0zIFxyXG4gICAgICAgICAgICBsZzpoaWRkZW4gbGc6bWwtMCBsZzp3LTAgXHJcbiAgICAgICAgICAgIHRleHQtZ3JheS0zMDAgaG92ZXI6dGV4dC15ZWxsb3ctNTAwICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByb3VuZGVkXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSBob3ZlcjpzY2FsZS0xMjUgaG92ZXI6Ymctb3BhY2l0eS01MCB0cmFuc2l0aW9uIGVhc2Utb3V0IGR1cmF0aW9uLTUwMFxyXG4gICAgICAgICAgICBmb2N1czp0ZXh0LXdoaXRlXHJcbiAgICAgICAgICAgIGZvY3VzOm91dGxpbmUtbm9uZWB9XHJcbiAgICAgIGlkPVwiaGFtYnVyZ2VyLWJ0blwiXHJcbiAgICAgIGFyaWEtbGFiZWw9XCJIYW1idXJnZXIgTWVudSBUb2dnbGUgQnV0dG9uXCJcclxuICAgICAgYXJpYS1leHBhbmRlZD17aXNPcGVufVxyXG4gICAgICBhcmlhLWNvbnRyb2xzPVwie21lbnVJZH1cIlxyXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgdGFiSW5kZXg9XCIwXCJcclxuICAgICAgb25DbGljaz17KGV2ZW50KSA9PiBoYW5kbGVUb2dnbGVNZW51Q2xpY2soZXZlbnQsICFvcGVuKX1cclxuICAgICAgey4uLnByb3BzfVxyXG4gICAgPlxyXG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJoYW1idXJnZXItYm94XCI+XHJcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaGFtYnVyZ2VyLWlubmVyIHJvdW5kZWRcIj48L3NwYW4+XHJcbiAgICAgIDwvc3Bhbj5cclxuICAgIDwvYnV0dG9uPlxyXG4gICk7XHJcbn07XHJcblxyXG5IYW1idXJnZXIucHJvcFR5cGVzID0ge1xyXG4gIG9wZW46IGJvb2wuaXNSZXF1aXJlZCxcclxuICBzZXRPcGVuOiBmdW5jLmlzUmVxdWlyZWQsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIYW1idXJnZXI7XHJcbiIsIi8qKlxyXG4gKiBIYW1idXJnZXIgTWVudVxyXG4gKiBAZGVzY3JpcHRpb24gT3BlbnMgYW5kIENsb3NlIGJhc2VkIG9uIHByb3BlcnRpZXMgcGFzc2VkIGZyb20gdGhlIGFzc29jaWF0ZWQgSGFtYnVyZ2VyIFRvZ2dsZSBCdXR0b24sIHNlZSBIYW1idXJnZXIuanNcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBOZXh0TGluayBmcm9tICduZXh0L2xpbmsnO1xyXG5cclxuaW1wb3J0IHsgYm9vbCB9IGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuY29uc3QgSGFtYnVyZ2VyTWVudSA9ICh7IG9wZW4sIC4uLnByb3BzIH0pID0+IHtcclxuICBjb25zdCBpc0hpZGRlbiA9IG9wZW4gPyB0cnVlIDogZmFsc2U7XHJcbiAgY29uc3QgaXNPcGVuID0gb3BlbjtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXZcclxuICAgICAgYXJpYS1oaWRkZW49eyFpc0hpZGRlbn1cclxuICAgICAgY2xhc3NOYW1lPXtgYmxvY2sgbXQtMiB3LWZ1bGwgbGc6aW5saW5lLWZsZXggbGc6ZmxleC1ncm93IGxnOnctYXV0byBcclxuICAgICR7IWlzSGlkZGVuID8gJ2hpZGRlbicgOiAnJ31gfVxyXG4gICAgPlxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgY2xhc3NOYW1lPXtgbGc6dHJhbnNsYXRlLXktMFxyXG4gICAgICAgICAgICBsZzppbmxpbmUtZmxleCBsZzpmbGV4LXJvdyBsZzptbC1hdXRvIGxnOnctYXV0byB3LWZ1bGwgXHJcbiAgICAgICAgICAgIGxnOml0ZW1zLWNlbnRlciBpdGVtcy1zdGFydCBmbGV4IGZsZXgtY29sIGxnOmgtYXV0b1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uICR7XHJcbiAgICAgICAgICAgICAgaXNPcGVuXHJcbiAgICAgICAgICAgICAgICA/ICd0cmFuc2xhdGUteS0wIGVhc2Utb3V0IGR1cmF0aW9uLTEwMDAgdHJhbnNmb3JtICdcclxuICAgICAgICAgICAgICAgIDogJy10cmFuc2xhdGUteS1mdWxsIGVhc2UtaW4gZHVyYXRpb24tMTAwMCB0cmFuc2Zvcm0gJ1xyXG4gICAgICAgICAgICB9YH1cclxuICAgICAgPlxyXG4gICAgICAgIDxOZXh0TGluayBocmVmPVwiL2Jsb2dcIj5cclxuICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YGJsb2NrIHctZnVsbFxyXG4gICAgICAgICAgICAgbWQ6cHgtMyBtZDpweS0yIHJvdW5kZWQgbWQ6dGV4dC1sZ1xyXG4gICAgICAgICAgICB0ZXh0LXllbGxvdy01MDAgaG92ZXI6dGV4dC13aGl0ZSBcclxuICAgICAgICAgICAgbGc6aG92ZXI6YmcteWVsbG93LTUwMCBcclxuICAgICAgICAgICAgYWN0aXZlOnRleHQtd2hpdGUgZm9jdXM6b3V0bGluZS1ub25lXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSAkeydob3ZlcjpzY2FsZS14LTkwIHRyYW5zaXRpb24gZWFzZS1pbi1vdXQgZHVyYXRpb24tNTAwJ31gfVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICBCbG9nXHJcbiAgICAgICAgICA8L2E+XHJcbiAgICAgICAgPC9OZXh0TGluaz5cclxuXHJcbiAgICAgICAgPE5leHRMaW5rIGhyZWY9XCIvYWJvdXRcIj5cclxuICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YGJsb2NrIG10LTEgdy1mdWxsIFxyXG4gICAgICAgICAgICAgICAgbWQ6cHgtMyBtZDpweS0yIHJvdW5kZWQgbWQ6dGV4dC1sZ1xyXG4gICAgICAgICAgICAgICAgdGV4dC15ZWxsb3ctNDAwIGhvdmVyOnRleHQtd2hpdGUgXHJcbiAgICAgICAgICAgICAgICBsZzpob3ZlcjpiZy15ZWxsb3ctNTAwIFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlOnRleHQtd2hpdGUgZm9jdXM6b3V0bGluZS1ub25lIFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICR7J2hvdmVyOnNjYWxlLXgtOTAgdHJhbnNpdGlvbiBlYXNlLWluLW91dCBkdXJhdGlvbi01MDAnfWB9XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIEFib3V0XHJcbiAgICAgICAgICA8L2E+XHJcbiAgICAgICAgPC9OZXh0TGluaz5cclxuXHJcbiAgICAgICAgPE5leHRMaW5rIGhyZWY9XCJodHRwczovL3d3dy5naXRodWIuY29tL2R0cm8tZGV2dWtcIj5cclxuICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YGJsb2NrIG10LTEgdy1mdWxsIFxyXG4gICAgICAgICAgICAgICAgbWQ6cHgtMyBtZDpweS0yIHJvdW5kZWQgbWQ6dGV4dC1sZ1xyXG4gICAgICAgICAgICAgICAgdGV4dC15ZWxsb3ctNTAwIGhvdmVyOnRleHQtd2hpdGUgXHJcbiAgICAgICAgICAgICAgICBsZzpob3ZlcjpiZy15ZWxsb3ctNTAwIFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlOnRleHQtd2hpdGUgZm9jdXM6b3V0bGluZS1ub25lXCJcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAkeydob3ZlcjpzY2FsZS14LTkwIHRyYW5zaXRpb24gZWFzZS1pbi1vdXQgZHVyYXRpb24tNTAwJ31gfVxyXG4gICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgR2l0aHViXHJcbiAgICAgICAgICA8L2E+XHJcbiAgICAgICAgPC9OZXh0TGluaz5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuSGFtYnVyZ2VyTWVudS5wcm9wVHlwZXMgPSB7XHJcbiAgb3BlbjogYm9vbC5pc1JlcXVpcmVkLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGFtYnVyZ2VyTWVudTtcclxuIiwiLyoqXHJcbiAqIEhlYWRcclxuICogQGRlc2NyaXB0aW9uIFNpdGUgSGVhZCBtb2RpZmljYXRpb25zXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcbmltcG9ydCBOZXh0SGVhZCBmcm9tICduZXh0L2hlYWQnO1xyXG5cclxuY29uc3QgSGVhZCA9ICh7IHRpdGxlLCBkZXNjcmlwdGlvbiB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxOZXh0SGVhZD5cclxuICAgICAgPG1ldGEgY2hhclNldD1cIlVURi04XCIgLz5cclxuICAgICAgPHRpdGxlPnt0aXRsZSB8fCAnJ308L3RpdGxlPlxyXG4gICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PXtkZXNjcmlwdGlvbiB8fCAnJ30gLz5cclxuICAgICAgPG1ldGFcclxuICAgICAgICBuYW1lPVwidmlld3BvcnRcIlxyXG4gICAgICAgIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSBzaHJpbmstdG8tZml0PW5vLCB1c2VyLXNjYWxhYmxlPTBcIlxyXG4gICAgICAvPlxyXG4gICAgPC9OZXh0SGVhZD5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVhZDtcclxuXHJcbkhlYWQucHJvcFR5cGVzID0ge1xyXG4gIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgZGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxufTtcclxuIiwiLyoqXHJcbiAqIEhlYWRlciBDb21wb25lbnRcclxuICogQGRlc2NyaXB0aW9uIFNpdGUgSGVhZGVyIGluY2x1ZGluZyB0aGUgTmF2aWdhdGlvbiBtZW51XHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XHJcblxyXG5pbXBvcnQgTmF2QmFyIGZyb20gJ0AvY29tcG9uZW50cy9OYXZiYXInO1xyXG5cclxuY29uc3QgSGVhZGVyID0gKHsgY2FwdGlvbiwgYXV0aG9yLCBkZXNjcmlwdGlvbiB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxoZWFkZXJcclxuICAgICAgaWQ9XCJoZWFkZXJcIlxyXG4gICAgICByb2xlPVwiYmFubmVyXCJcclxuICAgICAgY2xhc3NOYW1lPVwic3RpY2t5LWhlYWRlciBcclxuICAgICAgICAgICAgICBiZy1ncmF5LTgwMFxyXG4gICAgICAgICAgICAgIHRleHQtY2VudGVyXCJcclxuICAgID5cclxuICAgICAgPE5hdkJhciBhdXRob3I9e2F1dGhvcn0gLz5cclxuICAgICAgPGRpdlxyXG4gICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcGItNSBmb250LWV4dHJhYm9sZCBtZDpmb250LWJsYWNrXHJcbiAgICAgICAgICAgICAgIHRleHQtbGcgbWQ6dGV4dC0zeGwgbGc6dGV4dC00eGxcclxuICAgICAgICAgICAgICAgdGV4dC13aGl0ZSBcIlxyXG4gICAgICA+XHJcbiAgICAgICAge2NhcHRpb24gfHwgJyd9XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTMwMCB3LWZ1bGxcIj5cclxuICAgICAgICA8c2VjdGlvbiBhcmlhLWxhYmVsPVwiRGVtbyBkZXNjcmlwdGlvblwiPlxyXG4gICAgICAgICAgPGgxXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1kOnB0LTUgZm9udC1ib2xkIHRleHQtZ3JheS03MDAgaXRhbGljIFxyXG4gICAgICAgICAgICBmb250LXNhbnMgdGV4dC1zbSBtZDp0ZXh0LXhsIHRleHQtY2VudGVyXCJcclxuICAgICAgICAgID5cclxuICAgICAgICAgICAge2Rlc2NyaXB0aW9ufVxyXG4gICAgICAgICAgPC9oMT5cclxuICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9oZWFkZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjtcclxuXHJcbkhlYWRlci5wcm9wVHlwZXMgPSB7XHJcbiAgY2FwdGlvbjogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gIGF1dGhvcjogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gIGRlc2NyaXB0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBOYXZpZ2F0aW9uIE1lbnUgQmFyIENvbXBvbmVudFxyXG4gKiBAZGVzY3JpcHRpb24gSG9yaXpvbnRhbCBWZXJ0aWNhbGx5IGV4cGFuZGluZyBOYXZpZ2F0aW9uIE1lbnUgd2l0aCBhbmltYXRpb25zXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5pbXBvcnQgTmV4dExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZU9uTW91c2VDbGlja091dHNpZGVOYXYgfSBmcm9tICdAL2xpYi9ob29rcy5qcyc7XHJcblxyXG5pbXBvcnQgQXZhdGFyIGZyb20gJ0AvY29tcG9uZW50cy9BdmF0YXInO1xyXG5pbXBvcnQgSGFtQnVyZ2VyIGZyb20gJ0AvY29tcG9uZW50cy9IYW1idXJnZXInO1xyXG5pbXBvcnQgSGFtQnVyZ2VyTWVudSBmcm9tICdAL2NvbXBvbmVudHMvSGFtYnVyZ2VyTWVudSc7XHJcblxyXG4vKipcclxuICogTWFpbiBOYXZpZ2F0aW9uIE1lbnUgQmFyIChIb3Jpem9udGFsKVxyXG4gKi9cclxuY29uc3QgTmF2QmFyID0gKHsgYXV0aG9yIH0pID0+IHtcclxuICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3Qgbm9kZSA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCBtZW51SWQgPSAnbW9iaWxlLW1lbnUnO1xyXG5cclxuICB1c2VPbk1vdXNlQ2xpY2tPdXRzaWRlTmF2KG5vZGUsICgpID0+IHNldE9wZW4oZmFsc2UpKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDw+XHJcbiAgICAgIDxkaXYgcmVmPXtub2RlfSBjbGFzc05hbWU9XCJcIj5cclxuICAgICAgICA8bmF2XHJcbiAgICAgICAgICBpZD1cIm5hdmJhclwiXHJcbiAgICAgICAgICByb2xlPVwibmF2aWdhdGlvblwiXHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBcclxuICAgICAgICAgICAgICAgICAgICBweC00IHB5LTNcclxuICAgICAgICAgICAgICAgICAgICBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cclxuICAgICAgICAgICAgICAgICAgICBiZy1ncmF5LTgwMCBmbGV4LXdyYXAgXHJcbiAgICAgICAgICAgICAgICAgICAgbWQ6cHktMlwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZDpwLTJcIj5cclxuICAgICAgICAgICAgPE5leHRMaW5rIGhyZWY9XCIvXCI+XHJcbiAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHctYXV0byBjdXJzb3ItcG9pbnRlciBmb2N1czpvdXRsaW5lLW5vbmVcIj5cclxuICAgICAgICAgICAgICAgIDxBdmF0YXJcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC0xMiB3LTEyIHJvdW5kZWQtZnVsbCBtZDptci0yIG1kOmgtMjAgbWQ6dy0yMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLTQgYm9yZGVyLXdoaXRlLTIwMCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSBob3ZlcjpzY2FsZS0xMjUgaG92ZXI6Ymctb3BhY2l0eS01MCB0cmFuc2l0aW9uIGVhc2Utb3V0IGR1cmF0aW9uLTUwMFwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG5cclxuICAgICAgICAgICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMyBmb250LWJvbGQgaXRhbGljXHJcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0LXhsIG1kOnRleHQtM3hsIGxnOnRleHQtNHhsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0LWJsdWUtNDAwXCJcclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAge2F1dGhvciB8fCAnJ31cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgIDwvTmV4dExpbms+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmxvY2sgbWQ6bXktMiBtbC1hdXRvIG1kOnctYXV0b1wiPlxyXG4gICAgICAgICAgICA8SGFtQnVyZ2VyIG9wZW49e29wZW59IHNldE9wZW49e3NldE9wZW59IGFyaWEtY29udHJvbHM9e21lbnVJZH0gLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPEhhbUJ1cmdlck1lbnUgb3Blbj17b3Blbn0gc2V0T3Blbj17c2V0T3Blbn0gaWQ9e21lbnVJZH0gLz5cclxuICAgICAgICA8L25hdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8Lz5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTmF2QmFyO1xyXG5cclxuTmF2QmFyLnByb3BUeXBlcyA9IHtcclxuICBhdXRob3I6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxufTtcclxuIiwiLyoqXHJcbiAqIEhvb2tzIEZ1bmN0aW9uc1xyXG4gKiBAZGVzY3JpcHRpb24gTWFpbiBHbG9iYWwgU2l0ZSBIb29rcyB0byBpbmNsdWRlZCBoZXJlXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcblxyXG4vKipcclxuICogVXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSB1c2VyIGNsaWNrZWQgb3V0c2lkZSBhbiBlbGVtZW50IChlLmcuIE5hdiBCYXIgTWVudSlcclxuICogQHBhcmFtIHsqfSByZWZcclxuICogQHBhcmFtIHsqfSBoYW5kbGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXNlT25Nb3VzZUNsaWNrT3V0c2lkZU5hdiA9IChyZWYsIGhhbmRsZXIpID0+IHtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcclxuICAgICAgaWYgKCFyZWYuY3VycmVudCB8fCByZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGhhbmRsZXIoZXZlbnQpO1xyXG4gICAgfTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RlbmVyKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBsaXN0ZW5lcik7XHJcbiAgICB9O1xyXG4gIH0sIFtyZWYsIGhhbmRsZXJdKTtcclxufTtcclxuIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsImltcG9ydCBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGFzc2lnbj1PYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KTttb2R1bGUuZXhwb3J0cz1hc3NpZ247bW9kdWxlLmV4cG9ydHMuZGVmYXVsdD1tb2R1bGUuZXhwb3J0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1hc3NpZ24uanMubWFwIiwiXG4gICAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgICAgXCIvXCIsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcmVxdWlyZShcIkQ6XFxcXFdvcmtBcmVhXFxcXEdpdEh1YlxcXFxuZXh0anMtZ2gtcGFnZXMtZXhhbXBsZVxcXFxwYWdlc1xcXFxpbmRleC5qc1wiKTtcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgIiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7XG4gIGFkZEJhc2VQYXRoLFxuICBhZGRMb2NhbGUsXG4gIGdldERvbWFpbkxvY2FsZSxcbiAgaXNMb2NhbFVSTCxcbiAgTmV4dFJvdXRlcixcbiAgUHJlZmV0Y2hPcHRpb25zLFxuICByZXNvbHZlSHJlZixcbn0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IHVzZUludGVyc2VjdGlvbiB9IGZyb20gJy4vdXNlLWludGVyc2VjdGlvbidcblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgUmVxdWlyZWRLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBuZXZlciA6IEtcbn1ba2V5b2YgVF1cbnR5cGUgT3B0aW9uYWxLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBLIDogbmV2ZXJcbn1ba2V5b2YgVF1cblxuZXhwb3J0IHR5cGUgTGlua1Byb3BzID0ge1xuICBocmVmOiBVcmxcbiAgYXM/OiBVcmxcbiAgcmVwbGFjZT86IGJvb2xlYW5cbiAgc2Nyb2xsPzogYm9vbGVhblxuICBzaGFsbG93PzogYm9vbGVhblxuICBwYXNzSHJlZj86IGJvb2xlYW5cbiAgcHJlZmV0Y2g/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG50eXBlIExpbmtQcm9wc1JlcXVpcmVkID0gUmVxdWlyZWRLZXlzPExpbmtQcm9wcz5cbnR5cGUgTGlua1Byb3BzT3B0aW9uYWwgPSBPcHRpb25hbEtleXM8TGlua1Byb3BzPlxuXG5jb25zdCBwcmVmZXRjaGVkOiB7IFtjYWNoZUtleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cblxuZnVuY3Rpb24gcHJlZmV0Y2goXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBvcHRpb25zPzogUHJlZmV0Y2hPcHRpb25zXG4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFyb3V0ZXIpIHJldHVyblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9KVxuICBjb25zdCBjdXJMb2NhbGUgPVxuICAgIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBvcHRpb25zLmxvY2FsZVxuICAgICAgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZVxuXG4gIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCk6IGJvb2xlYW4ge1xuICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudFxuICByZXR1cm4gKFxuICAgICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgIGV2ZW50Lm1ldGFLZXkgfHxcbiAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgZXZlbnQuc2hpZnRLZXkgfHxcbiAgICBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDIpXG4gIClcbn1cblxuZnVuY3Rpb24gbGlua0NsaWNrZWQoXG4gIGU6IFJlYWN0Lk1vdXNlRXZlbnQsXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2hhbGxvdz86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW4sXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4pOiB2b2lkIHtcbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQScgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhaXNMb2NhbFVSTChocmVmKSkpIHtcbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIC8vICBhdm9pZCBzY3JvbGwgZm9yIHVybHMgd2l0aCBhbmNob3IgcmVmc1xuICBpZiAoc2Nyb2xsID09IG51bGwpIHtcbiAgICBzY3JvbGwgPSBhcy5pbmRleE9mKCcjJykgPCAwXG4gIH1cblxuICAvLyByZXBsYWNlIHN0YXRlIGluc3RlYWQgb2YgcHVzaCBpZiBwcm9wIGlzIHByZXNlbnRcbiAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7XG4gICAgc2hhbGxvdyxcbiAgICBsb2NhbGUsXG4gICAgc2Nyb2xsLFxuICB9KS50aGVuKChzdWNjZXNzOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFzdWNjZXNzKSByZXR1cm5cbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAvLyBGSVhNRTogcHJvcGVyIHJvdXRlIGFubm91bmNpbmcgYXQgUm91dGVyIGxldmVsLCBub3QgTGluazpcbiAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gTGluayhwcm9wczogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48TGlua1Byb3BzPikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzOiB7XG4gICAgICBrZXk6IHN0cmluZ1xuICAgICAgZXhwZWN0ZWQ6IHN0cmluZ1xuICAgICAgYWN0dWFsOiBzdHJpbmdcbiAgICB9KSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArXG4gICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgOiAnJylcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc1JlcXVpcmVkLCB0cnVlPiA9IHtcbiAgICAgIGhyZWY6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHM6IExpbmtQcm9wc1JlcXVpcmVkW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIHJlcXVpcmVkUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzUmVxdWlyZWRbXVxuICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNSZXF1aXJlZCkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldID09IG51bGwgfHxcbiAgICAgICAgICAodHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc09wdGlvbmFsLCB0cnVlPiA9IHtcbiAgICAgIGFzOiB0cnVlLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgbG9jYWxlOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCBvcHRpb25hbFByb3BzOiBMaW5rUHJvcHNPcHRpb25hbFtdID0gT2JqZWN0LmtleXMoXG4gICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc09wdGlvbmFsW11cbiAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzT3B0aW9uYWwpID0+IHtcbiAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XVxuXG4gICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnICYmIHZhbFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdyZXBsYWNlJyB8fFxuICAgICAgICBrZXkgPT09ICdzY3JvbGwnIHx8XG4gICAgICAgIGtleSA9PT0gJ3NoYWxsb3cnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Bhc3NIcmVmJyB8fFxuICAgICAgICBrZXkgPT09ICdwcmVmZXRjaCdcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGNvbnN0IGhhc1dhcm5lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSlcbiAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50KSB7XG4gICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuICBjb25zdCBwID0gcHJvcHMucHJlZmV0Y2ggIT09IGZhbHNlXG5cbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAgY29uc3QgcGF0aG5hbWUgPSAocm91dGVyICYmIHJvdXRlci5wYXRobmFtZSkgfHwgJy8nXG5cbiAgY29uc3QgeyBocmVmLCBhcyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuaHJlZiwgdHJ1ZSlcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgYXM6IHByb3BzLmFzXG4gICAgICAgID8gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmFzKVxuICAgICAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmLFxuICAgIH1cbiAgfSwgW3BhdGhuYW1lLCBwcm9wcy5ocmVmLCBwcm9wcy5hc10pXG5cbiAgbGV0IHsgY2hpbGRyZW4sIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlIH0gPSBwcm9wc1xuXG4gIC8vIERlcHJlY2F0ZWQuIFdhcm5pbmcgc2hvd24gYnkgcHJvcFR5cGUgY2hlY2suIElmIHRoZSBjaGlsZHJlbiBwcm92aWRlZCBpcyBhIHN0cmluZyAoPExpbms+ZXhhbXBsZTwvTGluaz4pIHdlIHdyYXAgaXQgaW4gYW4gPGE+IHRhZ1xuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICBjb25zdCBjaGlsZDogYW55ID0gQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgY29uc3QgY2hpbGRSZWY6IGFueSA9IGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmXG5cbiAgY29uc3QgW3NldEludGVyc2VjdGlvblJlZiwgaXNWaXNpYmxlXSA9IHVzZUludGVyc2VjdGlvbih7XG4gICAgcm9vdE1hcmdpbjogJzIwMHB4JyxcbiAgfSlcbiAgY29uc3Qgc2V0UmVmID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsOiBFbGVtZW50KSA9PiB7XG4gICAgICBzZXRJbnRlcnNlY3Rpb25SZWYoZWwpXG4gICAgICBpZiAoY2hpbGRSZWYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGRSZWYoZWwpXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2NoaWxkUmVmLCBzZXRJbnRlcnNlY3Rpb25SZWZdXG4gIClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzaG91bGRQcmVmZXRjaCA9IGlzVmlzaWJsZSAmJiBwICYmIGlzTG9jYWxVUkwoaHJlZilcbiAgICBjb25zdCBjdXJMb2NhbGUgPVxuICAgICAgdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZVxuICAgIGNvbnN0IGlzUHJlZmV0Y2hlZCA9XG4gICAgICBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhcyArIChjdXJMb2NhbGUgPyAnJScgKyBjdXJMb2NhbGUgOiAnJyldXG4gICAgaWYgKHNob3VsZFByZWZldGNoICYmICFpc1ByZWZldGNoZWQpIHtcbiAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgbG9jYWxlOiBjdXJMb2NhbGUsXG4gICAgICB9KVxuICAgIH1cbiAgfSwgW2FzLCBocmVmLCBpc1Zpc2libGUsIGxvY2FsZSwgcCwgcm91dGVyXSlcblxuICBjb25zdCBjaGlsZFByb3BzOiB7XG4gICAgb25Nb3VzZUVudGVyPzogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICBvbkNsaWNrOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIGhyZWY/OiBzdHJpbmdcbiAgICByZWY/OiBhbnlcbiAgfSA9IHtcbiAgICByZWY6IHNldFJlZixcbiAgICBvbkNsaWNrOiAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSlcbiAgICAgIH1cbiAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlKVxuICAgICAgfVxuICAgIH0sXG4gIH1cblxuICBjaGlsZFByb3BzLm9uTW91c2VFbnRlciA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSByZXR1cm5cbiAgICBpZiAoY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpXG4gICAgfVxuICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHsgcHJpb3JpdHk6IHRydWUgfSlcbiAgfVxuXG4gIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXJcbiAgaWYgKHByb3BzLnBhc3NIcmVmIHx8IChjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKSkge1xuICAgIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgICB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG5cbiAgICBjb25zdCBsb2NhbGVEb21haW4gPSBnZXREb21haW5Mb2NhbGUoXG4gICAgICBhcyxcbiAgICAgIGN1ckxvY2FsZSxcbiAgICAgIHJvdXRlciAmJiByb3V0ZXIubG9jYWxlcyxcbiAgICAgIHJvdXRlciAmJiByb3V0ZXIuZG9tYWluTG9jYWxlc1xuICAgIClcblxuICAgIGNoaWxkUHJvcHMuaHJlZiA9XG4gICAgICBsb2NhbGVEb21haW4gfHxcbiAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGUpKVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcylcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlua1xuIiwiLyoqXG4gKiBSZW1vdmVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggaWYgdGhlcmUgaXMgb25lLiBQcmVzZXJ2ZXMgdGhlIHJvb3QgcGF0aCBgL2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpICYmIHBhdGggIT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aFxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBhY2NvcmRpbmcgdG8gdGhlIGB0cmFpbGluZ1NsYXNoYCBvcHRpb25cbiAqIGluIGBuZXh0LmNvbmZpZy5qc2AuXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSFxuICA/IChwYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoKVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nXG4gICAgICB9XG4gICAgfVxuICA6IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoXG4iLCJ0eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGUgPSBhbnlcbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja09wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IG51bWJlclxufVxudHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUgPSB7XG4gIHJlYWRvbmx5IGRpZFRpbWVvdXQ6IGJvb2xlYW5cbiAgdGltZVJlbWFpbmluZzogKCkgPT4gbnVtYmVyXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogKFxuICAgICAgY2FsbGJhY2s6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkLFxuICAgICAgb3B0cz86IFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zXG4gICAgKSA9PiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlXG4gIH1cbn1cblxuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrKSB8fFxuICBmdW5jdGlvbiAoXG4gICAgY2I6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkXG4gICk6IE5vZGVKUy5UaW1lb3V0IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2Ioe1xuICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChEYXRlLm5vdygpIC0gc3RhcnQpKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9LCAxKVxuICB9XG5cbmV4cG9ydCBkZWZhdWx0IHJlcXVlc3RJZGxlQ2FsbGJhY2tcbiIsImltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IENsaWVudEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9idWlsZC93ZWJwYWNrL3BsdWdpbnMvYnVpbGQtbWFuaWZlc3QtcGx1Z2luJ1xuaW1wb3J0IGdldEFzc2V0UGF0aEZyb21Sb3V0ZSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUnXG5pbXBvcnQgcmVxdWVzdElkbGVDYWxsYmFjayBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMFxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fQlVJTERfTUFOSUZFU1Q/OiBDbGllbnRCdWlsZE1hbmlmZXN0XG4gICAgX19CVUlMRF9NQU5JRkVTVF9DQj86IEZ1bmN0aW9uXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBleHBvcnRzOiBhbnlcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludEZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVFbnRyeXBvaW50ID0gTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3MgfCBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlU3R5bGVTaGVldCB7XG4gIGhyZWY6IHN0cmluZ1xuICBjb250ZW50OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgZXh0ZW5kcyBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIHN0eWxlczogUm91dGVTdHlsZVNoZWV0W11cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkUm91dGVGYWlsdXJlIHtcbiAgZXJyb3I6IHVua25vd25cbn1cbmV4cG9ydCB0eXBlIFJvdXRlTG9hZGVyRW50cnkgPSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgfCBMb2FkZWRSb3V0ZUZhaWx1cmVcblxuZXhwb3J0IHR5cGUgRnV0dXJlPFY+ID0ge1xuICByZXNvbHZlOiAoZW50cnlwb2ludDogVikgPT4gdm9pZFxuICBmdXR1cmU6IFByb21pc2U8Vj5cbn1cbmZ1bmN0aW9uIHdpdGhGdXR1cmU8VD4oXG4gIGtleTogc3RyaW5nLFxuICBtYXA6IE1hcDxzdHJpbmcsIEZ1dHVyZTxUPiB8IFQ+LFxuICBnZW5lcmF0b3I/OiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGVudHJ5OiBGdXR1cmU8VD4gfCBUIHwgdW5kZWZpbmVkID0gbWFwLmdldChrZXkpXG4gIGlmIChlbnRyeSkge1xuICAgIGlmICgnZnV0dXJlJyBpbiBlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1dHVyZVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KVxuICB9XG4gIGxldCByZXNvbHZlcjogKGVudHJ5cG9pbnQ6IFQpID0+IHZvaWRcbiAgY29uc3QgcHJvbTogUHJvbWlzZTxUPiA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSByZXNvbHZlXG4gIH0pXG4gIG1hcC5zZXQoa2V5LCAoZW50cnkgPSB7IHJlc29sdmU6IHJlc29sdmVyISwgZnV0dXJlOiBwcm9tIH0pKVxuICByZXR1cm4gZ2VuZXJhdG9yXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICBnZW5lcmF0b3IoKS50aGVuKCh2YWx1ZSkgPT4gKHJlc29sdmVyKHZhbHVlKSwgdmFsdWUpKVxuICAgIDogcHJvbVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTG9hZGVyIHtcbiAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVFbnRyeXBvaW50PlxuICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bik6IHZvaWRcbiAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlTG9hZGVyRW50cnk+XG4gIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG59XG5cbmZ1bmN0aW9uIGhhc1ByZWZldGNoKGxpbms/OiBIVE1MTGlua0VsZW1lbnQpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGRldGVjdCBJRTExIHNpbmNlIGl0IHN1cHBvcnRzIHByZWZldGNoIGJ1dCBpc24ndCBkZXRlY3RlZFxuICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICghIXdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiAhIShkb2N1bWVudCBhcyBhbnkpLmRvY3VtZW50TW9kZSkgfHxcbiAgICAgIGxpbmsucmVsTGlzdC5zdXBwb3J0cygncHJlZmV0Y2gnKVxuICAgIClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgY2FuUHJlZmV0Y2g6IGJvb2xlYW4gPSBoYXNQcmVmZXRjaCgpXG5cbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIGxpbms/OiBIVE1MTGlua0VsZW1lbnRcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl1gKSkge1xuICAgICAgcmV0dXJuIHJlcygpXG4gICAgfVxuXG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbDpcbiAgICBpZiAoYXMpIGxpbmshLmFzID0gYXNcbiAgICBsaW5rIS5yZWwgPSBgcHJlZmV0Y2hgXG4gICAgbGluayEuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOIVxuICAgIGxpbmshLm9ubG9hZCA9IHJlc1xuICAgIGxpbmshLm9uZXJyb3IgPSByZWpcblxuICAgIC8vIGBocmVmYCBzaG91bGQgYWx3YXlzIGJlIGxhc3Q6XG4gICAgbGluayEuaHJlZiA9IGhyZWZcblxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluaylcbiAgfSlcbn1cblxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpXG4vLyBUT0RPOiB1bmV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycjogRXJyb3IpOiBFcnJvciB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnI/OiBFcnJvcik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyXG59XG5cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChcbiAgc3JjOiBzdHJpbmcsXG4gIHNjcmlwdD86IEhUTUxTY3JpcHRFbGVtZW50XG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAvLyAxLiBTZXR1cCBzdWNjZXNzL2ZhaWx1cmUgaG9va3MgaW4gY2FzZSB0aGUgYnJvd3NlciBzeW5jaHJvbm91c2x5XG4gICAgLy8gICAgZXhlY3V0ZXMgd2hlbiBgc3JjYCBpcyBzZXQuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmVcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+XG4gICAgICByZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICR7c3JjfWApKSlcblxuICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgIC8vICAgIGJyb3dzZXIgYmVnaW5zIHRvIGZldGNoLlxuICAgIHNjcmlwdC5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU4hXG5cbiAgICAvLyAzLiBGaW5hbGx5LCBzZXQgdGhlIHNvdXJjZSBhbmQgaW5qZWN0IGludG8gdGhlIERPTSBpbiBjYXNlIHRoZSBjaGlsZFxuICAgIC8vICAgIG11c3QgYmUgYXBwZW5kZWQgZm9yIGZldGNoaW5nIHRvIHN0YXJ0LlxuICAgIHNjcmlwdC5zcmMgPSBzcmNcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaWRsZVRpbWVvdXQ8VD4obXM6IG51bWJlciwgZXJyOiBFcnJvcik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChlcnIpLCBtcykpXG4gIClcbn1cblxuLy8gVE9ETzogc3RvcCBleHBvcnRpbmcgb3IgY2FjaGUgdGhlIGZhaWx1cmVcbi8vIEl0J2QgYmUgYmVzdCB0byBzdG9wIGV4cG9ydGluZyB0aGlzLiBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gV2UncmVcbi8vIG9ubHkgZXhwb3J0aW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbHR5IHdpdGggdGhlIGBwYWdlLWxvYWRlcmAuXG4vLyBPbmx5IGNhY2hlIHRoaXMgcmVzcG9uc2UgYXMgYSBsYXN0IHJlc29ydCBpZiB3ZSBjYW5ub3QgZWxpbWluYXRlIGFsbCBvdGhlclxuLy8gY29kZSBicmFuY2hlcyB0aGF0IHVzZSB0aGUgQnVpbGQgTWFuaWZlc3QgQ2FsbGJhY2sgYW5kIHB1c2ggdGhlbSB0aHJvdWdoXG4vLyB0aGUgUm91dGUgTG9hZGVyIGludGVyZmFjZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCk6IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4ge1xuICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpXG4gIH1cblxuICBjb25zdCBvbkJ1aWxkTWFuaWZlc3Q6IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4gPSBuZXcgUHJvbWlzZTxcbiAgICBDbGllbnRCdWlsZE1hbmlmZXN0XG4gID4oKHJlc29sdmUpID0+IHtcbiAgICAvLyBNYW5kYXRvcnkgYmVjYXVzZSB0aGlzIGlzIG5vdCBjb25jdXJyZW50IHNhZmU6XG4gICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0JcbiAgICBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0IgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVClcbiAgICAgIGNiICYmIGNiKClcbiAgICB9XG4gIH0pXG4gIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgIG9uQnVpbGRNYW5pZmVzdCxcbiAgICBpZGxlVGltZW91dDxDbGllbnRCdWlsZE1hbmlmZXN0PihcbiAgICAgIE1TX01BWF9JRExFX0RFTEFZLFxuICAgICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSlcbiAgICApLFxuICBdKVxufVxuXG5pbnRlcmZhY2UgUm91dGVGaWxlcyB7XG4gIHNjcmlwdHM6IHN0cmluZ1tdXG4gIGNzczogc3RyaW5nW11cbn1cbmZ1bmN0aW9uIGdldEZpbGVzRm9yUm91dGUoXG4gIGFzc2V0UHJlZml4OiBzdHJpbmcsXG4gIHJvdXRlOiBzdHJpbmdcbik6IFByb21pc2U8Um91dGVGaWxlcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgYXNzZXRQcmVmaXggK1xuICAgICAgICAgICcvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcycgK1xuICAgICAgICAgIGVuY29kZVVSSShnZXRBc3NldFBhdGhGcm9tUm91dGUocm91dGUsICcuanMnKSksXG4gICAgICBdLFxuICAgICAgLy8gU3R5bGVzIGFyZSBoYW5kbGVkIGJ5IGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50OlxuICAgICAgY3NzOiBbXSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkudGhlbigobWFuaWZlc3QpID0+IHtcbiAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSlcbiAgICB9XG4gICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKFxuICAgICAgKGVudHJ5KSA9PiBhc3NldFByZWZpeCArICcvX25leHQvJyArIGVuY29kZVVSSShlbnRyeSlcbiAgICApXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmpzJykpLFxuICAgICAgY3NzOiBhbGxGaWxlcy5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5jc3MnKSksXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUxvYWRlcihhc3NldFByZWZpeDogc3RyaW5nKTogUm91dGVMb2FkZXIge1xuICBjb25zdCBlbnRyeXBvaW50czogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVFbnRyeXBvaW50PiB8IFJvdXRlRW50cnlwb2ludFxuICA+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IGxvYWRlZFNjcmlwdHM6IE1hcDxzdHJpbmcsIFByb21pc2U8dW5rbm93bj4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHN0eWxlU2hlZXRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHJvdXRlczogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4gfCBSb3V0ZUxvYWRlckVudHJ5XG4gID4gPSBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjOiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBsZXQgcHJvbTogUHJvbWlzZTx1bmtub3duPiB8IHVuZGVmaW5lZCA9IGxvYWRlZFNjcmlwdHMuZ2V0KHNyYylcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICAvLyBTa2lwIGV4ZWN1dGluZyBzY3JpcHQgaWYgaXQncyBhbHJlYWR5IGluIHRoZSBET006XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGxvYWRlZFNjcmlwdHMuc2V0KHNyYywgKHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSkpXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3R5bGVTaGVldChocmVmOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4ge1xuICAgIGxldCBwcm9tOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4gfCB1bmRlZmluZWQgPSBzdHlsZVNoZWV0cy5nZXQoaHJlZilcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICBzdHlsZVNoZWV0cy5zZXQoXG4gICAgICBocmVmLFxuICAgICAgKHByb20gPSBmZXRjaChocmVmKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogJHtocmVmfWApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpID0+ICh7IGhyZWY6IGhyZWYsIGNvbnRlbnQ6IHRleHQgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9KSlcbiAgICApXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIGVudHJ5cG9pbnRzKVxuICAgIH0sXG4gICAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6ICgpID0+IHVua25vd24pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShleGVjdXRlKVxuICAgICAgICAudGhlbigoZm4pID0+IGZuKCkpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIChleHBvcnRzOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBjb21wb25lbnQ6IChleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCkgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKGVycikgPT4gKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICApXG4gICAgICAgIC50aGVuKChpbnB1dDogUm91dGVFbnRyeXBvaW50KSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkID0gZW50cnlwb2ludHMuZ2V0KHJvdXRlKVxuICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpXG4gICAgICAgICAgaWYgKG9sZCAmJiAncmVzb2x2ZScgaW4gb2xkKSBvbGQucmVzb2x2ZShpbnB1dClcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gd2l0aEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5Pihyb3V0ZSwgcm91dGVzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzY3JpcHRzLCBjc3MgfSA9IGF3YWl0IGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAgIGNvbnN0IFssIHN0eWxlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBlbnRyeXBvaW50cy5oYXMocm91dGUpXG4gICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNzcy5tYXAoZmV0Y2hTdHlsZVNoZWV0KSksXG4gICAgICAgICAgXSBhcyBjb25zdClcblxuICAgICAgICAgIGNvbnN0IGVudHJ5cG9pbnQ6IFJvdXRlRW50cnlwb2ludCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKSxcbiAgICAgICAgICAgIGlkbGVUaW1lb3V0PFJvdXRlTG9hZGVyRW50cnk+KFxuICAgICAgICAgICAgICBNU19NQVhfSURMRV9ERUxBWSxcbiAgICAgICAgICAgICAgbWFya0Fzc2V0RXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKGBSb3V0ZSBkaWQgbm90IGNvbXBsZXRlIGxvYWRpbmc6ICR7cm91dGV9YClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdKVxuICAgICAgICAgIGNvbnN0IHJlczogUm91dGVMb2FkZXJFbnRyeSA9IE9iamVjdC5hc3NpZ248XG4gICAgICAgICAgICB7IHN0eWxlczogUm91dGVTdHlsZVNoZWV0W10gfSxcbiAgICAgICAgICAgIFJvdXRlRW50cnlwb2ludFxuICAgICAgICAgID4oeyBzdHlsZXMgfSwgZW50cnlwb2ludClcbiAgICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiBlbnRyeXBvaW50ID8gZW50cnlwb2ludCA6IHJlc1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL3F1aWNrbGluay9ibG9iLzQ1M2E2NjFmYTFmYTk0MGUyZDJlMDQ0NDUyMzk4ZTM4YzY3YTk4ZmIvc3JjL2luZGV4Lm1qcyNMMTE1LUwxMThcbiAgICAgIC8vIExpY2Vuc2U6IEFwYWNoZSAyLjBcbiAgICAgIGxldCBjblxuICAgICAgaWYgKChjbiA9IChuYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uKSkge1xuICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgaWYgKGNuLnNhdmVEYXRhIHx8IC8yZy8udGVzdChjbi5lZmZlY3RpdmVUeXBlKSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpXG4gICAgICAgIC50aGVuKChvdXRwdXQpID0+XG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjYW5QcmVmZXRjaFxuICAgICAgICAgICAgICA/IG91dHB1dC5zY3JpcHRzLm1hcCgoc2NyaXB0KSA9PiBwcmVmZXRjaFZpYURvbShzY3JpcHQsICdzY3JpcHQnKSlcbiAgICAgICAgICAgICAgOiBbXVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB0aGlzLmxvYWRSb3V0ZShyb3V0ZSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChcbiAgICAgICAgICAvLyBzd2FsbG93IHByZWZldGNoIGVycm9yc1xuICAgICAgICAgICgpID0+IHt9XG4gICAgICAgIClcbiAgICB9LFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVJvdXRlTG9hZGVyXG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbiAgJ2xvY2FsZScsXG4gICdsb2NhbGVzJyxcbiAgJ2RlZmF1bHRMb2NhbGUnLFxuICAnaXNSZWFkeScsXG5dXG5jb25zdCByb3V0ZXJFdmVudHMgPSBbXG4gICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLFxuICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgJ2hhc2hDaGFuZ2VTdGFydCcsXG4gICdoYXNoQ2hhbmdlQ29tcGxldGUnLFxuXVxuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgJ3B1c2gnLFxuICAncmVwbGFjZScsXG4gICdyZWxvYWQnLFxuICAnYmFjaycsXG4gICdwcmVmZXRjaCcsXG4gICdiZWZvcmVQb3BTdGF0ZScsXG5dXG5cbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmV2ZW50c1xuICB9LFxufSlcblxudXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaCgoZmllbGQ6IHN0cmluZykgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZDogc3RyaW5nKSA9PiB7XG4gIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG4gIDsoc2luZ2xldG9uUm91dGVyIGFzIGFueSlbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgfVxufSlcblxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50OiBzdHJpbmcpID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5KCgpID0+IHtcbiAgICBSb3V0ZXIuZXZlbnRzLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZXZlbnRGaWVsZCA9IGBvbiR7ZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHtldmVudC5zdWJzdHJpbmcoXG4gICAgICAgIDFcbiAgICAgICl9YFxuICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlciBhcyBhbnlcbiAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgQXJyYXkuaXNBcnJheShfcm91dGVyW3Byb3BlcnR5XSkgPyBbXSA6IHt9LFxuICAgICAgICBfcm91dGVyW3Byb3BlcnR5XVxuICAgICAgKSAvLyBtYWtlcyBzdXJlIHF1ZXJ5IGlzIG5vdCBzdGF0ZWZ1bFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBfcm91dGVyW3Byb3BlcnR5XVxuICB9XG5cbiAgLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuICBpbnN0YW5jZS5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGluc3RhbmNlW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgcmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgZnJvbSAnLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2snXG5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0gUGljazxJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQsICdyb290TWFyZ2luJz5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uID0geyBkaXNhYmxlZD86IGJvb2xlYW4gfSAmIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxudHlwZSBPYnNlcnZlQ2FsbGJhY2sgPSAoaXNWaXNpYmxlOiBib29sZWFuKSA9PiB2b2lkXG50eXBlIE9ic2VydmVyID0ge1xuICBpZDogc3RyaW5nXG4gIG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICBlbGVtZW50czogTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz5cbn1cblxuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb248VCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgcm9vdE1hcmdpbixcbiAgZGlzYWJsZWQsXG59OiBVc2VJbnRlcnNlY3Rpb24pOiBbKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB2b2lkLCBib29sZWFuXSB7XG4gIGNvbnN0IGlzRGlzYWJsZWQ6IGJvb2xlYW4gPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcblxuICBjb25zdCB1bm9ic2VydmUgPSB1c2VSZWY8RnVuY3Rpb24+KClcbiAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgY29uc3Qgc2V0UmVmID0gdXNlQ2FsbGJhY2soXG4gICAgKGVsOiBUIHwgbnVsbCkgPT4ge1xuICAgICAgaWYgKHVub2JzZXJ2ZS5jdXJyZW50KSB7XG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50KClcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuXG5cbiAgICAgIGlmIChlbCAmJiBlbC50YWdOYW1lKSB7XG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShcbiAgICAgICAgICBlbCxcbiAgICAgICAgICAoaXNWaXNpYmxlKSA9PiBpc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpLFxuICAgICAgICAgIHsgcm9vdE1hcmdpbiB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuICAgIFtpc0Rpc2FibGVkLCByb290TWFyZ2luLCB2aXNpYmxlXVxuICApXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICBpZiAoIXZpc2libGUpIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gc2V0VmlzaWJsZSh0cnVlKSlcbiAgICB9XG4gIH0sIFt2aXNpYmxlXSlcblxuICByZXR1cm4gW3NldFJlZiwgdmlzaWJsZV1cbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZShcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgY2FsbGJhY2s6IE9ic2VydmVDYWxsYmFjayxcbiAgb3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XG4pOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKVxuICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spXG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KVxuICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCk6IHZvaWQge1xuICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KVxuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KVxuXG4gICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXA8c3RyaW5nLCBPYnNlcnZlcj4oKVxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KTogT2JzZXJ2ZXIge1xuICBjb25zdCBpZCA9IG9wdGlvbnMucm9vdE1hcmdpbiB8fCAnJ1xuICBsZXQgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGlkKVxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+KClcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDBcbiAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIG9wdGlvbnMpXG5cbiAgb2JzZXJ2ZXJzLnNldChcbiAgICBpZCxcbiAgICAoaW5zdGFuY2UgPSB7XG4gICAgICBpZCxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgZWxlbWVudHMsXG4gICAgfSlcbiAgKVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5leHRDb21wb25lbnRUeXBlLCBOZXh0UGFnZUNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvdXRpbHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyLCB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcblxuZXhwb3J0IHR5cGUgV2l0aFJvdXRlclByb3BzID0ge1xuICByb3V0ZXI6IE5leHRSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgRXhjbHVkZVJvdXRlclByb3BzPFA+ID0gUGljazxcbiAgUCxcbiAgRXhjbHVkZTxrZXlvZiBQLCBrZXlvZiBXaXRoUm91dGVyUHJvcHM+XG4+XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhSb3V0ZXI8XG4gIFAgZXh0ZW5kcyBXaXRoUm91dGVyUHJvcHMsXG4gIEMgPSBOZXh0UGFnZUNvbnRleHRcbj4oXG4gIENvbXBvc2VkQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxDLCBhbnksIFA+XG4pOiBSZWFjdC5Db21wb25lbnRUeXBlPEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPj4ge1xuICBmdW5jdGlvbiBXaXRoUm91dGVyV3JhcHBlcihwcm9wczogYW55KTogSlNYLkVsZW1lbnQge1xuICAgIHJldHVybiA8Q29tcG9zZWRDb21wb25lbnQgcm91dGVyPXt1c2VSb3V0ZXIoKX0gey4uLnByb3BzfSAvPlxuICB9XG5cbiAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbiAgOyhXaXRoUm91dGVyV3JhcHBlciBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHMgPSAoQ29tcG9zZWRDb21wb25lbnQgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgXG4gIH1cblxuICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXJcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUb2tlbml6ZSBpbnB1dCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGxleGVyKHN0cikge1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gc3RyW2ldO1xuICAgICAgICBpZiAoY2hhciA9PT0gXCIqXCIgfHwgY2hhciA9PT0gXCIrXCIgfHwgY2hhciA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJNT0RJRklFUlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRVNDQVBFRF9DSEFSXCIsIGluZGV4OiBpKyssIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIntcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk9QRU5cIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIn1cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNMT1NFXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBgMC05YFxuICAgICAgICAgICAgICAgIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBBLVpgXG4gICAgICAgICAgICAgICAgICAgIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBhLXpgXG4gICAgICAgICAgICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgX2BcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9PT0gOTUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhcmFtZXRlciBuYW1lIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTkFNRVwiLCBpbmRleDogaSwgdmFsdWU6IG5hbWUgfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIihcIikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXR0ZXJuIGNhbm5vdCBzdGFydCB3aXRoIFxcXCI/XFxcIiBhdCBcIiArIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXSArIHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJbal0gPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJbaiArIDFdICE9PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhcHR1cmluZyBncm91cHMgYXJlIG5vdCBhbGxvd2VkIGF0IFwiICsgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5iYWxhbmNlZCBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGF0dGVybiBhdCBcIiArIGkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIlBBVFRFUk5cIiwgaW5kZXg6IGksIHZhbHVlOiBwYXR0ZXJuIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0hBUlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgIH1cbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRU5EXCIsIGluZGV4OiBpLCB2YWx1ZTogXCJcIiB9KTtcbiAgICByZXR1cm4gdG9rZW5zO1xufVxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHRva2VucyA9IGxleGVyKHN0cik7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5wcmVmaXhlcywgcHJlZml4ZXMgPSBfYSA9PT0gdm9pZCAwID8gXCIuL1wiIDogX2E7XG4gICAgdmFyIGRlZmF1bHRQYXR0ZXJuID0gXCJbXlwiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8IFwiLyM/XCIpICsgXCJdKz9cIjtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICB2YXIgdHJ5Q29uc3VtZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmIChpIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaV0udHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnNbaSsrXS52YWx1ZTtcbiAgICB9O1xuICAgIHZhciBtdXN0Q29uc3VtZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNvbnN1bWUodHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YXIgX2EgPSB0b2tlbnNbaV0sIG5leHRUeXBlID0gX2EudHlwZSwgaW5kZXggPSBfYS5pbmRleDtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBuZXh0VHlwZSArIFwiIGF0IFwiICsgaW5kZXggKyBcIiwgZXhwZWN0ZWQgXCIgKyB0eXBlKTtcbiAgICB9O1xuICAgIHZhciBjb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHdoaWxlICgodmFsdWUgPSB0cnlDb25zdW1lKFwiQ0hBUlwiKSB8fCB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0cnlDb25zdW1lKFwiQ0hBUlwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0cnlDb25zdW1lKFwiTkFNRVwiKTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0cnlDb25zdW1lKFwiUEFUVEVSTlwiKTtcbiAgICAgICAgaWYgKG5hbWUgfHwgcGF0dGVybikge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNoYXIgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmIChwcmVmaXhlcy5pbmRleE9mKHByZWZpeCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybiB8fCBkZWZhdWx0UGF0dGVybixcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogdHJ5Q29uc3VtZShcIk1PRElGSUVSXCIpIHx8IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gY2hhciB8fCB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlbiA9IHRyeUNvbnN1bWUoXCJPUEVOXCIpO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gdHJ5Q29uc3VtZShcIk5BTUVcIikgfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuXzEgPSB0cnlDb25zdW1lKFwiUEFUVEVSTlwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICBtdXN0Q29uc3VtZShcIkNMT1NFXCIpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVfMSB8fCAocGF0dGVybl8xID8ga2V5KysgOiBcIlwiKSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBuYW1lXzEgJiYgIXBhdHRlcm5fMSA/IGRlZmF1bHRQYXR0ZXJuIDogcGF0dGVybl8xLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogc3VmZml4LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtdXN0Q29uc3VtZShcIkVORFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uKHRva2Vucywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJlRmxhZ3MgPSBmbGFncyhvcHRpb25zKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLmVuY29kZSwgZW5jb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2EsIF9iID0gb3B0aW9ucy52YWxpZGF0ZSwgdmFsaWRhdGUgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICAgIHZhciBtYXRjaGVzID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpJFwiLCByZUZsYWdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEgPyBkYXRhW3Rva2VuLm5hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiP1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIjtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbm90IHJlcGVhdCwgYnV0IGdvdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYWxsIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiICsgdG9rZW4ucGF0dGVybiArIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudCArIHRva2VuLnN1ZmZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZW5jb2RlKFN0cmluZyh2YWx1ZSksIHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudCArIHRva2VuLnN1ZmZpeDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB0eXBlT2ZNZXNzYWdlID0gcmVwZWF0ID8gXCJhbiBhcnJheVwiIDogXCJhIHN0cmluZ1wiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gYmUgXCIgKyB0eXBlT2ZNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xufVxuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbjtcbi8qKlxuICogQ3JlYXRlIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIHNwZWMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHN0ciwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuZGVjb2RlLCBkZWNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgIHZhciBtID0gcmUuZXhlYyhwYXRobmFtZSk7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHBhdGggPSBtWzBdLCBpbmRleCA9IG0uaW5kZXg7XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGlmIChtW2ldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChrZXkubW9kaWZpZXIgPT09IFwiKlwiIHx8IGtleS5tb2RpZmllciA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gbVtpXS5zcGxpdChrZXkucHJlZml4ICsga2V5LnN1ZmZpeCkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IGRlY29kZShtW2ldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgaW5kZXg6IGluZGV4LCBwYXJhbXM6IHBhcmFtcyB9O1xuICAgIH07XG59XG5leHBvcnRzLnJlZ2V4cFRvRnVuY3Rpb24gPSByZWdleHBUb0Z1bmN0aW9uO1xuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG59XG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGZsYWdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNlbnNpdGl2ZSA/IFwiXCIgOiBcImlcIjtcbn1cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKSB7XG4gICAgaWYgKCFrZXlzKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICAgIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGksXG4gICAgICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAocGF0aHMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7IH0pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XCIgKyBwYXJ0cy5qb2luKFwifFwiKSArIFwiKVwiLCBmbGFncyhvcHRpb25zKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvUmVnZXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdleHAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLnN0cmljdCwgc3RyaWN0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gb3B0aW9ucy5zdGFydCwgc3RhcnQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IG9wdGlvbnMuZW5kLCBlbmQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfZDtcbiAgICB2YXIgZW5kc1dpdGggPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmVuZHNXaXRoIHx8IFwiXCIpICsgXCJdfCRcIjtcbiAgICB2YXIgZGVsaW1pdGVyID0gXCJbXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl1cIjtcbiAgICB2YXIgcm91dGUgPSBzdGFydCA/IFwiXlwiIDogXCJcIjtcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICAgIGZvciAodmFyIF9pID0gMCwgdG9rZW5zXzEgPSB0b2tlbnM7IF9pIDwgdG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc18xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4ucHJlZml4KSk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5zdWZmaXgpKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMpXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCB8fCBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLm1vZGlmaWVyID09PSBcIitcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2QgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgPyBcIj9cIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgXCIoKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKD86XCIgKyBzdWZmaXggKyBwcmVmaXggKyBcIig/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSkqKVwiICsgc3VmZml4ICsgXCIpXCIgKyBtb2Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgXCIoXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpXCIgKyBzdWZmaXggKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBzdWZmaXggKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgaWYgKCFzdHJpY3QpXG4gICAgICAgICAgICByb3V0ZSArPSBkZWxpbWl0ZXIgKyBcIj9cIjtcbiAgICAgICAgcm91dGUgKz0gIW9wdGlvbnMuZW5kc1dpdGggPyBcIiRcIiA6IFwiKD89XCIgKyBlbmRzV2l0aCArIFwiKVwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGVuZFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzRW5kRGVsaW1pdGVkID0gdHlwZW9mIGVuZFRva2VuID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGRlbGltaXRlci5pbmRleE9mKGVuZFRva2VuW2VuZFRva2VuLmxlbmd0aCAtIDFdKSA+IC0xXG4gICAgICAgICAgICA6IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGVuZFRva2VuID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgZGVsaW1pdGVyICsgXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpKT9cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRW5kRGVsaW1pdGVkKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/PVwiICsgZGVsaW1pdGVyICsgXCJ8XCIgKyBlbmRzV2l0aCArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJvdXRlLCBmbGFncyhvcHRpb25zKSk7XG59XG5leHBvcnRzLnRva2Vuc1RvUmVnZXhwID0gdG9rZW5zVG9SZWdleHA7XG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wYXRoVG9SZWdleHAgPSBwYXRoVG9SZWdleHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBBbXBTdGF0ZUNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFtcCgpOiBib29sZWFuIHtcbiAgLy8gRG9uJ3QgYXNzaWduIHRoZSBjb250ZXh0IHZhbHVlIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBieXRlc1xuICByZXR1cm4gaXNJbkFtcE1vZGUoUmVhY3QudXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpKVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgSGVhZE1hbmFnZXJDb250ZXh0OiBSZWFjdC5Db250ZXh0PHtcbiAgdXBkYXRlSGVhZD86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIG1vdW50ZWRJbnN0YW5jZXM/OiBhbnlcbiAgdXBkYXRlU2NyaXB0cz86IChzdGF0ZTogYW55KSA9PiB2b2lkXG4gIHNjcmlwdHM/OiBhbnlcbn0+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgSGVhZE1hbmFnZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0hlYWRNYW5hZ2VyQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dCdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiAvPl1cbiAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICBoZWFkLnB1c2goPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIC8+KVxuICB9XG4gIHJldHVybiBoZWFkXG59XG5cbmZ1bmN0aW9uIG9ubHlSZWFjdEVsZW1lbnQoXG4gIGxpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgY2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbik6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiB7XG4gIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIC8vIEFkZHMgc3VwcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KFxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAoXG4gICAgICAgICAgZnJhZ21lbnRMaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgICAgICAgZnJhZ21lbnRDaGlsZDogUmVhY3QuUmVhY3RDaGlsZFxuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkRWxlbWVudHMgTGlzdCBvZiBtdWx0aXBsZSA8SGVhZD4gaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoXG4gIGhlYWRFbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogV2l0aEluQW1wTW9kZVxuKSB7XG4gIHJldHVybiBoZWFkRWxlbWVudHNcbiAgICAucmVkdWNlKFxuICAgICAgKGxpc3Q6IFJlYWN0LlJlYWN0Q2hpbGRbXSwgaGVhZEVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRFbGVtZW50Q2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KFxuICAgICAgICAgIGhlYWRFbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGxpc3QuY29uY2F0KGhlYWRFbGVtZW50Q2hpbGRyZW4pXG4gICAgICB9LFxuICAgICAgW11cbiAgICApXG4gICAgLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLmNvbmNhdChkZWZhdWx0SGVhZChwcm9wcy5pbkFtcE1vZGUpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFwcm9wcy5pbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJ10uc29tZSgodXJsKSA9PlxuICAgICAgICAgICAgYy5wcm9wc1snaHJlZiddLnN0YXJ0c1dpdGgodXJsKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7IC4uLihjLnByb3BzIHx8IHt9KSB9XG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtaHJlZiddID0gbmV3UHJvcHNbJ2hyZWYnXVxuICAgICAgICAgIG5ld1Byb3BzWydocmVmJ10gPSB1bmRlZmluZWRcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gSGVhZCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IGFtcFN0YXRlID0gdXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpXG4gIGNvbnN0IGhlYWRNYW5hZ2VyID0gdXNlQ29udGV4dChIZWFkTWFuYWdlckNvbnRleHQpXG4gIHJldHVybiAoXG4gICAgPEVmZmVjdFxuICAgICAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU9e3JlZHVjZUNvbXBvbmVudHN9XG4gICAgICBoZWFkTWFuYWdlcj17aGVhZE1hbmFnZXJ9XG4gICAgICBpbkFtcE1vZGU9e2lzSW5BbXBNb2RlKGFtcFN0YXRlKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9FZmZlY3Q+XG4gIClcbn1cblxuLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbkhlYWQucmV3aW5kID0gKCkgPT4ge31cblxuZXhwb3J0IGRlZmF1bHQgSGVhZFxuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuKToge1xuICBkZXRlY3RlZExvY2FsZT86IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG59IHtcbiAgbGV0IGRldGVjdGVkTG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgLy8gZmlyc3QgaXRlbSB3aWxsIGJlIGVtcHR5IHN0cmluZyBmcm9tIHNwbGl0dGluZyBhdCBmaXJzdCBjaGFyXG4gIGNvbnN0IHBhdGhuYW1lUGFydHMgPSBwYXRobmFtZS5zcGxpdCgnLycpXG5cbiAgOyhsb2NhbGVzIHx8IFtdKS5zb21lKChsb2NhbGUpID0+IHtcbiAgICBpZiAocGF0aG5hbWVQYXJ0c1sxXS50b0xvd2VyQ2FzZSgpID09PSBsb2NhbGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgZGV0ZWN0ZWRMb2NhbGUgPSBsb2NhbGVcbiAgICAgIHBhdGhuYW1lUGFydHMuc3BsaWNlKDEsIDEpXG4gICAgICBwYXRobmFtZSA9IHBhdGhuYW1lUGFydHMuam9pbignLycpIHx8ICcvJ1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBkZXRlY3RlZExvY2FsZSxcbiAgfVxufVxuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlcj4obnVsbCBhcyBhbnkpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiIsIi8qIGdsb2JhbCBfX05FWFRfREFUQV9fICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gsXG4gIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHsgR29vZFBhZ2VDYWNoZSwgU3R5bGVTaGVldFR1cGxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHtcbiAgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCxcbiAgaXNBc3NldEVycm9yLFxuICBtYXJrQXNzZXRFcnJvcixcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlcidcbmltcG9ydCB7IERvbWFpbkxvY2FsZXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvY29uZmlnJ1xuaW1wb3J0IHsgZGVub3JtYWxpemVQYWdlUGF0aCB9IGZyb20gJy4uLy4uL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGgnXG5pbXBvcnQgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gZnJvbSAnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnXG5pbXBvcnQgbWl0dCwgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL21pdHQnXG5pbXBvcnQge1xuICBBcHBDb250ZXh0VHlwZSxcbiAgZm9ybWF0V2l0aFZhbGlkYXRpb24sXG4gIGdldExvY2F0aW9uT3JpZ2luLFxuICBnZXRVUkwsXG4gIGxvYWRHZXRJbml0aWFsUHJvcHMsXG4gIE5leHRQYWdlQ29udGV4dCxcbiAgU1QsXG4gIE5FWFRfREFUQSxcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vdXRpbHMvaXMtZHluYW1pYydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHJlc29sdmVSZXdyaXRlcyBmcm9tICcuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMnXG5pbXBvcnQgeyBnZXRSb3V0ZU1hdGNoZXIgfSBmcm9tICcuL3V0aWxzL3JvdXRlLW1hdGNoZXInXG5pbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi91dGlscy9yb3V0ZS1yZWdleCdcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAvKiBwcm9kICovXG4gICAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIH1cbn1cblxuaW50ZXJmYWNlIFJvdXRlUHJvcGVydGllcyB7XG4gIHNoYWxsb3c6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFRyYW5zaXRpb25PcHRpb25zIHtcbiAgc2hhbGxvdz86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2VcbiAgc2Nyb2xsPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgTmV4dEhpc3RvcnlTdGF0ZSB7XG4gIHVybDogc3RyaW5nXG4gIGFzOiBzdHJpbmdcbiAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbn1cblxudHlwZSBIaXN0b3J5U3RhdGUgPVxuICB8IG51bGxcbiAgfCB7IF9fTjogZmFsc2UgfVxuICB8ICh7IF9fTjogdHJ1ZTsgaWR4OiBudW1iZXIgfSAmIE5leHRIaXN0b3J5U3RhdGUpXG5cbmxldCBkZXRlY3REb21haW5Mb2NhbGU6IHR5cGVvZiBpbXBvcnQoJy4uL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGVcblxuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZSgnLi4vaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpXG4gICAgLmRldGVjdERvbWFpbkxvY2FsZVxufVxuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgIGNhbmNlbGxlZDogdHJ1ZSxcbiAgfSlcbn1cblxuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZykge1xuICByZXR1cm4gcHJlZml4ICYmIHBhdGguc3RhcnRzV2l0aCgnLycpXG4gICAgPyBwYXRoID09PSAnLydcbiAgICAgID8gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gocHJlZml4KVxuICAgICAgOiBgJHtwcmVmaXh9JHtwYXRoTm9RdWVyeUhhc2gocGF0aCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aH1gXG4gICAgOiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21haW5Mb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGxvY2FsZXM/OiBzdHJpbmdbXSxcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIGxvY2FsZSA9IGxvY2FsZSB8fCBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlXG5cbiAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIGxvY2FsZSlcblxuICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgcmV0dXJuIGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHtcbiAgICAgICAgYmFzZVBhdGggfHwgJydcbiAgICAgIH0ke2xvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke2xvY2FsZX1gfSR7cGF0aH1gXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJlxuICAgICAgIXBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUgKyAnLycpICYmXG4gICAgICBwYXRoICE9PSAnLycgKyBsb2NhbGVcbiAgICAgID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsTG9jYWxlKHBhdGg6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIGxvY2FsZSAmJlxuICAgICAgKHBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUgKyAnLycpIHx8IHBhdGggPT09ICcvJyArIGxvY2FsZSlcbiAgICAgID8gcGF0aC5zdWJzdHIobG9jYWxlLmxlbmd0aCArIDEpIHx8ICcvJ1xuICAgICAgOiBwYXRoXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZnVuY3Rpb24gcGF0aE5vUXVlcnlIYXNoKHBhdGg6IHN0cmluZykge1xuICBjb25zdCBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/JylcbiAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJylcblxuICBpZiAocXVlcnlJbmRleCA+IC0xIHx8IGhhc2hJbmRleCA+IC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBwYXRoID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpXG4gIHJldHVybiBwYXRoID09PSBiYXNlUGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgoYmFzZVBhdGggKyAnLycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyB3ZSBvbmx5IGFkZCB0aGUgYmFzZXBhdGggb24gcmVsYXRpdmUgdXJsc1xuICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHBhdGggPSBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aClcbiAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkgcGF0aCA9IGAvJHtwYXRofWBcbiAgcmV0dXJuIHBhdGhcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSBnaXZlbiB1cmwgaXMgcm91dGFibGUgYnkgdGhlIE5leHQuanMgcm91dGVyIChicm93c2VyIG9ubHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKFxuICByb3V0ZTogc3RyaW5nLFxuICBhc1BhdGhuYW1lOiBzdHJpbmcsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKSB7XG4gIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnXG5cbiAgY29uc3QgZHluYW1pY1JlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHNcbiAgY29uc3QgZHluYW1pY01hdGNoZXMgPVxuICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyBnZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeVxuXG4gIGludGVycG9sYXRlZFJvdXRlID0gcm91dGVcbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcylcblxuICBpZiAoXG4gICAgIXBhcmFtcy5ldmVyeSgocGFyYW0pID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJ1xuICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXVxuXG4gICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWBcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gXG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdXG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiZcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9XG4gICAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUhLnJlcGxhY2UoXG4gICAgICAgICAgICByZXBsYWNlZCxcbiAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICAgICAgICA/ICh2YWx1ZSBhcyBzdHJpbmdbXSlcbiAgICAgICAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgZnVsbHkgZW5jb2RlZCBpbnN0ZWFkIG9mIGp1c3RcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBVUkwgYW5kIHdlIGV4cGVjdCBVUkwgZW5jb2RlZCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHBhcnNpbmcgZHluYW1pYyByb3V0ZSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgKHNlZ21lbnQpID0+IGVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJy8nKVxuICAgICAgICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSBhcyBzdHJpbmcpXG4gICAgICAgICAgKSB8fCAnLycpXG4gICAgICApXG4gICAgfSlcbiAgKSB7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuXG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICB9XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGUsXG4gIH1cbn1cblxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSwgcGFyYW1zOiBzdHJpbmdbXSkge1xuICBjb25zdCBmaWx0ZXJlZFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG5cbiAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWx0ZXJlZFF1ZXJ5XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBnaXZlbiBoeXBlcmxpbmsgd2l0aCBhIGNlcnRhaW4gcm91dGVyIHN0YXRlIChiYXNlUGF0aCBub3QgaW5jbHVkZWQpLlxuICogUHJlc2VydmVzIGFic29sdXRlIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSHJlZihcbiAgY3VycmVudFBhdGg6IHN0cmluZyxcbiAgaHJlZjogVXJsLFxuICByZXNvbHZlQXM/OiBib29sZWFuXG4pOiBzdHJpbmcge1xuICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICBjb25zdCBiYXNlID0gbmV3IFVSTChjdXJyZW50UGF0aCwgJ2h0dHA6Ly9uJylcbiAgY29uc3QgdXJsQXNTdHJpbmcgPVxuICAgIHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiBmb3JtYXRXaXRoVmFsaWRhdGlvbihocmVmKVxuICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICBpZiAoIWlzTG9jYWxVUkwodXJsQXNTdHJpbmcpKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKVxuICAgIGZpbmFsVXJsLnBhdGhuYW1lID0gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goZmluYWxVcmwucGF0aG5hbWUpXG4gICAgbGV0IGludGVycG9sYXRlZEFzID0gJydcblxuICAgIGlmIChcbiAgICAgIGlzRHluYW1pY1JvdXRlKGZpbmFsVXJsLnBhdGhuYW1lKSAmJlxuICAgICAgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmXG4gICAgICByZXNvbHZlQXNcbiAgICApIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShmaW5hbFVybC5zZWFyY2hQYXJhbXMpXG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0LCBwYXJhbXMgfSA9IGludGVycG9sYXRlQXMoXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgcXVlcnlcbiAgICAgIClcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRBcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgIGhhc2g6IGZpbmFsVXJsLmhhc2gsXG4gICAgICAgICAgcXVlcnk6IG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgcGFyYW1zKSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgb3JpZ2luIGRpZG4ndCBjaGFuZ2UsIGl0IG1lYW5zIHdlIHJlY2VpdmVkIGEgcmVsYXRpdmUgaHJlZlxuICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9XG4gICAgICBmaW5hbFVybC5vcmlnaW4gPT09IGJhc2Uub3JpZ2luXG4gICAgICAgID8gZmluYWxVcmwuaHJlZi5zbGljZShmaW5hbFVybC5vcmlnaW4ubGVuZ3RoKVxuICAgICAgICA6IGZpbmFsVXJsLmhyZWZcblxuICAgIHJldHVybiAocmVzb2x2ZUFzXG4gICAgICA/IFtyZXNvbHZlZEhyZWYsIGludGVycG9sYXRlZEFzIHx8IHJlc29sdmVkSHJlZl1cbiAgICAgIDogcmVzb2x2ZWRIcmVmKSBhcyBzdHJpbmdcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiAocmVzb2x2ZUFzID8gW3VybEFzU3RyaW5nXSA6IHVybEFzU3RyaW5nKSBhcyBzdHJpbmdcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmw6IHN0cmluZykge1xuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG5cbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsXG59XG5cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXI6IE5leHRSb3V0ZXIsIHVybDogVXJsLCBhcz86IFVybCkge1xuICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCB1cmwsIHRydWUpXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgY29uc3QgaHJlZkhhZE9yaWdpbiA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbilcbiAgY29uc3QgYXNIYWRPcmlnaW4gPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pXG5cbiAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKVxuICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBc1xuXG4gIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZkhhZE9yaWdpbiA/IHJlc29sdmVkSHJlZiA6IGFkZEJhc2VQYXRoKHJlc29sdmVkSHJlZilcbiAgY29uc3QgcHJlcGFyZWRBcyA9IGFzXG4gICAgPyBzdHJpcE9yaWdpbihyZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIGFzKSlcbiAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgIGFzOiBhc0hhZE9yaWdpbiA/IHByZXBhcmVkQXMgOiBhZGRCYXNlUGF0aChwcmVwYXJlZEFzKSxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICAgIHwgJ2lzUmVhZHknXG4gID5cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hPcHRpb25zID0ge1xuICBwcmlvcml0eT86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cblxuZXhwb3J0IHR5cGUgUHJpdmF0ZVJvdXRlSW5mbyA9XG4gIHwgKE9taXQ8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnc3R5bGVTaGVldHMnPiAmIHsgaW5pdGlhbDogdHJ1ZSB9KVxuICB8IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mb1xuXG5leHBvcnQgdHlwZSBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbiAgcHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGVycj86IEVycm9yXG4gIGVycm9yPzogYW55XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzID0gUGljazxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdDb21wb25lbnQnIHwgJ2Vycic+ICYge1xuICByb3V0ZXI6IFJvdXRlclxufSAmIFJlY29yZDxzdHJpbmcsIGFueT5cbmV4cG9ydCB0eXBlIEFwcENvbXBvbmVudCA9IENvbXBvbmVudFR5cGU8QXBwUHJvcHM+XG5cbnR5cGUgU3Vic2NyaXB0aW9uID0gKFxuICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICBBcHA6IEFwcENvbXBvbmVudCxcbiAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbikgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IE5leHRIaXN0b3J5U3RhdGUpID0+IGJvb2xlYW5cblxudHlwZSBDb21wb25lbnRMb2FkQ2FuY2VsID0gKCgpID0+IHZvaWQpIHwgbnVsbFxuXG50eXBlIEhpc3RvcnlNZXRob2QgPSAncmVwbGFjZVN0YXRlJyB8ICdwdXNoU3RhdGUnXG5cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5ICYmXG4gICEhKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IHYgPSAnX19uZXh0J1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWVcbiAgICB9IGNhdGNoIChuKSB7fVxuICB9KSgpXG5cbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJylcblxuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmw6IHN0cmluZywgYXR0ZW1wdHM6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAvL1xuICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAvLyA+IG9wdGlvbi5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgLy9cbiAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBpZiAoYXR0ZW1wdHMgPiAxICYmIHJlcy5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxKVxuICAgICAgfVxuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gcmVzLmpzb24oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEubm90Rm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vdEZvdW5kOiBTU0dfREFUQV9OT1RfRk9VTkQgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoZGF0YUhyZWY6IHN0cmluZywgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW4pIHtcbiAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEpLmNhdGNoKChlcnI6IEVycm9yKSA9PiB7XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAvLyBsb29wLlxuXG4gICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIGltcGxlbWVudHMgQmFzZVJvdXRlciB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIGBSb3V0ZXJgXG4gICAqL1xuICBjb21wb25lbnRzOiB7IFtwYXRobmFtZTogc3RyaW5nXTogUHJpdmF0ZVJvdXRlSW5mbyB9XG4gIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gIHNkYzogeyBbYXNQYXRoOiBzdHJpbmddOiBvYmplY3QgfSA9IHt9XG4gIHN1YjogU3Vic2NyaXB0aW9uXG4gIGNsYzogQ29tcG9uZW50TG9hZENhbmNlbFxuICBwYWdlTG9hZGVyOiBhbnlcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyXG4gIF93cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICBpc1NzcjogYm9vbGVhblxuICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gIF9pbkZsaWdodFJvdXRlPzogc3RyaW5nXG4gIF9zaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgaXNSZWFkeTogYm9vbGVhblxuXG4gIHByaXZhdGUgX2lkeDogbnVtYmVyID0gMFxuXG4gIHN0YXRpYyBldmVudHM6IE1pdHRFbWl0dGVyID0gbWl0dCgpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICB7XG4gICAgICBpbml0aWFsUHJvcHMsXG4gICAgICBwYWdlTG9hZGVyLFxuICAgICAgQXBwLFxuICAgICAgd3JhcEFwcCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIGVycixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsb2NhbGUsXG4gICAgICBsb2NhbGVzLFxuICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgIGRvbWFpbkxvY2FsZXMsXG4gICAgfToge1xuICAgICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb25cbiAgICAgIGluaXRpYWxQcm9wczogYW55XG4gICAgICBwYWdlTG9hZGVyOiBhbnlcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgQXBwOiBBcHBDb21wb25lbnRcbiAgICAgIHdyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgICAgbG9jYWxlPzogc3RyaW5nXG4gICAgICBsb2NhbGVzPzogc3RyaW5nW11cbiAgICAgIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgICAgIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gICAgfVxuICApIHtcbiAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICB0aGlzLnJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgQ29tcG9uZW50OiBBcHAgYXMgQ29tcG9uZW50VHlwZSxcbiAgICAgIHN0eWxlU2hlZXRzOiBbXG4gICAgICAgIC8qIC9fYXBwIGRvZXMgbm90IG5lZWQgaXRzIHN0eWxlc2hlZXRzIG1hbmFnZWQgKi9cbiAgICAgIF0sXG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlclxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9XG4gICAgICBpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnRcblxuICAgIHRoaXMuYXNQYXRoID0gYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzXG4gICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoXG4gICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb25cbiAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcFxuICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgIHRoaXMuaXNTc3IgPSB0cnVlXG5cbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrXG5cbiAgICB0aGlzLmlzUmVhZHkgPSAhIShcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8XG4gICAgICBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8XG4gICAgICAoIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaClcbiAgICApXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXNcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICAgIGdldFVSTCgpLFxuICAgICAgICAgIHsgbG9jYWxlIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpXG5cbiAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZSBhcyBIaXN0b3J5U3RhdGVcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpc1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZvcmNlZFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgdW5kZWZpbmVkXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zLCBpZHggfSA9IHN0YXRlXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5faWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICAgJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgaWR4KVxuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2ISlcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHsgeDogMCwgeTogMCB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lkeCA9IGlkeFxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gdGhpcy5hc1BhdGggJiYgcGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKFxuICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICB1cmwsXG4gICAgICBhcyxcbiAgICAgIE9iamVjdC5hc3NpZ248e30sIFRyYW5zaXRpb25PcHRpb25zLCBUcmFuc2l0aW9uT3B0aW9ucz4oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgfSksXG4gICAgICBmb3JjZWRTY3JvbGxcbiAgICApXG4gIH1cblxuICByZWxvYWQoKTogdm9pZCB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqL1xuICBiYWNrKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICBwdXNoKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHVwZGF0ZSBoaXN0b3J5IGJlZm9yZSByb3V0ZSBjaGFuZ2VcbiAgICAgIC8vIGlzIGNvbXBsZXRlLCBhcyB0aGUgcG9wc3RhdGUgZXZlbnQgc2hvdWxkIGhhbmRsZSB0aGlzIGNhcHR1cmUuXG4gICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTbmFwc2hvdCBzY3JvbGwgcG9zaXRpb24gcmlnaHQgYmVmb3JlIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZTpcbiAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgeDogc2VsZi5wYWdlWE9mZnNldCwgeTogc2VsZi5wYWdlWU9mZnNldCB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH1cbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcmVwbGFjZSh1cmw6IFVybCwgYXM/OiBVcmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY2hhbmdlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zLFxuICAgIGZvcmNlZFNjcm9sbD86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmxcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgIGlmICgob3B0aW9ucyBhcyBhbnkpLl9oKSB7XG4gICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBzY3JvbGwgcmVzZXQgYmVoYXZpb3IgdW5sZXNzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHRvIGJlXG4gICAgLy8gYGZhbHNlYCEgVGhpcyBtYWtlcyB0aGUgYmVoYXZpb3IgYmV0d2VlbiB1c2luZyBgUm91dGVyI3B1c2hgIGFuZCBhXG4gICAgLy8gYDxMaW5rIC8+YCBjb25zaXN0ZW50LlxuICAgIG9wdGlvbnMuc2Nyb2xsID0gISEob3B0aW9ucy5zY3JvbGwgPz8gdHJ1ZSlcblxuICAgIGxldCBsb2NhbGVDaGFuZ2UgPSBvcHRpb25zLmxvY2FsZSAhPT0gdGhpcy5sb2NhbGVcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID09PSBmYWxzZVxuICAgICAgICAgID8gdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmxvY2FsZVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IHRoaXMubG9jYWxlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcylcbiAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG5cbiAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZVxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhcnNlZEFzLnBhdGhuYW1lKVxuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgICB1cmwgPSBhZGRCYXNlUGF0aChcbiAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICAgICAgaGFzQmFzZVBhdGgodXJsKSA/IGRlbEJhc2VQYXRoKHVybCkgOiB1cmwsXG4gICAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgICApLnBhdGhuYW1lXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlXG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgIGlmICghdGhpcy5sb2NhbGVzPy5pbmNsdWRlcyh0aGlzLmxvY2FsZSEpKSB7XG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlKVxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKFxuICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5sb2NhbGVcbiAgICAgIClcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGlkTmF2aWdhdGUgJiZcbiAgICAgICAgICBkZXRlY3RlZERvbWFpbiAmJlxuICAgICAgICAgIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpblxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSBkZWxCYXNlUGF0aChhcylcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtcbiAgICAgICAgICAgIGRldGVjdGVkRG9tYWluLmRvbWFpblxuICAgICAgICAgIH0ke2FkZEJhc2VQYXRoKFxuICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgIHRoaXMubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgIDogYC8ke3RoaXMubG9jYWxlfWBcbiAgICAgICAgICAgIH0ke2FzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGh9YCB8fCAnLydcbiAgICAgICAgICApfWBcbiAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZVxuICAgIH1cbiAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgICBjb25zdCByb3V0ZVByb3BzID0geyBzaGFsbG93IH1cblxuICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlKSB7XG4gICAgICB0aGlzLmFib3J0Q29tcG9uZW50TG9hZCh0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKVxuICAgIH1cblxuICAgIGFzID0gYWRkQmFzZVBhdGgoXG4gICAgICBhZGRMb2NhbGUoXG4gICAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgICBvcHRpb25zLmxvY2FsZSxcbiAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICApXG4gICAgKVxuICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShcbiAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgdGhpcy5sb2NhbGVcbiAgICApXG4gICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzXG5cbiAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cblxuICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykpIHtcbiAgICAgIHRoaXMuYXNQYXRoID0gY2xlYW5lZEFzXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKVxuICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdLCBudWxsKVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkXG5cbiAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICBsZXQgcGFnZXM6IGFueSwgcmV3cml0ZXM6IGFueVxuICAgIHRyeSB7XG4gICAgICBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgICA7KHsgX19yZXdyaXRlczogcmV3cml0ZXMgfSA9IGF3YWl0IGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcGFyc2VkID0gdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkLCBwYWdlcykgYXMgdHlwZW9mIHBhcnNlZFxuXG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgfVxuXG4gICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgIHBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgID8gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUpKVxuICAgICAgOiBwYXRobmFtZVxuXG4gICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSdcbiAgICB9XG5cbiAgICBsZXQgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgYWRkQmFzZVBhdGgoXG4gICAgICAgICAgYWRkTG9jYWxlKGRlbEJhc2VQYXRoKHBhcnNlUmVsYXRpdmVVcmwoYXMpLnBhdGhuYW1lKSwgdGhpcy5sb2NhbGUpXG4gICAgICAgICksXG4gICAgICAgIHBhZ2VzLFxuICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIChwOiBzdHJpbmcpID0+IHRoaXMuX3Jlc29sdmVIcmVmKHsgcGF0aG5hbWU6IHAgfSwgcGFnZXMpLnBhdGhuYW1lISxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG5cbiAgICAgIGlmIChyZXNvbHZlZEFzICE9PSBhcykge1xuICAgICAgICBjb25zdCBwb3RlbnRpYWxIcmVmID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZUhyZWYoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWQsIHtcbiAgICAgICAgICAgICAgcGF0aG5hbWU6IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICAgICAgaGFzQmFzZVBhdGgocmVzb2x2ZWRBcykgPyBkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgICAgICAgICkucGF0aG5hbWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApLnBhdGhuYW1lIVxuICAgICAgICApXG5cbiAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocG90ZW50aWFsSHJlZikpIHtcbiAgICAgICAgICByb3V0ZSA9IHBvdGVudGlhbEhyZWZcbiAgICAgICAgICBwYXRobmFtZSA9IHBvdGVudGlhbEhyZWZcbiAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNMb2NhbFVSTChhcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgK1xuICAgICAgICAgICAgYFxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vZXJyLnNoL25leHQuanMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcylcbiAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZVxuXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWVcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSlcbiAgICAgICAgOiAoe30gYXMgeyByZXN1bHQ6IHVuZGVmaW5lZDsgcGFyYW1zOiB1bmRlZmluZWQgfSlcblxuICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IChzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyBgSW50ZXJwb2xhdGluZyBocmVmYFxuICAgICAgICAgICAgICAgICAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgXG4gICAgICAgICAgICAgIH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgKHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgXG4gICAgICAgICAgICAgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy8ke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJ1xuICAgICAgICAgICAgICAgICAgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnXG4gICAgICAgICAgICAgIH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMhKSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgfVxuICAgIH1cblxuICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKHJlc29sdmVkQXMsIHRoaXMubG9jYWxlKSksXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICAgIGxldCB7IGVycm9yLCBwcm9wcywgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgaWYgKChfX05fU1NHIHx8IF9fTl9TU1ApICYmIHByb3BzKSB7XG4gICAgICAgIGlmICgocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMgJiYgKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZEhyZWYsIHBhZ2VzLCBmYWxzZSlcblxuICAgICAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHBhcnNlZEhyZWYucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwsIGFzOiBuZXdBcyB9ID0gcHJlcGFyZVVybEFzKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCBuZXdVcmwsIG5ld0FzLCBvcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb25cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgIGlmIChwcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgbGV0IG5vdEZvdW5kUm91dGVcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KCcvNDA0JylcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCdcbiAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy9fZXJyb3InXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICB7IHNoYWxsb3c6IGZhbHNlIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnNldChcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lISxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGNsZWFuZWRBcyxcbiAgICAgICAgcm91dGVJbmZvLFxuICAgICAgICBmb3JjZWRTY3JvbGwgfHwgKG9wdGlvbnMuc2Nyb2xsID8geyB4OiAwLCB5OiAwIH0gOiBudWxsKVxuICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIGVycm9yID0gZXJyb3IgfHwgZVxuICAgICAgICBlbHNlIHRocm93IGVcbiAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IHRoaXMubG9jYWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgIGlkeDogdGhpcy5faWR4ID0gbWV0aG9kICE9PSAncHVzaFN0YXRlJyA/IHRoaXMuX2lkeCA6IHRoaXMuX2lkeCArIDEsXG4gICAgICAgIH0gYXMgSGlzdG9yeVN0YXRlLFxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgJycsXG4gICAgICAgIGFzXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgZXJyOiBFcnJvciAmIHsgY29kZTogYW55OyBjYW5jZWxsZWQ6IGJvb2xlYW4gfSxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllcyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKGlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIGxldCBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgICAgIGxldCBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBDb21wb25lbnQhID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygc3R5bGVTaGVldHMhID09PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIDsoeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFxuICAgICAgICAgICcvX2Vycm9yJ1xuICAgICAgICApKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgIGVycixcbiAgICAgICAgZXJyb3I6IGVycixcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycilcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgICAgICByb3V0ZUluZm9FcnIsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXNcbiAgKTogUHJvbWlzZTxQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUm91dGVJbmZvOiBQcml2YXRlUm91dGVJbmZvIHwgdW5kZWZpbmVkID0gdGhpcy5jb21wb25lbnRzW1xuICAgICAgICByb3V0ZVxuICAgICAgXVxuICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ1JvdXRlSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdSb3V0ZUluZm9cbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FjaGVkUm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPVxuICAgICAgICBleGlzdGluZ1JvdXRlSW5mbyAmJiAnaW5pdGlhbCcgaW4gZXhpc3RpbmdSb3V0ZUluZm9cbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogZXhpc3RpbmdSb3V0ZUluZm9cbiAgICAgIGNvbnN0IHJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgID8gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgIDogYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKSA9PiAoe1xuICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgfSkpXG5cbiAgICAgIGNvbnN0IHsgQ29tcG9uZW50LCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoJ3JlYWN0LWlzJylcbiAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGFIcmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgaWYgKF9fTl9TU0cgfHwgX19OX1NTUCkge1xuICAgICAgICBkYXRhSHJlZiA9IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZihcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICBkZWxCYXNlUGF0aChhcyksXG4gICAgICAgICAgX19OX1NTRyxcbiAgICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+KCgpID0+XG4gICAgICAgIF9fTl9TU0dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogX19OX1NTUFxuICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgfSBhcyBhbnlcbiAgICAgICAgICAgIClcbiAgICAgIClcblxuICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHNcbiAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm9cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKGVyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcylcbiAgICB9XG4gIH1cblxuICBzZXQoXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gICAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gZmFsc2VcblxuICAgIHRoaXMucm91dGUgPSByb3V0ZVxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIHRoaXMuYXNQYXRoID0gYXNcbiAgICByZXR1cm4gdGhpcy5ub3RpZnkoZGF0YSwgcmVzZXRTY3JvbGwpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKVxuICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZVxuICAgIGlmIChoYXNoID09PSAnJykge1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmIChpZEVsKSB7XG4gICAgICBpZEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXVxuICAgIGlmIChuYW1lRWwpIHtcbiAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgX3Jlc29sdmVIcmVmKHBhcnNlZEhyZWY6IFVybE9iamVjdCwgcGFnZXM6IHN0cmluZ1tdLCBhcHBseUJhc2VQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlZEhyZWZcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgICBkZW5vcm1hbGl6ZVBhZ2VQYXRoKGFwcGx5QmFzZVBhdGggPyBkZWxCYXNlUGF0aChwYXRobmFtZSEpIDogcGF0aG5hbWUhKVxuICAgIClcblxuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgICByZXR1cm4gcGFyc2VkSHJlZlxuICAgIH1cblxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUhKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgcGFnZXMuc29tZSgocGFnZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNEeW5hbWljUm91dGUocGFnZSkgJiZcbiAgICAgICAgICBnZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSEpXG4gICAgICAgICkge1xuICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSBhcHBseUJhc2VQYXRoID8gYWRkQmFzZVBhdGgocGFnZSkgOiBwYWdlXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhcnNlZEhyZWYucGF0aG5hbWUhKVxuICAgIHJldHVybiBwYXJzZWRIcmVmXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBhc3luYyBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICBsZXQgeyBwYXRobmFtZSB9ID0gcGFyc2VkXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBwYXRobmFtZSA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lXG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcblxuICAgICAgICBsZXQgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aClcbiAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKFxuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICApXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgIGFzUGF0aCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMsIGZhbHNlKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyh1cmwpLnRoZW4oKGlzU3NnOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHJldHVybiBpc1NzZ1xuICAgICAgICAgID8gdGhpcy5fZ2V0U3RhdGljRGF0YShcbiAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICAgICAgICAgICAgICA6IHRoaXMubG9jYWxlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8R29vZFBhZ2VDYWNoZT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICh0aGlzLmNsYyA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuc2RjW2NhY2hlS2V5XSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNkY1tjYWNoZUtleV0pXG4gICAgfVxuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICB0aGlzLnNkY1tjYWNoZUtleV0gPSBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U2VydmVyRGF0YShkYXRhSHJlZjogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+IHtcbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcilcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHAgYXMgQXBwQ29tcG9uZW50KVxuICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZVxuICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzPEFwcENvbnRleHRUeXBlPFJvdXRlcj4+KEFwcCwge1xuICAgICAgQXBwVHJlZSxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIGN0eCxcbiAgICB9KVxuICB9XG5cbiAgYWJvcnRDb21wb25lbnRMb2FkKGFzOiBzdHJpbmcsIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllcyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFxuICAgICAgICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICAgICAgIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJvdXRlUHJvcHNcbiAgICAgIClcbiAgICAgIHRoaXMuY2xjKClcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeShcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihcbiAgICAgIGRhdGEsXG4gICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50IGFzIEFwcENvbXBvbmVudCxcbiAgICAgIHJlc2V0U2Nyb2xsXG4gICAgKVxuICB9XG59XG4iLCIvLyBGb3JtYXQgZnVuY3Rpb24gbW9kaWZpZWQgZnJvbSBub2RlanNcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAnLi9xdWVyeXN0cmluZydcblxuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VXJsKHVybE9iajogVXJsT2JqZWN0KSB7XG4gIGxldCB7IGF1dGgsIGhvc3RuYW1lIH0gPSB1cmxPYmpcbiAgbGV0IHByb3RvY29sID0gdXJsT2JqLnByb3RvY29sIHx8ICcnXG4gIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCAnJ1xuICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8ICcnXG4gIGxldCBxdWVyeSA9IHVybE9iai5xdWVyeSB8fCAnJ1xuICBsZXQgaG9zdDogc3RyaW5nIHwgZmFsc2UgPSBmYWxzZVxuXG4gIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCAnOicpICsgJ0AnIDogJydcblxuICBpZiAodXJsT2JqLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0XG4gIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZignOicpID8gYFske2hvc3RuYW1lfV1gIDogaG9zdG5hbWUpXG4gICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5ICYmIHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBxdWVyeSA9IFN0cmluZyhxdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5IGFzIFBhcnNlZFVybFF1ZXJ5KSlcbiAgfVxuXG4gIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IChxdWVyeSAmJiBgPyR7cXVlcnl9YCkgfHwgJydcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOidcblxuICBpZiAoXG4gICAgdXJsT2JqLnNsYXNoZXMgfHxcbiAgICAoKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSlcbiAgKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJylcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnXG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoWzBdICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaFxuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpXG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpXG5cbiAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gXG59XG4iLCIvLyBUcmFuc2xhdGVzIGEgbG9naWNhbCByb3V0ZSBpbnRvIGl0cyBwYWdlcyBhc3NldCBwYXRoIChyZWxhdGl2ZSBmcm9tIGEgY29tbW9uIHByZWZpeClcbi8vIFwiYXNzZXQgcGF0aFwiIGJlaW5nIGl0cyBqYXZhc2NyaXB0IGZpbGUsIGRhdGEgZmlsZSwgcHJlcmVuZGVyZWQgaHRtbCwuLi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFzc2V0UGF0aEZyb21Sb3V0ZShcbiAgcm91dGU6IHN0cmluZyxcbiAgZXh0OiBzdHJpbmcgPSAnJ1xuKTogc3RyaW5nIHtcbiAgY29uc3QgcGF0aCA9XG4gICAgcm91dGUgPT09ICcvJ1xuICAgICAgPyAnL2luZGV4J1xuICAgICAgOiAvXlxcL2luZGV4KFxcL3wkKS8udGVzdChyb3V0ZSlcbiAgICAgID8gYC9pbmRleCR7cm91dGV9YFxuICAgICAgOiBgJHtyb3V0ZX1gXG4gIHJldHVybiBwYXRoICsgZXh0XG59XG4iLCIvLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1JvdXRlKHJvdXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSlcbn1cbiIsImltcG9ydCB7IGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcblxuLyoqXG4gKiBQYXJzZXMgcGF0aC1yZWxhdGl2ZSB1cmxzIChlLmcuIGAvaGVsbG8vd29ybGQ/Zm9vPWJhcmApLiBJZiB1cmwgaXNuJ3QgcGF0aC1yZWxhdGl2ZVxuICogKGUuZy4gYC4vaGVsbG9gKSB0aGVuIGF0IGxlYXN0IGJhc2UgbXVzdCBiZS5cbiAqIEFic29sdXRlIHVybHMgYXJlIHJlamVjdGVkIHdpdGggb25lIGV4Y2VwdGlvbiwgaW4gdGhlIGJyb3dzZXIsIGFic29sdXRlIHVybHMgdGhhdCBhcmUgb25cbiAqIHRoZSBjdXJyZW50IG9yaWdpbiB3aWxsIGJlIHBhcnNlZCBhcyByZWxhdGl2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWxhdGl2ZVVybCh1cmw6IHN0cmluZywgYmFzZT86IHN0cmluZykge1xuICBjb25zdCBnbG9iYWxCYXNlID0gbmV3IFVSTChcbiAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIClcbiAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgZ2xvYmFsQmFzZSkgOiBnbG9iYWxCYXNlXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcywgc2VhcmNoLCBoYXNoLCBocmVmLCBvcmlnaW4gfSA9IG5ldyBVUkwoXG4gICAgdXJsLFxuICAgIHJlc29sdmVkQmFzZVxuICApXG4gIGlmIChvcmlnaW4gIT09IGdsb2JhbEJhc2Uub3JpZ2luKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhcmlhbnQ6IGludmFsaWQgcmVsYXRpdmUgVVJMLCByb3V0ZXIgcmVjZWl2ZWQgJHt1cmx9YClcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgaHJlZjogaHJlZi5zbGljZShnbG9iYWxCYXNlLm9yaWdpbi5sZW5ndGgpLFxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBwYXRoVG9SZWdleHAgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwJ1xuXG5leHBvcnQgeyBwYXRoVG9SZWdleHAgfVxuXG5leHBvcnQgY29uc3QgbWF0Y2hlck9wdGlvbnM6IHBhdGhUb1JlZ2V4cC5Ub2tlbnNUb1JlZ2V4cE9wdGlvbnMgJlxuICBwYXRoVG9SZWdleHAuUGFyc2VPcHRpb25zID0ge1xuICBzZW5zaXRpdmU6IGZhbHNlLFxuICBkZWxpbWl0ZXI6ICcvJyxcbn1cblxuZXhwb3J0IGNvbnN0IGN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnM6IHBhdGhUb1JlZ2V4cC5Ub2tlbnNUb1JlZ2V4cE9wdGlvbnMgJlxuICBwYXRoVG9SZWdleHAuUGFyc2VPcHRpb25zID0ge1xuICAuLi5tYXRjaGVyT3B0aW9ucyxcbiAgc3RyaWN0OiB0cnVlLFxufVxuXG5leHBvcnQgZGVmYXVsdCAoY3VzdG9tUm91dGUgPSBmYWxzZSkgPT4ge1xuICByZXR1cm4gKHBhdGg6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGtleXM6IHBhdGhUb1JlZ2V4cC5LZXlbXSA9IFtdXG4gICAgY29uc3QgbWF0Y2hlclJlZ2V4ID0gcGF0aFRvUmVnZXhwLnBhdGhUb1JlZ2V4cChcbiAgICAgIHBhdGgsXG4gICAgICBrZXlzLFxuICAgICAgY3VzdG9tUm91dGUgPyBjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zIDogbWF0Y2hlck9wdGlvbnNcbiAgICApXG4gICAgY29uc3QgbWF0Y2hlciA9IHBhdGhUb1JlZ2V4cC5yZWdleHBUb0Z1bmN0aW9uKG1hdGNoZXJSZWdleCwga2V5cylcblxuICAgIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmFtcz86IGFueSkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gcGF0aG5hbWUgPT0gbnVsbCA/IGZhbHNlIDogbWF0Y2hlcihwYXRobmFtZSlcbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoY3VzdG9tUm91dGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgIC8vIHVubmFtZWQgcGFyYW1zIHNob3VsZCBiZSByZW1vdmVkIGFzIHRoZXlcbiAgICAgICAgICAvLyBhcmUgbm90IGFsbG93ZWQgdG8gYmUgdXNlZCBpbiB0aGUgZGVzdGluYXRpb25cbiAgICAgICAgICBpZiAodHlwZW9mIGtleS5uYW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZGVsZXRlIChyZXMucGFyYW1zIGFzIGFueSlba2V5Lm5hbWVdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgLi4ucmVzLnBhcmFtcyB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vcXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgKiBhcyBwYXRoVG9SZWdleHAgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwJ1xuXG50eXBlIFBhcmFtcyA9IHsgW3BhcmFtOiBzdHJpbmddOiBhbnkgfVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZU5vblBhdGgodmFsdWU6IHN0cmluZywgcGFyYW1zOiBQYXJhbXMpOiBzdHJpbmcge1xuICBpZiAoIXZhbHVlLmluY2x1ZGVzKCc6JykpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoYDoke2tleX1gKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXCpgLCAnZycpLFxuICAgICAgICAgIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX0FTVEVSSVNLU2BcbiAgICAgICAgKVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXD9gLCAnZycpLFxuICAgICAgICAgIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX1FVRVNUSU9OYFxuICAgICAgICApXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYDoke2tleX1cXFxcK2AsICdnJyksIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX1BMVVNgKVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9KD8hXFxcXHcpYCwgJ2cnKSxcbiAgICAgICAgICBgLS1FU0NBUEVEX1BBUkFNX0NPTE9OJHtrZXl9YFxuICAgICAgICApXG4gICAgfVxuICB9XG4gIHZhbHVlID0gdmFsdWVcbiAgICAucmVwbGFjZSgvKDp8XFwqfFxcP3xcXCt8XFwofFxcKXxcXHt8XFx9KS9nLCAnXFxcXCQxJylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX1BMVVMvZywgJysnKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fQ09MT04vZywgJzonKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fUVVFU1RJT04vZywgJz8nKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fQVNURVJJU0tTL2csICcqJylcblxuICAvLyB0aGUgdmFsdWUgbmVlZHMgdG8gc3RhcnQgd2l0aCBhIGZvcndhcmQtc2xhc2ggdG8gYmUgY29tcGlsZWRcbiAgLy8gY29ycmVjdGx5XG4gIHJldHVybiBwYXRoVG9SZWdleHBcbiAgICAuY29tcGlsZShgLyR7dmFsdWV9YCwgeyB2YWxpZGF0ZTogZmFsc2UgfSkocGFyYW1zKVxuICAgIC5zdWJzdHIoMSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJlcGFyZURlc3RpbmF0aW9uKFxuICBkZXN0aW5hdGlvbjogc3RyaW5nLFxuICBwYXJhbXM6IFBhcmFtcyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICBhcHBlbmRQYXJhbXNUb1F1ZXJ5OiBib29sZWFuXG4pIHtcbiAgbGV0IHBhcnNlZERlc3RpbmF0aW9uOiB7XG4gICAgcXVlcnk/OiBQYXJzZWRVcmxRdWVyeVxuICAgIHByb3RvY29sPzogc3RyaW5nXG4gICAgaG9zdG5hbWU/OiBzdHJpbmdcbiAgICBwb3J0Pzogc3RyaW5nXG4gIH0gJiBSZXR1cm5UeXBlPHR5cGVvZiBwYXJzZVJlbGF0aXZlVXJsPiA9IHt9IGFzIGFueVxuXG4gIC8vIGNsb25lIHF1ZXJ5IHNvIHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWxcbiAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBxdWVyeSlcbiAgY29uc3QgaGFkTG9jYWxlID0gcXVlcnkuX19uZXh0TG9jYWxlXG4gIGRlbGV0ZSBxdWVyeS5fX25leHRMb2NhbGVcbiAgZGVsZXRlIHF1ZXJ5Ll9fbmV4dERlZmF1bHRMb2NhbGVcblxuICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9ID0gbmV3IFVSTChkZXN0aW5hdGlvbilcblxuICAgIHBhcnNlZERlc3RpbmF0aW9uID0ge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgICAgaGFzaCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXN0UXVlcnkgPSBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeVxuICBjb25zdCBkZXN0UGF0aCA9IGAke3BhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lIX0ke1xuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggfHwgJydcbiAgfWBcbiAgY29uc3QgZGVzdFBhdGhQYXJhbUtleXM6IHBhdGhUb1JlZ2V4cC5LZXlbXSA9IFtdXG4gIHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoZGVzdFBhdGgsIGRlc3RQYXRoUGFyYW1LZXlzKVxuXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1zID0gZGVzdFBhdGhQYXJhbUtleXMubWFwKChrZXkpID0+IGtleS5uYW1lKVxuXG4gIGxldCBkZXN0aW5hdGlvbkNvbXBpbGVyID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUoXG4gICAgZGVzdFBhdGgsXG4gICAgLy8gd2UgZG9uJ3QgdmFsaWRhdGUgd2hpbGUgY29tcGlsaW5nIHRoZSBkZXN0aW5hdGlvbiBzaW5jZSB3ZSBzaG91bGRcbiAgICAvLyBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGJlZm9yZSB3ZSBnb3QgdG8gdGhpcyBwb2ludCBhbmQgdmFsaWRhdGluZ1xuICAgIC8vIGJyZWFrcyBjb21waWxpbmcgZGVzdGluYXRpb25zIHdpdGggbmFtZWQgcGF0dGVybiBwYXJhbXMgZnJvbSB0aGUgc291cmNlXG4gICAgLy8gZS5nLiAvc29tZXRoaW5nOmhlbGxvKC4qKSAtPiAvYW5vdGhlci86aGVsbG8gaXMgYnJva2VuIHdpdGggdmFsaWRhdGlvblxuICAgIC8vIHNpbmNlIGNvbXBpbGUgdmFsaWRhdGlvbiBpcyBtZWFudCBmb3IgcmV2ZXJzaW5nIGFuZCBub3QgZm9yIGluc2VydGluZ1xuICAgIC8vIHBhcmFtcyBmcm9tIGEgc2VwYXJhdGUgcGF0aC1yZWdleCBpbnRvIGFub3RoZXJcbiAgICB7IHZhbGlkYXRlOiBmYWxzZSB9XG4gIClcbiAgbGV0IG5ld1VybFxuXG4gIC8vIHVwZGF0ZSBhbnkgcGFyYW1zIGluIHF1ZXJ5IHZhbHVlc1xuICBmb3IgKGNvbnN0IFtrZXksIHN0ck9yQXJyYXldIG9mIE9iamVjdC5lbnRyaWVzKGRlc3RRdWVyeSkpIHtcbiAgICBsZXQgdmFsdWUgPSBBcnJheS5pc0FycmF5KHN0ck9yQXJyYXkpID8gc3RyT3JBcnJheVswXSA6IHN0ck9yQXJyYXlcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIHRoZSB2YWx1ZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgZm9yd2FyZC1zbGFzaCB0byBiZSBjb21waWxlZFxuICAgICAgLy8gY29ycmVjdGx5XG4gICAgICB2YWx1ZSA9IGNvbXBpbGVOb25QYXRoKHZhbHVlLCBwYXJhbXMpXG4gICAgfVxuICAgIGRlc3RRdWVyeVtrZXldID0gdmFsdWVcbiAgfVxuXG4gIC8vIGFkZCBwYXRoIHBhcmFtcyB0byBxdWVyeSBpZiBpdCdzIG5vdCBhIHJlZGlyZWN0IGFuZCBub3RcbiAgLy8gYWxyZWFkeSBkZWZpbmVkIGluIGRlc3RpbmF0aW9uIHF1ZXJ5IG9yIHBhdGhcbiAgbGV0IHBhcmFtS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcylcblxuICAvLyByZW1vdmUgaW50ZXJuYWwgcGFyYW0gZm9yIGkxOG5cbiAgaWYgKGhhZExvY2FsZSkge1xuICAgIHBhcmFtS2V5cyA9IHBhcmFtS2V5cy5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09ICduZXh0SW50ZXJuYWxMb2NhbGUnKVxuICB9XG5cbiAgaWYgKFxuICAgIGFwcGVuZFBhcmFtc1RvUXVlcnkgJiZcbiAgICAhcGFyYW1LZXlzLnNvbWUoKGtleSkgPT4gZGVzdFBhdGhQYXJhbXMuaW5jbHVkZXMoa2V5KSlcbiAgKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyYW1LZXlzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gZGVzdFF1ZXJ5KSkge1xuICAgICAgICBkZXN0UXVlcnlba2V5XSA9IHBhcmFtc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBuZXdVcmwgPSBkZXN0aW5hdGlvbkNvbXBpbGVyKHBhcmFtcylcblxuICAgIGNvbnN0IFtwYXRobmFtZSwgaGFzaF0gPSBuZXdVcmwuc3BsaXQoJyMnKVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoID0gYCR7aGFzaCA/ICcjJyA6ICcnfSR7aGFzaCB8fCAnJ31gXG4gICAgZGVsZXRlIChwYXJzZWREZXN0aW5hdGlvbiBhcyBhbnkpLnNlYXJjaFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL0V4cGVjdGVkIC4qPyB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5LykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRvIHVzZSBhIG11bHRpLW1hdGNoIGluIHRoZSBkZXN0aW5hdGlvbiB5b3UgbXVzdCBhZGQgXFxgKlxcYCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJhbSBuYW1lIHRvIHNpZ25pZnkgaXQgc2hvdWxkIHJlcGVhdC4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvaW52YWxpZC1tdWx0aS1tYXRjaGBcbiAgICAgIClcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBRdWVyeSBtZXJnZSBvcmRlciBsb3dlc3QgcHJpb3JpdHkgdG8gaGlnaGVzdFxuICAvLyAxLiBpbml0aWFsIFVSTCBxdWVyeSB2YWx1ZXNcbiAgLy8gMi4gcGF0aCBzZWdtZW50IHZhbHVlc1xuICAvLyAzLiBkZXN0aW5hdGlvbiBzcGVjaWZpZWQgcXVlcnkgdmFsdWVzXG4gIHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5ID0ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIC4uLnBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdVcmwsXG4gICAgcGFyc2VkRGVzdGluYXRpb24sXG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHBhdGhNYXRjaCBmcm9tICcuL3BhdGgtbWF0Y2gnXG5pbXBvcnQgcHJlcGFyZURlc3RpbmF0aW9uIGZyb20gJy4vcHJlcGFyZS1kZXN0aW5hdGlvbidcbmltcG9ydCB7IFJld3JpdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvbG9hZC1jdXN0b20tcm91dGVzJ1xuaW1wb3J0IHsgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2ggfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9IGZyb20gJy4uLy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJ1xuXG5jb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXIgPSBwYXRoTWF0Y2godHJ1ZSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZVJld3JpdGVzKFxuICBhc1BhdGg6IHN0cmluZyxcbiAgcGFnZXM6IHN0cmluZ1tdLFxuICByZXdyaXRlczogUmV3cml0ZVtdLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gIHJlc29sdmVIcmVmOiAocGF0aDogc3RyaW5nKSA9PiBzdHJpbmcsXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuKSB7XG4gIGlmICghcGFnZXMuaW5jbHVkZXMobm9ybWFsaXplTG9jYWxlUGF0aChhc1BhdGgsIGxvY2FsZXMpLnBhdGhuYW1lKSkge1xuICAgIGZvciAoY29uc3QgcmV3cml0ZSBvZiByZXdyaXRlcykge1xuICAgICAgY29uc3QgbWF0Y2hlciA9IGN1c3RvbVJvdXRlTWF0Y2hlcihyZXdyaXRlLnNvdXJjZSlcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoZXIoYXNQYXRoKVxuXG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIGlmICghcmV3cml0ZS5kZXN0aW5hdGlvbikge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBwcm94aWVkIHJld3JpdGUgd2hpY2ggaXNuJ3QgaGFuZGxlZCBvbiB0aGUgY2xpZW50XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXN0UmVzID0gcHJlcGFyZURlc3RpbmF0aW9uKFxuICAgICAgICAgIHJld3JpdGUuZGVzdGluYXRpb24sXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgICBhc1BhdGggPSBkZXN0UmVzLnBhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lIVxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBkZXN0UmVzLnBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5KVxuXG4gICAgICAgIGNvbnN0IGZzUGF0aG5hbWUgPSBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICAgIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGFzUGF0aCksXG4gICAgICAgICAgbG9jYWxlc1xuICAgICAgICApLnBhdGhuYW1lXG5cbiAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgYXNQYXRoID0gZnNQYXRobmFtZVxuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIG5vdyBtYXRjaCBhIHBhZ2UgYXMgdGhpcyBtZWFucyB3ZSBhcmUgZG9uZVxuICAgICAgICAgIC8vIHJlc29sdmluZyB0aGUgcmV3cml0ZXNcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbWF0Y2ggYSBkeW5hbWljLXJvdXRlLCBpZiBzbyB3ZSBicmVhayB0aGUgcmV3cml0ZXMgY2hhaW5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gcmVzb2x2ZUhyZWYoZnNQYXRobmFtZSlcblxuICAgICAgICBpZiAocmVzb2x2ZWRIcmVmICE9PSBhc1BhdGggJiYgcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgIGFzUGF0aCA9IGZzUGF0aG5hbWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhc1BhdGhcbn1cbiIsImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBHcm91cCB7XG4gIHBvczogbnVtYmVyXG4gIHJlcGVhdDogYm9vbGVhblxuICBvcHRpb25hbDogYm9vbGVhblxufVxuXG4vLyB0aGlzIGlzbid0IGltcG9ydGluZyB0aGUgZXNjYXBlLXN0cmluZy1yZWdleCBtb2R1bGVcbi8vIHRvIHJlZHVjZSBieXRlc1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihwYXJhbTogc3RyaW5nKSB7XG4gIGNvbnN0IG9wdGlvbmFsID0gcGFyYW0uc3RhcnRzV2l0aCgnWycpICYmIHBhcmFtLmVuZHNXaXRoKCddJylcbiAgaWYgKG9wdGlvbmFsKSB7XG4gICAgcGFyYW0gPSBwYXJhbS5zbGljZSgxLCAtMSlcbiAgfVxuICBjb25zdCByZXBlYXQgPSBwYXJhbS5zdGFydHNXaXRoKCcuLi4nKVxuICBpZiAocmVwZWF0KSB7XG4gICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKVxuICB9XG4gIHJldHVybiB7IGtleTogcGFyYW0sIHJlcGVhdCwgb3B0aW9uYWwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVSZWdleChcbiAgbm9ybWFsaXplZFJvdXRlOiBzdHJpbmdcbik6IHtcbiAgcmU6IFJlZ0V4cFxuICBuYW1lZFJlZ2V4Pzogc3RyaW5nXG4gIHJvdXRlS2V5cz86IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfVxuICBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfVxufSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gKG5vcm1hbGl6ZWRSb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJylcbiAgICAuc2xpY2UoMSlcbiAgICAuc3BsaXQoJy8nKVxuXG4gIGNvbnN0IGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9ID0ge31cbiAgbGV0IGdyb3VwSW5kZXggPSAxXG4gIGNvbnN0IHBhcmFtZXRlcml6ZWRSb3V0ZSA9IHNlZ21lbnRzXG4gICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpXG4gICAgICAgIGdyb3Vwc1trZXldID0geyBwb3M6IGdyb3VwSW5kZXgrKywgcmVwZWF0LCBvcHRpb25hbCB9XG4gICAgICAgIHJldHVybiByZXBlYXQgPyAob3B0aW9uYWwgPyAnKD86LyguKz8pKT8nIDogJy8oLis/KScpIDogJy8oW14vXSs/KSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgfVxuICAgIH0pXG4gICAgLmpvaW4oJycpXG5cbiAgLy8gZGVhZCBjb2RlIGVsaW1pbmF0ZSBmb3IgYnJvd3NlciBzaW5jZSBpdCdzIG9ubHkgbmVlZGVkXG4gIC8vIHdoaWxlIGdlbmVyYXRpbmcgcm91dGVzLW1hbmlmZXN0XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGxldCByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICBsZXQgcm91dGVLZXlDaGFyTGVuZ3RoID0gMVxuXG4gICAgLy8gYnVpbGRzIGEgbWluaW1hbCByb3V0ZUtleSB1c2luZyBvbmx5IGEteiBhbmQgbWluaW1hbCBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgIGNvbnN0IGdldFNhZmVSb3V0ZUtleSA9ICgpID0+IHtcbiAgICAgIGxldCByb3V0ZUtleSA9ICcnXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVLZXlDaGFyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm91dGVLZXkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyb3V0ZUtleUNoYXJDb2RlKVxuICAgICAgICByb3V0ZUtleUNoYXJDb2RlKytcblxuICAgICAgICBpZiAocm91dGVLZXlDaGFyQ29kZSA+IDEyMikge1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckxlbmd0aCsrXG4gICAgICAgICAgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3V0ZUtleVxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlS2V5czogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9ID0ge31cblxuICAgIGxldCBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSA9IHNlZ21lbnRzXG4gICAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpXG4gICAgICAgICAgLy8gcmVwbGFjZSBhbnkgbm9uLXdvcmQgY2hhcmFjdGVycyBzaW5jZSB0aGV5IGNhbiBicmVha1xuICAgICAgICAgIC8vIHRoZSBuYW1lZCByZWdleFxuICAgICAgICAgIGxldCBjbGVhbmVkS2V5ID0ga2V5LnJlcGxhY2UoL1xcVy9nLCAnJylcbiAgICAgICAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlXG5cbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIHN0aWxsIGludmFsaWQgYW5kIGZhbGxiYWNrIHRvIHVzaW5nIGEga25vd25cbiAgICAgICAgICAvLyBzYWZlIGtleVxuICAgICAgICAgIGlmIChjbGVhbmVkS2V5Lmxlbmd0aCA9PT0gMCB8fCBjbGVhbmVkS2V5Lmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KGNsZWFuZWRLZXkuc3Vic3RyKDAsIDEpKSkpIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludmFsaWRLZXkpIHtcbiAgICAgICAgICAgIGNsZWFuZWRLZXkgPSBnZXRTYWZlUm91dGVLZXkoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdXRlS2V5c1tjbGVhbmVkS2V5XSA9IGtleVxuICAgICAgICAgIHJldHVybiByZXBlYXRcbiAgICAgICAgICAgID8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgPyBgKD86Lyg/PCR7Y2xlYW5lZEtleX0+Lis/KSk/YFxuICAgICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT4uKz8pYFxuICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+W14vXSs/KWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgICAgZ3JvdXBzLFxuICAgICAgcm91dGVLZXlzLFxuICAgICAgbmFtZWRSZWdleDogYF4ke25hbWVkUGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgZ3JvdXBzLFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcblxudHlwZSBTdGF0ZSA9IEpTWC5FbGVtZW50W10gfCB1bmRlZmluZWRcblxudHlwZSBTaWRlRWZmZWN0UHJvcHMgPSB7XG4gIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlOiA8VD4oXG4gICAgY29tcG9uZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgIHByb3BzOiBUXG4gICkgPT4gU3RhdGVcbiAgaGFuZGxlU3RhdGVDaGFuZ2U/OiAoc3RhdGU6IFN0YXRlKSA9PiB2b2lkXG4gIGhlYWRNYW5hZ2VyOiBhbnlcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbXBvbmVudDxTaWRlRWZmZWN0UHJvcHM+IHtcbiAgcHJpdmF0ZSBfaGFzSGVhZE1hbmFnZXI6IGJvb2xlYW5cblxuICBlbWl0Q2hhbmdlID0gKCk6IHZvaWQgPT4ge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci51cGRhdGVIZWFkKFxuICAgICAgICB0aGlzLnByb3BzLnJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKFxuICAgICAgICAgIFsuLi50aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXNdLFxuICAgICAgICAgIHRoaXMucHJvcHNcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLl9oYXNIZWFkTWFuYWdlciA9XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyICYmIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlc1xuXG4gICAgaWYgKGlzU2VydmVyICYmIHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuYWRkKHRoaXMpXG4gICAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5hZGQodGhpcylcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5kZWxldGUodGhpcylcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCJpbXBvcnQgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBmb3JtYXRVcmwgfSBmcm9tICcuL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgTWFuaWZlc3RJdGVtIH0gZnJvbSAnLi4vc2VydmVyL2xvYWQtY29tcG9uZW50cydcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdAbmV4dC9lbnYnXG5pbXBvcnQgeyBCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vc2VydmVyL2dldC1wYWdlLWZpbGVzJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uL3NlcnZlci9jb25maWcnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiBzdHJpbmdbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBkb2NDb21wb25lbnRzUmVuZGVyZWQ6IHtcbiAgICBIdG1sPzogYm9vbGVhblxuICAgIE1haW4/OiBib29sZWFuXG4gICAgSGVhZD86IGJvb2xlYW5cbiAgICBOZXh0U2NyaXB0PzogYm9vbGVhblxuICB9XG4gIGJ1aWxkTWFuaWZlc3Q6IEJ1aWxkTWFuaWZlc3RcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkeW5hbWljSW1wb3J0czogTWFuaWZlc3RJdGVtW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxuICBkZXZPbmx5Q2FjaGVCdXN0ZXJRdWVyeVN0cmluZzogc3RyaW5nXG4gIHNjcmlwdExvYWRlcjogeyBkZWZlcj86IHN0cmluZ1tdOyBlYWdlcj86IGFueVtdIH1cbiAgbG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IGFueVxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPFQgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxUPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPFQ+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHN0YXR1czogbnVtYmVyLCB1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuXG4gIC8qKlxuICAgKiBTZXQgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgc2V0UHJldmlld0RhdGE6IChcbiAgICBkYXRhOiBvYmplY3QgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgKGluIHNlY29uZHMpIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIGxhc3QgZm9yLlxuICAgICAgICogVGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGJ5IHJvdW5kaW5nIGRvd24uXG4gICAgICAgKiBCeSBkZWZhdWx0LCBubyBtYXhpbXVtIGFnZSBpcyBzZXQgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gZmluaXNoZXNcbiAgICAgICAqIHdoZW4gdGhlIGNsaWVudCBzaHV0cyBkb3duIChicm93c2VyIGlzIGNsb3NlZCkuXG4gICAgICAgKi9cbiAgICAgIG1heEFnZT86IG51bWJlclxuICAgIH1cbiAgKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgY2xlYXJQcmV2aWV3RGF0YTogKCkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4oQXBwOiBOZXh0Q29tcG9uZW50VHlwZTxDLCBJUCwgUD4sIGN0eDogQyk6IFByb21pc2U8SVA+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoQXBwLnByb3RvdHlwZT8uZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgQXBwXG4gICAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgKGN0eC5jdHggJiYgY3R4LmN0eC5yZXMpXG5cbiAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge30gYXMgSVBcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpXG5cbiAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgQXBwXG4gICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2dldERpc3BsYXlOYW1lKFxuICAgICAgICAgIEFwcFxuICAgICAgICApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmw6IFVybE9iamVjdCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh1cmxPYmplY3RLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJ1xuIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5ub3JtYWxpemVQYXRoU2VwPW5vcm1hbGl6ZVBhdGhTZXA7ZXhwb3J0cy5kZW5vcm1hbGl6ZVBhZ2VQYXRoPWRlbm9ybWFsaXplUGFnZVBhdGg7ZnVuY3Rpb24gbm9ybWFsaXplUGF0aFNlcChwYXRoKXtyZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csJy8nKTt9ZnVuY3Rpb24gZGVub3JtYWxpemVQYWdlUGF0aChwYWdlKXtwYWdlPW5vcm1hbGl6ZVBhdGhTZXAocGFnZSk7aWYocGFnZS5zdGFydHNXaXRoKCcvaW5kZXgvJykpe3BhZ2U9cGFnZS5zbGljZSg2KTt9ZWxzZSBpZihwYWdlPT09Jy9pbmRleCcpe3BhZ2U9Jy8nO31yZXR1cm4gcGFnZTt9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL2hlYWQnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMVxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMVxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMSc7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICdAL2NvbXBvbmVudHMvQ29udGFpbmVyJztcblxuY29uc3QgSG9tZSA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8Q29udGFpbmVyPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJkaXZpZGUteSBkaXZpZGUtZ3JheS0yMDAgYWxpZ24tdGV4dC10b3AgbWF4LXctNHhsIG14LWF1dG8gbWItMTZcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZDpwdC0xMCBmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBteC1hdXRvIG1iLTE2XCI+XG4gICAgICAgICAgPGgxXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJwYi01IHRleHQtbGcgbWQ6dGV4dC0zeGwgdGV4dC1jZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0LWJsdWUtODAwIFxuICAgICAgICAgICAgICAgICAgICAgIGZvbnQtYm9sZCBsZWFkaW5nLW5vcm1hbFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgTmV4dC5qcyBTdGF0aWMgSFRNTCBhcHAgZGVwbG95bWVudCB0byBHaXRIdWIgUHJvamVjdCBQYWdlcyBEZW1vXG4gICAgICAgICAgPC9oMT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvbnQtbm9ybWFsIGxlYWRpbmctbm9ybWFsIHNtOnRleHQtc20gbGc6bGVhZGluZy1yZWxheGVkXCI+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgSGkgYWxsLCB0aGlzIGlzIGFuIGRlbW8gb2YgaG93IHdlIGNhbiBkZXBsb3kgYSBOZXh0LmpzIHYxMCBhcHAsIHdpdGggVGFpbHdpbmQgQ1NTXG4gICAgICAgICAgICAgIHN0eWxpbmcgdG8gR2l0SHViIFByb2plY3QgcGFnZXMueycgJ31cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgIEdpdEh1YiBQcm9qZWN0IHBhZ2VzIGNhbiBiZSBob3N0ZWQgYWxvbmdzaWRlIHNwZWNpZmljIEdpdEh1YiBwcm9qZWN0cyAvIHJlcG9zaXRvcmllcy5cbiAgICAgICAgICAgICAgVGhleSBjYW4gYmUgZG9jdW1lbnRzIG9yIHdlYiBwYWdlcy5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgIFRoZSBzdGF0aWMgSHRtbCBwYWdlcyBoZXJlIGhhdmUgYmVlbiBjcmVhdGVkIGluIHRoZSBHaXRIdWIgcmVwb3NpdG9yeSwgYW5kIGhhdmUgYmVlblxuICAgICAgICAgICAgICBwdXNoZWQgdG8gYSBcImdoLXBhZ2VzXCIgYnJhbmNoIGFuZCBwdWJsaXNoZWQuXG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICBUaGlzIGFwcCB3YXMgY3JlYXRlZCB3aXRoIE5leHQuanMgdjEwKyBhbmQgVGFpbHdpbmQgMi4wKyBhbmQgZXhwb3J0ZWQgdG8gc3RhdGljIEhUTUwuXG4gICAgICAgICAgICAgIFNpbmNlIHRoZSBwYWdlcyBhcmUgc3RhdGljYWxseSBnZW5lcmF0ZWQgYXQgYnVpbGQgdGltZSwgdGhleSBhcmUgdmVyeSBmYXN0IHRvIHJlbmRlcixcbiAgICAgICAgICAgICAgZGVzcGl0ZSBzdGlsbCBiZWluZyByZWFjdGl2ZS4gVGhlIGJlbmVmaXQgYmVpbmcgdGhhdCB0aGV5IGFyZSBvcHRpbWl6ZWQgYW5kIGRvIG5vdFxuICAgICAgICAgICAgICByZXF1aXJlIGFueSBzZXJ2ZXItc2lkZSBjb21wdXRhdGlvbiwgZ2l2aW5nIGEgZmFzdGVyIGxvYWRpbmcgZXhwZXJpZW5jZS5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgIEZ1cnRoZXIgZGV0YWlscyBvZiBob3cgdGhpcyB3YXMgZG9uZSBjYW4gYmUgcmVhZCBpbiB0aGUgUkVBRE1FIGZpbGUsIGluIHRoZSBtYWluXG4gICAgICAgICAgICAgIHByb2plY3QgcmVwb3NpdG9yeS5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L0NvbnRhaW5lcj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWU7XG4iXSwic291cmNlUm9vdCI6IiJ9